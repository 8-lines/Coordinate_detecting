#line 1 "c:\\users\\олег\\desktop\\проект\\trialcptrfromvideo\\cptrfromvideo\\positioning.cpp"
#line 1 "c:\\users\\олег\\desktop\\проект\\trialcptrfromvideo\\cptrfromvideo\\Matrix.h"
#line 1 "c:\\users\\олег\\desktop\\проект\\trialcptrfromvideo\\cptrfromvideo\\Header.h"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgproc.hpp"













































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"



















































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"

























































#line 60 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"
#line 61 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"




#line 66 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"








#line 75 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"





#line 81 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"









#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"














#pragma once

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 





#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


















#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"










#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"













#pragma once







































































































































#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"






































#line 190 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"


#line 193 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"

#line 195 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"





#line 201 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"



#line 205 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"






#line 212 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"






#line 219 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"




#line 224 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"






























































































































































































































































































































































































































































































#pragma region Input Buffer SAL 1 compatibility macros




































































































































































































































































































































































































































































                                                




                                                

















































































































































































































































































































#pragma endregion Input Buffer SAL 1 compatibility macros

















































































#line 1549 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"






























#line 1580 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"
























#line 1605 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"












#line 1618 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"







































#line 1658 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"


























































































































#line 1781 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"






































































































#line 1884 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"








































































































































































#line 2053 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"





































































































#line 2155 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"



















































































































































































































#line 2367 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"
extern "C" {




#line 2373 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"



































































































































































































































#line 2601 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    

#line 2640 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"









































































































































































































































#line 2874 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"









#line 2884 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"


    
    
#line 2889 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"






#line 2896 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"
#line 2897 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"






#line 2904 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"
#line 2905 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"










#line 2916 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"

































#line 2950 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"






















}
#line 2974 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ConcurrencySal.h"


















#pragma once


extern "C" {
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ConcurrencySal.h"
















































































































































































































































#line 265 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ConcurrencySal.h"



#line 269 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ConcurrencySal.h"


















































































#line 352 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ConcurrencySal.h"


}
#line 356 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ConcurrencySal.h"

#line 358 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ConcurrencySal.h"
#line 2976 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sal.h"


#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#pragma pack(push,8)

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"












#pragma once






#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"








#pragma pack(push,8)


extern "C" {
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"





#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"

#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"
#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"



typedef unsigned __int64    uintptr_t;


#line 50 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"

#line 52 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"





typedef char *  va_list;
#line 59 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"

#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"





#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"







#line 75 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"


#line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"













#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"







#line 100 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"














#line 115 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"


extern void __cdecl __va_start(va_list *, ...);


















#line 137 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"


}
#line 141 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"

#pragma pack(pop)

#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vadefs.h"
#line 64 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


extern "C" {
#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"





#line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#line 79 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"







#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"









#line 102 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"










#line 114 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


#line 117 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 118 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"





#line 124 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"









#line 134 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 136 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"







#line 144 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#line 150 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 152 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 153 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#line 158 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 160 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 161 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


 

#line 166 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
  
 #line 168 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 169 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"










#line 180 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 181 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 188 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 189 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

















#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#line 212 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"








#line 221 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 228 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 229 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"





#line 235 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 242 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 243 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 250 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 251 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#line 256 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


#line 259 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 261 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 262 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 263 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"





#line 269 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"










#line 280 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 282 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 283 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 284 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"










#line 295 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 302 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 303 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

















#line 321 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 322 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



#line 326 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 333 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 334 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 341 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 348 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 350 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 351 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



 
  
 



#line 361 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 362 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


 
  
  
 



#line 372 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 373 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


 
  
   
  

#line 381 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
 



#line 386 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 387 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


 
  
 



#line 396 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 397 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


 
  
 



#line 406 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 407 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



#line 411 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"





#line 417 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#line 422 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 424 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 425 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



typedef unsigned __int64    size_t;


#line 432 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 434 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



typedef size_t rsize_t;

#line 440 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 441 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



typedef __int64             intptr_t;


#line 448 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 450 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"












typedef __int64             ptrdiff_t;


#line 466 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 468 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"







typedef unsigned short wint_t;
typedef unsigned short wctype_t;

#line 479 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


















typedef int errno_t;
#line 499 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


typedef  long __time32_t;   

#line 504 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


typedef __int64 __time64_t;     

#line 509 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"





typedef __time64_t time_t;      
#line 516 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 518 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"







#line 526 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 527 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"





#line 533 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#line 538 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 540 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 541 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"





#line 547 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



#line 551 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"




#line 556 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 558 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 559 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"












 __declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
 __declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);
#line 574 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

__declspec(dllimport) __declspec(noreturn)
void __cdecl _invoke_watson(  const wchar_t *,   const wchar_t *,   const wchar_t *, unsigned int, uintptr_t);






 







 
  
 #line 594 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 595 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"







#line 603 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


































































































































































#line 766 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 767 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1833 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"















































































































































#line 1977 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"
#line 1978 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct * pthreadlocinfo;
typedef struct threadmbcinfostruct * pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct
{
    pthreadlocinfo locinfo;
    pthreadmbcinfo mbcinfo;
} _locale_tstruct, *_locale_t;


typedef struct localerefcount {
        char *locale;
        wchar_t *wlocale;
        int *refcount;
        int *wrefcount;
} locrefcount;

typedef struct threadlocaleinfostruct {
        int refcount;
        unsigned int lc_codepage;
        unsigned int lc_collate_cp;
        unsigned int lc_time_cp;
        locrefcount lc_category[6];
        int lc_clike;
        int mb_cur_max;
        int * lconv_intl_refcount;
        int * lconv_num_refcount;
        int * lconv_mon_refcount;
        struct lconv * lconv;
        int * ctype1_refcount;
        unsigned short * ctype1;
        const unsigned short * pctype;
        const unsigned char * pclmap;
        const unsigned char * pcumap;
        struct __lc_time_data * lc_time_curr;
        wchar_t * locale_name[6];
} threadlocinfo;

#line 2021 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"


}
#line 2025 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



#line 2029 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 2031 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



#line 2035 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 2037 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



#line 2041 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 2043 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"






#line 2050 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"



#line 2054 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#pragma pack(pop)

#line 2058 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"

#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"
















#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"









































#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"






#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"
#line 85 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"




#line 90 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"
#line 91 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"
































#line 124 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits.h"
#line 91 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/hal/interface.h"














#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstddef"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xkeycheck.h"

#pragma once






 
















































































#line 91 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xkeycheck.h"

  














































































#line 244 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xkeycheck.h"
 #line 245 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xkeycheck.h"

#line 247 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xkeycheck.h"

#line 249 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xkeycheck.h"
#line 250 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xkeycheck.h"





#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

#pragma pack(push,8)















































#line 59 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

		





#line 70 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

		


		




		

 
  

 

#line 88 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

 
  
 #line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"



 
  
 #line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"










































	
	






		


			
		#line 153 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
	#line 154 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

	
	




		

#line 164 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
			
		#line 166 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
	#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

	
	

#line 172 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

#line 174 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
		
	#line 176 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

#line 178 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"






	
		#pragma detect_mismatch("_MSC_VER", "1700")
	#line 187 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

	
		#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "0")
	#line 191 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

	
		

#line 196 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

#line 198 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
			#pragma detect_mismatch("RuntimeLibrary", "MD_DynamicRelease")
		

#line 202 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
	#line 203 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#line 204 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#line 205 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"


	
#line 209 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"




#line 214 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"




#line 219 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

#line 221 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#line 222 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"



#line 226 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"









#line 236 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

#line 238 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"


 
#line 242 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

 
 

 









 









 









 
































#line 310 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"





#line 316 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
 
 
#line 319 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

 
 

 #line 324 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"











#line 336 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\use_ansi.h"













#pragma once














#pragma comment(lib,"msvcprt")
#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\use_ansi.h"

























#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\use_ansi.h"

#line 59 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\use_ansi.h"

#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\use_ansi.h"

#line 63 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\use_ansi.h"
#line 338 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"



#line 342 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"







#line 350 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"


 











 
  

#line 368 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
   
  #line 370 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
 #line 371 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"






 










 
  

#line 392 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
   
  #line 394 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
 #line 395 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

 
  

#line 400 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
   
  #line 402 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
 #line 403 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"


 

   


#line 411 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
    
   #line 413 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

 #line 415 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"


 
  

#line 421 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
   
  #line 423 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
 #line 424 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

 
  
 #line 428 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

 
   


     
   #line 435 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
 #line 436 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"


    
#line 440 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"



		

 
  
  
  




  
  
  

  







   
   
   
  #line 469 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

  
  
  
  

 












#line 489 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

 
namespace std {
typedef bool _Bool;
}
 #line 495 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

		





		






typedef __int64 _Longlong;
typedef unsigned __int64 _ULonglong;

		







 
#line 522 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

		
 
#line 526 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
 
  
typedef unsigned short char16_t;
typedef unsigned int char32_t;
 #line 531 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
 #line 532 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

		
		






 
namespace std {
enum _Uninitialized
	{	
	_Noinit
	};

		

#pragma warning(push)
#pragma warning(disable:4412)
class __declspec(dllimport) _Lockit
	{	
public:
 

  
















#line 575 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
	__thiscall _Lockit();	
	explicit __thiscall _Lockit(int);	
	__thiscall ~_Lockit() throw ();	
  #line 579 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

    static  void __cdecl _Lockit_ctor(int);
    static  void __cdecl _Lockit_dtor(int);

private:
    static  void __cdecl _Lockit_ctor(_Lockit *);
    static  void __cdecl _Lockit_ctor(_Lockit *, int);
    static  void __cdecl _Lockit_dtor(_Lockit *);

	 _Lockit(const _Lockit&);				
	_Lockit&  operator=(const _Lockit&);	

	int _Locktype;

  











#line 606 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
	};

 



































































  



  


  



  


  
 #line 692 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

class __declspec(dllimport) _Init_locks
	{	
public:
 
      










#line 709 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
    __thiscall _Init_locks();
	__thiscall ~_Init_locks() throw ();
  #line 712 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"

private:
    static  void __cdecl _Init_locks_ctor(_Init_locks *);
    static  void __cdecl _Init_locks_dtor(_Init_locks *);

 







#line 726 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
	};

#pragma warning(pop)
}
 #line 731 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"





		

__declspec(dllimport) void __cdecl _Atexit(void (__cdecl *)(void));

typedef int _Mbstatet;
typedef unsigned long _Uint32t;




 
 

 
 #pragma pack(pop)
#line 752 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"
#line 753 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\yvals.h"





#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstddef"







 #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"














#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"


extern "C" {
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"







#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"


namespace std { typedef decltype(__nullptr) nullptr_t; }
using ::std::nullptr_t;
#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"




__declspec(dllimport) extern int * __cdecl _errno(void);


errno_t __cdecl _set_errno(  int _Value);
errno_t __cdecl _get_errno(  int * _Value);
#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"








#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"









#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"

__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);


}
#line 76 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"

#line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stddef.h"
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstddef"
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstddef"

 
namespace std {
using :: ptrdiff_t; using :: size_t;
}
 #line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstddef"

 
namespace std {
typedef double max_align_t;	
}
 #line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstddef"
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstddef"
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstddef"





#line 16 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/hal/interface.h"



#line 20 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/hal/interface.h"




















#line 41 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/hal/interface.h"
   typedef unsigned uint;
#line 43 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/hal/interface.h"

typedef signed char schar;


   typedef unsigned char uchar;
   typedef unsigned short ushort;
#line 50 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/hal/interface.h"


   typedef __int64 int64;
   typedef unsigned __int64 uint64;







#line 62 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/hal/interface.h"




















































































































#line 179 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/hal/interface.h"
#line 92 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"



#line 96 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"

#line 98 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"

#line 100 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"

#line 102 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"

#line 104 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"








#line 113 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"
#line 114 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"



#line 118 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"

#line 120 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"







#line 128 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"

































enum CpuFeatures {
    CPU_MMX             = 1,
    CPU_SSE             = 2,
    CPU_SSE2            = 3,
    CPU_SSE3            = 4,
    CPU_SSSE3           = 5,
    CPU_SSE4_1          = 6,
    CPU_SSE4_2          = 7,
    CPU_POPCNT          = 8,
    CPU_FP16            = 9,
    CPU_AVX             = 10,
    CPU_AVX2            = 11,
    CPU_FMA3            = 12,

    CPU_AVX_512F        = 13,
    CPU_AVX_512BW       = 14,
    CPU_AVX_512CD       = 15,
    CPU_AVX_512DQ       = 16,
    CPU_AVX_512ER       = 17,
    CPU_AVX_512IFMA512  = 18,
    CPU_AVX_512PF       = 19,
    CPU_AVX_512VBMI     = 20,
    CPU_AVX_512VL       = 21,

    CPU_NEON            = 100
};


#line 1 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"






















































































































#line 121 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"





#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\emmintrin.h"




















#pragma once






#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\emmintrin.h"




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmmintrin.h"



























#pragma once






#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmmintrin.h"





#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\mmintrin.h"


















#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\mmintrin.h"



#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\mmintrin.h"


extern "C" { 


#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\mmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(8)) __m64
{
    unsigned __int64    m64_u64;
    float               m64_f32[2];
    __int8              m64_i8[8];
    __int16             m64_i16[4];
    __int32             m64_i32[2];    
    __int64             m64_i64;
    unsigned __int8     m64_u8[8];
    unsigned __int16    m64_u16[4];
    unsigned __int32    m64_u32[2];
} __m64;


void  _m_empty(void);
__m64 _m_from_int(int _I);
int   _m_to_int(__m64 _M);
__m64 _m_packsswb(__m64 _MM1, __m64 _MM2);
__m64 _m_packssdw(__m64 _MM1, __m64 _MM2);
__m64 _m_packuswb(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhdq(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckldq(__m64 _MM1, __m64 _MM2);


__m64 _m_paddb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddd(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubd(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmaddwd(__m64 _MM1, __m64 _MM2);
__m64 _m_pmulhw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmullw(__m64 _MM1, __m64 _MM2);


__m64 _m_psllw(__m64 _M, __m64 _Count);
__m64 _m_psllwi(__m64 _M, int _Count);
__m64 _m_pslld(__m64 _M, __m64 _Count);
__m64 _m_pslldi(__m64 _M, int _Count);
__m64 _m_psllq(__m64 _M, __m64 _Count);
__m64 _m_psllqi(__m64 _M, int _Count);
__m64 _m_psraw(__m64 _M, __m64 _Count);
__m64 _m_psrawi(__m64 _M, int _Count);
__m64 _m_psrad(__m64 _M, __m64 _Count);
__m64 _m_psradi(__m64 _M, int _Count);
__m64 _m_psrlw(__m64 _M, __m64 _Count);
__m64 _m_psrlwi(__m64 _M, int _Count);
__m64 _m_psrld(__m64 _M, __m64 _Count);
__m64 _m_psrldi(__m64 _M, int _Count);
__m64 _m_psrlq(__m64 _M, __m64 _Count);
__m64 _m_psrlqi(__m64 _M, int _Count);


__m64 _m_pand(__m64 _MM1, __m64 _MM2);
__m64 _m_pandn(__m64 _MM1, __m64 _MM2);
__m64 _m_por(__m64 _MM1, __m64 _MM2);
__m64 _m_pxor(__m64 _MM1, __m64 _MM2);


__m64 _m_pcmpeqb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqd(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtd(__m64 _MM1, __m64 _MM2);


__m64 _mm_setzero_si64(void);
__m64 _mm_set_pi32(int _I1, int _I0);
__m64 _mm_set_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_set_pi8(char _B7, char _B6, char _B5, char _B4,
                  char _B3, char _B2, char _B1, char _B0);
__m64 _mm_set1_pi32(int _I);
__m64 _mm_set1_pi16(short _S);
__m64 _mm_set1_pi8(char _B);
__m64 _mm_setr_pi32(int _I1, int _I0);
__m64 _mm_setr_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_setr_pi8(char _B7, char _B6, char _B5, char _B4,
                   char _B3, char _B2, char _B1, char _B0);




























































}; 
#line 184 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\mmintrin.h"

#line 186 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\mmintrin.h"
#line 187 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\mmintrin.h"
#line 188 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\mmintrin.h"

#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmmintrin.h"
#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmmintrin.h"

















typedef union __declspec(intrin_type) __declspec(align(16)) __m128 {
     float               m128_f32[4];
     unsigned __int64    m128_u64[2];
     __int8              m128_i8[16];
     __int16             m128_i16[8];
     __int32             m128_i32[4];
     __int64             m128_i64[2];
     unsigned __int8     m128_u8[16];
     unsigned __int16    m128_u16[8];
     unsigned __int32    m128_u32[4];
 } __m128;



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"














#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"





#pragma pack(push,8)


extern "C" {
#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"







#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"





#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"













typedef struct _heapinfo {
        int * _pentry;
        size_t _size;
        int _useflag;
        } _HEAPINFO;

#line 65 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"



































#line 101 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"



      __declspec(dllimport)  __declspec(noalias) __declspec(restrict)    void * __cdecl calloc(  size_t _Count,   size_t _Size);
__declspec(dllimport)                     __declspec(noalias)                                                                             void   __cdecl free(    void * _Memory);
      __declspec(dllimport)  __declspec(noalias) __declspec(restrict)                              void * __cdecl malloc(  size_t _Size);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                           void * __cdecl realloc(    void * _Memory,   size_t _NewSize);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                       void * __cdecl _recalloc(    void * _Memory,   size_t _Count,   size_t _Size);
__declspec(dllimport)                     __declspec(noalias)                                                                             void   __cdecl _aligned_free(    void * _Memory);
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_malloc(  size_t _Size,   size_t _Alignment);
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_offset_malloc(  size_t _Size,   size_t _Alignment,   size_t _Offset);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_realloc(    void * _Memory,   size_t _NewSize,   size_t _Alignment);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                       void * __cdecl _aligned_recalloc(    void * _Memory,   size_t _Count,   size_t _Size,   size_t _Alignment);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_offset_realloc(    void * _Memory,   size_t _NewSize,   size_t _Alignment,   size_t _Offset);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                       void * __cdecl _aligned_offset_recalloc(    void * _Memory,   size_t _Count,   size_t _Size,   size_t _Alignment,   size_t _Offset);
  __declspec(dllimport)                                                  size_t __cdecl _aligned_msize(  void * _Memory,   size_t _Alignment,   size_t _Offset);
#line 124 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"
















#line 141 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"


__declspec(dllimport) int     __cdecl _resetstkoflw (void);
#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"



__declspec(dllimport) unsigned long __cdecl _set_malloc_crt_max_wait(  unsigned long _NewValue);








#line 158 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"

      __declspec(dllimport) void *  __cdecl _expand(  void * _Memory,   size_t _NewSize);
  __declspec(dllimport) size_t  __cdecl _msize(  void * _Memory);




#line 166 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"

    void *          __cdecl _alloca(  size_t _Size);


__declspec(dllimport)  int     __cdecl _heapwalk(  _HEAPINFO * _EntryInfo);
__declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);
#line 173 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"


  __declspec(dllimport) int     __cdecl _heapadd(  void * _Memory,   size_t _Size);
  __declspec(dllimport) int     __cdecl _heapchk(void);
  __declspec(dllimport) int     __cdecl _heapmin(void);
__declspec(dllimport) int     __cdecl _heapset(  unsigned int _Fill);
__declspec(dllimport) size_t  __cdecl _heapused(size_t * _Used, size_t * _Commit);
#line 181 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"







#line 189 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"





#line 195 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"

typedef char __static_assert_t[ (sizeof(unsigned int) <= 16) ];


#pragma warning(push)
#pragma warning(disable:6540)
__inline void *_MarkAllocaS(   void *_Ptr, unsigned int _Marker)
{
    if (_Ptr)
    {
        *((unsigned int*)_Ptr) = _Marker;
        _Ptr = (char*)_Ptr + 16;
    }
    return _Ptr;
}
#pragma warning(pop)
#line 212 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"








#line 221 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"






#line 228 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"









__pragma(warning(push))
__pragma(warning(disable: 6014))
__declspec(noalias) __inline void __cdecl _freea(    void * _Memory)
{
    unsigned int _Marker;
    if (_Memory)
    {
        _Memory = (char*)_Memory - 16;
        _Marker = *(unsigned int *)_Memory;
        if (_Marker == 0xDDDD)
        {
            free(_Memory);
        }





#line 256 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"
    }
}
__pragma(warning(pop))
#line 260 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"
#line 261 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"
#line 262 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"




#line 267 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"

#line 269 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"






















}
#line 293 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"

#pragma pack(pop)

#line 297 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\malloc.h"
#line 75 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmmintrin.h"
#line 76 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmmintrin.h"
#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmmintrin.h"

 
 
 
 
 
 
 
 
 
 




 
 
 
 
 
 
 
 
 
 







































































 
 
 


extern "C" { 
  
#line 181 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmmintrin.h"





extern __m128 _mm_add_ss(__m128 _A, __m128 _B);
extern __m128 _mm_add_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ss(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ps(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ss(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ps(__m128 _A, __m128 _B);
extern __m128 _mm_div_ss(__m128 _A, __m128 _B);
extern __m128 _mm_div_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sqrt_ss(__m128 _A);
extern __m128 _mm_sqrt_ps(__m128 _A);
extern __m128 _mm_rcp_ss(__m128 _A);
extern __m128 _mm_rcp_ps(__m128 _A);
extern __m128 _mm_rsqrt_ss(__m128 _A);
extern __m128 _mm_rsqrt_ps(__m128 _A);
extern __m128 _mm_min_ss(__m128 _A, __m128 _B);
extern __m128 _mm_min_ps(__m128 _A, __m128 _B);
extern __m128 _mm_max_ss(__m128 _A, __m128 _B);
extern __m128 _mm_max_ps(__m128 _A, __m128 _B);





extern __m128 _mm_and_ps(__m128 _A, __m128 _B);
extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B);
extern __m128 _mm_or_ps(__m128 _A, __m128 _B);
extern __m128 _mm_xor_ps(__m128 _A, __m128 _B);





extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B);
extern int _mm_comieq_ss(__m128 _A, __m128 _B);
extern int _mm_comilt_ss(__m128 _A, __m128 _B);
extern int _mm_comile_ss(__m128 _A, __m128 _B);
extern int _mm_comigt_ss(__m128 _A, __m128 _B);
extern int _mm_comige_ss(__m128 _A, __m128 _B);
extern int _mm_comineq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomieq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomilt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomile_ss(__m128 _A, __m128 _B);
extern int _mm_ucomigt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomige_ss(__m128 _A, __m128 _B);
extern int _mm_ucomineq_ss(__m128 _A, __m128 _B);





extern int _mm_cvt_ss2si(__m128 _A);
extern __m64 _mm_cvt_ps2pi(__m128 _A);
extern int _mm_cvtt_ss2si(__m128 _A);
extern __m64 _mm_cvtt_ps2pi(__m128 _A);
extern __m128 _mm_cvt_si2ss(__m128, int);
extern __m128 _mm_cvt_pi2ps(__m128, __m64);
extern float _mm_cvtss_f32(__m128 _A);





extern __int64 _mm_cvtss_si64(__m128 _A);
extern __int64 _mm_cvttss_si64(__m128 _A);
extern __m128  _mm_cvtsi64_ss(__m128 _A, __int64 _B);
#line 275 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmmintrin.h"





extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned int _Imm8);
extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B);
extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B);
extern __m128 _mm_loadh_pi(__m128, __m64 const*);
extern __m128 _mm_movehl_ps(__m128, __m128);
extern __m128 _mm_movelh_ps(__m128, __m128);
extern void _mm_storeh_pi(__m64 *, __m128);
extern __m128 _mm_loadl_pi(__m128, __m64 const*);
extern void _mm_storel_pi(__m64 *, __m128);
extern int _mm_movemask_ps(__m128 _A);





extern int _m_pextrw(__m64, int);
extern __m64 _m_pinsrw(__m64, int, int);
extern __m64 _m_pmaxsw(__m64, __m64);
extern __m64 _m_pmaxub(__m64, __m64);
extern __m64 _m_pminsw(__m64, __m64);
extern __m64 _m_pminub(__m64, __m64);
extern int _m_pmovmskb(__m64);
extern __m64 _m_pmulhuw(__m64, __m64);
extern __m64 _m_pshufw(__m64, int);
extern void _m_maskmovq(__m64, __m64, char *);
extern __m64 _m_pavgb(__m64, __m64);
extern __m64 _m_pavgw(__m64, __m64);
extern __m64 _m_psadbw(__m64, __m64);





extern __m128 _mm_set_ss(float _A);
extern __m128 _mm_set_ps1(float _A);
extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setzero_ps(void);
extern __m128 _mm_load_ss(float const*_A);
extern __m128 _mm_load_ps1(float const*_A);
extern __m128 _mm_load_ps(float const*_A);
extern __m128 _mm_loadr_ps(float const*_A);
extern __m128 _mm_loadu_ps(float const*_A);
extern void _mm_store_ss(float *_V, __m128 _A);
extern void _mm_store_ps1(float *_V, __m128 _A);
extern void _mm_store_ps(float *_V, __m128 _A);
extern void _mm_storer_ps(float *_V, __m128 _A);
extern void _mm_storeu_ps(float *_V, __m128 _A);
extern void _mm_prefetch(char const*_A, int _Sel);
extern void _mm_stream_pi(__m64 *, __m64);
extern void _mm_stream_ps(float *, __m128);
extern __m128 _mm_move_ss(__m128 _A, __m128 _B);

extern void _mm_sfence(void);
extern unsigned int _mm_getcsr(void);
extern void _mm_setcsr(unsigned int);






























 
 
 

 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi16_ps(__m64 a)
{
  __m128 tmp;
  __m64  ext_val = _m_pcmpgtw(_mm_setzero_si64(), a);

  tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(a, ext_val));
  return(_mm_cvt_pi2ps(_mm_movelh_ps(tmp, tmp), 
                        _m_punpcklwd(a, ext_val)));
}


 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpu16_ps(__m64 a)
{
  __m128 tmp;
  __m64  ext_val = _mm_setzero_si64();

  tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(a, ext_val));
  return(_mm_cvt_pi2ps(_mm_movelh_ps(tmp, tmp), 
                        _m_punpcklwd(a, ext_val)));
}


 
 
 
 
 
 
 
 
__inline __m64 _mm_cvtps_pi16(__m128 a)
{
  return _m_packssdw(_mm_cvt_ps2pi(a), 
                        _mm_cvt_ps2pi(_mm_movehl_ps(a, a)));
}


 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi8_ps(__m64 a)
{
  __m64  ext_val = _m_pcmpgtb(_mm_setzero_si64(), a);

  return _mm_cvtpi16_ps(_m_punpcklbw(a, ext_val));
}


 
 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpu8_ps(__m64 a)
{
  return _mm_cvtpu16_ps(_m_punpcklbw(a, _mm_setzero_si64()));
}


 
 
 
 
 
 
 
 
__inline __m64 _mm_cvtps_pi8(__m128 a)
{
  return _m_packsswb(_mm_cvtps_pi16(a), _mm_setzero_si64());
}


 
 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi32x2_ps(__m64 a, __m64 b)
{
  return _mm_movelh_ps(_mm_cvt_pi2ps(_mm_setzero_ps(), a), 
                       _mm_cvt_pi2ps(_mm_setzero_ps(), b)); 
}



}; 
#line 487 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmmintrin.h"

#line 489 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmmintrin.h"

#line 491 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmmintrin.h"
#line 492 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmmintrin.h"
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\emmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(16)) __m128i {
    __int8              m128i_i8[16];
    __int16             m128i_i16[8];
    __int32             m128i_i32[4];    
    __int64             m128i_i64[2];
    unsigned __int8     m128i_u8[16];
    unsigned __int16    m128i_u16[8];
    unsigned __int32    m128i_u32[4];
    unsigned __int64    m128i_u64[2];
} __m128i;

typedef struct __declspec(intrin_type) __declspec(align(16)) __m128d {
    double              m128d_f64[2];
} __m128d;






 
 
 


extern "C" { 
  
#line 63 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\emmintrin.h"





extern __m128d _mm_add_sd(__m128d _A, __m128d _B);
extern __m128d _mm_add_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_pd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_sd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_pd(__m128d _A);
extern __m128d _mm_div_sd(__m128d _A, __m128d _B);
extern __m128d _mm_div_pd(__m128d _A, __m128d _B);
extern __m128d _mm_min_sd(__m128d _A, __m128d _B);
extern __m128d _mm_min_pd(__m128d _A, __m128d _B);
extern __m128d _mm_max_sd(__m128d _A, __m128d _B);
extern __m128d _mm_max_pd(__m128d _A, __m128d _B);





extern __m128d _mm_and_pd(__m128d _A, __m128d _B);
extern __m128d _mm_andnot_pd(__m128d _A, __m128d _B);
extern __m128d _mm_or_pd(__m128d _A, __m128d _B);
extern __m128d _mm_xor_pd(__m128d _A, __m128d _B);





extern __m128d _mm_cmpeq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpeq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_sd(__m128d _A, __m128d _B);
extern int _mm_comieq_sd(__m128d _A, __m128d _B);
extern int _mm_comilt_sd(__m128d _A, __m128d _B);
extern int _mm_comile_sd(__m128d _A, __m128d _B);
extern int _mm_comigt_sd(__m128d _A, __m128d _B);
extern int _mm_comige_sd(__m128d _A, __m128d _B);
extern int _mm_comineq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomieq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomilt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomile_sd(__m128d _A, __m128d _B);
extern int _mm_ucomigt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomige_sd(__m128d _A, __m128d _B);
extern int _mm_ucomineq_sd(__m128d _A, __m128d _B);





extern __m128d _mm_cvtepi32_pd(__m128i _A);
extern __m128i _mm_cvtpd_epi32(__m128d _A);
extern __m128i _mm_cvttpd_epi32(__m128d _A);
extern __m128 _mm_cvtepi32_ps(__m128i _A);
extern __m128i _mm_cvtps_epi32(__m128 _A);
extern __m128i _mm_cvttps_epi32(__m128 _A);
extern __m128 _mm_cvtpd_ps(__m128d _A);
extern __m128d _mm_cvtps_pd(__m128 _A);
extern __m128 _mm_cvtsd_ss(__m128 _A, __m128d _B);
extern __m128d _mm_cvtss_sd(__m128d _A, __m128 _B);

extern int _mm_cvtsd_si32(__m128d _A);
extern int _mm_cvttsd_si32(__m128d _A);
extern __m128d _mm_cvtsi32_sd(__m128d _A, int _B);

extern __m64 _mm_cvtpd_pi32(__m128d _A);
extern __m64 _mm_cvttpd_pi32(__m128d _A);
extern __m128d _mm_cvtpi32_pd(__m64 _A);





extern __m128d _mm_unpackhi_pd(__m128d _A, __m128d _B);
extern __m128d _mm_unpacklo_pd(__m128d _A, __m128d _B);
extern int _mm_movemask_pd(__m128d _A);
extern __m128d _mm_shuffle_pd(__m128d _A, __m128d _B, int _I);





extern __m128d _mm_load_pd(double const*_Dp);
extern __m128d _mm_load1_pd(double const*_Dp);
extern __m128d _mm_loadr_pd(double const*_Dp);
extern __m128d _mm_loadu_pd(double const*_Dp);
extern __m128d _mm_load_sd(double const*_Dp);
extern __m128d _mm_loadh_pd(__m128d _A, double const*_Dp);
extern __m128d _mm_loadl_pd(__m128d _A, double const*_Dp);





extern __m128d _mm_set_sd(double _W);
extern __m128d _mm_set1_pd(double _A);
extern __m128d _mm_set_pd(double _Z, double _Y);
extern __m128d _mm_setr_pd(double _Y, double _Z);
extern __m128d _mm_setzero_pd(void);
extern __m128d _mm_move_sd(__m128d _A, __m128d _B);





extern void _mm_store_sd(double *_Dp, __m128d _A);
extern void _mm_store1_pd(double *_Dp, __m128d _A);
extern void _mm_store_pd(double *_Dp, __m128d _A);
extern void _mm_storeu_pd(double *_Dp, __m128d _A);
extern void _mm_storer_pd(double *_Dp, __m128d _A);
extern void _mm_storeh_pd(double *_Dp, __m128d _A);
extern void _mm_storel_pd(double *_Dp, __m128d _A);





extern __m128i _mm_add_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi32(__m128i _A, __m128i _B);
extern __m64 _mm_add_si64(__m64 _A, __m64 _B);
extern __m128i _mm_add_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_madd_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_min_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_min_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_mullo_epi16(__m128i _A, __m128i _B);
extern __m64 _mm_mul_su32(__m64 _A, __m64 _B);
extern __m128i _mm_mul_epu32(__m128i _A, __m128i _B);
extern __m128i _mm_sad_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi32(__m128i _A, __m128i _B);
extern __m64 _mm_sub_si64(__m64 _A, __m64 _B);
extern __m128i _mm_sub_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu16(__m128i _A, __m128i _B);





extern __m128i _mm_and_si128(__m128i _A, __m128i _B);
extern __m128i _mm_andnot_si128(__m128i _A, __m128i _B);
extern __m128i _mm_or_si128(__m128i _A, __m128i _B);
extern __m128i _mm_xor_si128(__m128i _A, __m128i _B);





extern __m128i _mm_slli_si128(__m128i _A, int _Imm);
extern __m128i _mm_slli_epi16(__m128i _A, int _Count);
extern __m128i _mm_sll_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi32(__m128i _A, int _Count);
extern __m128i _mm_sll_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi64(__m128i _A, int _Count);
extern __m128i _mm_sll_epi64(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi16(__m128i _A, int _Count);
extern __m128i _mm_sra_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi32(__m128i _A, int _Count);
extern __m128i _mm_sra_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_si128(__m128i _A, int _Imm);
extern __m128i _mm_srli_epi16(__m128i _A, int _Count);
extern __m128i _mm_srl_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi32(__m128i _A, int _Count);
extern __m128i _mm_srl_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi64(__m128i _A, int _Count);
extern __m128i _mm_srl_epi64(__m128i _A, __m128i _Count);





extern __m128i _mm_cmpeq_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi32(__m128i _A, __m128i _B);





extern __m128i _mm_cvtsi32_si128(int _A);
extern int _mm_cvtsi128_si32(__m128i _A);





extern __m128i _mm_packs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_packs_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_packus_epi16(__m128i _A, __m128i _B);
extern int _mm_extract_epi16(__m128i _A, int _Imm);
extern __m128i _mm_insert_epi16(__m128i _A, int _B, int _Imm);
extern int _mm_movemask_epi8(__m128i _A);
extern __m128i _mm_shuffle_epi32(__m128i _A, int _Imm);
extern __m128i _mm_shufflehi_epi16(__m128i _A, int _Imm);
extern __m128i _mm_shufflelo_epi16(__m128i _A, int _Imm);
extern __m128i _mm_unpackhi_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi64(__m128i _A, __m128i _B);





extern __m128i _mm_load_si128(__m128i const*_P);
extern __m128i _mm_loadu_si128(__m128i const*_P);
extern __m128i _mm_loadl_epi64(__m128i const*_P);





extern __m128i _mm_set_epi64(__m64 _Q1, __m64 _Q0);
extern __m128i _mm_set_epi32(int _I3, int _I2, int _I1, int _I0);
extern __m128i _mm_set_epi16(short _W7, short _W6, short _W5, short _W4,
                             short _W3, short _W2, short _W1, short _W0);
extern __m128i _mm_set_epi8(char _B15, char _B14, char _B13, char _B12, 
                            char _B11, char _B10, char _B9, char _B8, 
                            char _B7, char _B6, char _B5, char _B4, 
                            char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_set1_epi64(__m64 _Q);
extern __m128i _mm_set1_epi32(int _I);
extern __m128i _mm_set1_epi16(short _W);
extern __m128i _mm_set1_epi8(char _B);
extern __m128i _mm_setl_epi64(__m128i _Q);
extern __m128i _mm_setr_epi64(__m64 _Q0, __m64 _Q1);
extern __m128i _mm_setr_epi32(int _I0, int _I1, int _I2, int _I3);
extern __m128i _mm_setr_epi16(short _W0, short _W1, short _W2, short _W3, 
                              short _W4, short _W5, short _W6, short _W7);
extern __m128i _mm_setr_epi8(char _B15, char _B14, char _B13, char _B12, 
                             char _B11, char _B10, char _B9, char _B8, 
                             char _B7, char _B6, char _B5, char _B4, 
                             char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_setzero_si128(void);





extern void _mm_store_si128(__m128i *_P, __m128i _B);
extern void _mm_storeu_si128(__m128i *_P, __m128i _B);
extern void _mm_storel_epi64(__m128i *_P, __m128i _Q);
extern void _mm_maskmoveu_si128(__m128i _D, __m128i _N, char *_P);





extern __m128i _mm_move_epi64(__m128i _Q);
extern __m128i _mm_movpi64_epi64(__m64 _Q);
extern __m64 _mm_movepi64_pi64(__m128i _Q);





extern void _mm_stream_pd(double *_Dp, __m128d _A);
extern void _mm_stream_si128(__m128i *_P, __m128i _A);
extern void _mm_clflush(void const*_P);
extern void _mm_lfence(void);
extern void _mm_mfence(void);
extern void _mm_stream_si32(int *_P, int _I);
extern void _mm_pause(void);





extern double _mm_cvtsd_f64(__m128d _A);







extern __m128  _mm_castpd_ps(__m128d);
extern __m128i _mm_castpd_si128(__m128d);
extern __m128d _mm_castps_pd(__m128);
extern __m128i _mm_castps_si128(__m128);
extern __m128  _mm_castsi128_ps(__m128i);
extern __m128d _mm_castsi128_pd(__m128i);






extern __int64 _mm_cvtsd_si64(__m128d);
extern __int64 _mm_cvttsd_si64(__m128d);
extern __m128d _mm_cvtsi64_sd(__m128d, __int64);
extern __m128i _mm_cvtsi64_si128(__int64);
extern __int64 _mm_cvtsi128_si64(__m128i);


#line 407 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\emmintrin.h"


}; 
#line 411 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\emmintrin.h"

#line 413 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\emmintrin.h"

#line 415 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\emmintrin.h"
#line 416 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\emmintrin.h"
#line 128 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"










#line 139 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"

#line 141 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"














#line 156 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"


#line 159 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"


#line 162 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"


#line 165 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"


#line 168 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"


#line 171 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"


#line 174 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"


#line 177 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"


#line 180 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"


#line 183 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"


#line 186 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"


#line 189 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"


#line 192 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"


#line 195 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"


#line 198 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"


#line 201 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"


#line 204 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"


#line 207 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"



#line 211 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cv_cpu_dispatch.h"
#line 190 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"









#line 201 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"

#line 203 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"

typedef union Cv16suf
{
    short i;


#line 210 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"
    struct _fp16Format
    {
        unsigned int significand : 10;
        unsigned int exponent    : 5;
        unsigned int sign        : 1;
    } fmt;
}
Cv16suf;

typedef union Cv32suf
{
    int i;
    unsigned u;
    float f;
    struct _fp32Format
    {
        unsigned int significand : 23;
        unsigned int exponent    : 8;
        unsigned int sign        : 1;
    } fmt;
}
Cv32suf;

typedef union Cv64suf
{
    int64 i;
    uint64 u;
    double f;
}
Cv64suf;









#line 250 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"

#line 252 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"

#line 254 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"




#line 259 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"



#line 263 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"
#line 264 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"






#line 271 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"
#line 272 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"








































#line 313 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"



#line 317 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"










#line 328 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"
#line 329 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"









#line 339 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"
#line 340 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"






















#line 363 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"












#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\setjmp.h"















#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\setjmp.h"









#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\setjmp.h"





#pragma pack(push,8)


extern "C" {
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\setjmp.h"




































#line 79 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\setjmp.h"

typedef struct __declspec(align(16)) _SETJMP_FLOAT128 {
    unsigned __int64 Part[2];
} SETJMP_FLOAT128;


typedef SETJMP_FLOAT128 _JBTYPE;



#line 90 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\setjmp.h"

typedef struct _JUMP_BUFFER {
    unsigned __int64 Frame;
    unsigned __int64 Rbx;
    unsigned __int64 Rsp;
    unsigned __int64 Rbp;
    unsigned __int64 Rsi;
    unsigned __int64 Rdi;
    unsigned __int64 R12;
    unsigned __int64 R13;
    unsigned __int64 R14;
    unsigned __int64 R15;
    unsigned __int64 Rip;
    unsigned long MxCsr;
    unsigned short FpCsr;
    unsigned short Spare;
    
    SETJMP_FLOAT128 Xmm6;
    SETJMP_FLOAT128 Xmm7;
    SETJMP_FLOAT128 Xmm8;
    SETJMP_FLOAT128 Xmm9;
    SETJMP_FLOAT128 Xmm10;
    SETJMP_FLOAT128 Xmm11;
    SETJMP_FLOAT128 Xmm12;
    SETJMP_FLOAT128 Xmm13;
    SETJMP_FLOAT128 Xmm14;
    SETJMP_FLOAT128 Xmm15;
} _JUMP_BUFFER;
































#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\setjmp.h"





typedef _JBTYPE jmp_buf[16];


#line 160 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\setjmp.h"




int __cdecl _setjmp(  jmp_buf _Buf);


}
#line 169 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\setjmp.h"


#pragma warning(push)
#pragma warning(disable:4987)
extern "C"
{
__declspec(dllimport) __declspec(noreturn) void __cdecl longjmp(  jmp_buf _Buf,   int _Value) throw(...);
}
#pragma warning(pop)


#line 181 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\setjmp.h"

#pragma pack(pop)

#line 185 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\setjmp.h"
#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"






#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"













#pragma once






#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wmmintrin.h"
















#pragma once






#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wmmintrin.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\nmmintrin.h"

















#pragma once






#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\nmmintrin.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\smmintrin.h"

















#pragma once






#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\smmintrin.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\tmmintrin.h"










#pragma once






#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\tmmintrin.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\pmmintrin.h"


















#pragma once






#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\pmmintrin.h"






 
 
 














 
 
 


extern "C" { 
  
#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\pmmintrin.h"





extern __m128 _mm_addsub_ps(__m128 a, __m128 b);
extern __m128 _mm_hadd_ps(__m128 a, __m128 b);
extern __m128 _mm_hsub_ps(__m128 a, __m128 b);
extern __m128 _mm_movehdup_ps(__m128 a);
extern __m128 _mm_moveldup_ps(__m128 a);





extern __m128d _mm_addsub_pd(__m128d a, __m128d b);
extern __m128d _mm_hadd_pd(__m128d a, __m128d b);
extern __m128d _mm_hsub_pd(__m128d a, __m128d b);
extern __m128d _mm_loaddup_pd(double const * dp);
extern __m128d _mm_movedup_pd(__m128d a);




extern __m128i _mm_lddqu_si128(__m128i const *p);







extern void _mm_monitor(void const *p, unsigned extensions, unsigned hints);




extern void _mm_mwait(unsigned extensions, unsigned hints);


}; 
#line 100 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\pmmintrin.h"

#line 102 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\pmmintrin.h"

#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\pmmintrin.h"
#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\pmmintrin.h"
#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\tmmintrin.h"









extern "C" {
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_hadd_epi16 (__m128i a, __m128i b);
    extern __m128i _mm_hadd_epi32 (__m128i a, __m128i b);
    extern __m128i _mm_hadds_epi16 (__m128i a, __m128i b);

    extern __m64 _mm_hadd_pi16 (__m64 a, __m64 b);
    extern __m64 _mm_hadd_pi32 (__m64 a, __m64 b);
    extern __m64 _mm_hadds_pi16 (__m64 a, __m64 b);

    
    

    extern __m128i _mm_hsub_epi16 (__m128i a, __m128i b);
    extern __m128i _mm_hsub_epi32 (__m128i a, __m128i b);
    extern __m128i _mm_hsubs_epi16 (__m128i a, __m128i b);

    extern __m64 _mm_hsub_pi16 (__m64 a, __m64 b);
    extern __m64 _mm_hsub_pi32 (__m64 a, __m64 b);
    extern __m64 _mm_hsubs_pi16 (__m64 a, __m64 b);

    
    

    extern __m128i _mm_maddubs_epi16 (__m128i a, __m128i b);

    extern __m64 _mm_maddubs_pi16 (__m64 a, __m64 b);

    
    

    extern __m128i _mm_mulhrs_epi16 (__m128i a, __m128i b);

    extern __m64 _mm_mulhrs_pi16 (__m64 a, __m64 b);

    
    

    extern __m128i _mm_shuffle_epi8 (__m128i a, __m128i b);

    extern __m64 _mm_shuffle_pi8 (__m64 a, __m64 b);

    
    

    extern __m128i _mm_sign_epi8 (__m128i a, __m128i b);
    extern __m128i _mm_sign_epi16 (__m128i a, __m128i b);
    extern __m128i _mm_sign_epi32 (__m128i a, __m128i b);

    extern __m64 _mm_sign_pi8 (__m64 a, __m64 b);
    extern __m64 _mm_sign_pi16 (__m64 a, __m64 b);
    extern __m64 _mm_sign_pi32 (__m64 a, __m64 b);

    
    

    extern __m128i _mm_alignr_epi8 (__m128i a, __m128i b, int n);

    extern __m64 _mm_alignr_pi8 (__m64 a, __m64 b, int n);

    
    

    extern __m128i _mm_abs_epi8 (__m128i a);
    extern __m128i _mm_abs_epi16 (__m128i a);
    extern __m128i _mm_abs_epi32 (__m128i a);

    extern __m64 _mm_abs_pi8 (__m64 a);
    extern __m64 _mm_abs_pi16 (__m64 a);
    extern __m64 _mm_abs_pi32 (__m64 a);


};
#line 108 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\tmmintrin.h"

#line 110 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\tmmintrin.h"

#line 112 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\tmmintrin.h"

#line 114 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\tmmintrin.h"
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\smmintrin.h"


















































extern "C" {
#line 80 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\smmintrin.h"

        
        

        extern __m128i _mm_blend_epi16 (__m128i v1, __m128i v2,
                                        const int mask);
        extern __m128i _mm_blendv_epi8 (__m128i v1, __m128i v2, __m128i mask);

        
        

        extern __m128  _mm_blend_ps (__m128  v1, __m128  v2, const int mask);
        extern __m128  _mm_blendv_ps(__m128  v1, __m128  v2, __m128 v3);

        
        

        extern __m128d _mm_blend_pd (__m128d v1, __m128d v2, const int mask);
        extern __m128d _mm_blendv_pd(__m128d v1, __m128d v2, __m128d v3);

        
        

        extern __m128  _mm_dp_ps(__m128  val1, __m128  val2, const int mask);
        extern __m128d _mm_dp_pd(__m128d val1, __m128d val2, const int mask);

        
        

        extern __m128i _mm_cmpeq_epi64(__m128i val1, __m128i val2);

        

        extern __m128i _mm_min_epi8 (__m128i val1, __m128i val2);
        extern __m128i _mm_max_epi8 (__m128i val1, __m128i val2);

        extern __m128i _mm_min_epu16(__m128i val1, __m128i val2);
        extern __m128i _mm_max_epu16(__m128i val1, __m128i val2);

        extern __m128i _mm_min_epi32(__m128i val1, __m128i val2);
        extern __m128i _mm_max_epi32(__m128i val1, __m128i val2);
        extern __m128i _mm_min_epu32(__m128i val1, __m128i val2);
        extern __m128i _mm_max_epu32(__m128i val1, __m128i val2);

        
        

        extern __m128i _mm_mullo_epi32(__m128i a, __m128i b);

        
        

        extern __m128i _mm_mul_epi32(__m128i a, __m128i b);

        
        

        extern int _mm_testz_si128(__m128i mask, __m128i val);

        
        

        extern int _mm_testc_si128(__m128i mask, __m128i val);

        
        
        

        extern int _mm_testnzc_si128(__m128i mask, __m128i s2);

        
        
        
        
        

        extern __m128 _mm_insert_ps(__m128 dst, __m128 src, const int ndx);

        




        
        

        extern int _mm_extract_ps(__m128 src, const int ndx);

        
        




        
        





        
        

        extern __m128i _mm_insert_epi8 (__m128i dst, int s, const int ndx);
        extern __m128i _mm_insert_epi32(__m128i dst, int s, const int ndx);


        extern __m128i _mm_insert_epi64(__m128i dst, __int64 s, const int ndx);
#line 190 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\smmintrin.h"
        
        

        extern int   _mm_extract_epi8 (__m128i src, const int ndx);
        extern int   _mm_extract_epi32(__m128i src, const int ndx);


        extern __int64 _mm_extract_epi64(__m128i src, const int ndx);
#line 199 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\smmintrin.h"

        
        

        extern __m128i _mm_minpos_epu16(__m128i shortValues);

        

        extern __m128d _mm_round_pd(__m128d val, int iRoundMode);
        extern __m128d _mm_round_sd(__m128d dst, __m128d val, int iRoundMode);

        

        extern __m128  _mm_round_ps(__m128  val, int iRoundMode);
        extern __m128  _mm_round_ss(__m128 dst, __m128  val, int iRoundMode);

        

        extern __m128i _mm_cvtepi8_epi32 (__m128i byteValues);
        extern __m128i _mm_cvtepi16_epi32(__m128i shortValues);
        extern __m128i _mm_cvtepi8_epi64 (__m128i byteValues); 
        extern __m128i _mm_cvtepi32_epi64(__m128i intValues);
        extern __m128i _mm_cvtepi16_epi64(__m128i shortValues);
        extern __m128i _mm_cvtepi8_epi16 (__m128i byteValues);

        

        extern __m128i _mm_cvtepu8_epi32 (__m128i byteValues);
        extern __m128i _mm_cvtepu16_epi32(__m128i shortValues);
        extern __m128i _mm_cvtepu8_epi64 (__m128i shortValues);
        extern __m128i _mm_cvtepu32_epi64(__m128i intValues);
        extern __m128i _mm_cvtepu16_epi64(__m128i shortValues);
        extern __m128i _mm_cvtepu8_epi16 (__m128i byteValues);


        
        

        extern __m128i _mm_packus_epi32(__m128i val1, __m128i val2);

        
        
        

        extern __m128i _mm_mpsadbw_epu8(__m128i s1, __m128i s2, const int msk);

        



        extern __m128i _mm_stream_load_si128(__m128i* v1);


}; 
#line 254 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\smmintrin.h"

#line 256 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\smmintrin.h"

#line 258 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\smmintrin.h"
#line 259 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\smmintrin.h"
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\nmmintrin.h"



extern "C" {
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\nmmintrin.h"












































 
    extern __m128i _mm_cmpistrm (__m128i a, __m128i b, const int mode);
    extern int     _mm_cmpistri (__m128i a, __m128i b, const int mode);

    extern __m128i _mm_cmpestrm (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int     _mm_cmpestri (__m128i a, int la, __m128i b, int lb, const int mode);





    extern int     _mm_cmpistrz (__m128i a, __m128i b, const int mode);
    extern int     _mm_cmpistrc (__m128i a, __m128i b, const int mode);
    extern int     _mm_cmpistrs (__m128i a, __m128i b, const int mode);
    extern int     _mm_cmpistro (__m128i a, __m128i b, const int mode);
    extern int     _mm_cmpistra (__m128i a, __m128i b, const int mode);

    extern int     _mm_cmpestrz (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int     _mm_cmpestrc (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int     _mm_cmpestrs (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int     _mm_cmpestro (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int     _mm_cmpestra (__m128i a, int la, __m128i b, int lb, const int mode);






    extern __m128i _mm_cmpgt_epi64(__m128i val1, __m128i val2);





    extern int _mm_popcnt_u32(unsigned int v);


    extern __int64 _mm_popcnt_u64(unsigned __int64 v);
#line 116 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\nmmintrin.h"





    extern unsigned int _mm_crc32_u8 (unsigned int crc, unsigned char v);
    extern unsigned int _mm_crc32_u16(unsigned int crc, unsigned short v);
    extern unsigned int _mm_crc32_u32(unsigned int crc, unsigned int v);


    extern unsigned __int64 _mm_crc32_u64(unsigned __int64 crc, unsigned __int64 v);
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\nmmintrin.h"


}; 
#line 132 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\nmmintrin.h"

#line 134 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\nmmintrin.h"

#line 136 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\nmmintrin.h"
#line 137 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\nmmintrin.h"
#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wmmintrin.h"



extern "C" {
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wmmintrin.h"





extern __m128i _mm_aesdec_si128(__m128i v, __m128i rkey);





extern __m128i _mm_aesdeclast_si128(__m128i v, __m128i rkey);





extern __m128i _mm_aesenc_si128(__m128i v, __m128i rkey);





extern __m128i _mm_aesenclast_si128(__m128i v, __m128i rkey);





extern __m128i _mm_aesimc_si128(__m128i v);






extern __m128i _mm_aeskeygenassist_si128(__m128i ckey, const int rcon);







extern __m128i _mm_clmulepi64_si128(__m128i v1, __m128i v2, 
					    const int imm8);





}; 
#line 85 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wmmintrin.h"

#line 87 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wmmintrin.h"

#line 89 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wmmintrin.h"
#line 90 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wmmintrin.h"
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"


extern "C" {
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"




typedef union __declspec(intrin_type) __declspec(align(32)) __m256 {
    float m256_f32[8];
} __m256;

typedef struct __declspec(intrin_type) __declspec(align(32)) __m256d {
    double m256d_f64[4];
} __m256d;

typedef union  __declspec(intrin_type) __declspec(align(32)) __m256i {
    __int8              m256i_i8[32];
    __int16             m256i_i16[16];
    __int32             m256i_i32[8];
    __int64             m256i_i64[4];
    unsigned __int8     m256i_u8[32];
    unsigned __int16    m256i_u16[16];
    unsigned __int32    m256i_u32[8];
    unsigned __int64    m256i_u64[4];
} __m256i;



















































extern __m256d __cdecl _mm256_add_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_add_ps(__m256, __m256);












extern __m256d __cdecl _mm256_addsub_pd(__m256d, __m256d);












extern __m256 __cdecl _mm256_addsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_and_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_and_ps(__m256, __m256);








extern __m256d __cdecl _mm256_andnot_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_andnot_ps(__m256, __m256);













extern __m256d __cdecl _mm256_blend_pd(__m256d, __m256d, const int);













extern __m256 __cdecl _mm256_blend_ps(__m256, __m256, const int);









extern __m256d __cdecl _mm256_blendv_pd(__m256d, __m256d, __m256d);









extern __m256 __cdecl _mm256_blendv_ps(__m256, __m256, __m256);








extern __m256d __cdecl _mm256_div_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_div_ps(__m256, __m256);














extern __m256 __cdecl _mm256_dp_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_hadd_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hadd_ps(__m256, __m256);








extern __m256d __cdecl _mm256_hsub_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_max_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_max_ps(__m256, __m256);








extern __m256d __cdecl _mm256_min_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_min_ps(__m256, __m256);









extern __m256d __cdecl _mm256_mul_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_mul_ps(__m256, __m256);








extern __m256d __cdecl _mm256_or_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_or_ps(__m256, __m256);











extern __m256d __cdecl _mm256_shuffle_pd(__m256d, __m256d, const int);












extern __m256 __cdecl _mm256_shuffle_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_sub_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_sub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_xor_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_xor_ps(__m256, __m256);















extern __m128d __cdecl _mm_cmp_pd(__m128d, __m128d, const int);
extern __m256d __cdecl _mm256_cmp_pd(__m256d, __m256d, const int);















extern __m128 __cdecl _mm_cmp_ps(__m128, __m128, const int);
extern __m256 __cdecl _mm256_cmp_ps(__m256, __m256, const int);












extern __m128d __cdecl _mm_cmp_sd(__m128d, __m128d, const int);












extern __m128 __cdecl _mm_cmp_ss(__m128, __m128, const int);








extern __m256d __cdecl _mm256_cvtepi32_pd(__m128i);








extern __m256  __cdecl _mm256_cvtepi32_ps(__m256i);









extern __m128  __cdecl _mm256_cvtpd_ps(__m256d);








extern __m256i __cdecl _mm256_cvtps_epi32(__m256);









extern __m256d __cdecl _mm256_cvtps_pd(__m128);












extern __m128i __cdecl _mm256_cvttpd_epi32(__m256d);








extern __m128i __cdecl _mm256_cvtpd_epi32(__m256d);












extern __m256i __cdecl _mm256_cvttps_epi32(__m256);







extern __m128  __cdecl _mm256_extractf128_ps(__m256, const int);
extern __m128d __cdecl _mm256_extractf128_pd(__m256d, const int);
extern __m128i __cdecl _mm256_extractf128_si256(__m256i, const int);






extern void __cdecl _mm256_zeroall(void);







extern void __cdecl _mm256_zeroupper(void);









extern __m256  __cdecl _mm256_permutevar_ps(__m256, __m256i);
extern __m128  __cdecl _mm_permutevar_ps(__m128, __m128i);









extern __m256  __cdecl _mm256_permute_ps(__m256, int);
extern __m128  __cdecl _mm_permute_ps(__m128, int);









extern __m256d __cdecl _mm256_permutevar_pd(__m256d, __m256i);
extern __m128d __cdecl _mm_permutevar_pd(__m128d, __m128i);









extern __m256d __cdecl _mm256_permute_pd(__m256d, int);
extern __m128d __cdecl _mm_permute_pd(__m128d, int);








extern __m256  __cdecl _mm256_permute2f128_ps(__m256, __m256, int);
extern __m256d __cdecl _mm256_permute2f128_pd(__m256d, __m256d, int);
extern __m256i __cdecl _mm256_permute2f128_si256(__m256i, __m256i, int);








extern __m256  __cdecl _mm256_broadcast_ss(float const *);
extern __m128  __cdecl _mm_broadcast_ss(float const *);







extern __m256d __cdecl _mm256_broadcast_sd(double const *);







extern __m256  __cdecl _mm256_broadcast_ps(__m128 const *);
extern __m256d __cdecl _mm256_broadcast_pd(__m128d const *);









extern __m256  __cdecl _mm256_insertf128_ps(__m256, __m128, int);
extern __m256d __cdecl _mm256_insertf128_pd(__m256d, __m128d, int);
extern __m256i __cdecl _mm256_insertf128_si256(__m256i, __m128i, int);








extern __m256d __cdecl _mm256_load_pd(double const *);
extern void    __cdecl _mm256_store_pd(double *, __m256d);








extern __m256  __cdecl _mm256_load_ps(float const *);
extern void    __cdecl _mm256_store_ps(float *, __m256);








extern __m256d __cdecl _mm256_loadu_pd(double const *);
extern void    __cdecl _mm256_storeu_pd(double *, __m256d);








extern __m256  __cdecl _mm256_loadu_ps(float const *);
extern void    __cdecl _mm256_storeu_ps(float *, __m256);








extern __m256i __cdecl _mm256_load_si256(__m256i const *);
extern void    __cdecl _mm256_store_si256(__m256i *, __m256i);








extern __m256i __cdecl _mm256_loadu_si256(__m256i const *);
extern void    __cdecl _mm256_storeu_si256(__m256i *, __m256i);







































































extern __m256d __cdecl _mm256_maskload_pd(double const *, __m256i);
extern void    __cdecl _mm256_maskstore_pd(double *, __m256i, __m256d);
extern __m128d __cdecl _mm_maskload_pd(double const *, __m128i);
extern void    __cdecl _mm_maskstore_pd(double *, __m128i, __m128d);



















extern __m256  __cdecl _mm256_maskload_ps(float const *, __m256i);
extern void    __cdecl _mm256_maskstore_ps(float *, __m256i, __m256);
extern __m128  __cdecl _mm_maskload_ps(float const *, __m128i);
extern void    __cdecl _mm_maskstore_ps(float *, __m128i, __m128);







extern __m256  __cdecl _mm256_movehdup_ps(__m256);







extern __m256  __cdecl _mm256_moveldup_ps(__m256);







extern __m256d __cdecl _mm256_movedup_pd(__m256d);









extern __m256i __cdecl _mm256_lddqu_si256(__m256i const *);







extern void    __cdecl _mm256_stream_si256(__m256i *, __m256i);








extern void    __cdecl _mm256_stream_pd(double *, __m256d);








extern void    __cdecl _mm256_stream_ps(float *, __m256);









extern __m256  __cdecl _mm256_rcp_ps(__m256);










extern __m256  __cdecl _mm256_rsqrt_ps(__m256);








extern __m256d __cdecl _mm256_sqrt_pd(__m256d);








extern __m256  __cdecl _mm256_sqrt_ps(__m256);












extern __m256d __cdecl _mm256_round_pd(__m256d, int);














extern __m256  __cdecl _mm256_round_ps(__m256, int);









extern __m256d __cdecl _mm256_unpackhi_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpackhi_ps(__m256, __m256);







extern __m256d __cdecl _mm256_unpacklo_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpacklo_ps(__m256, __m256);









extern int     __cdecl _mm256_testz_si256(__m256i, __m256i);


			  
extern int     __cdecl _mm256_testc_si256(__m256i, __m256i);


			  
extern int     __cdecl _mm256_testnzc_si256(__m256i, __m256i);














extern int     __cdecl _mm256_testz_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testc_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testnzc_pd(__m256d, __m256d);
extern int     __cdecl _mm_testz_pd(__m128d, __m128d);
extern int     __cdecl _mm_testc_pd(__m128d, __m128d);
extern int     __cdecl _mm_testnzc_pd(__m128d, __m128d);












extern int     __cdecl _mm256_testz_ps(__m256, __m256);
extern int     __cdecl _mm256_testc_ps(__m256, __m256);
extern int     __cdecl _mm256_testnzc_ps(__m256, __m256);
extern int     __cdecl _mm_testz_ps(__m128, __m128);
extern int     __cdecl _mm_testc_ps(__m128, __m128);
extern int     __cdecl _mm_testnzc_ps(__m128, __m128);








extern int     __cdecl _mm256_movemask_pd(__m256d);








extern int     __cdecl _mm256_movemask_ps(__m256);




extern __m256d __cdecl _mm256_setzero_pd(void);
extern __m256  __cdecl _mm256_setzero_ps(void);
extern __m256i __cdecl _mm256_setzero_si256(void);




extern __m256d __cdecl _mm256_set_pd(double, double, double, double);
extern __m256  __cdecl _mm256_set_ps(float, float, float, float,
                                            float, float, float, float);
extern __m256i __cdecl _mm256_set_epi8(char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char);
extern __m256i __cdecl _mm256_set_epi16(short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short);
extern __m256i __cdecl _mm256_set_epi32(int, int, int, int,
                                               int, int, int, int);
extern __m256i __cdecl _mm256_set_epi64x(__int64, __int64,
                                                __int64, __int64);










extern __m256d __cdecl _mm256_setr_pd(double, double, double, double);
extern __m256  __cdecl _mm256_setr_ps(float, float, float, float,
                                             float, float, float, float);
extern __m256i __cdecl _mm256_setr_epi8(char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char);
extern __m256i __cdecl _mm256_setr_epi16(short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short);
extern __m256i __cdecl _mm256_setr_epi32(int, int, int, int,
                                                int, int, int, int);
extern __m256i __cdecl _mm256_setr_epi64x(__int64, __int64,
                                                 __int64, __int64);







extern __m256d __cdecl _mm256_set1_pd(double);
extern __m256  __cdecl _mm256_set1_ps(float);
extern __m256i __cdecl _mm256_set1_epi8(char);
extern __m256i __cdecl _mm256_set1_epi16(short);
extern __m256i __cdecl _mm256_set1_epi32(int);
extern __m256i __cdecl _mm256_set1_epi64x(long long);







extern __m256  __cdecl _mm256_castpd_ps(__m256d);
extern __m256d __cdecl _mm256_castps_pd(__m256);
extern __m256i __cdecl _mm256_castps_si256(__m256);
extern __m256i __cdecl _mm256_castpd_si256(__m256d);
extern __m256  __cdecl _mm256_castsi256_ps(__m256i);
extern __m256d __cdecl _mm256_castsi256_pd(__m256i);
extern __m128  __cdecl _mm256_castps256_ps128(__m256);
extern __m128d __cdecl _mm256_castpd256_pd128(__m256d);
extern __m128i __cdecl _mm256_castsi256_si128(__m256i);
extern __m256  __cdecl _mm256_castps128_ps256(__m128);
extern __m256d __cdecl _mm256_castpd128_pd256(__m128d);
extern __m256i __cdecl _mm256_castsi128_si256(__m128i);






extern __m128  __cdecl _mm_cvtph_ps(__m128i);
extern __m256  __cdecl _mm256_cvtph_ps(__m128i);
extern __m128i __cdecl _mm_cvtps_ph(__m128 m1, const int imm);
extern __m128i __cdecl _mm256_cvtps_ph(__m256, int);




















extern unsigned __int64 __cdecl _xgetbv(unsigned int);


extern void __cdecl _xsetbv(unsigned int, unsigned __int64);






extern void __cdecl _xsave(void *, unsigned __int64);

extern void __cdecl _xsave64(void *, unsigned __int64);
#line 1216 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"






extern void __cdecl _xsaveopt(void *, unsigned __int64);

extern void __cdecl _xsaveopt64(void *, unsigned __int64);
#line 1226 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"






extern void __cdecl _xrstor(void const *, unsigned __int64);

extern void __cdecl _xrstor64(void const *, unsigned __int64);
#line 1236 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"





extern void __cdecl _fxsave(void *);

extern void __cdecl _fxsave64(void *);
#line 1245 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"





extern void __cdecl _fxrstor(void const *);

extern void __cdecl _fxrstor64(void const *);
#line 1254 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"







extern int __cdecl _rdrand16_step(unsigned short *);
extern int __cdecl _rdrand32_step(unsigned int *);

extern int __cdecl _rdrand64_step(unsigned __int64 *);
#line 1266 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"





extern unsigned int     __cdecl _readfsbase_u32();
extern unsigned int     __cdecl _readgsbase_u32();
extern unsigned __int64 __cdecl _readfsbase_u64();
extern unsigned __int64 __cdecl _readgsbase_u64();




extern void __cdecl _writefsbase_u32(unsigned int);
extern void __cdecl _writegsbase_u32(unsigned int);
extern void __cdecl _writefsbase_u64(unsigned __int64);
extern void __cdecl _writegsbase_u64(unsigned __int64);
#line 1284 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"




extern __m128  __cdecl _mm_fmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_sd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmsub_pd(__m256d, __m256d, __m256d);





extern __m128  __cdecl _mm_fmaddsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmaddsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsubadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsubadd_pd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmaddsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmaddsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsubadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsubadd_pd(__m256d, __m256d, __m256d);





extern __m256i __cdecl _mm256_cmpeq_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_cmpgt_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi64(__m256i, __m256i);





extern __m256i __cdecl _mm256_max_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu32(__m256i, __m256i);

extern __m256i __cdecl _mm256_min_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu32(__m256i, __m256i);





extern __m256i __cdecl _mm256_and_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_andnot_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_or_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_xor_si256(__m256i, __m256i);





extern __m256i __cdecl _mm256_abs_epi8(__m256i);
extern __m256i __cdecl _mm256_abs_epi16(__m256i);
extern __m256i __cdecl _mm256_abs_epi32(__m256i);

extern __m256i __cdecl _mm256_add_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_adds_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sub_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_subs_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_avg_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_avg_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hadd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadd_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadds_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hsub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_madd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_maddubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mulhi_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mullo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mullo_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mul_epu32(__m256i, __m256i);
extern __m256i __cdecl _mm256_mul_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_sign_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhrs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sad_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mpsadbw_epu8(__m256i, __m256i, const int);





extern __m256i __cdecl _mm256_slli_si256(__m256i, const int);
extern __m256i __cdecl _mm256_srli_si256(__m256i, const int);

extern __m256i __cdecl _mm256_sll_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_slli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_sllv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sllv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_sllv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_sllv_epi64(__m128i, __m128i);

extern __m256i __cdecl _mm256_sra_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sra_epi32(__m256i, __m128i);

extern __m256i __cdecl _mm256_srai_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srai_epi32(__m256i, int);

extern __m256i __cdecl _mm256_srav_epi32(__m256i, __m256i);

extern __m128i __cdecl _mm_srav_epi32(__m128i, __m128i);

extern __m256i __cdecl _mm256_srl_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_srli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_srlv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_srlv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_srlv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_srlv_epi64(__m128i, __m128i);





extern __m128i __cdecl _mm_blend_epi32(__m128i, __m128i, const int);

extern __m256i __cdecl _mm256_blend_epi32(__m256i,__m256i, const int);

extern __m256i __cdecl _mm256_alignr_epi8(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_blendv_epi8(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_blend_epi16(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_packs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packs_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpackhi_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpacklo_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_shuffle_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_shuffle_epi32(__m256i, const int);

extern __m256i __cdecl _mm256_shufflehi_epi16(__m256i, const int);
extern __m256i __cdecl _mm256_shufflelo_epi16(__m256i, const int);

extern __m128i __cdecl _mm256_extracti128_si256(__m256i, const int);
extern __m256i __cdecl _mm256_inserti128_si256(__m256i, __m128i, const int);





extern __m128  __cdecl _mm_broadcastss_ps(__m128);
extern __m128d __cdecl _mm_broadcastsd_pd(__m128d);

extern __m128i __cdecl _mm_broadcastb_epi8(__m128i);
extern __m128i __cdecl _mm_broadcastw_epi16(__m128i);
extern __m128i __cdecl _mm_broadcastd_epi32(__m128i);
extern __m128i __cdecl _mm_broadcastq_epi64(__m128i);

extern __m256  __cdecl _mm256_broadcastss_ps(__m128);
extern __m256d __cdecl _mm256_broadcastsd_pd(__m128d);

extern __m256i __cdecl _mm256_broadcastb_epi8(__m128i);
extern __m256i __cdecl _mm256_broadcastw_epi16(__m128i);
extern __m256i __cdecl _mm256_broadcastd_epi32(__m128i);
extern __m256i __cdecl _mm256_broadcastq_epi64(__m128i);

extern __m256i __cdecl _mm256_broadcastsi128_si256(__m128i);






extern __m256i __cdecl _mm256_cvtepi8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi32_epi64(__m128i);

extern __m256i __cdecl _mm256_cvtepu8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu32_epi64(__m128i);






extern int __cdecl _mm256_movemask_epi8(__m256i);





extern __m128i __cdecl _mm_maskload_epi32(int const * ,
                                          __m128i     );
extern __m128i __cdecl _mm_maskload_epi64(__int64 const * ,
                                          __m128i         );

extern void __cdecl _mm_maskstore_epi32(int *   ,
                                        __m128i ,
                                        __m128i );
extern void __cdecl _mm_maskstore_epi64(__int64 * ,
                                        __m128i   ,
                                        __m128i   );

extern __m256i __cdecl _mm256_maskload_epi32(int const * ,
                                             __m256i     );
extern __m256i __cdecl _mm256_maskload_epi64(__int64 const * ,
                                             __m256i         );

extern void __cdecl _mm256_maskstore_epi32(int *   ,
                                           __m256i ,
                                           __m256i );
extern void __cdecl _mm256_maskstore_epi64(__int64 * ,
                                           __m256i   ,
                                           __m256i   );





extern __m256i __cdecl _mm256_permutevar8x32_epi32(__m256i, __m256i);
extern __m256  __cdecl _mm256_permutevar8x32_ps(__m256, __m256i);

extern __m256i __cdecl _mm256_permute4x64_epi64(__m256i, const int);
extern __m256d __cdecl _mm256_permute4x64_pd(__m256d, const int);

extern __m256i __cdecl _mm256_permute2x128_si256(__m256i, __m256i, const int);





extern __m256i  __cdecl _mm256_stream_load_si256(__m256i const *);






extern __m256d __cdecl _mm256_mask_i32gather_pd(__m256d        ,
                                                double const * ,
                                                __m128i        ,
                                                __m256d        ,
                                                const int      );
extern __m256  __cdecl _mm256_mask_i32gather_ps(__m256         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m256         ,
                                                const int      );
extern __m256d __cdecl _mm256_mask_i64gather_pd(__m256d        ,
                                                double const * ,
                                                __m256i        ,
                                                __m256d        ,
                                                const int      );
extern __m128  __cdecl _mm256_mask_i64gather_ps(__m128         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m128         ,
                                                const int      );

extern __m128d __cdecl _mm_mask_i32gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i32gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );
extern __m128d __cdecl _mm_mask_i64gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i64gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );


extern __m256i __cdecl _mm256_mask_i32gather_epi32(__m256i     ,
                                                   int const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i32gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m128i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m128i __cdecl _mm256_mask_i64gather_epi32(__m128i     ,
                                                   int     const * ,
                                                   __m256i     ,
                                                   __m128i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i64gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );

extern __m128i __cdecl _mm_mask_i32gather_epi32(__m128i         ,
                                                int const *     ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i32gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi32(__m128i         ,
                                                int     const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );





extern __m256d __cdecl _mm256_i32gather_pd(double const * ,
                                           __m128i        ,
                                           const int      );
extern __m256  __cdecl _mm256_i32gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );
extern __m256d __cdecl _mm256_i64gather_pd(double const * ,
                                           __m256i        ,
                                           const int      );
extern __m128  __cdecl _mm256_i64gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );

extern __m128d __cdecl _mm_i32gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i32gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );
extern __m128d __cdecl _mm_i64gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i64gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );

extern __m256i __cdecl _mm256_i32gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i32gather_epi64(__int64 const * ,
                                              __m128i         ,
                                              const int       );
extern __m128i __cdecl _mm256_i64gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i64gather_epi64(__int64 const * ,
                                              __m256i         ,
                                              const int       );

extern __m128i __cdecl _mm_i32gather_epi32(int const *     ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i32gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi32(int     const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );





extern unsigned int     _bextr_u32(unsigned int ,
                                   unsigned int ,
                                   unsigned int );
extern unsigned int     _blsi_u32(unsigned int);
extern unsigned int     _blsmsk_u32(unsigned int);
extern unsigned int     _blsr_u32(unsigned int);
extern unsigned int     _bzhi_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _mulx_u32(unsigned int ,
                                  unsigned int ,
                                  unsigned int * );
extern unsigned int     _pdep_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _pext_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _rorx_u32(unsigned int ,
                                  const unsigned int );
extern int              _sarx_i32(int ,
                                  unsigned int );
extern unsigned int     _shlx_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _shrx_u32(unsigned int ,
                                          unsigned int );


extern unsigned __int64 _bextr_u64(unsigned __int64 ,
                                   unsigned int ,
                                   unsigned int );
extern unsigned __int64 _blsi_u64(unsigned __int64);
extern unsigned __int64 _blsmsk_u64(unsigned __int64);
extern unsigned __int64 _blsr_u64(unsigned __int64);
extern unsigned __int64 _bzhi_u64(unsigned __int64 ,
                                  unsigned int );
extern unsigned __int64 _mulx_u64(unsigned __int64 ,
                                  unsigned __int64 ,
                                  unsigned __int64 * );
extern unsigned __int64 _pdep_u64(unsigned __int64 ,
                                  unsigned __int64 );
extern unsigned __int64 _pext_u64(unsigned __int64 ,
                                  unsigned __int64 );
extern unsigned __int64 _rorx_u64(unsigned __int64 ,
                                  const unsigned int );
extern __int64          _sarx_i64(__int64 ,
                                  unsigned int );
extern unsigned __int64 _shlx_u64(unsigned __int64 ,
                                  unsigned int );
extern unsigned __int64 _shrx_u64(unsigned __int64 ,
                                          unsigned int );
#line 1804 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"








extern unsigned int     _lzcnt_u32(unsigned int);

extern unsigned __int64 _lzcnt_u64(unsigned __int64);
#line 1816 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"








extern unsigned int     _tzcnt_u32(unsigned int);

extern unsigned __int64 _tzcnt_u64(unsigned __int64);
#line 1828 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"






extern void __cdecl _invpcid(unsigned int , void * );


long _InterlockedCompareExchange_HLEAcquire(long volatile *,long,long);
long _InterlockedCompareExchange_HLERelease(long volatile *,long,long);
__int64 _InterlockedCompareExchange64_HLEAcquire(__int64 volatile *,__int64,__int64);
__int64 _InterlockedCompareExchange64_HLERelease(__int64 volatile *,__int64,__int64);
void *_InterlockedCompareExchangePointer_HLEAcquire(void *volatile *,void *,void *);
void *_InterlockedCompareExchangePointer_HLERelease(void *volatile *,void *,void *);
long _InterlockedExchangeAdd_HLEAcquire(long volatile *,long);
long _InterlockedExchangeAdd_HLERelease(long volatile *,long);
__int64 _InterlockedExchangeAdd64_HLEAcquire(__int64 volatile *,__int64);
__int64 _InterlockedExchangeAdd64_HLERelease(__int64 volatile *,__int64);
void _Store_HLERelease(long volatile *,long);
void _Store64_HLERelease(__int64 volatile *,__int64);
void _StorePointer_HLERelease(void * volatile *,void *);











unsigned __int32 _xbegin(void);
void _xend(void);
void _xabort(const unsigned int imm);
unsigned char _xtest(void);


}; 
#line 1869 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"

#line 1871 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"

#line 1873 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"
#line 1874 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\immintrin.h"

#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ammintrin.h"












#pragma once






#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ammintrin.h"


extern "C" { 
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ammintrin.h"





























































































__m128 _mm_macc_ps(__m128, __m128, __m128);
__m128d _mm_macc_pd(__m128d, __m128d, __m128d);
__m128 _mm_macc_ss(__m128, __m128, __m128);
__m128d _mm_macc_sd(__m128d, __m128d, __m128d);
__m128 _mm_maddsub_ps(__m128, __m128, __m128);
__m128d _mm_maddsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msubadd_ps(__m128, __m128, __m128);
__m128d _mm_msubadd_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ps(__m128, __m128, __m128);
__m128d _mm_msub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ss(__m128, __m128, __m128);
__m128d _mm_msub_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ps(__m128, __m128, __m128);
__m128d _mm_nmacc_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ss(__m128, __m128, __m128);
__m128d _mm_nmacc_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ps(__m128, __m128, __m128);
__m128d _mm_nmsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ss(__m128, __m128, __m128);
__m128d _mm_nmsub_sd(__m128d, __m128d, __m128d);


__m128i _mm_maccs_epi16(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccs_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccslo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macclo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccshi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macchi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maddsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maddd_epi16(__m128i, __m128i, __m128i);


__m128i _mm_haddw_epi8(__m128i);
__m128i _mm_haddd_epi8(__m128i);
__m128i _mm_haddq_epi8(__m128i);
__m128i _mm_haddd_epi16(__m128i);
__m128i _mm_haddq_epi16(__m128i);
__m128i _mm_haddq_epi32(__m128i);
__m128i _mm_haddw_epu8(__m128i);
__m128i _mm_haddd_epu8(__m128i);
__m128i _mm_haddq_epu8(__m128i);
__m128i _mm_haddd_epu16(__m128i);
__m128i _mm_haddq_epu16(__m128i);
__m128i _mm_haddq_epu32(__m128i);
__m128i _mm_hsubw_epi8(__m128i);
__m128i _mm_hsubd_epi16(__m128i);
__m128i _mm_hsubq_epi32(__m128i);


__m128i _mm_cmov_si128(__m128i, __m128i, __m128i);
__m128i _mm_perm_epi8(__m128i, __m128i, __m128i);


__m128i _mm_rot_epi8(__m128i, __m128i);
__m128i _mm_rot_epi16(__m128i, __m128i);
__m128i _mm_rot_epi32(__m128i, __m128i);
__m128i _mm_rot_epi64(__m128i, __m128i);
__m128i _mm_roti_epi8(__m128i, int);
__m128i _mm_roti_epi16(__m128i, int);
__m128i _mm_roti_epi32(__m128i, int);
__m128i _mm_roti_epi64(__m128i, int);
__m128i _mm_shl_epi8(__m128i, __m128i);
__m128i _mm_shl_epi16(__m128i, __m128i);
__m128i _mm_shl_epi32(__m128i, __m128i);
__m128i _mm_shl_epi64(__m128i, __m128i);
__m128i _mm_sha_epi8(__m128i, __m128i);
__m128i _mm_sha_epi16(__m128i, __m128i);
__m128i _mm_sha_epi32(__m128i, __m128i);
__m128i _mm_sha_epi64(__m128i, __m128i);



__m128i _mm_com_epu8(__m128i, __m128i, int);
__m128i _mm_com_epu16(__m128i, __m128i, int);
__m128i _mm_com_epu32(__m128i, __m128i, int);
__m128i _mm_com_epu64(__m128i, __m128i, int);
__m128i _mm_com_epi8(__m128i, __m128i, int);
__m128i _mm_com_epi16(__m128i, __m128i, int);
__m128i _mm_com_epi32(__m128i, __m128i, int);
__m128i _mm_com_epi64(__m128i, __m128i, int);



__m128 _mm_frcz_ps(__m128);
__m128d _mm_frcz_pd(__m128d);
__m128 _mm_frcz_ss(__m128, __m128);
__m128d _mm_frcz_sd(__m128d, __m128d);








__m128 _mm_permute2_ps(__m128, __m128, __m128i, int);
__m128d _mm_permute2_pd(__m128d, __m128d, __m128i, int);



__m256 _mm256_macc_ps(__m256, __m256, __m256);
__m256d _mm256_macc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_maddsub_ps(__m256, __m256, __m256);
__m256d _mm256_maddsub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msubadd_ps(__m256, __m256, __m256);
__m256d _mm256_msubadd_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msub_ps(__m256, __m256, __m256);
__m256d _mm256_msub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmacc_ps(__m256, __m256, __m256);
__m256d _mm256_nmacc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmsub_ps(__m256, __m256, __m256);
__m256d _mm256_nmsub_pd(__m256d, __m256d, __m256d);
__m256i _mm256_cmov_si256(__m256i, __m256i, __m256i);
__m256 _mm256_frcz_ps(__m256);
__m256d _mm256_frcz_pd(__m256d);
__m256 _mm256_permute2_ps(__m256, __m256, __m256i, int);
__m256d _mm256_permute2_pd(__m256d, __m256d, __m256i, int);


void __llwpcb(void *);
void *__slwpcb();
void __lwpval32(unsigned int, unsigned int, unsigned int);
unsigned char __lwpins32(unsigned int, unsigned int, unsigned int);

void __lwpval64(unsigned __int64, unsigned int, unsigned int);
unsigned char __lwpins64(unsigned __int64, unsigned int, unsigned int);
#line 249 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ammintrin.h"


unsigned int _bextr_u32(unsigned int, unsigned int, unsigned int);
unsigned int _andn_u32(unsigned int, unsigned int);
unsigned int _tzcnt_u32(unsigned int);
unsigned int _lzcnt_u32(unsigned int);
unsigned int _blsr_u32(unsigned int);
unsigned int _blsmsk_u32(unsigned int);
unsigned int _blsi_u32(unsigned int);

unsigned __int64 _bextr_u64(unsigned __int64, unsigned int, unsigned int);
unsigned __int64 _andn_u64(unsigned __int64, unsigned __int64);
unsigned __int64 _tzcnt_u64(unsigned __int64);
unsigned __int64 _lzcnt_u64(unsigned __int64);
unsigned __int64 _blsr_u64(unsigned __int64);
unsigned __int64 _blsmsk_u64(unsigned __int64);
unsigned __int64 _blsi_u64(unsigned __int64);
#line 267 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ammintrin.h"


unsigned int _bextri_u32(unsigned int, unsigned int);
unsigned int _blcfill_u32(unsigned int);
unsigned int _blsfill_u32(unsigned int);
unsigned int _blcs_u32(unsigned int);
unsigned int _tzmsk_u32(unsigned int);
unsigned int _blcic_u32(unsigned int);
unsigned int _blsic_u32(unsigned int);
unsigned int _t1mskc_u32(unsigned int);
unsigned int _blcmsk_u32(unsigned int);
unsigned int _blci_u32(unsigned int);

unsigned __int64 _bextri_u64(unsigned __int64, unsigned int);
unsigned __int64 _blcfill_u64(unsigned __int64);
unsigned __int64 _blsfill_u64(unsigned __int64);
unsigned __int64 _blcs_u64(unsigned __int64);
unsigned __int64 _tzmsk_u64(unsigned __int64);
unsigned __int64 _blcic_u64(unsigned __int64);
unsigned __int64 _blsic_u64(unsigned __int64);
unsigned __int64 _t1mskc_u64(unsigned __int64);
unsigned __int64 _blcmsk_u64(unsigned __int64);
unsigned __int64 _blci_u64(unsigned __int64);
#line 291 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ammintrin.h"


}; 
#line 295 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ammintrin.h"

#line 297 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ammintrin.h"
#line 298 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ammintrin.h"
#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ammintrin.h"
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"



#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"



#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"

#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"

#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"


extern "C" {
#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"






















#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"


#line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"






#line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"




#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"




#line 88 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"




#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"




#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"


void * _AddressOfReturnAddress(void);
unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanForward64(unsigned long * _Index, unsigned __int64 _Mask);
unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanReverse64(unsigned long * _Index, unsigned __int64 _Mask);























long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);


short _InterlockedAnd16_np(short volatile * _Value, short _Mask);

__int64 _InterlockedAnd64(__int64 volatile * _Value, __int64 _Mask);


__int64 _InterlockedAnd64_np(__int64 volatile * _Value, __int64 _Mask);

char _InterlockedAnd8(char volatile * _Value, char _Mask);


char _InterlockedAnd8_np(char volatile * _Value, char _Mask);



long _InterlockedAnd_np(long volatile * _Value, long _Mask);

long __cdecl _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);

unsigned char _InterlockedCompareExchange128(__int64 volatile * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult);
unsigned char _InterlockedCompareExchange128_np(__int64 volatile * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult);
short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);


short _InterlockedCompareExchange16_np(short volatile * _Destination, short _Exchange, short _Comparand);

__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);


__int64 _InterlockedCompareExchange64_np(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);

char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);



void * _InterlockedCompareExchangePointer(void * volatile * _Destination, void * _Exchange, void * _Comparand);


void * _InterlockedCompareExchangePointer_np(void * volatile * _Destination, void * _Exchange, void * _Comparand);



long _InterlockedCompareExchange_np(long volatile * _Destination, long _Exchange, long _Comparand);

long __cdecl _InterlockedDecrement(long volatile * _Addend);

short _InterlockedDecrement16(short volatile * _Addend);



__int64 _InterlockedDecrement64(__int64 volatile * _Addend);






long __cdecl _InterlockedExchange(long volatile * _Target, long _Value);
short _InterlockedExchange16(short volatile * _Target, short _Value);


__int64 _InterlockedExchange64(__int64 volatile * _Target, __int64 _Value);


char _InterlockedExchange8(char volatile * _Target, char _Value);


long __cdecl _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);



__int64 _InterlockedExchangeAdd64(__int64 volatile * _Addend, __int64 _Value);



char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);






void * _InterlockedExchangePointer(void * volatile * _Target, void * _Value);




long __cdecl _InterlockedIncrement(long volatile * _Addend);

short _InterlockedIncrement16(short volatile * _Addend);



__int64 _InterlockedIncrement64(__int64 volatile * _Addend);






long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);


short _InterlockedOr16_np(short volatile * _Value, short _Mask);

__int64 _InterlockedOr64(__int64 volatile * _Value, __int64 _Mask);


__int64 _InterlockedOr64_np(__int64 volatile * _Value, __int64 _Mask);

char _InterlockedOr8(char volatile * _Value, char _Mask);


char _InterlockedOr8_np(char volatile * _Value, char _Mask);



long _InterlockedOr_np(long volatile * _Value, long _Mask);

long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);


short _InterlockedXor16_np(short volatile * _Value, short _Mask);

__int64 _InterlockedXor64(__int64 volatile * _Value, __int64 _Mask);


__int64 _InterlockedXor64_np(__int64 volatile * _Value, __int64 _Mask);

char _InterlockedXor8(char volatile * _Value, char _Mask);


char _InterlockedXor8_np(char volatile * _Value, char _Mask);



long _InterlockedXor_np(long volatile * _Value, long _Mask);









void _ReadBarrier(void);

void _ReadWriteBarrier(void);
void * _ReturnAddress(void);

void _WriteBarrier(void);




void __addgsbyte(unsigned long, unsigned char);
void __addgsdword(unsigned long, unsigned long);
void __addgsqword(unsigned long, unsigned __int64);
void __addgsword(unsigned long, unsigned short);
void __code_seg(const char *);
void __cpuid(int[4], int);
void __cpuidex(int[4], int, int);
void __cdecl __debugbreak(void);

__int64 __emul(int, int);
unsigned __int64 __emulu(unsigned int, unsigned int);
__declspec(noreturn) void __fastfail(unsigned int);
void __faststorefence(void);
unsigned int __getcallerseflags(void);
void __halt(void);

unsigned char __inbyte(unsigned short);
void __inbytestring(unsigned short, unsigned char *, unsigned long);



void __incgsbyte(unsigned long);
void __incgsdword(unsigned long);
void __incgsqword(unsigned long);
void __incgsword(unsigned long);
unsigned long __indword(unsigned short);
void __indwordstring(unsigned short, unsigned long *, unsigned long);
void __int2c(void);
void __invlpg(void *);
unsigned short __inword(unsigned short);
void __inwordstring(unsigned short, unsigned short *, unsigned long);









void __lidt(void *);
unsigned __int64 __ll_lshift(unsigned __int64, int);
__int64 __ll_rshift(__int64, int);
unsigned int __lzcnt(unsigned int);
unsigned short __lzcnt16(unsigned short);
unsigned __int64 __lzcnt64(unsigned __int64);
void __movsb(unsigned char *, unsigned char const *, size_t);
void __movsd(unsigned long *, unsigned long const *, size_t);
void __movsq(unsigned long long *, unsigned long long const *, size_t);
void __movsw(unsigned short *, unsigned short const *, size_t);
__int64 __mulh(__int64, __int64);
void __nop(void);
void __nvreg_restore_fence(void);
void __nvreg_save_fence(void);
void __outbyte(unsigned short, unsigned char);
void __outbytestring(unsigned short, unsigned char *, unsigned long);
void __outdword(unsigned short, unsigned long);
void __outdwordstring(unsigned short, unsigned long *, unsigned long);
void __outword(unsigned short, unsigned short);
void __outwordstring(unsigned short, unsigned short *, unsigned long);
unsigned int __popcnt(unsigned int);
unsigned short __popcnt16(unsigned short);
unsigned __int64 __popcnt64(unsigned __int64);


unsigned __int64 __rdtsc(void);
unsigned __int64 __rdtscp(unsigned int *);
unsigned __int64 __readcr0(void);

unsigned __int64 __readcr2(void);

unsigned __int64 __readcr3(void);

unsigned __int64 __readcr4(void);

unsigned __int64 __readcr8(void);

unsigned __int64 __readdr(unsigned int);

unsigned __int64 __readeflags(void);





unsigned char __readgsbyte(unsigned long);
unsigned long __readgsdword(unsigned long);
unsigned __int64 __readgsqword(unsigned long);
unsigned short __readgsword(unsigned long);
unsigned __int64 __readmsr(unsigned long);
unsigned __int64 __readpmc(unsigned long);
unsigned long __segmentlimit(unsigned long);

unsigned __int64 __shiftleft128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);
unsigned __int64 __shiftright128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);
void __sidt(void *);

void __stosb(unsigned char *, unsigned char, size_t);
void __stosd(unsigned long *, unsigned long, size_t);
void __stosq(unsigned __int64 *, unsigned __int64, size_t);
void __stosw(unsigned short *, unsigned short, size_t);
void __svm_clgi(void);
void __svm_invlpga(void *, int);
void __svm_skinit(int);
void __svm_stgi(void);
void __svm_vmload(size_t);
void __svm_vmrun(size_t);
void __svm_vmsave(size_t);


void __ud2(void);
unsigned __int64 __ull_rshift(unsigned __int64, int);
unsigned __int64 __umulh(unsigned __int64, unsigned __int64);
void __vmx_off(void);
unsigned char __vmx_on(unsigned __int64 *);
unsigned char __vmx_vmclear(unsigned __int64 *);
unsigned char __vmx_vmlaunch(void);
unsigned char __vmx_vmptrld(unsigned __int64 *);
void __vmx_vmptrst(unsigned __int64 *);
unsigned char __vmx_vmread(size_t, size_t *);
unsigned char __vmx_vmresume(void);
unsigned char __vmx_vmwrite(size_t, size_t);
void __wbinvd(void);


void __writecr0(unsigned __int64);

void __writecr3(unsigned __int64);

void __writecr4(unsigned __int64);

void __writecr8(unsigned __int64);

void __writedr(unsigned int, unsigned __int64);

void __writeeflags(unsigned __int64);





void __writegsbyte(unsigned long, unsigned char);
void __writegsdword(unsigned long, unsigned long);
void __writegsqword(unsigned long, unsigned __int64);
void __writegsword(unsigned long, unsigned short);
void __writemsr(unsigned long, unsigned __int64);

unsigned char _bittest(long const *, long);
unsigned char _bittest64(__int64 const *, __int64);
unsigned char _bittestandcomplement(long *, long);
unsigned char _bittestandcomplement64(__int64 *, __int64);
unsigned char _bittestandreset(long *, long);
unsigned char _bittestandreset64(__int64 *, __int64);
unsigned char _bittestandset(long *, long);
unsigned char _bittestandset64(__int64 *, __int64);
  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64);
  unsigned long __cdecl _byteswap_ulong(  unsigned long);
  unsigned short __cdecl _byteswap_ushort(  unsigned short);
void __cdecl _disable(void);
void __cdecl _enable(void);
unsigned char _interlockedbittestandreset(long volatile *, long);
unsigned char _interlockedbittestandreset64(__int64 volatile *, __int64);



unsigned char _interlockedbittestandset(long volatile *, long);
unsigned char _interlockedbittestandset64(__int64 volatile *, __int64);





  unsigned long __cdecl _lrotl(  unsigned long,   int);
  unsigned long __cdecl _lrotr(  unsigned long,   int);




























































void _m_prefetch(void *);
void _m_prefetchw(volatile const void *);



































__m128i _mm_abs_epi16(__m128i);
__m128i _mm_abs_epi32(__m128i);
__m128i _mm_abs_epi8(__m128i);
__m64 _mm_abs_pi16(__m64);
__m64 _mm_abs_pi32(__m64);
__m64 _mm_abs_pi8(__m64);
__m128i _mm_add_epi16(__m128i, __m128i);
__m128i _mm_add_epi32(__m128i, __m128i);
__m128i _mm_add_epi64(__m128i, __m128i);
__m128i _mm_add_epi8(__m128i, __m128i);
__m128d _mm_add_pd(__m128d, __m128d);
__m128 _mm_add_ps(__m128, __m128);
__m128d _mm_add_sd(__m128d, __m128d);

__m128 _mm_add_ss(__m128, __m128);
__m128i _mm_adds_epi16(__m128i, __m128i);
__m128i _mm_adds_epi8(__m128i, __m128i);
__m128i _mm_adds_epu16(__m128i, __m128i);
__m128i _mm_adds_epu8(__m128i, __m128i);
__m128d _mm_addsub_pd(__m128d, __m128d);
__m128 _mm_addsub_ps(__m128, __m128);
__m128i _mm_alignr_epi8(__m128i, __m128i, int);
__m64 _mm_alignr_pi8(__m64, __m64, int);
__m128d _mm_and_pd(__m128d, __m128d);
__m128 _mm_and_ps(__m128, __m128);
__m128i _mm_and_si128(__m128i, __m128i);
__m128d _mm_andnot_pd(__m128d, __m128d);
__m128 _mm_andnot_ps(__m128, __m128);
__m128i _mm_andnot_si128(__m128i, __m128i);
__m128i _mm_avg_epu16(__m128i, __m128i);
__m128i _mm_avg_epu8(__m128i, __m128i);
__m128i _mm_blend_epi16(__m128i, __m128i, int);
__m128d _mm_blend_pd(__m128d, __m128d, int);
__m128 _mm_blend_ps(__m128, __m128, int);
__m128i _mm_blendv_epi8(__m128i, __m128i, __m128i);
__m128d _mm_blendv_pd(__m128d, __m128d, __m128d);
__m128 _mm_blendv_ps(__m128, __m128, __m128);
void _mm_clflush(void const *);
__m128i _mm_cmpeq_epi16(__m128i, __m128i);
__m128i _mm_cmpeq_epi32(__m128i, __m128i);
__m128i _mm_cmpeq_epi64(__m128i, __m128i);
__m128i _mm_cmpeq_epi8(__m128i, __m128i);
__m128d _mm_cmpeq_pd(__m128d, __m128d);
__m128 _mm_cmpeq_ps(__m128, __m128);
__m128d _mm_cmpeq_sd(__m128d, __m128d);
__m128 _mm_cmpeq_ss(__m128, __m128);
int _mm_cmpestra(__m128i, int, __m128i, int, int);
int _mm_cmpestrc(__m128i, int, __m128i, int, int);
int _mm_cmpestri(__m128i, int, __m128i, int, int);
__m128i _mm_cmpestrm(__m128i, int, __m128i, int, int);
int _mm_cmpestro(__m128i, int, __m128i, int, int);
int _mm_cmpestrs(__m128i, int, __m128i, int, int);
int _mm_cmpestrz(__m128i, int, __m128i, int, int);
__m128d _mm_cmpge_pd(__m128d, __m128d);
__m128 _mm_cmpge_ps(__m128, __m128);
__m128d _mm_cmpge_sd(__m128d, __m128d);
__m128 _mm_cmpge_ss(__m128, __m128);
__m128i _mm_cmpgt_epi16(__m128i, __m128i);
__m128i _mm_cmpgt_epi32(__m128i, __m128i);
__m128i _mm_cmpgt_epi64(__m128i, __m128i);
__m128i _mm_cmpgt_epi8(__m128i, __m128i);
__m128d _mm_cmpgt_pd(__m128d, __m128d);
__m128 _mm_cmpgt_ps(__m128, __m128);
__m128d _mm_cmpgt_sd(__m128d, __m128d);
__m128 _mm_cmpgt_ss(__m128, __m128);
int _mm_cmpistra(__m128i, __m128i, int);
int _mm_cmpistrc(__m128i, __m128i, int);
int _mm_cmpistri(__m128i, __m128i, int);
__m128i _mm_cmpistrm(__m128i, __m128i, int);
int _mm_cmpistro(__m128i, __m128i, int);
int _mm_cmpistrs(__m128i, __m128i, int);
int _mm_cmpistrz(__m128i, __m128i, int);
__m128d _mm_cmple_pd(__m128d, __m128d);
__m128 _mm_cmple_ps(__m128, __m128);
__m128d _mm_cmple_sd(__m128d, __m128d);
__m128 _mm_cmple_ss(__m128, __m128);
__m128i _mm_cmplt_epi16(__m128i, __m128i);
__m128i _mm_cmplt_epi32(__m128i, __m128i);
__m128i _mm_cmplt_epi8(__m128i, __m128i);
__m128d _mm_cmplt_pd(__m128d, __m128d);
__m128 _mm_cmplt_ps(__m128, __m128);
__m128d _mm_cmplt_sd(__m128d, __m128d);
__m128 _mm_cmplt_ss(__m128, __m128);
__m128d _mm_cmpneq_pd(__m128d, __m128d);
__m128 _mm_cmpneq_ps(__m128, __m128);
__m128d _mm_cmpneq_sd(__m128d, __m128d);
__m128 _mm_cmpneq_ss(__m128, __m128);
__m128d _mm_cmpnge_pd(__m128d, __m128d);
__m128 _mm_cmpnge_ps(__m128, __m128);
__m128d _mm_cmpnge_sd(__m128d, __m128d);
__m128 _mm_cmpnge_ss(__m128, __m128);
__m128d _mm_cmpngt_pd(__m128d, __m128d);
__m128 _mm_cmpngt_ps(__m128, __m128);
__m128d _mm_cmpngt_sd(__m128d, __m128d);
__m128 _mm_cmpngt_ss(__m128, __m128);
__m128d _mm_cmpnle_pd(__m128d, __m128d);
__m128 _mm_cmpnle_ps(__m128, __m128);
__m128d _mm_cmpnle_sd(__m128d, __m128d);
__m128 _mm_cmpnle_ss(__m128, __m128);
__m128d _mm_cmpnlt_pd(__m128d, __m128d);
__m128 _mm_cmpnlt_ps(__m128, __m128);
__m128d _mm_cmpnlt_sd(__m128d, __m128d);
__m128 _mm_cmpnlt_ss(__m128, __m128);
__m128d _mm_cmpord_pd(__m128d, __m128d);
__m128 _mm_cmpord_ps(__m128, __m128);
__m128d _mm_cmpord_sd(__m128d, __m128d);
__m128 _mm_cmpord_ss(__m128, __m128);
__m128d _mm_cmpunord_pd(__m128d, __m128d);
__m128 _mm_cmpunord_ps(__m128, __m128);
__m128d _mm_cmpunord_sd(__m128d, __m128d);
__m128 _mm_cmpunord_ss(__m128, __m128);
int _mm_comieq_sd(__m128d, __m128d);
int _mm_comieq_ss(__m128, __m128);
int _mm_comige_sd(__m128d, __m128d);
int _mm_comige_ss(__m128, __m128);
int _mm_comigt_sd(__m128d, __m128d);
int _mm_comigt_ss(__m128, __m128);
int _mm_comile_sd(__m128d, __m128d);
int _mm_comile_ss(__m128, __m128);
int _mm_comilt_sd(__m128d, __m128d);
int _mm_comilt_ss(__m128, __m128);
int _mm_comineq_sd(__m128d, __m128d);
int _mm_comineq_ss(__m128, __m128);
unsigned int _mm_crc32_u16(unsigned int, unsigned short);
unsigned int _mm_crc32_u32(unsigned int, unsigned int);
unsigned __int64 _mm_crc32_u64(unsigned __int64, unsigned __int64);
unsigned int _mm_crc32_u8(unsigned int, unsigned char);


__m128 _mm_cvt_si2ss(__m128, int);
int _mm_cvt_ss2si(__m128);
__m128i _mm_cvtepi16_epi32(__m128i);
__m128i _mm_cvtepi16_epi64(__m128i);
__m128i _mm_cvtepi32_epi64(__m128i);
__m128d _mm_cvtepi32_pd(__m128i);
__m128 _mm_cvtepi32_ps(__m128i);
__m128i _mm_cvtepi8_epi16(__m128i);
__m128i _mm_cvtepi8_epi32(__m128i);
__m128i _mm_cvtepi8_epi64(__m128i);
__m128i _mm_cvtepu16_epi32(__m128i);
__m128i _mm_cvtepu16_epi64(__m128i);
__m128i _mm_cvtepu32_epi64(__m128i);
__m128i _mm_cvtepu8_epi16(__m128i);
__m128i _mm_cvtepu8_epi32(__m128i);
__m128i _mm_cvtepu8_epi64(__m128i);
__m128i _mm_cvtpd_epi32(__m128d);

__m128 _mm_cvtpd_ps(__m128d);

__m128i _mm_cvtps_epi32(__m128);
__m128d _mm_cvtps_pd(__m128);
int _mm_cvtsd_si32(__m128d);
__int64 _mm_cvtsd_si64(__m128d);
__int64 _mm_cvtsd_si64x(__m128d);
__m128 _mm_cvtsd_ss(__m128, __m128d);
int _mm_cvtsi128_si32(__m128i);
__int64 _mm_cvtsi128_si64(__m128i);
__int64 _mm_cvtsi128_si64x(__m128i);
__m128d _mm_cvtsi32_sd(__m128d, int);
__m128i _mm_cvtsi32_si128(int);
__m128d _mm_cvtsi64_sd(__m128d, __int64);
__m128i _mm_cvtsi64_si128(__int64);
__m128 _mm_cvtsi64_ss(__m128, __int64);
__m128d _mm_cvtsi64x_sd(__m128d, __int64);
__m128i _mm_cvtsi64x_si128(__int64);
__m128 _mm_cvtsi64x_ss(__m128, __int64);
__m128d _mm_cvtss_sd(__m128d, __m128);
__int64 _mm_cvtss_si64(__m128);
__int64 _mm_cvtss_si64x(__m128);

int _mm_cvtt_ss2si(__m128);
__m128i _mm_cvttpd_epi32(__m128d);

__m128i _mm_cvttps_epi32(__m128);
int _mm_cvttsd_si32(__m128d);
__int64 _mm_cvttsd_si64(__m128d);
__int64 _mm_cvttsd_si64x(__m128d);
__int64 _mm_cvttss_si64(__m128);
__int64 _mm_cvttss_si64x(__m128);
__m128d _mm_div_pd(__m128d, __m128d);
__m128 _mm_div_ps(__m128, __m128);
__m128d _mm_div_sd(__m128d, __m128d);
__m128 _mm_div_ss(__m128, __m128);
__m128d _mm_dp_pd(__m128d, __m128d, int);
__m128 _mm_dp_ps(__m128, __m128, int);
int _mm_extract_epi16(__m128i, int);
int _mm_extract_epi32(__m128i, int);
__int64 _mm_extract_epi64(__m128i, int);
int _mm_extract_epi8(__m128i, int);
int _mm_extract_ps(__m128, int);
__m128i _mm_extract_si64(__m128i, __m128i);
__m128i _mm_extracti_si64(__m128i, int, int);
unsigned int _mm_getcsr(void);
__m128i _mm_hadd_epi16(__m128i, __m128i);
__m128i _mm_hadd_epi32(__m128i, __m128i);
__m128d _mm_hadd_pd(__m128d, __m128d);
__m64 _mm_hadd_pi16(__m64, __m64);
__m64 _mm_hadd_pi32(__m64, __m64);
__m128 _mm_hadd_ps(__m128, __m128);
__m128i _mm_hadds_epi16(__m128i, __m128i);
__m64 _mm_hadds_pi16(__m64, __m64);
__m128i _mm_hsub_epi16(__m128i, __m128i);
__m128i _mm_hsub_epi32(__m128i, __m128i);
__m128d _mm_hsub_pd(__m128d, __m128d);
__m64 _mm_hsub_pi16(__m64, __m64);
__m64 _mm_hsub_pi32(__m64, __m64);
__m128 _mm_hsub_ps(__m128, __m128);
__m128i _mm_hsubs_epi16(__m128i, __m128i);
__m64 _mm_hsubs_pi16(__m64, __m64);
__m128i _mm_insert_epi16(__m128i, int, int);
__m128i _mm_insert_epi32(__m128i, int, int);
__m128i _mm_insert_epi64(__m128i, __int64, int);
__m128i _mm_insert_epi8(__m128i, int, int);
__m128 _mm_insert_ps(__m128, __m128, int);
__m128i _mm_insert_si64(__m128i, __m128i);
__m128i _mm_inserti_si64(__m128i, __m128i, int, int);
__m128i _mm_lddqu_si128(__m128i const *);
void _mm_lfence(void);
__m128d _mm_load1_pd(double const *);
__m128d _mm_load_pd(double const *);
__m128 _mm_load_ps(float const *);
__m128 _mm_load_ps1(float const *);
__m128d _mm_load_sd(double const *);
__m128i _mm_load_si128(__m128i const *);
__m128 _mm_load_ss(float const *);
__m128d _mm_loaddup_pd(double const *);
__m128d _mm_loadh_pd(__m128d, double const *);
__m128 _mm_loadh_pi(__m128, __m64 const *);
__m128i _mm_loadl_epi64(__m128i const *);
__m128d _mm_loadl_pd(__m128d, double const *);
__m128 _mm_loadl_pi(__m128, __m64 const *);
__m128d _mm_loadr_pd(double const *);
__m128 _mm_loadr_ps(float const *);
__m128d _mm_loadu_pd(double const *);
__m128 _mm_loadu_ps(float const *);
__m128i _mm_loadu_si128(__m128i const *);
__m128i _mm_madd_epi16(__m128i, __m128i);
__m128i _mm_maddubs_epi16(__m128i, __m128i);
__m64 _mm_maddubs_pi16(__m64, __m64);
void _mm_maskmoveu_si128(__m128i, __m128i, char *);
__m128i _mm_max_epi16(__m128i, __m128i);
__m128i _mm_max_epi32(__m128i, __m128i);
__m128i _mm_max_epi8(__m128i, __m128i);
__m128i _mm_max_epu16(__m128i, __m128i);
__m128i _mm_max_epu32(__m128i, __m128i);
__m128i _mm_max_epu8(__m128i, __m128i);
__m128d _mm_max_pd(__m128d, __m128d);
__m128 _mm_max_ps(__m128, __m128);
__m128d _mm_max_sd(__m128d, __m128d);
__m128 _mm_max_ss(__m128, __m128);
void _mm_mfence(void);
__m128i _mm_min_epi16(__m128i, __m128i);
__m128i _mm_min_epi32(__m128i, __m128i);
__m128i _mm_min_epi8(__m128i, __m128i);
__m128i _mm_min_epu16(__m128i, __m128i);
__m128i _mm_min_epu32(__m128i, __m128i);
__m128i _mm_min_epu8(__m128i, __m128i);
__m128d _mm_min_pd(__m128d, __m128d);
__m128 _mm_min_ps(__m128, __m128);
__m128d _mm_min_sd(__m128d, __m128d);
__m128 _mm_min_ss(__m128, __m128);
__m128i _mm_minpos_epu16(__m128i);
void _mm_monitor(void const *, unsigned int, unsigned int);
__m128i _mm_move_epi64(__m128i);
__m128d _mm_move_sd(__m128d, __m128d);
__m128 _mm_move_ss(__m128, __m128);
__m128d _mm_movedup_pd(__m128d);
__m128 _mm_movehdup_ps(__m128);
__m128 _mm_movehl_ps(__m128, __m128);
__m128 _mm_moveldup_ps(__m128);
__m128 _mm_movelh_ps(__m128, __m128);
int _mm_movemask_epi8(__m128i);
int _mm_movemask_pd(__m128d);
int _mm_movemask_ps(__m128);


__m128i _mm_mpsadbw_epu8(__m128i, __m128i, int);
__m128i _mm_mul_epi32(__m128i, __m128i);
__m128i _mm_mul_epu32(__m128i, __m128i);
__m128d _mm_mul_pd(__m128d, __m128d);
__m128 _mm_mul_ps(__m128, __m128);
__m128d _mm_mul_sd(__m128d, __m128d);
__m128 _mm_mul_ss(__m128, __m128);

__m128i _mm_mulhi_epi16(__m128i, __m128i);
__m128i _mm_mulhi_epu16(__m128i, __m128i);
__m128i _mm_mulhrs_epi16(__m128i, __m128i);
__m64 _mm_mulhrs_pi16(__m64, __m64);
__m128i _mm_mullo_epi16(__m128i, __m128i);
__m128i _mm_mullo_epi32(__m128i, __m128i);
void _mm_mwait(unsigned int, unsigned int);
__m128d _mm_or_pd(__m128d, __m128d);
__m128 _mm_or_ps(__m128, __m128);
__m128i _mm_or_si128(__m128i, __m128i);
__m128i _mm_packs_epi16(__m128i, __m128i);
__m128i _mm_packs_epi32(__m128i, __m128i);
__m128i _mm_packus_epi16(__m128i, __m128i);
__m128i _mm_packus_epi32(__m128i, __m128i);
void _mm_pause(void);
int _mm_popcnt_u32(unsigned int);
__int64 _mm_popcnt_u64(unsigned __int64);
void _mm_prefetch(char const *, int);
__m128 _mm_rcp_ps(__m128);
__m128 _mm_rcp_ss(__m128);
__m128d _mm_round_pd(__m128d, int);
__m128 _mm_round_ps(__m128, int);
__m128d _mm_round_sd(__m128d, __m128d, int);
__m128 _mm_round_ss(__m128, __m128, int);
__m128 _mm_rsqrt_ps(__m128);
__m128 _mm_rsqrt_ss(__m128);
__m128i _mm_sad_epu8(__m128i, __m128i);
__m128i _mm_set1_epi16(short);
__m128i _mm_set1_epi32(int);

__m128i _mm_set1_epi64x(__int64);
__m128i _mm_set1_epi8(char);
__m128d _mm_set1_pd(double);



__m128i _mm_set_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_set_epi32(int, int, int, int);

__m128i _mm_set_epi64x(__int64, __int64);
__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_set_pd(double, double);



__m128 _mm_set_ps(float, float, float, float);
__m128 _mm_set_ps1(float);
__m128d _mm_set_sd(double);
__m128 _mm_set_ss(float);
void _mm_setcsr(unsigned int);
__m128i _mm_setl_epi64(__m128i);
__m128i _mm_setr_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_setr_epi32(int, int, int, int);

__m128i _mm_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_setr_pd(double, double);



__m128 _mm_setr_ps(float, float, float, float);
__m128d _mm_setzero_pd(void);
__m128 _mm_setzero_ps(void);
__m128i _mm_setzero_si128(void);

void _mm_sfence(void);
__m128i _mm_shuffle_epi32(__m128i, int);
__m128i _mm_shuffle_epi8(__m128i, __m128i);
__m128d _mm_shuffle_pd(__m128d, __m128d, int);
__m64 _mm_shuffle_pi8(__m64, __m64);
__m128 _mm_shuffle_ps(__m128, __m128, unsigned int);
__m128i _mm_shufflehi_epi16(__m128i, int);
__m128i _mm_shufflelo_epi16(__m128i, int);
__m128i _mm_sign_epi16(__m128i, __m128i);
__m128i _mm_sign_epi32(__m128i, __m128i);
__m128i _mm_sign_epi8(__m128i, __m128i);
__m64 _mm_sign_pi16(__m64, __m64);
__m64 _mm_sign_pi32(__m64, __m64);
__m64 _mm_sign_pi8(__m64, __m64);
__m128i _mm_sll_epi16(__m128i, __m128i);
__m128i _mm_sll_epi32(__m128i, __m128i);
__m128i _mm_sll_epi64(__m128i, __m128i);
__m128i _mm_slli_epi16(__m128i, int);
__m128i _mm_slli_epi32(__m128i, int);
__m128i _mm_slli_epi64(__m128i, int);
__m128i _mm_slli_si128(__m128i, int);
__m128d _mm_sqrt_pd(__m128d);
__m128 _mm_sqrt_ps(__m128);
__m128d _mm_sqrt_sd(__m128d, __m128d);
__m128 _mm_sqrt_ss(__m128);
__m128i _mm_sra_epi16(__m128i, __m128i);
__m128i _mm_sra_epi32(__m128i, __m128i);
__m128i _mm_srai_epi16(__m128i, int);
__m128i _mm_srai_epi32(__m128i, int);
__m128i _mm_srl_epi16(__m128i, __m128i);
__m128i _mm_srl_epi32(__m128i, __m128i);
__m128i _mm_srl_epi64(__m128i, __m128i);
__m128i _mm_srli_epi16(__m128i, int);
__m128i _mm_srli_epi32(__m128i, int);
__m128i _mm_srli_epi64(__m128i, int);
__m128i _mm_srli_si128(__m128i, int);
void _mm_store1_pd(double *, __m128d);
void _mm_store_pd(double *, __m128d);
void _mm_store_ps(float *, __m128);
void _mm_store_ps1(float *, __m128);
void _mm_store_sd(double *, __m128d);
void _mm_store_si128(__m128i *, __m128i);
void _mm_store_ss(float *, __m128);
void _mm_storeh_pd(double *, __m128d);
void _mm_storeh_pi(__m64 *, __m128);
void _mm_storel_epi64(__m128i *, __m128i);
void _mm_storel_pd(double *, __m128d);
void _mm_storel_pi(__m64 *, __m128);
void _mm_storer_pd(double *, __m128d);
void _mm_storer_ps(float *, __m128);
void _mm_storeu_pd(double *, __m128d);
void _mm_storeu_ps(float *, __m128);
void _mm_storeu_si128(__m128i *, __m128i);
__m128i _mm_stream_load_si128(__m128i *);
void _mm_stream_pd(double *, __m128d);

void _mm_stream_ps(float *, __m128);
void _mm_stream_sd(double *, __m128d);
void _mm_stream_si128(__m128i *, __m128i);
void _mm_stream_si32(int *, int);
void _mm_stream_si64x(__int64 *, __int64);
void _mm_stream_ss(float *, __m128);
__m128i _mm_sub_epi16(__m128i, __m128i);
__m128i _mm_sub_epi32(__m128i, __m128i);
__m128i _mm_sub_epi64(__m128i, __m128i);
__m128i _mm_sub_epi8(__m128i, __m128i);
__m128d _mm_sub_pd(__m128d, __m128d);
__m128 _mm_sub_ps(__m128, __m128);
__m128d _mm_sub_sd(__m128d, __m128d);

__m128 _mm_sub_ss(__m128, __m128);
__m128i _mm_subs_epi16(__m128i, __m128i);
__m128i _mm_subs_epi8(__m128i, __m128i);
__m128i _mm_subs_epu16(__m128i, __m128i);
__m128i _mm_subs_epu8(__m128i, __m128i);
int _mm_testc_si128(__m128i, __m128i);
int _mm_testnzc_si128(__m128i, __m128i);
int _mm_testz_si128(__m128i, __m128i);
int _mm_ucomieq_sd(__m128d, __m128d);
int _mm_ucomieq_ss(__m128, __m128);
int _mm_ucomige_sd(__m128d, __m128d);
int _mm_ucomige_ss(__m128, __m128);
int _mm_ucomigt_sd(__m128d, __m128d);
int _mm_ucomigt_ss(__m128, __m128);
int _mm_ucomile_sd(__m128d, __m128d);
int _mm_ucomile_ss(__m128, __m128);
int _mm_ucomilt_sd(__m128d, __m128d);
int _mm_ucomilt_ss(__m128, __m128);
int _mm_ucomineq_sd(__m128d, __m128d);
int _mm_ucomineq_ss(__m128, __m128);
__m128i _mm_unpackhi_epi16(__m128i, __m128i);
__m128i _mm_unpackhi_epi32(__m128i, __m128i);
__m128i _mm_unpackhi_epi64(__m128i, __m128i);
__m128i _mm_unpackhi_epi8(__m128i, __m128i);
__m128d _mm_unpackhi_pd(__m128d, __m128d);
__m128 _mm_unpackhi_ps(__m128, __m128);
__m128i _mm_unpacklo_epi16(__m128i, __m128i);
__m128i _mm_unpacklo_epi32(__m128i, __m128i);
__m128i _mm_unpacklo_epi64(__m128i, __m128i);
__m128i _mm_unpacklo_epi8(__m128i, __m128i);
__m128d _mm_unpacklo_pd(__m128d, __m128d);
__m128 _mm_unpacklo_ps(__m128, __m128);
__m128d _mm_xor_pd(__m128d, __m128d);
__m128 _mm_xor_ps(__m128, __m128);
__m128i _mm_xor_si128(__m128i, __m128i);
__int64 _mul128(__int64 _Multiplier, __int64 _Multiplicand, __int64 * _HighProduct);
unsigned int __cdecl _rotl(  unsigned int _Value,   int _Shift);
unsigned short _rotl16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotl64(  unsigned __int64 _Value,   int _Shift);
unsigned char _rotl8(unsigned char _Value, unsigned char _Shift);
unsigned int __cdecl _rotr(  unsigned int _Value,   int _Shift);
unsigned short _rotr16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotr64(  unsigned __int64 _Value,   int _Shift);
unsigned char _rotr8(unsigned char _Value, unsigned char _Shift);
int __cdecl _setjmp(jmp_buf);
int __cdecl _setjmpex(jmp_buf);
unsigned __int64 _umul128(unsigned __int64 _Multiplier, unsigned __int64 _Multiplicand, unsigned __int64 * _HighProduct);


}
#line 1030 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"
#line 1031 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"
#line 1032 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\intrin.h"

#line 364 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"



#line 368 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"









#line 378 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"



#line 382 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"
#line 383 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"








#line 392 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"




#line 397 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"













#line 411 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"




#line 416 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"









#line 426 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"




#line 431 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"



#line 435 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"
#line 53 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/version.hpp"






































































#line 72 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/version.hpp"
#line 54 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"



















































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/opencv_modules.hpp"
































#line 53 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\climits"

#pragma once





#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\climits"





#line 55 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstdlib"

#pragma once










 #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"















#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"






#pragma pack(push,8)


extern "C" {
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"



















typedef int (__cdecl * _onexit_t)(void);



#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"



#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"




#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"


#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"






typedef struct _div_t {
        int quot;
        int rem;
} div_t;

typedef struct _ldiv_t {
        long quot;
        long rem;
} ldiv_t;

typedef struct _lldiv_t {
        long long quot;
        long long rem;
} lldiv_t;


#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"










#pragma pack(4)
typedef struct {
    unsigned char ld[10];
} _LDOUBLE;
#pragma pack()













#line 121 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

typedef struct {
        double x;
} _CRT_DOUBLE;

typedef struct {
    float f;
} _CRT_FLOAT;





typedef struct {
        


        long double x;
} _LONGDOUBLE;



#pragma pack(4)
typedef struct {
    unsigned char ld12[12];
} _LDBL12;
#pragma pack()


#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"












__declspec(dllimport) extern int __mb_cur_max;



#line 168 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
__declspec(dllimport) int __cdecl ___mb_cur_max_func(void);
__declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t);
#line 171 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"





































typedef void (__cdecl *_purecall_handler)(void); 


__declspec(dllimport) _purecall_handler __cdecl _set_purecall_handler(  _purecall_handler _Handler);
__declspec(dllimport) _purecall_handler __cdecl _get_purecall_handler(void);
#line 214 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"


extern "C++"
{




#line 223 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
}
#line 225 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"



typedef void (__cdecl *_invalid_parameter_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); 


__declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(  _invalid_parameter_handler _Handler);
__declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);
#line 234 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"











__declspec(dllimport) unsigned long * __cdecl __doserrno(void);


errno_t __cdecl _set_doserrno(  unsigned long _Value);
errno_t __cdecl _get_doserrno(  unsigned long * _Value);


__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char ** __cdecl __sys_errlist(void);


__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int * __cdecl __sys_nerr(void);
















#line 273 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"




__declspec(dllimport) extern int __argc;          
__declspec(dllimport) extern char ** __argv;      
__declspec(dllimport) extern wchar_t ** __wargv;  







#line 288 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#line 290 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"








__declspec(dllimport) extern char ** _environ;    
__declspec(dllimport) extern wchar_t ** _wenviron;    
#line 301 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#line 303 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern char * _pgmptr;      
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern wchar_t * _wpgmptr;  




















#line 327 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

errno_t __cdecl _get_pgmptr(  char ** _Value);
errno_t __cdecl _get_wpgmptr(  wchar_t ** _Value);



__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern int _fmode;          



#line 338 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

__declspec(dllimport) errno_t __cdecl _set_fmode(  int _Mode);
__declspec(dllimport) errno_t __cdecl _get_fmode(  int * _PMode);





#line 347 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C++"
{
template <typename _CountofType, size_t _SizeOfArray>
char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

}
#line 354 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
#line 355 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"





__declspec(dllimport) __declspec(noreturn) void __cdecl exit(  int _Code);
__declspec(dllimport) __declspec(noreturn) void __cdecl _exit(  int _Code);
__declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);
#line 364 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(  unsigned int _Flags,   unsigned int _Mask);



        int       __cdecl abs(  int _X);
        long      __cdecl labs(  long _X);
        long long __cdecl llabs(  long long _X);
#line 373 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

        __int64    __cdecl _abs64(__int64);




















#line 396 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"















#line 412 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
        int    __cdecl atexit(void (__cdecl *)(void));
#line 414 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"


  __declspec(dllimport) double  __cdecl atof(  const char *_String);
  __declspec(dllimport) double  __cdecl _atof_l(  const char *_String,   _locale_t _Locale);
#line 419 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
  __declspec(dllimport)  int    __cdecl atoi(  const char *_Str);
  __declspec(dllimport) int    __cdecl _atoi_l(  const char *_Str,   _locale_t _Locale);
  __declspec(dllimport) long   __cdecl atol(  const char *_Str);
  __declspec(dllimport) long   __cdecl _atol_l(  const char *_Str,   _locale_t _Locale);



  __declspec(dllimport) void * __cdecl bsearch_s(  const void * _Key,   const void * _Base, 
          rsize_t _NumOfElements,   rsize_t _SizeOfElements,
          int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
#line 430 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
  __declspec(dllimport) void * __cdecl bsearch(  const void * _Key,   const void * _Base, 
          size_t _NumOfElements,   size_t _SizeOfElements,
          int (__cdecl * _PtFuncCompare)(const void *, const void *));


__declspec(dllimport) void __cdecl qsort_s(  void * _Base, 
          rsize_t _NumOfElements,   rsize_t _SizeOfElements,
          int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void *_Context);
#line 439 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
__declspec(dllimport) void __cdecl qsort(  void * _Base, 
	  size_t _NumOfElements,   size_t _SizeOfElements, 
          int (__cdecl * _PtFuncCompare)(const void *, const void *));
#line 443 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
          unsigned short __cdecl _byteswap_ushort(  unsigned short _Short);
          unsigned long  __cdecl _byteswap_ulong (  unsigned long _Long);
          unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Int64);
  __declspec(dllimport) div_t  __cdecl div(  int _Numerator,   int _Denominator);


  __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl getenv(  const char * _VarName);

 __declspec(dllimport) errno_t __cdecl getenv_s(  size_t * _ReturnSize,   char * _DstBuf,   rsize_t _DstSize,   const char * _VarName);
#line 453 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(  size_t * _ReturnSize, char (&_Dest)[_Size],   const char * _VarName) throw() { return getenv_s(_ReturnSize, _Dest, _Size, _VarName); } }



#line 458 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _dupenv_s(    char **_PBuffer,   size_t * _PBufferSizeInBytes,   const char * _VarName);



#line 464 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
#line 465 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _itoa_s(  int _Value,   char * _DstBuf,   size_t _Size,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _itoa_s(  int _Value, char (&_Dest)[_Size],   int _Radix) throw() { return _itoa_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _itoa( int _Value,   char *_Dest,  int _Radix);
 __declspec(dllimport) errno_t __cdecl _i64toa_s(  __int64 _Val,   char * _DstBuf,   size_t _Size,   int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _i64toa(  __int64 _Val,     char * _DstBuf,   int _Radix);
 __declspec(dllimport) errno_t __cdecl _ui64toa_s(  unsigned __int64 _Val,   char * _DstBuf,   size_t _Size,   int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _ui64toa(  unsigned __int64 _Val,     char * _DstBuf,   int _Radix);
  __declspec(dllimport) __int64 __cdecl _atoi64(  const char * _String);
  __declspec(dllimport) __int64 __cdecl _atoi64_l(  const char * _String,   _locale_t _Locale);
  __declspec(dllimport) __int64 __cdecl _strtoi64(  const char * _String,     char ** _EndPtr,   int _Radix);
  __declspec(dllimport) __int64 __cdecl _strtoi64_l(  const char * _String,     char ** _EndPtr,   int _Radix,   _locale_t _Locale);
  __declspec(dllimport) unsigned __int64 __cdecl _strtoui64(  const char * _String,     char ** _EndPtr,   int _Radix);
  __declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(  const char * _String,     char ** _EndPtr,   int  _Radix,   _locale_t _Locale);
  __declspec(dllimport) ldiv_t __cdecl ldiv(  long _Numerator,   long _Denominator);
  __declspec(dllimport) lldiv_t __cdecl lldiv(  long long _Numerator,   long long _Denominator);

extern "C++"
{
    inline long abs(long _X)
    {
        return labs(_X);
    }
    inline long long abs(long long _X)
    {
        return llabs(_X);
    }
    inline ldiv_t div(long _A1, long _A2)
    {
        return ldiv(_A1, _A2);
    }
    inline lldiv_t div(long long _A1, long long _A2)
    {
        return lldiv(_A1, _A2);
    }
}
#line 502 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
 __declspec(dllimport) errno_t __cdecl _ltoa_s(  long _Val,   char * _DstBuf,   size_t _Size,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(  long _Value, char (&_Dest)[_Size],   int _Radix) throw() { return _ltoa_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _ltoa( long _Value,   char *_Dest,  int _Radix);
  __declspec(dllimport) int    __cdecl mblen(    const char * _Ch,   size_t _MaxCount);
  __declspec(dllimport) int    __cdecl _mblen_l(    const char * _Ch,   size_t _MaxCount,   _locale_t _Locale);
  __declspec(dllimport) size_t __cdecl _mbstrlen(  const char * _Str);
  __declspec(dllimport) size_t __cdecl _mbstrlen_l(  const char *_Str,   _locale_t _Locale);
  __declspec(dllimport) size_t __cdecl _mbstrnlen(  const char *_Str,   size_t _MaxCount);
  __declspec(dllimport) size_t __cdecl _mbstrnlen_l(  const char *_Str,   size_t _MaxCount,   _locale_t _Locale);
__declspec(dllimport) int    __cdecl mbtowc(    wchar_t * _DstCh,     const char * _SrcCh,   size_t _SrcSizeInBytes);
__declspec(dllimport) int    __cdecl _mbtowc_l(    wchar_t * _DstCh,     const char * _SrcCh,   size_t _SrcSizeInBytes,   _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl mbstowcs_s(  size_t * _PtNumOfCharConverted,   wchar_t * _DstBuf,   size_t _SizeInWords,   const char * _SrcBuf,   size_t _MaxCount );
extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(  size_t * _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   const char * _Source,   size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest,  const char * _Source,  size_t _MaxCount);

 __declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(  size_t * _PtNumOfCharConverted,   wchar_t * _DstBuf,   size_t _SizeInWords,   const char * _SrcBuf,   size_t _MaxCount,   _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(  size_t * _PtNumOfCharConverted, wchar_t (&_Dest)[_Size],   const char * _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl _mbstowcs_l(  wchar_t *_Dest,   const char * _Source,   size_t _MaxCount,   _locale_t _Locale);

  __declspec(dllimport) int    __cdecl rand(void);


#line 525 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) int    __cdecl _set_error_mode(  int _Mode);

__declspec(dllimport) void   __cdecl srand(  unsigned int _Seed);
  __declspec(dllimport) double __cdecl strtod(  const char * _Str,     char ** _EndPtr);
  __declspec(dllimport) double __cdecl _strtod_l(  const char * _Str,     char ** _EndPtr,   _locale_t _Locale);
  __declspec(dllimport) long   __cdecl strtol(  const char * _Str,     char ** _EndPtr,   int _Radix );
  __declspec(dllimport) long   __cdecl _strtol_l(  const char *_Str,     char **_EndPtr,   int _Radix,   _locale_t _Locale);
  __declspec(dllimport) unsigned long __cdecl strtoul(  const char * _Str,     char ** _EndPtr,   int _Radix);
  __declspec(dllimport) unsigned long __cdecl _strtoul_l(const char * _Str,     char **_EndPtr,   int _Radix,   _locale_t _Locale);




__declspec(dllimport) int __cdecl system(  const char * _Command);
#line 541 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
#line 542 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _ultoa_s(  unsigned long _Val,   char * _DstBuf,   size_t _Size,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(  unsigned long _Value, char (&_Dest)[_Size],   int _Radix) throw() { return _ultoa_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _ultoa( unsigned long _Value,   char *_Dest,  int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int    __cdecl wctomb(  char * _MbCh,   wchar_t _WCh);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int    __cdecl _wctomb_l(    char * _MbCh,   wchar_t _WCh,   _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl wctomb_s(  int * _SizeConverted,   char * _MbCh,   rsize_t _SizeInBytes,   wchar_t _WCh);
#line 551 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
 __declspec(dllimport) errno_t __cdecl _wctomb_s_l(  int * _SizeConverted,   char * _MbCh,   size_t _SizeInBytes,   wchar_t _WCh,   _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl wcstombs_s(  size_t * _PtNumOfCharConverted,   char * _Dst,   size_t _DstSizeInBytes,   const wchar_t * _Src,   size_t _MaxCountInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(  size_t * _PtNumOfCharConverted,   char (&_Dest)[_Size],   const wchar_t * _Source,   size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl wcstombs( char *_Dest,  const wchar_t * _Source,  size_t _MaxCount);
 __declspec(dllimport) errno_t __cdecl _wcstombs_s_l(  size_t * _PtNumOfCharConverted,   char * _Dst,   size_t _DstSizeInBytes,   const wchar_t * _Src,   size_t _MaxCountInBytes,   _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(  size_t * _PtNumOfCharConverted,   char (&_Dest)[_Size],   const wchar_t * _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl _wcstombs_l(  char *_Dest,   const wchar_t * _Source,   size_t _MaxCount,   _locale_t _Locale);

























#line 584 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
















































































 __declspec(dllimport) errno_t __cdecl _itow_s (  int _Val,   wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(  int _Value, wchar_t (&_Dest)[_Size],   int _Radix) throw() { return _itow_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _itow( int _Value,   wchar_t *_Dest,  int _Radix);
 __declspec(dllimport) errno_t __cdecl _ltow_s (  long _Val,   wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(  long _Value, wchar_t (&_Dest)[_Size],   int _Radix) throw() { return _ltow_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _ltow( long _Value,   wchar_t *_Dest,  int _Radix);
 __declspec(dllimport) errno_t __cdecl _ultow_s (  unsigned long _Val,   wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(  unsigned long _Value, wchar_t (&_Dest)[_Size],   int _Radix) throw() { return _ultow_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _ultow( unsigned long _Value,   wchar_t *_Dest,  int _Radix);
  __declspec(dllimport) double __cdecl wcstod(  const wchar_t * _Str,     wchar_t ** _EndPtr);
  __declspec(dllimport) double __cdecl _wcstod_l(  const wchar_t *_Str,     wchar_t ** _EndPtr,   _locale_t _Locale);
  __declspec(dllimport) long   __cdecl wcstol(  const wchar_t *_Str,     wchar_t ** _EndPtr, int _Radix);
  __declspec(dllimport) long   __cdecl _wcstol_l(  const wchar_t *_Str,     wchar_t **_EndPtr, int _Radix,   _locale_t _Locale);
  __declspec(dllimport) unsigned long __cdecl wcstoul(  const wchar_t *_Str,     wchar_t ** _EndPtr, int _Radix);
  __declspec(dllimport) unsigned long __cdecl _wcstoul_l(  const wchar_t *_Str,     wchar_t **_EndPtr, int _Radix,   _locale_t _Locale);



  __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) wchar_t * __cdecl _wgetenv(  const wchar_t * _VarName);
 __declspec(dllimport) errno_t __cdecl _wgetenv_s(  size_t * _ReturnSize,   wchar_t * _DstBuf,   size_t _DstSizeInWords,   const wchar_t * _VarName);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wgetenv_s(  size_t * _ReturnSize, wchar_t (&_Dest)[_Size],   const wchar_t * _VarName) throw() { return _wgetenv_s(_ReturnSize, _Dest, _Size, _VarName); } }




#line 690 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _wdupenv_s(    wchar_t **_Buffer,   size_t *_BufferSizeInWords,   const wchar_t *_VarName);



#line 696 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"



__declspec(dllimport) int __cdecl _wsystem(  const wchar_t * _Command);
#line 701 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#line 703 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

  __declspec(dllimport) double __cdecl _wtof(  const wchar_t *_Str);
  __declspec(dllimport) double __cdecl _wtof_l(  const wchar_t *_Str,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _wtoi(  const wchar_t *_Str);
  __declspec(dllimport) int __cdecl _wtoi_l(  const wchar_t *_Str,   _locale_t _Locale);
  __declspec(dllimport) long __cdecl _wtol(  const wchar_t *_Str);
  __declspec(dllimport) long __cdecl _wtol_l(  const wchar_t *_Str,   _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl _i64tow_s(  __int64 _Val,   wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) wchar_t * __cdecl _i64tow(  __int64 _Val,     wchar_t * _DstBuf,   int _Radix);
 __declspec(dllimport) errno_t __cdecl _ui64tow_s(  unsigned __int64 _Val,   wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) wchar_t * __cdecl _ui64tow(  unsigned __int64 _Val,     wchar_t * _DstBuf,   int _Radix);
  __declspec(dllimport) __int64   __cdecl _wtoi64(  const wchar_t *_Str);
  __declspec(dllimport) __int64   __cdecl _wtoi64_l(  const wchar_t *_Str,   _locale_t _Locale);
  __declspec(dllimport) __int64   __cdecl _wcstoi64(  const wchar_t * _Str,     wchar_t ** _EndPtr,   int _Radix);
  __declspec(dllimport) __int64   __cdecl _wcstoi64_l(  const wchar_t * _Str,     wchar_t ** _EndPtr,   int _Radix,   _locale_t _Locale);
  __declspec(dllimport) unsigned __int64  __cdecl _wcstoui64(  const wchar_t * _Str,     wchar_t ** _EndPtr,   int _Radix);
  __declspec(dllimport) unsigned __int64  __cdecl _wcstoui64_l(  const wchar_t *_Str ,     wchar_t ** _EndPtr,   int _Radix,   _locale_t _Locale);


#line 724 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"














#line 739 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

  __declspec(dllimport) char * __cdecl _fullpath(  char * _FullPath,   const char * _Path,   size_t _SizeInBytes);





#line 747 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _ecvt_s(  char * _DstBuf,   size_t _Size,   double _Val,   int _NumOfDights,   int * _PtDec,   int * _PtSign);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Dest)[_Size],   double _Value,   int _NumOfDigits,   int * _PtDec,   int * _PtSign) throw() { return _ecvt_s(_Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign); } }
  __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _ecvt(  double _Val,   int _NumOfDigits,   int * _PtDec,   int * _PtSign);
 __declspec(dllimport) errno_t __cdecl _fcvt_s(  char * _DstBuf,   size_t _Size,   double _Val,   int _NumOfDec,   int * _PtDec,   int * _PtSign);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _fcvt_s(char (&_Dest)[_Size],   double _Value,   int _NumOfDigits,   int * _PtDec,   int * _PtSign) throw() { return _fcvt_s(_Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign); } }
  __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _fcvt(  double _Val,   int _NumOfDec,   int * _PtDec,   int * _PtSign);
__declspec(dllimport) errno_t __cdecl _gcvt_s(  char * _DstBuf,   size_t _Size,   double _Val,   int _NumOfDigits);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _gcvt_s(char (&_Dest)[_Size],   double _Value,   int _NumOfDigits) throw() { return _gcvt_s(_Dest, _Size, _Value, _NumOfDigits); } }
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _gcvt(  double _Val,   int _NumOfDigits,     char * _DstBuf);

  __declspec(dllimport) int __cdecl _atodbl(  _CRT_DOUBLE * _Result,   char * _Str);
  __declspec(dllimport) int __cdecl _atoldbl(  _LDOUBLE * _Result,   char * _Str);
  __declspec(dllimport) int __cdecl _atoflt(  _CRT_FLOAT * _Result,   char * _Str);
  __declspec(dllimport) int __cdecl _atodbl_l(  _CRT_DOUBLE * _Result,   char * _Str,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _atoldbl_l(  _LDOUBLE * _Result,   char * _Str,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _atoflt_l(  _CRT_FLOAT * _Result,   char * _Str,   _locale_t _Locale);
          unsigned long __cdecl _lrotl(  unsigned long _Val,   int _Shift);
          unsigned long __cdecl _lrotr(  unsigned long _Val,   int _Shift);
 __declspec(dllimport) errno_t   __cdecl _makepath_s(  char * _PathResult,   size_t _SizeInWords,   const char * _Drive,   const char * _Dir,   const char * _Filename,
          const char * _Ext);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Path)[_Size],   const char * _Drive,   const char * _Dir,   const char * _Filename,   const char * _Ext) throw() { return _makepath_s(_Path, _Size, _Drive, _Dir, _Filename, _Ext); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _makepath(  char *_Path,  const char * _Drive,  const char * _Dir,  const char * _Filename,  const char * _Ext);












#line 783 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"












#line 796 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
        _onexit_t __cdecl _onexit(  _onexit_t _Func);
#line 798 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"
        


__declspec(dllimport) void __cdecl perror(  const char * _ErrMsg);
#line 803 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#pragma warning (push)
#pragma warning (disable:6540) 


  __declspec(dllimport) int    __cdecl _putenv(  const char * _EnvString);
 __declspec(dllimport) errno_t __cdecl _putenv_s(  const char * _Name,   const char * _Value);
#line 811 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

        unsigned int __cdecl _rotl(  unsigned int _Val,   int _Shift);
        unsigned __int64 __cdecl _rotl64(  unsigned __int64 _Val,   int _Shift);
        unsigned int __cdecl _rotr(  unsigned int _Val,   int _Shift);
        unsigned __int64 __cdecl _rotr64(  unsigned __int64 _Val,   int _Shift);
#pragma warning (pop)


__declspec(dllimport) errno_t __cdecl _searchenv_s(  const char * _Filename,   const char * _EnvVar,   char * _ResultPath,   size_t _SizeInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(  const char * _Filename,   const char * _EnvVar, char (&_ResultPath)[_Size]) throw() { return _searchenv_s(_Filename, _EnvVar, _ResultPath, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _searchenv( const char * _Filename,  const char * _EnvVar,   char *_ResultPath);
#line 823 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void   __cdecl _splitpath(  const char * _FullPath,     char * _Drive,     char * _Dir,     char * _Filename,     char * _Ext);
 __declspec(dllimport) errno_t  __cdecl _splitpath_s(  const char * _FullPath, 
		  char * _Drive,   size_t _DriveSize, 
		  char * _Dir,   size_t _DirSize, 
		  char * _Filename,   size_t _FilenameSize, 
		  char * _Ext,   size_t _ExtSize);
extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(  const char *_Dest,   char (&_Drive)[_DriveSize],   char (&_Dir)[_DirSize],   char (&_Name)[_NameSize],   char (&_Ext)[_ExtSize]) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }

__declspec(dllimport) void   __cdecl _swab(    char * _Buf1,     char * _Buf2, int _SizeInBytes);








#line 842 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

  __declspec(dllimport) wchar_t * __cdecl _wfullpath(  wchar_t * _FullPath,   const wchar_t * _Path,   size_t _SizeInWords);



#line 848 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _wmakepath_s(  wchar_t * _PathResult,   size_t _SIZE,   const wchar_t * _Drive,   const wchar_t * _Dir,   const wchar_t * _Filename,
          const wchar_t * _Ext);        
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_ResultPath)[_Size],   const wchar_t * _Drive,   const wchar_t * _Dir,   const wchar_t * _Filename,   const wchar_t * _Ext) throw() { return _wmakepath_s(_ResultPath, _Size, _Drive, _Dir, _Filename, _Ext); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath(  wchar_t *_ResultPath,  const wchar_t * _Drive,  const wchar_t * _Dir,  const wchar_t * _Filename,  const wchar_t * _Ext);


__declspec(dllimport) void __cdecl _wperror(  const wchar_t * _ErrMsg);
#line 857 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"


  __declspec(dllimport) int    __cdecl _wputenv(  const wchar_t * _EnvString);
 __declspec(dllimport) errno_t __cdecl _wputenv_s(  const wchar_t * _Name,   const wchar_t * _Value);
__declspec(dllimport) errno_t __cdecl _wsearchenv_s(  const wchar_t * _Filename,   const wchar_t * _EnvVar,   wchar_t * _ResultPath,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(  const wchar_t * _Filename,   const wchar_t * _EnvVar, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _EnvVar, _ResultPath, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv( const wchar_t * _Filename,  const wchar_t * _EnvVar,   wchar_t *_ResultPath);
#line 865 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void   __cdecl _wsplitpath(  const wchar_t * _FullPath,     wchar_t * _Drive,     wchar_t * _Dir,     wchar_t * _Filename,     wchar_t * _Ext);
__declspec(dllimport) errno_t __cdecl _wsplitpath_s(  const wchar_t * _FullPath, 
		  wchar_t * _Drive,   size_t _DriveSize, 
		  wchar_t * _Dir,   size_t _DirSize, 
		  wchar_t * _Filename,   size_t _FilenameSize, 
		  wchar_t * _Ext,   size_t _ExtSize);
extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(  const wchar_t *_Path,   wchar_t (&_Drive)[_DriveSize],   wchar_t (&_Dir)[_DirSize],   wchar_t (&_Name)[_NameSize],   wchar_t (&_Ext)[_ExtSize]) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }


#line 876 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"



__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "SetErrorMode" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _seterrormode(  int _Mode);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Beep" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _beep(  unsigned _Frequency,   unsigned _Duration);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Sleep" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _sleep(  unsigned long _Duration);
#line 883 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#line 885 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

















#line 903 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#pragma warning(push)
#pragma warning(disable: 4141)  
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl ecvt(  double _Val,   int _NumOfDigits,   int * _PtDec,   int * _PtSign);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl fcvt(  double _Val,   int _NumOfDec,   int * _PtDec,   int * _PtSign);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))		__declspec(dllimport) char * __cdecl gcvt(  double _Val,   int _NumOfDigits,     char * _DstBuf);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))		__declspec(dllimport) char * __cdecl itoa(  int _Val,     char * _DstBuf,   int _Radix);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))		__declspec(dllimport) char * __cdecl ltoa(  long _Val,     char * _DstBuf,   int _Radix);


  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_putenv" ". See online help for details.")) __declspec(dllimport) int    __cdecl putenv(  const char * _EnvString);
#line 915 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_swab" ". See online help for details."))										__declspec(dllimport) void   __cdecl swab(  char * _Buf1,  char * _Buf2,   int _SizeInBytes);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))	__declspec(dllimport) char * __cdecl ultoa(  unsigned long _Val,     char * _Dstbuf,   int _Radix);
#pragma warning(pop)
_onexit_t __cdecl onexit(  _onexit_t _Func);

#line 922 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#line 924 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"


}

#line 929 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#pragma pack(pop)

#line 933 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdlib.h"

#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstdlib"
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstdlib"

 

namespace std {
using :: size_t; using :: div_t; using :: ldiv_t;

using :: abort; using :: abs; using :: atexit;
using :: atof; using :: atoi; using :: atol;
using :: bsearch; using :: calloc; using :: div;
using :: exit; using :: free;
using :: labs; using :: ldiv; using :: malloc;
using :: mblen; using :: mbstowcs; using :: mbtowc;
using :: qsort; using :: rand; using :: realloc;
using :: srand; using :: strtod; using :: strtol;
using :: strtoul;
using :: wcstombs; using :: wctomb;

using :: lldiv_t;
using :: llabs; using :: lldiv;

 
using :: getenv;
using :: system;
 #line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstdlib"
}
 #line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstdlib"
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstdlib"





#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ymath.h"

#pragma once





 
extern "C" {
 #line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ymath.h"

#pragma pack(push, 8)



		





		






		
typedef union
	{	
	unsigned short _Word[8];
	float _Float;
	double _Double;
	long double _Long_double;
	} _Dconst;

		
void __cdecl _Feraise(int);

		
__declspec(dllimport) double __cdecl _Cosh(double, double);
__declspec(dllimport) short __cdecl _Dtest(double *);
__declspec(dllimport) short __cdecl _Exp(double *, double, short);
__declspec(dllimport) double __cdecl _Sinh(double, double);
extern __declspec(dllimport)  _Dconst _Denorm, _Hugeval, _Inf,
	_Nan, _Snan;

		
__declspec(dllimport) float __cdecl _FCosh(float, float);
__declspec(dllimport) short __cdecl _FDtest(float *);
__declspec(dllimport) short __cdecl _FExp(float *, float, short);
__declspec(dllimport) float __cdecl _FSinh(float, float);
extern __declspec(dllimport)  _Dconst _FDenorm, _FInf, _FNan, _FSnan;

		
__declspec(dllimport) long double __cdecl _LCosh(long double, long double);
__declspec(dllimport) short __cdecl _LDtest(long double *);
__declspec(dllimport) short __cdecl _LExp(long double *, long double, short);
__declspec(dllimport) long double __cdecl _LSinh(long double, long double);
extern __declspec(dllimport)  _Dconst _LDenorm, _LInf, _LNan, _LSnan;

 
}
 #line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ymath.h"


#pragma pack(pop)

#line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ymath.h"
#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ymath.h"





#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cfloat"

#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\float.h"















#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\float.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtwrn.h"











#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtwrn.h"














































#line 65 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtwrn.h"
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\float.h"








#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\float.h"

#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\float.h"
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\float.h"
#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\float.h"


extern "C" {
#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\float.h"











































 __declspec(dllimport) unsigned int __cdecl _clearfp(void);
#pragma warning(push)
#pragma warning(disable: 4141)
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) unsigned int __cdecl _controlfp(  unsigned int _NewValue,  unsigned int _Mask);
#pragma warning(pop)
 __declspec(dllimport) void __cdecl _set_controlfp(  unsigned int _NewValue,   unsigned int _Mask);
 __declspec(dllimport) errno_t __cdecl _controlfp_s(  unsigned int *_CurrentState,   unsigned int _NewValue,   unsigned int _Mask);
 __declspec(dllimport) unsigned int __cdecl _statusfp(void);
 __declspec(dllimport) void __cdecl _fpreset(void);



#line 96 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\float.h"


































































#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\float.h"



#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\float.h"

 __declspec(dllimport) unsigned int __cdecl _control87(  unsigned int _NewValue,  unsigned int _Mask);



#line 173 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\float.h"



  __declspec(dllimport) extern int * __cdecl __fpecode(void);































  __declspec(dllimport) double __cdecl _copysign (  double _Number,   double _Sign);
  __declspec(dllimport) double __cdecl _chgsign (  double _X);

#line 212 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\float.h"
  __declspec(dllimport) double __cdecl _scalb(  double _X,   long _Y);
  __declspec(dllimport) double __cdecl _logb(  double _X);
  __declspec(dllimport) double __cdecl _nextafter(  double _X,   double _Y);
  __declspec(dllimport) int    __cdecl _finite(  double _X);
  __declspec(dllimport) int    __cdecl _isnan(  double _X);
  __declspec(dllimport) int    __cdecl _fpclass(  double _X);


  __declspec(dllimport) float __cdecl _scalbf(  float _X,   long _Y);
#line 222 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\float.h"





















 __declspec(dllimport) void __cdecl fpreset(void);





























































#line 306 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\float.h"


}
#line 310 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\float.h"

#line 312 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\float.h"
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cfloat"
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cfloat"





#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cmath"

#pragma once















 #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

















#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"





#pragma pack(push,8)


extern "C" {
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"








struct _exception {
        int type;       
        char *name;     
        double arg1;    
        double arg2;    
        double retval;  
        } ;


#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"







struct _complex {
        double x,y; 
        } ;




#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"


#line 65 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"






















__declspec(dllimport) extern double _HUGE;


#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"













        double  __cdecl acos(  double _X);
        double  __cdecl asin(  double _X);
        double  __cdecl atan(  double _X);
        double  __cdecl atan2(  double _Y,   double _X);





        double  __cdecl cos(  double _X);
        double  __cdecl cosh(  double _X);
        double  __cdecl exp(  double _X);
 double  __cdecl fabs(  double _X);
        double  __cdecl fmod(  double _X,   double _Y);
        double  __cdecl log(  double _X);
        double  __cdecl log10(  double _X);
        double  __cdecl pow(  double _X,   double _Y);
        double  __cdecl sin(  double _X);
        double  __cdecl sinh(  double _X);
        double  __cdecl tan(  double _X);
        double  __cdecl tanh(  double _X);
  double  __cdecl sqrt(  double _X);






__declspec(dllimport) double  __cdecl _cabs(  struct _complex _Complex_value);
__declspec(dllimport) double  __cdecl ceil(  double _X);
__declspec(dllimport) double  __cdecl floor(  double _X);
__declspec(dllimport) double  __cdecl frexp(  double _X,   int * _Y);
__declspec(dllimport) double  __cdecl _hypot(  double _X,   double _Y);
__declspec(dllimport) float   __cdecl _hypotf(  float _X,   float _Y);
__declspec(dllimport) double  __cdecl _j0(  double _X );
__declspec(dllimport) double  __cdecl _j1(  double _X );
__declspec(dllimport) double  __cdecl _jn(int _X,   double _Y);
__declspec(dllimport) double  __cdecl ldexp(  double _X,   int _Y);




#line 149 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
        int     __cdecl _matherr(  struct _exception * _Except);
#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
#line 152 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
__declspec(dllimport) double  __cdecl modf(  double _X,   double * _Y);

__declspec(dllimport) double  __cdecl _y0(  double _X);
__declspec(dllimport) double  __cdecl _y1(  double _X);
__declspec(dllimport) double  __cdecl _yn(  int _X,   double _Y);




static __inline double __cdecl hypot(  double _X,   double _Y)
{
    return _hypot(_X, _Y);
}

static __inline float __cdecl hypotf(  float _X,   float _Y)
{
    return _hypotf(_X, _Y);
}

#line 172 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"





#line 178 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"







__declspec(dllimport) float  __cdecl acosf(   float _X);
__declspec(dllimport) float  __cdecl asinf(   float _X);
__declspec(dllimport) float  __cdecl atanf(   float _X);
__declspec(dllimport) float  __cdecl atan2f(   float  _Y,   float  _X);
__declspec(dllimport) float  __cdecl cosf(   float _X);
__declspec(dllimport) float  __cdecl sinf(   float _X);
__declspec(dllimport) float  __cdecl tanf(   float _X);


__declspec(dllimport) float  __cdecl coshf(   float _X);
__declspec(dllimport) float  __cdecl sinhf(   float _X);
__declspec(dllimport) float  __cdecl tanhf(   float _X);


__declspec(dllimport) float  __cdecl expf(   float  _X);
__declspec(dllimport) float  __cdecl logf(   float  _X);
__declspec(dllimport) float  __cdecl log10f(   float  _X);
__declspec(dllimport) float  __cdecl modff(   float  _X,   float*  _Y);


__declspec(dllimport) float  __cdecl powf(   float _X,   float _Y);
__declspec(dllimport) float  __cdecl sqrtf(   float  _X);


__declspec(dllimport) float  __cdecl ceilf(   float  _X);
__declspec(dllimport) float  __cdecl floorf(   float  _X);
__declspec(dllimport) float  __cdecl fmodf(   float  _X,   float _Y);

__declspec(dllimport) float __cdecl _copysignf (  float _Number,   float _Sign);
__declspec(dllimport) float __cdecl _chgsignf (  float _X);
__declspec(dllimport) float __cdecl _logbf(  float _X);
__declspec(dllimport) float __cdecl _nextafterf(  float _X,   float _Y);
__declspec(dllimport) int    __cdecl _finitef(  float _X);
__declspec(dllimport) int    __cdecl _isnanf(  float _X);
__declspec(dllimport) int    __cdecl _fpclassf(  float _X);

#line 222 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"








































#line 263 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"


































































inline long double acosl(  long double _X)
        {return (acos((double)_X)); }
inline long double asinl(  long double _X)
        {return (asin((double)_X)); }
inline long double atanl(  long double _X)
        {return (atan((double)_X)); }
inline long double atan2l(  long double _Y,   long double _X)
        {return (atan2((double)_Y, (double)_X)); }
inline long double ceill(  long double _X)
        {return (ceil((double)_X)); }
inline long double cosl(  long double _X)
        {return (cos((double)_X)); }
inline long double coshl(  long double _X)
        {return (cosh((double)_X)); }
inline long double expl(  long double _X)
        {return (exp((double)_X)); }
inline long double fabsl(  long double _X)
        {return (fabs((double)_X)); }
inline long double floorl(  long double _X)
        {return (floor((double)_X)); }
inline long double fmodl(  long double _X,   long double _Y)
        {return (fmod((double)_X, (double)_Y)); }
inline long double frexpl(  long double _X,   int *_Y)
        {return (frexp((double)_X, _Y)); }
inline long double ldexpl(  long double _X,   int _Y)
        {return (ldexp((double)_X, _Y)); }
inline long double logl(  long double _X)
        {return (log((double)_X)); }
inline long double log10l(  long double _X)
        {return (log10((double)_X)); }
inline long double modfl(  long double _X,   long double *_Y)
        {double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (long double)_Di;
        return (_Df); }
inline long double powl(  long double _X,   long double _Y)
        {return (pow((double)_X, (double)_Y)); }
inline long double sinl(  long double _X)
        {return (sin((double)_X)); }
inline long double sinhl(  long double _X)
        {return (sinh((double)_X)); }
inline long double sqrtl(  long double _X)
        {return (sqrt((double)_X)); }
inline long double tanl(  long double _X)
        {return (tan((double)_X)); }

inline long double tanhl(  long double _X)
        {return (tanh((double)_X)); }

inline long double _chgsignl(  long double _Number)
{
    return _chgsign(static_cast<double>(_Number)); 
}

inline long double _copysignl(  long double _Number,   long double _Sign)
{
    return _copysign(static_cast<double>(_Number), static_cast<double>(_Sign)); 
}

inline float frexpf(  float _X,   int *_Y)
        {return ((float)frexp((double)_X, _Y)); }


inline float fabsf(  float _X)
        {return ((float)fabs((double)_X)); }
#line 394 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

inline float ldexpf(  float _X,   int _Y)
        {return ((float)ldexp((double)_X, _Y)); }










































#line 440 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
#line 441 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"
#line 442 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

















__declspec(dllimport) extern double HUGE;


#line 463 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_cabs" ". See online help for details.")) __declspec(dllimport) double  __cdecl cabs(  struct _complex _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_j0" ". See online help for details.")) __declspec(dllimport) double  __cdecl j0(  double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_j1" ". See online help for details.")) __declspec(dllimport) double  __cdecl j1(  double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_jn" ". See online help for details.")) __declspec(dllimport) double  __cdecl jn(  int _X,   double _Y);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_y0" ". See online help for details.")) __declspec(dllimport) double  __cdecl y0(  double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_y1" ". See online help for details.")) __declspec(dllimport) double  __cdecl y1(  double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_yn" ". See online help for details.")) __declspec(dllimport) double  __cdecl yn(  int _X,   double _Y);

#line 473 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

#line 475 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"


}

extern "C++" {

template<class _Ty> inline
        _Ty _Pow_int(_Ty _X, int _Y)
        {unsigned int _N;
        if (_Y >= 0)
                _N = (unsigned int)_Y;
        else
                _N = (unsigned int)(-_Y);
        for (_Ty _Z = _Ty(1); ; _X *= _X)
                {if ((_N & 1) != 0)
                        _Z *= _X;
                if ((_N >>= 1) == 0)
                        return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

inline double __cdecl abs(  double _X)
        {return (fabs(_X)); }
inline double __cdecl pow(  double _X,   int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl abs(  float _X)
        {return (fabsf(_X)); }
inline float __cdecl acos(  float _X)
        {return (acosf(_X)); }
inline float __cdecl asin(  float _X)
        {return (asinf(_X)); }
inline float __cdecl atan(  float _X)
        {return (atanf(_X)); }
inline float __cdecl atan2(  float _Y,   float _X)
        {return (atan2f(_Y, _X)); }
inline float __cdecl ceil(  float _X)
        {return (ceilf(_X)); }
inline float __cdecl cos(  float _X)
        {return (cosf(_X)); }
inline float __cdecl cosh(  float _X)
        {return (coshf(_X)); }
inline float __cdecl exp(  float _X)
        {return (expf(_X)); }
inline float __cdecl fabs(  float _X)
        {return (fabsf(_X)); }
inline float __cdecl floor(  float _X)
        {return (floorf(_X)); }
inline float __cdecl fmod(  float _X,   float _Y)
        {return (fmodf(_X, _Y)); }
inline float __cdecl frexp(  float _X,   int * _Y)
        {return (frexpf(_X, _Y)); }
inline float __cdecl ldexp(  float _X,   int _Y)
        {return (ldexpf(_X, _Y)); }
inline float __cdecl log(  float _X)
        {return (logf(_X)); }
inline float __cdecl log10(  float _X)
        {return (log10f(_X)); }
inline float __cdecl modf(  float _X,   float * _Y)
        {return (modff(_X, _Y)); }
inline float __cdecl pow(  float _X,   float _Y)
        {return (powf(_X, _Y)); }
inline float __cdecl pow(  float _X,   int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl sin(  float _X)
        {return (sinf(_X)); }
inline float __cdecl sinh(  float _X)
        {return (sinhf(_X)); }
inline float __cdecl sqrt(  float _X)
        {return (sqrtf(_X)); }
inline float __cdecl tan(  float _X)
        {return (tanf(_X)); }
inline float __cdecl tanh(  float _X)
        {return (tanhf(_X)); }
inline long double __cdecl abs(  long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl acos(  long double _X)
        {return (acosl(_X)); }
inline long double __cdecl asin(  long double _X)
        {return (asinl(_X)); }
inline long double __cdecl atan(  long double _X)
        {return (atanl(_X)); }
inline long double __cdecl atan2(  long double _Y,   long double _X)
        {return (atan2l(_Y, _X)); }
inline long double __cdecl ceil(  long double _X)
        {return (ceill(_X)); }
inline long double __cdecl cos(  long double _X)
        {return (cosl(_X)); }
inline long double __cdecl cosh(  long double _X)
        {return (coshl(_X)); }
inline long double __cdecl exp(  long double _X)
        {return (expl(_X)); }
inline long double __cdecl fabs(  long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl floor(  long double _X)
        {return (floorl(_X)); }
inline long double __cdecl fmod(  long double _X,   long double _Y)
        {return (fmodl(_X, _Y)); }
inline long double __cdecl frexp(  long double _X,   int * _Y)
        {return (frexpl(_X, _Y)); }
inline long double __cdecl ldexp(  long double _X,   int _Y)
        {return (ldexpl(_X, _Y)); }
inline long double __cdecl log(  long double _X)
        {return (logl(_X)); }
inline long double __cdecl log10(  long double _X)
        {return (log10l(_X)); }
inline long double __cdecl modf(  long double _X,   long double * _Y)
        {return (modfl(_X, _Y)); }
inline long double __cdecl pow(  long double _X,   long double _Y)
        {return (powl(_X, _Y)); }
inline long double __cdecl pow(  long double _X,   int _Y)
        {return (_Pow_int(_X, _Y)); }
inline long double __cdecl sin(  long double _X)
        {return (sinl(_X)); }
inline long double __cdecl sinh(  long double _X)
        {return (sinhl(_X)); }
inline long double __cdecl sqrt(  long double _X)
        {return (sqrtl(_X)); }
inline long double __cdecl tan(  long double _X)
        {return (tanl(_X)); }
inline long double __cdecl tanh(  long double _X)
        {return (tanhl(_X)); }

}
#line 597 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

#pragma pack(pop)

#line 601 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"







































#line 641 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cmath"

 
 #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xtgmath.h"

#pragma once




 
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
	
template<class _T1,
	class _Ret>
	struct unary_function;

	
template<class _T1,
	class _T2,
	class _Ret>
	struct binary_function;

	
struct _Nil
	{	
	};
static _Nil _Nil_obj;

	
template<class _Ty,
	_Ty _Val>
	struct integral_constant
	{	
	static const _Ty value = _Val;

	typedef _Ty value_type;
	typedef integral_constant<_Ty, _Val> type;

	operator value_type() const
		{	
		return (value);
		}
	};

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

	
template<bool>
	struct _Cat_base
		: false_type
	{	
	};

template<>
	struct _Cat_base<true>
		: true_type
	{	
	};

	
template<bool _Test,
	class _Ty = void>
	struct enable_if
	{	
	};

template<class _Ty>
	struct enable_if<true, _Ty>
	{	
	typedef _Ty type;
	};

	
template<bool _Test,
	class _Ty1,
	class _Ty2>
	struct conditional
	{	
	typedef _Ty2 type;
	};

template<class _Ty1,
	class _Ty2>
	struct conditional<true, _Ty1, _Ty2>
	{	
	typedef _Ty1 type;
	};

	
template<class _Ty1, class _Ty2>
	struct is_same
		: false_type
	{	
	};

template<class _Ty1>
	struct is_same<_Ty1, _Ty1>
		: true_type
	{	
	};

	
template<class _Ty>
	struct remove_const
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_const<const _Ty>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_const<const _Ty[]>
	{	
	typedef _Ty type[];
	};

template<class _Ty, unsigned int _Nx>
	struct remove_const<const _Ty[_Nx]>
	{	
	typedef _Ty type[_Nx];
	};

	
template<class _Ty>
	struct remove_volatile
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_volatile<volatile _Ty>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_volatile<volatile _Ty[]>
	{	
	typedef _Ty type[];
	};

template<class _Ty, unsigned int _Nx>
	struct remove_volatile<volatile _Ty[_Nx]>
	{	
	typedef _Ty type[_Nx];
	};

	
template<class _Ty>
	struct remove_cv
	{	
	typedef typename remove_const<typename remove_volatile<_Ty>::type>::type
		type;
	};

	
template<class _Ty>
	struct _Is_integral
		: false_type
	{	
	};

template<>
	struct _Is_integral<bool>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned char>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed char>
		: true_type
	{	
	};

 
template<>
	struct _Is_integral<wchar_t>
		: true_type
	{	
	};
 #line 201 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"

template<>
	struct _Is_integral<unsigned short>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed short>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned int>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed int>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned long>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed long>
		: true_type
	{	
	};

 











#line 251 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"

 
template<>
	struct _Is_integral<__int64>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned __int64>
		: true_type
	{	
	};
 #line 265 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"

	
template<class _Ty>
	struct is_integral
		: _Is_integral<typename remove_cv<_Ty>::type>
	{	
	};

	
template<class _Ty>
	struct _Is_floating_point
		: false_type
	{	
	};

template<>
	struct _Is_floating_point<float>
		: true_type
	{	
	};

template<>
	struct _Is_floating_point<double>
		: true_type
	{	
	};

template<>
	struct _Is_floating_point<long double>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_floating_point
		: _Is_floating_point<typename remove_cv<_Ty>::type>
	{	
	};

template<class _Ty>
	struct _Is_numeric
		: _Cat_base<is_integral<_Ty>::value
			|| is_floating_point<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct remove_reference
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_reference<_Ty&>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_reference<_Ty&&>
	{	
	typedef _Ty type;
	};

	
template<class _Tgt,
	class _Src>
	struct _Copy_cv
	{	
	typedef typename remove_reference<_Tgt>::type _Tgtx;
	typedef _Tgtx& type;
	};

template<class _Tgt,
	class _Src>
	struct _Copy_cv<_Tgt, const _Src>
	{	
	typedef typename remove_reference<_Tgt>::type _Tgtx;
	typedef const _Tgtx& type;
	};

template<class _Tgt,
	class _Src>
	struct _Copy_cv<_Tgt, volatile _Src>
	{	
	typedef typename remove_reference<_Tgt>::type _Tgtx;
	typedef volatile _Tgtx& type;
	};

template<class _Tgt,
	class _Src>
	struct _Copy_cv<_Tgt, const volatile _Src>
	{	
	typedef typename remove_reference<_Tgt>::type _Tgtx;
	typedef const volatile _Tgtx& type;
	};

template<class _Tgt,
	class _Src>
	struct _Copy_cv<_Tgt, _Src&>
	{	
	typedef typename _Copy_cv<_Tgt, _Src>::type type;
	};

	
struct _Wrap_int
	{	
	_Wrap_int(int)
		{	
		}
	};

































		
template<class _Ty>
	struct _Has_result_type
		{ template<class _Uty> static auto _Fn(int, typename remove_reference<typename _Uty::result_type>::type * = 0, typename remove_reference<typename _Uty::result_type>::type * = 0, typename remove_reference<typename _Uty::result_type>::type * = 0) -> true_type; template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; };
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 420 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"
#line 421 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xtr1common"





#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xtgmath.h"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
template<class _Ty>
	struct _Promote_to_float
	{	
	typedef typename conditional<is_integral<_Ty>::value,
		double, _Ty>::type type;
	};

template<class _Ty1,
	class _Ty2>
	struct _Common_float_type
	{	
	typedef typename _Promote_to_float<_Ty1>::type _Ty1f;
	typedef typename _Promote_to_float<_Ty2>::type _Ty2f;
	typedef typename conditional<is_same<_Ty1f, long double>::value
		|| is_same<_Ty2f, long double>::value, long double,
		typename conditional<is_same<_Ty1f, double>::value
			|| is_same<_Ty2f, double>::value, double,
			float>::type>::type type;
	};
}


































extern "C" double __cdecl pow(  double,   double);
float __cdecl  pow(  float,   float);
long double __cdecl  pow(  long double,   long double);

template<class _Ty1,
	class _Ty2> inline
	typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value
		&& ::std:: _Is_numeric<_Ty2>::value,
		typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type
	pow(const _Ty1 _Left, const _Ty2 _Right)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
	return (:: pow(type(_Left), type(_Right)));
	}


extern "C"  double __cdecl acos(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acos(_Ty _Left) { return (:: acos((double)_Left)); }
extern "C"  double __cdecl asin(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asin(_Ty _Left) { return (:: asin((double)_Left)); }
extern "C"  double __cdecl atan(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atan(_Ty _Left) { return (:: atan((double)_Left)); }
extern "C"  double __cdecl atan2(  double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: _Common_float_type<_Ty1, _Ty2>::type atan2(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: atan2((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl ceil(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ceil(_Ty _Left) { return (:: ceil((double)_Left)); }
extern "C"  double __cdecl cos(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cos(_Ty _Left) { return (:: cos((double)_Left)); }
extern "C"  double __cdecl cosh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cosh(_Ty _Left) { return (:: cosh((double)_Left)); }
extern "C"  double __cdecl exp(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp(_Ty _Left) { return (:: exp((double)_Left)); }

extern "C" __declspec(dllimport) double __cdecl floor(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type floor(_Ty _Left) { return (:: floor((double)_Left)); }
extern "C"  double __cdecl fmod(  double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: _Common_float_type<_Ty1, _Ty2>::type fmod(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmod((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl frexp(  double,   int *); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type frexp(_Ty _Left,   int * _Arg2) { return (:: frexp((double)_Left, _Arg2)); }
extern "C" __declspec(dllimport) double __cdecl ldexp(  double,   int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ldexp(_Ty _Left,   int _Arg2) { return (:: ldexp((double)_Left, _Arg2)); }
extern "C"  double __cdecl log(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log(_Ty _Left) { return (:: log((double)_Left)); }
extern "C"  double __cdecl log10(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log10(_Ty _Left) { return (:: log10((double)_Left)); }


extern "C"  double __cdecl sin(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sin(_Ty _Left) { return (:: sin((double)_Left)); }
extern "C"  double __cdecl sinh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sinh(_Ty _Left) { return (:: sinh((double)_Left)); }
extern "C"  double __cdecl sqrt(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sqrt(_Ty _Left) { return (:: sqrt((double)_Left)); }
extern "C"  double __cdecl tan(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tan(_Ty _Left) { return (:: tan((double)_Left)); }
extern "C"  double __cdecl tanh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tanh(_Ty _Left) { return (:: tanh((double)_Left)); }

 #line 110 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xtgmath.h"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 115 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xtgmath.h"
#line 116 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xtgmath.h"





#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cmath"
 #line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cmath"
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cmath"

 

namespace std {
using :: acosf; using :: asinf;
using :: atanf; using :: atan2f; using :: ceilf;
using :: cosf; using :: coshf; using :: expf;
using :: fabsf; using :: floorf; using :: fmodf;
using :: frexpf; using :: ldexpf; using :: logf;
using :: log10f; using :: modff; using :: powf;
using :: sinf; using :: sinhf; using :: sqrtf;
using :: tanf; using :: tanhf;

using :: acosl; using :: asinl;
using :: atanl; using :: atan2l; using :: ceill;
using :: cosl; using :: coshl; using :: expl;
using :: fabsl; using :: floorl; using :: fmodl;
using :: frexpl; using :: ldexpl; using :: logl;
using :: log10l; using :: modfl; using :: powl;
using :: sinl; using :: sinhl; using :: sqrtl;
using :: tanl; using :: tanhl;

using :: abs;

using :: acos; using :: asin;
using :: atan; using :: atan2; using :: ceil;
using :: cos; using :: cosh; using :: exp;
using :: fabs; using :: floor; using :: fmod;
using :: frexp; using :: ldexp; using :: log;
using :: log10; using :: modf; using :: pow;
using :: sin; using :: sinh; using :: sqrt;
using :: tan; using :: tanh;

using :: hypot; using :: hypotf;
}
 #line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cmath"
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cmath"





#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cwchar"

#pragma once










 #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

















#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

#pragma pack(push,8)


extern "C" {
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"






















#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"


struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;

#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"




__declspec(dllimport) FILE * __cdecl __iob_func(void);
#line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"






#line 81 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"


typedef unsigned long _fsize_t; 

#line 86 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"



struct _wfinddata32_t {
        unsigned    attrib;
        __time32_t  time_create;    
        __time32_t  time_access;    
        __time32_t  time_write;
        _fsize_t    size;
        wchar_t     name[260];
};

struct _wfinddata32i64_t {
        unsigned    attrib;
        __time32_t  time_create;    
        __time32_t  time_access;    
        __time32_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

struct _wfinddata64i32_t {
        unsigned    attrib;
        __time64_t  time_create;    
        __time64_t  time_access;    
        __time64_t  time_write;
        _fsize_t    size;
        wchar_t     name[260];
};

struct _wfinddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    
        __time64_t  time_access;    
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};



















#line 144 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"


#line 147 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"






























#line 178 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

#line 180 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
#line 181 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

__declspec(dllimport) const unsigned short * __cdecl __pctype_func(void);

__declspec(dllimport) extern const unsigned short *_pctype;


#line 188 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
#line 189 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
#line 190 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"





__declspec(dllimport) extern const unsigned short _wctype[];
#line 197 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

__declspec(dllimport) const wctype_t * __cdecl __pwctype_func(void);

__declspec(dllimport) extern const wctype_t *_pwctype;


#line 204 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
#line 205 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
#line 206 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"







                                
















  __declspec(dllimport) int __cdecl iswalpha(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswalpha_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswupper(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswupper_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswlower(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswlower_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswdigit(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswdigit_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswxdigit(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswxdigit_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswspace(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswspace_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswpunct(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswpunct_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswalnum(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswalnum_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswprint(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswprint_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswgraph(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswgraph_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswcntrl(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswcntrl_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswascii(  wint_t _C);


  __declspec(dllimport) int __cdecl isleadbyte(  int _C);
  __declspec(dllimport) int __cdecl _isleadbyte_l(  int _C,   _locale_t _Locale);
#line 258 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

  __declspec(dllimport) wint_t __cdecl towupper(  wint_t _C);
  __declspec(dllimport) wint_t __cdecl _towupper_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) wint_t __cdecl towlower(  wint_t _C);
  __declspec(dllimport) wint_t __cdecl _towlower_l(  wint_t _C,   _locale_t _Locale); 
  __declspec(dllimport) int __cdecl iswctype(  wint_t _C,   wctype_t _Type);
  __declspec(dllimport) int __cdecl _iswctype_l(  wint_t _C,   wctype_t _Type,   _locale_t _Locale);

  __declspec(dllimport) int __cdecl __iswcsymf(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswcsymf_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl __iswcsym(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswcsym_l(  wint_t _C,   _locale_t _Locale);


__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "iswctype" " instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(  wint_t _C,   wctype_t _Type);
#line 274 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"



#line 278 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"












#line 291 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

    __declspec(dllimport) wchar_t * __cdecl _wgetcwd(  wchar_t * _DstBuf,   int _SizeInWords);
    __declspec(dllimport) wchar_t * __cdecl _wgetdcwd(  int _Drive,   wchar_t * _DstBuf,   int _SizeInWords);





#line 300 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

  __declspec(dllimport) int __cdecl _wchdir(  const wchar_t * _Path);

#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

  __declspec(dllimport) int __cdecl _wmkdir(  const wchar_t * _Path);
  __declspec(dllimport) int __cdecl _wrmdir(  const wchar_t * _Path);


#line 310 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"



  __declspec(dllimport) int __cdecl _waccess(  const wchar_t * _Filename,   int _AccessMode);
 __declspec(dllimport) errno_t __cdecl _waccess_s(  const wchar_t * _Filename,   int _AccessMode);
  __declspec(dllimport) int __cdecl _wchmod(  const wchar_t * _Filename,   int _Mode);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wcreat(  const wchar_t * _Filename,   int _PermissionMode);
  __declspec(dllimport) intptr_t __cdecl _wfindfirst32(  const wchar_t * _Filename,   struct _wfinddata32_t * _FindData);
  __declspec(dllimport) int __cdecl _wfindnext32(  intptr_t _FindHandle,   struct _wfinddata32_t * _FindData);
__declspec(dllimport) int __cdecl _wunlink(  const wchar_t * _Filename);
  __declspec(dllimport) int __cdecl _wrename(  const wchar_t * _OldFilename,   const wchar_t * _NewFilename);
__declspec(dllimport) errno_t __cdecl _wmktemp_s(  wchar_t * _TemplateName,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wmktemp( wchar_t *_TemplateName);

  __declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(  const wchar_t * _Filename,   struct _wfinddata32i64_t * _FindData);
  __declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(  const wchar_t * _Filename,   struct _wfinddata64i32_t * _FindData);
  __declspec(dllimport) intptr_t __cdecl _wfindfirst64(  const wchar_t * _Filename,   struct _wfinddata64_t * _FindData);
  __declspec(dllimport) int __cdecl _wfindnext32i64(  intptr_t _FindHandle,   struct _wfinddata32i64_t * _FindData);
  __declspec(dllimport) int __cdecl _wfindnext64i32(  intptr_t _FindHandle,   struct _wfinddata64i32_t * _FindData);
  __declspec(dllimport) int __cdecl _wfindnext64(  intptr_t _FindHandle,   struct _wfinddata64_t * _FindData);

 __declspec(dllimport) errno_t __cdecl _wsopen_s(  int * _FileHandle,   const wchar_t * _Filename,   int _OpenFlag,   int _ShareFlag,   int _PermissionFlag);



  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wopen(  const wchar_t * _Filename,   int _OpenFlag, ...);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wsopen(  const wchar_t * _Filename,   int _OpenFlag, int _ShareFlag, ...);







#line 346 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"


#line 349 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"





 __declspec(dllimport) wchar_t * __cdecl _wsetlocale(  int _Category,   const wchar_t * _Locale);
 __declspec(dllimport) _locale_t __cdecl _wcreate_locale(  int _Category,   const wchar_t * _Locale);


#line 359 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"







__declspec(dllimport) intptr_t __cdecl _wexecl(  const wchar_t * _Filename,   const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexecle(  const wchar_t * _Filename,   const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexeclp(  const wchar_t * _Filename,   const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexeclpe(  const wchar_t * _Filename,   const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexecv(  const wchar_t * _Filename,   const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wexecve(  const wchar_t * _Filename,   const wchar_t * const * _ArgList,
          const wchar_t * const * _Env);
__declspec(dllimport) intptr_t __cdecl _wexecvp(  const wchar_t * _Filename,   const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wexecvpe(  const wchar_t * _Filename,   const wchar_t * const * _ArgList, 
          const wchar_t * const * _Env);
__declspec(dllimport) intptr_t __cdecl _wspawnl(  int _Mode,   const wchar_t * _Filename,   const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnle(  int _Mode,   const wchar_t * _Filename,   const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnlp(  int _Mode,   const wchar_t * _Filename,   const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnlpe(  int _Mode,   const wchar_t * _Filename,   const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnv(  int _Mode,   const wchar_t * _Filename,   const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wspawnve(  int _Mode,   const wchar_t * _Filename,   const wchar_t * const * _ArgList,
          const wchar_t * const * _Env);
__declspec(dllimport) intptr_t __cdecl _wspawnvp(  int _Mode,   const wchar_t * _Filename,   const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wspawnvpe(  int _Mode,   const wchar_t * _Filename,   const wchar_t * const * _ArgList,
          const wchar_t * const * _Env);






#line 393 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

#line 395 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"





































#line 433 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"





























#line 463 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

#line 465 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"







typedef unsigned short _ino_t;      


typedef unsigned short ino_t;
#line 477 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

#line 479 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"


typedef unsigned int _dev_t;        


typedef unsigned int dev_t;
#line 486 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

#line 488 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"


typedef long _off_t;                


typedef long off_t;
#line 495 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

#line 497 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"



struct _stat32 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
        };



struct stat {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#line 531 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

struct _stat32i64 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        __int64    st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
        };

struct _stat64i32 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

struct _stat64 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        __int64    st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };























#line 597 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"



#line 601 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"





__declspec(dllimport) int __cdecl _wstat32(  const wchar_t * _Name,   struct _stat32 * _Stat);

__declspec(dllimport) int __cdecl _wstat32i64(  const wchar_t * _Name,   struct _stat32i64 * _Stat);
__declspec(dllimport) int __cdecl _wstat64i32(  const wchar_t * _Name,   struct _stat64i32 * _Stat);
__declspec(dllimport) int __cdecl _wstat64(  const wchar_t * _Name,   struct _stat64 * _Stat);


#line 614 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

#line 616 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"











 __declspec(dllimport) errno_t __cdecl _cgetws_s(  wchar_t * _Buffer, size_t _SizeInWords,   size_t * _SizeRead);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _cgetws_s(  wchar_t (&_Buffer)[_Size], size_t * _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_cgetws_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _cgetws(  wchar_t *_Buffer);
  __declspec(dllimport) wint_t __cdecl _getwch(void);
  __declspec(dllimport) wint_t __cdecl _getwche(void);
  __declspec(dllimport) wint_t __cdecl _putwch(wchar_t _WCh);
  __declspec(dllimport) wint_t __cdecl _ungetwch(wint_t _WCh);
 __declspec(dllimport) int __cdecl _cputws(  const wchar_t * _String);
 __declspec(dllimport) int __cdecl _cwprintf(    const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _cwprintf_s(    const wchar_t * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _cwscanf(    const wchar_t * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _cwscanf_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _cwscanf_s(    const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _cwscanf_s_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vcwprintf(    const wchar_t *_Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vcwprintf_s(    const wchar_t *_Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl _cwprintf_p(    const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _vcwprintf_p(    const wchar_t*  _Format, va_list _ArgList);

__declspec(dllimport) int __cdecl _cwprintf_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _cwprintf_s_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _vcwprintf_l(    const wchar_t *_Format,   _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vcwprintf_s_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _cwprintf_p_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _vcwprintf_p_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);

 wint_t __cdecl _putwch_nolock(wchar_t _WCh);
  wint_t __cdecl _getwch_nolock(void);
  wint_t __cdecl _getwche_nolock(void);
 wint_t __cdecl _ungetwch_nolock(wint_t _WCh);


#line 661 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

#line 663 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"













  __declspec(dllimport) FILE * __cdecl _wfsopen(  const wchar_t * _Filename,   const wchar_t * _Mode,   int _ShFlag);
#line 678 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

 __declspec(dllimport) wint_t __cdecl fgetwc(  FILE * _File);
 __declspec(dllimport) wint_t __cdecl _fgetwchar(void);
 __declspec(dllimport) wint_t __cdecl fputwc(  wchar_t _Ch,   FILE * _File);
 __declspec(dllimport) wint_t __cdecl _fputwchar(  wchar_t _Ch);
  __declspec(dllimport) wint_t __cdecl getwc(  FILE * _File);
  __declspec(dllimport) wint_t __cdecl getwchar(void);
 __declspec(dllimport) wint_t __cdecl putwc(  wchar_t _Ch,   FILE * _File);
 __declspec(dllimport) wint_t __cdecl putwchar(  wchar_t _Ch);
 __declspec(dllimport) wint_t __cdecl ungetwc(  wint_t _Ch,   FILE * _File);

 __declspec(dllimport) wchar_t * __cdecl fgetws(  wchar_t * _Dst,   int _SizeInWords,   FILE * _File);
 __declspec(dllimport) int __cdecl fputws(  const wchar_t * _Str,   FILE * _File);
 __declspec(dllimport) wchar_t * __cdecl _getws_s(  wchar_t * _Str,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline wchar_t * __cdecl _getws_s(  wchar_t (&_String)[_Size]) throw() { return _getws_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_getws_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _getws(  wchar_t *_String);
 __declspec(dllimport) int __cdecl _putws(  const wchar_t * _Str);

 __declspec(dllimport) int __cdecl fwprintf(  FILE * _File,     const wchar_t * _Format, ...);

 __declspec(dllimport) int __cdecl fwprintf_s(  FILE * _File,     const wchar_t * _Format, ...);
#line 700 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
 __declspec(dllimport) int __cdecl wprintf(    const wchar_t * _Format, ...);

 __declspec(dllimport) int __cdecl wprintf_s(    const wchar_t * _Format, ...);
#line 704 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
  __declspec(dllimport) int __cdecl _scwprintf(    const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl vfwprintf(  FILE * _File,     const wchar_t * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vfwprintf_s(  FILE * _File,     const wchar_t * _Format, va_list _ArgList);
#line 709 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
 __declspec(dllimport) int __cdecl vwprintf(    const wchar_t * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vwprintf_s(    const wchar_t * _Format, va_list _ArgList);
#line 713 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"


__declspec(dllimport) int __cdecl swprintf_s(  wchar_t * _Dst,   size_t _SizeInWords,     const wchar_t * _Format, ...);
#line 717 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl swprintf_s(  wchar_t (&_Dest)[_Size],     const wchar_t * _Format, ...) throw() { va_list _ArgList; ( __va_start(&_ArgList, _Format) ); return vswprintf_s(_Dest, _Size, _Format, _ArgList); } __pragma(warning(pop)); }

__declspec(dllimport) int __cdecl vswprintf_s(  wchar_t * _Dst,   size_t _SizeInWords,     const wchar_t * _Format, va_list _ArgList);
#line 721 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
extern "C++" { template <size_t _Size> inline int __cdecl vswprintf_s(  wchar_t (&_Dest)[_Size],     const wchar_t * _Format, va_list _Args) throw() { return vswprintf_s(_Dest, _Size, _Format, _Args); } }

 __declspec(dllimport) int __cdecl _swprintf_c(  wchar_t * _DstBuf,   size_t _SizeInWords,     const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _vswprintf_c(  wchar_t * _DstBuf,   size_t _SizeInWords,     const wchar_t * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl _snwprintf_s(  wchar_t * _DstBuf,   size_t _DstSizeInWords,   size_t _MaxCount,     const wchar_t * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl _snwprintf_s(  wchar_t (&_Dest)[_Size],   size_t _Count,     const wchar_t * _Format, ...) throw() { va_list _ArgList; ( __va_start(&_ArgList, _Format) ); return _vsnwprintf_s(_Dest, _Size, _Count, _Format, _ArgList); } __pragma(warning(pop)); }
 __declspec(dllimport) int __cdecl _vsnwprintf_s(  wchar_t * _DstBuf,   size_t _DstSizeInWords,   size_t _MaxCount,     const wchar_t * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl _vsnwprintf_s(  wchar_t (&_Dest)[_Size],   size_t _Count,     const wchar_t * _Format, va_list _Args) throw() { return _vsnwprintf_s(_Dest, _Size, _Count, _Format, _Args); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwprintf(    wchar_t *_Dest,   size_t _Count,     const wchar_t * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnwprintf(    wchar_t *_Dest,   size_t _Count,     const wchar_t * _Format, va_list _Args);

 __declspec(dllimport) int __cdecl _fwprintf_p(  FILE * _File,     const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _wprintf_p(    const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _vfwprintf_p(  FILE * _File,     const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vwprintf_p(    const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _swprintf_p(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _vswprintf_p(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format, va_list _ArgList);
  __declspec(dllimport) int __cdecl _scwprintf_p(    const wchar_t * _Format, ...);
  __declspec(dllimport) int __cdecl _vscwprintf_p(    const wchar_t * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl _wprintf_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _wprintf_p_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _wprintf_s_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vwprintf_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vwprintf_p_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vwprintf_s_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(dllimport) int __cdecl _fwprintf_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _fwprintf_p_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _fwprintf_s_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vfwprintf_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vfwprintf_p_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vfwprintf_s_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(dllimport) int __cdecl _swprintf_c_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _swprintf_p_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _swprintf_s_l(  wchar_t * _DstBuf,   size_t _DstSize,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vswprintf_c_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vswprintf_p_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vswprintf_s_l(  wchar_t * _DstBuf,   size_t _DstSize,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);

  __declspec(dllimport) int __cdecl _scwprintf_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl _scwprintf_p_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl _vscwprintf_p_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwprintf_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snwprintf_s_l(  wchar_t * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnwprintf_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsnwprintf_s_l(  wchar_t * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);









#line 780 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"


#pragma warning(push)
#pragma warning(disable:4141 4996)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _swprintf(    wchar_t *_Dest,     const wchar_t * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _vswprintf(    wchar_t *_Dest,     const wchar_t * _Format, va_list _Args);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __swprintf_l(  wchar_t *_Dest,     const wchar_t * _Format, _locale_t _Plocinfo, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __vswprintf_l(  wchar_t *_Dest,     const wchar_t * _Format, _locale_t _Plocinfo, va_list _Args);
#pragma warning(pop)


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\swprintf.inl"












#pragma once







#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\swprintf.inl"










#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\swprintf.inl"

#pragma warning( push )
#pragma warning( disable : 4793 4412 )
static __inline int swprintf(wchar_t * _String, size_t _Count, const wchar_t * _Format, ...)
{
    va_list _Arglist;
    int _Ret;
    ( __va_start(&_Arglist, _Format) );
    _Ret = _vswprintf_c_l(_String, _Count, _Format, 0, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4412 )
static __inline int __cdecl vswprintf(wchar_t * _String, size_t _Count, const wchar_t * _Format, va_list _Ap)
{
    return _vswprintf_c_l(_String, _Count, _Format, 0, _Ap);
}
#pragma warning( pop )


#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\swprintf.inl"

#pragma warning( push )
#pragma warning( disable : 4793 4412 )
static __inline int _swprintf_l(wchar_t * _String, size_t _Count, const wchar_t * _Format, _locale_t _Plocinfo, ...)
{
    va_list _Arglist;
    int _Ret;
    ( __va_start(&_Arglist, _Plocinfo) );
    _Ret = _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4412 )
static __inline int __cdecl _vswprintf_l(wchar_t * _String, size_t _Count, const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap)
{
    return _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Ap);
}
#pragma warning( pop )


#pragma warning( push )
#pragma warning( disable : 4996 )

#pragma warning( push )
#pragma warning( disable : 4793 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int swprintf(    wchar_t * _String,     const wchar_t * _Format, ...)
{
    va_list _Arglist;
    ( __va_start(&_Arglist, _Format) );
    int _Ret = _vswprintf(_String, _Format, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int __cdecl vswprintf(    wchar_t * _String,     const wchar_t * _Format, va_list _Ap)
{
    return _vswprintf(_String, _Format, _Ap);
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4793 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int _swprintf_l(    wchar_t * _String,     const wchar_t * _Format, _locale_t _Plocinfo, ...)
{
    va_list _Arglist;
    ( __va_start(&_Arglist, _Plocinfo) );
    int _Ret = __vswprintf_l(_String, _Format, _Plocinfo, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int __cdecl _vswprintf_l(    wchar_t * _String,     const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap)
{
    return __vswprintf_l(_String, _Format, _Plocinfo, _Ap);
}
#pragma warning( pop )

#pragma warning( pop )

#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\swprintf.inl"

#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\swprintf.inl"
#line 129 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\swprintf.inl"

#line 790 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
#line 791 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"













#line 805 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

  __declspec(dllimport) wchar_t * __cdecl _wtempnam(  const wchar_t * _Directory,   const wchar_t * _FilePrefix);



#line 811 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

  __declspec(dllimport) int __cdecl _vscwprintf(    const wchar_t * _Format, va_list _ArgList);
  __declspec(dllimport) int __cdecl _vscwprintf_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl fwscanf(  FILE * _File,     const wchar_t * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _fwscanf_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, ...);

 __declspec(dllimport) int __cdecl fwscanf_s(  FILE * _File,     const wchar_t * _Format, ...);
#line 819 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
 __declspec(dllimport) int __cdecl _fwscanf_s_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, ...);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl swscanf(  const wchar_t * _Src,     const wchar_t * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _swscanf_l(  const wchar_t * _Src,     const wchar_t * _Format,   _locale_t _Locale, ...);

 __declspec(dllimport) int __cdecl swscanf_s(  const wchar_t *_Src,     const wchar_t * _Format, ...);
#line 825 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
 __declspec(dllimport) int __cdecl _swscanf_s_l(  const wchar_t * _Src,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwscanf(    const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwscanf_l(    const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snwscanf_s(    const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _snwscanf_s_l(    const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl wscanf(    const wchar_t * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wscanf_l(    const wchar_t * _Format,   _locale_t _Locale, ...);

 __declspec(dllimport) int __cdecl wscanf_s(    const wchar_t * _Format, ...);
#line 835 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
 __declspec(dllimport) int __cdecl _wscanf_s_l(    const wchar_t * _Format,   _locale_t _Locale, ...);

  __declspec(dllimport) FILE * __cdecl _wfdopen(  int _FileHandle ,   const wchar_t * _Mode);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl _wfopen(  const wchar_t * _Filename,   const wchar_t * _Mode);
 __declspec(dllimport) errno_t __cdecl _wfopen_s(  FILE ** _File,   const wchar_t * _Filename,   const wchar_t * _Mode);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl _wfreopen(  const wchar_t * _Filename,   const wchar_t * _Mode,   FILE * _OldFile);
 __declspec(dllimport) errno_t __cdecl _wfreopen_s(  FILE ** _File,   const wchar_t * _Filename,   const wchar_t * _Mode,   FILE * _OldFile);







  __declspec(dllimport) FILE * __cdecl _wpopen(  const wchar_t *_Command,   const wchar_t * _Mode);
#line 851 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

__declspec(dllimport) int __cdecl _wremove(  const wchar_t * _Filename);
 __declspec(dllimport) errno_t __cdecl _wtmpnam_s(  wchar_t * _DstBuf,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wtmpnam_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wtmpnam(  wchar_t *_Buffer);

 __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(  FILE * _File);
 __declspec(dllimport) wint_t __cdecl _fputwc_nolock(  wchar_t _Ch,   FILE * _File);
 __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(  wint_t _Ch,   FILE * _File);






#line 867 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
  inline wint_t __cdecl getwchar(void)
        {return (fgetwc((&__iob_func()[0]))); }   
 inline wint_t __cdecl putwchar(  wchar_t _C)
        {return (fputwc(_C, (&__iob_func()[1]))); }       
#line 872 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"










#line 883 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"


#line 886 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"














































































































#line 997 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"









#line 1007 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

  __declspec(dllimport) wchar_t * __cdecl _wcsdup(  const wchar_t * _Str);



#line 1013 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"


 __declspec(dllimport) errno_t __cdecl wcscat_s(  wchar_t * _Dst,   rsize_t _DstSize, const wchar_t * _Src);
#line 1017 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Dest)[_Size],   const wchar_t * _Source) throw() { return wcscat_s(_Dest, _Size, _Source); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcscat( wchar_t *_Dest,  const wchar_t * _Source);
  __declspec(dllimport) const wchar_t * __cdecl wcschr(  const wchar_t * _Str, wchar_t _Ch);
  __declspec(dllimport) int __cdecl wcscmp(  const wchar_t * _Str1,   const wchar_t * _Str2);

 __declspec(dllimport) errno_t __cdecl wcscpy_s(  wchar_t * _Dst,   rsize_t _DstSize,   const wchar_t * _Src);
#line 1024 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(  wchar_t (&_Dest)[_Size],   const wchar_t * _Source) throw() { return wcscpy_s(_Dest, _Size, _Source); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcscpy( wchar_t *_Dest,  const wchar_t * _Source);
  __declspec(dllimport) size_t __cdecl wcscspn(  const wchar_t * _Str,   const wchar_t * _Control);
  __declspec(dllimport) size_t __cdecl wcslen(  const wchar_t * _Str);
  __declspec(dllimport)


size_t __cdecl wcsnlen(  const wchar_t * _Src,   size_t _MaxCount);

  static __inline


size_t __cdecl wcsnlen_s(  const wchar_t * _Src,   size_t _MaxCount)
{
    return (_Src == 0) ? 0 : wcsnlen(_Src, _MaxCount);
}
#line 1041 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

 __declspec(dllimport) errno_t __cdecl wcsncat_s(  wchar_t * _Dst,   rsize_t _DstSize,   const wchar_t * _Src,   rsize_t _MaxCount);
#line 1044 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(  wchar_t (&_Dest)[_Size],   const wchar_t * _Source,   size_t _Count) throw() { return wcsncat_s(_Dest, _Size, _Source, _Count); } }

#pragma warning(push)
#pragma warning(disable:6059)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsncat(  wchar_t *_Dest,   const wchar_t * _Source,   size_t _Count);
#pragma warning(pop)

  __declspec(dllimport) int __cdecl wcsncmp(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount);

 __declspec(dllimport) errno_t __cdecl wcsncpy_s(  wchar_t * _Dst,   rsize_t _DstSize,   const wchar_t * _Src,   rsize_t _MaxCount);
#line 1055 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Dest)[_Size],   const wchar_t * _Source,   size_t _Count) throw() { return wcsncpy_s(_Dest, _Size, _Source, _Count); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsncpy(    wchar_t *_Dest,   const wchar_t * _Source,   size_t _Count);
  __declspec(dllimport) const wchar_t * __cdecl wcspbrk(  const wchar_t * _Str,   const wchar_t * _Control);
  __declspec(dllimport) const wchar_t * __cdecl wcsrchr(  const wchar_t * _Str,   wchar_t _Ch);
  __declspec(dllimport) size_t __cdecl wcsspn(  const wchar_t * _Str,   const wchar_t * _Control);
    __declspec(dllimport) const wchar_t * __cdecl wcsstr(  const wchar_t * _Str,   const wchar_t * _SubStr);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcstok(  wchar_t * _Str,   const wchar_t * _Delim);
  __declspec(dllimport) wchar_t * __cdecl wcstok_s(  wchar_t * _Str,   const wchar_t * _Delim,     wchar_t ** _Context);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcserror(  int _ErrNum);
 __declspec(dllimport) errno_t __cdecl _wcserror_s(  wchar_t * _Buf,   size_t _SizeInWords,   int _ErrNum);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size],   int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl __wcserror(  const wchar_t * _Str);
 __declspec(dllimport) errno_t __cdecl __wcserror_s(  wchar_t * _Buffer,   size_t _SizeInWords,   const wchar_t * _ErrMsg);
extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size],   const wchar_t * _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }

  __declspec(dllimport) int __cdecl _wcsicmp(  const wchar_t * _Str1,   const wchar_t * _Str2);
  __declspec(dllimport) int __cdecl _wcsicmp_l(  const wchar_t * _Str1,   const wchar_t * _Str2,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _wcsnicmp(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int __cdecl _wcsnicmp_l(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount,   _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl _wcsnset_s(  wchar_t * _Dst,   size_t _DstSizeInWords, wchar_t _Val,   size_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(  wchar_t (&_Dst)[_Size], wchar_t _Val,   size_t _MaxCount) throw() { return _wcsnset_s(_Dst, _Size, _Val, _MaxCount); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsnset(  wchar_t *_Str, wchar_t _Val,   size_t _MaxCount);
__declspec(dllimport) wchar_t * __cdecl _wcsrev(  wchar_t * _Str);
 __declspec(dllimport) errno_t __cdecl _wcsset_s(  wchar_t * _Str,   size_t _SizeInWords, wchar_t _Val);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(  wchar_t (&_Str)[_Size], wchar_t _Val) throw() { return _wcsset_s(_Str, _Size, _Val); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsset(  wchar_t *_Str, wchar_t _Val);

 __declspec(dllimport) errno_t __cdecl _wcslwr_s(  wchar_t * _Str,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcslwr( wchar_t *_String);
 __declspec(dllimport) errno_t __cdecl _wcslwr_s_l(  wchar_t * _Str,   size_t _SizeInWords,   _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcslwr_l(  wchar_t *_String,   _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl _wcsupr_s(  wchar_t * _Str,   size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsupr( wchar_t *_String);
 __declspec(dllimport) errno_t __cdecl _wcsupr_s_l(  wchar_t * _Str,   size_t _Size,   _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsupr_l(  wchar_t *_String,   _locale_t _Locale);
 __declspec(dllimport) size_t __cdecl wcsxfrm(    wchar_t * _Dst,   const wchar_t * _Src,   size_t _MaxCount);
 __declspec(dllimport) size_t __cdecl _wcsxfrm_l(    wchar_t * _Dst,   const wchar_t *_Src,   size_t _MaxCount,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl wcscoll(  const wchar_t * _Str1,   const wchar_t * _Str2);
  __declspec(dllimport) int __cdecl _wcscoll_l(  const wchar_t * _Str1,   const wchar_t * _Str2,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _wcsicoll(  const wchar_t * _Str1,   const wchar_t * _Str2);
  __declspec(dllimport) int __cdecl _wcsicoll_l(  const wchar_t * _Str1,   const wchar_t *_Str2,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _wcsncoll(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int __cdecl _wcsncoll_l(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _wcsnicoll(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int __cdecl _wcsnicoll_l(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount,   _locale_t _Locale);




extern "C++" {
  inline wchar_t * __cdecl wcschr(  wchar_t *_Str, wchar_t _Ch)
        {return ((wchar_t *)wcschr((const wchar_t *)_Str, _Ch)); }
  inline wchar_t * __cdecl wcspbrk(  wchar_t *_Str,   const wchar_t *_Control)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_Str, _Control)); }
  inline wchar_t * __cdecl wcsrchr(  wchar_t *_Str,   wchar_t _Ch)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_Str, _Ch)); }
    inline wchar_t * __cdecl wcsstr(  wchar_t *_Str,   const wchar_t *_SubStr)
        {return ((wchar_t *)wcsstr((const wchar_t *)_Str, _SubStr)); }
}
#line 1119 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
#line 1120 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"






#line 1127 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsdup" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsdup(  const wchar_t * _Str);



#line 1133 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"





  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsicmp" ". See online help for details.")) __declspec(dllimport) int __cdecl wcsicmp(  const wchar_t * _Str1,   const wchar_t * _Str2);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsnicmp" ". See online help for details.")) __declspec(dllimport) int __cdecl wcsnicmp(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsnset" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsnset(  wchar_t * _Str,   wchar_t _Val,   size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsrev" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsrev(  wchar_t * _Str);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsset" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsset(  wchar_t * _Str, wchar_t _Val);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcslwr" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcslwr(  wchar_t * _Str);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsupr" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsupr(  wchar_t * _Str);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsicoll" ". See online help for details.")) __declspec(dllimport) int __cdecl wcsicoll(  const wchar_t * _Str1,   const wchar_t * _Str2);

#line 1148 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"


#line 1151 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"


struct tm {
        int tm_sec;     
        int tm_min;     
        int tm_hour;    
        int tm_mday;    
        int tm_mon;     
        int tm_year;    
        int tm_wday;    
        int tm_yday;    
        int tm_isdst;   
        };

#line 1166 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"




 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wasctime(  const struct tm * _Tm);
__declspec(dllimport) errno_t __cdecl _wasctime_s(    wchar_t *_Buf,   size_t _SizeInWords,   const struct tm * _Tm);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wasctime_s(  wchar_t (&_Buffer)[_Size],   const struct tm * _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wctime32(  const __time32_t *_Time);
__declspec(dllimport) errno_t __cdecl _wctime32_s(    wchar_t* _Buf,   size_t _SizeInWords,   const __time32_t * _Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(  wchar_t (&_Buffer)[_Size],   const __time32_t * _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }

__declspec(dllimport) size_t __cdecl wcsftime(  wchar_t * _Buf,   size_t _SizeInWords,     const wchar_t * _Format,    const struct tm * _Tm);
__declspec(dllimport) size_t __cdecl _wcsftime_l(  wchar_t * _Buf,   size_t _SizeInWords,     const wchar_t *_Format,   const struct tm *_Tm,   _locale_t _Locale);

__declspec(dllimport) errno_t __cdecl _wstrdate_s(    wchar_t * _Buf,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wstrdate( wchar_t *_Buffer);

__declspec(dllimport) errno_t __cdecl _wstrtime_s(    wchar_t * _Buf,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wstrtime( wchar_t *_Buffer);

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wctime64(  const __time64_t * _Time);
__declspec(dllimport) errno_t __cdecl _wctime64_s(    wchar_t* _Buf,   size_t _SizeInWords,   const __time64_t *_Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(  wchar_t (&_Buffer)[_Size],   const __time64_t * _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wtime.inl"












#pragma once







#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wtime.inl"





#pragma warning(push)
#pragma warning(disable:4996)















static __inline wchar_t * __cdecl _wctime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _wctime64(_Time);
#pragma warning( pop )
}

static __inline errno_t __cdecl _wctime_s(wchar_t *_Buffer, size_t _SizeInWords, const time_t * _Time)
{
    return _wctime64_s(_Buffer, _SizeInWords, _Time);
}
#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wtime.inl"

#pragma warning(pop)

#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wtime.inl"
#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wtime.inl"
#line 1196 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
#line 1197 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"


#line 1200 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"


typedef int mbstate_t;
typedef wchar_t _Wint_t;

__declspec(dllimport) wint_t __cdecl btowc(int);
__declspec(dllimport) size_t __cdecl mbrlen(    const char * _Ch,   size_t _SizeInBytes,
                                mbstate_t * _State);
__declspec(dllimport) size_t __cdecl mbrtowc(    wchar_t * _DstCh,     const char * _SrcCh,
                                 size_t _SizeInBytes,   mbstate_t * _State);
__declspec(dllimport) errno_t __cdecl mbsrtowcs_s(  size_t* _Retval,   wchar_t * _Dst,   size_t _Size,     const char ** _PSrc,   size_t _N,   mbstate_t * _State);
extern "C++" { template <size_t _Size> inline errno_t __cdecl mbsrtowcs_s(  size_t * _Retval,   wchar_t (&_Dest)[_Size],     const char ** _PSource,   size_t _Count,   mbstate_t * _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl mbsrtowcs(  wchar_t *_Dest,  const char ** _PSrc,  size_t _Count,  mbstate_t * _State);

__declspec(dllimport) errno_t __cdecl wcrtomb_s(  size_t * _Retval,   char * _Dst,
          size_t _SizeInBytes,   wchar_t _Ch,   mbstate_t * _State);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcrtomb_s(  size_t * _Retval,   char (&_Dest)[_Size],   wchar_t _Source,   mbstate_t * _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl wcrtomb(  char *_Dest,  wchar_t _Source,  mbstate_t * _State);
__declspec(dllimport) errno_t __cdecl wcsrtombs_s(  size_t * _Retval,   char * _Dst,
          size_t _SizeInBytes,     const wchar_t ** _Src,   size_t _Size,   mbstate_t * _State);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsrtombs_s(  size_t * _Retval,   char (&_Dest)[_Size],     const wchar_t ** _PSrc,   size_t _Count,   mbstate_t * _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl wcsrtombs(  char *_Dest,  const wchar_t ** _PSource,  size_t _Count,  mbstate_t * _State);
__declspec(dllimport) int __cdecl wctob(  wint_t _WCh);




__declspec(dllimport)  void *  __cdecl memmove(  void * _Dst,   const void * _Src,   size_t _Size);

 

void *  __cdecl memcpy(  void * _Dst,   const void * _Src,   size_t _Size);

__declspec(dllimport) errno_t __cdecl memcpy_s(  void * _Dst,   rsize_t _DstSize,   const void * _Src,   rsize_t _MaxCount);
__declspec(dllimport) errno_t __cdecl memmove_s(  void * _Dst,   rsize_t _DstSize,   const void * _Src,   rsize_t _MaxCount);
#line 1236 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
__inline int __cdecl fwide(  FILE * _F, int _M)
        {(void)_F; return (_M); }
__inline int __cdecl mbsinit(  const mbstate_t *_P)
        {return (_P == 0 || *_P == 0); }
__inline const wchar_t * __cdecl wmemchr(  const wchar_t *_S,   wchar_t _C,   size_t _N)
        {for (; 0 < _N; ++_S, --_N)
                if (*_S == _C)
                        return (const wchar_t *)(_S);
        return (0); }
__inline int __cdecl wmemcmp(  const wchar_t *_S1,   const wchar_t *_S2,   size_t _N)
        {for (; 0 < _N; ++_S1, ++_S2, --_N)
                if (*_S1 != *_S2)
                        return (*_S1 < *_S2 ? -1 : +1);
        return (0); }

 

__inline  wchar_t * __cdecl wmemcpy(  wchar_t *_S1,   const wchar_t *_S2,   size_t _N)
        {
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
            return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));
#pragma warning( pop )
        }

__inline  wchar_t * __cdecl wmemmove(  wchar_t *_S1,   const wchar_t *_S2,   size_t _N)
        {
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
#pragma warning( disable : 6387)
			
            return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));
#pragma warning( pop )
        }


errno_t __cdecl wmemcpy_s(  wchar_t *_S1,   rsize_t _N1,   const wchar_t *_S2, rsize_t _N);
errno_t __cdecl wmemmove_s(  wchar_t *_S1,   rsize_t _N1,   const wchar_t *_S2,   rsize_t _N);
#line 1275 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

 

__inline wchar_t * __cdecl wmemset(  wchar_t *_S,   wchar_t _C,   size_t _N)
        {
            wchar_t *_Su = _S;
            for (; 0 < _N; ++_Su, --_N)
            {
                *_Su = _C;
            }
            return (_S);
        }


extern "C++" {
inline wchar_t * __cdecl wmemchr(  wchar_t *_S,   wchar_t _C,   size_t _N)
        { return (wchar_t *)wmemchr((const wchar_t *)_S, _C, _N); }
}
#line 1294 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"
#line 1295 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"


}       
#line 1299 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

#pragma pack(pop)

#line 1303 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\wchar.h"

#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cwchar"
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cwchar"

typedef mbstate_t _Mbstatet;

 
namespace std {
using :: _Mbstatet;

using :: mbstate_t; using :: size_t;
using :: tm; using :: wint_t;

using :: btowc; using :: fgetwc; using :: fgetws; using :: fputwc;
using :: fputws; using :: fwide; using :: fwprintf;
using :: fwscanf; using :: getwc; using :: getwchar;
using :: mbrlen; using :: mbrtowc; using :: mbsrtowcs;
using :: mbsinit; using :: putwc; using :: putwchar;
using :: swprintf; using :: swscanf; using :: ungetwc;
using :: vfwprintf; using :: vswprintf; using :: vwprintf;
using :: wcrtomb; using :: wprintf; using :: wscanf;
using :: wcsrtombs; using :: wcstol; using :: wcscat;
using :: wcschr; using :: wcscmp; using :: wcscoll;
using :: wcscpy; using :: wcscspn; using :: wcslen;
using :: wcsncat; using :: wcsncmp; using :: wcsncpy;
using :: wcspbrk; using :: wcsrchr; using :: wcsspn;

using :: wcstod; using :: wcstoul; using :: wcsstr;

using :: wcstok; using :: wcsxfrm; using :: wctob;
using :: wmemchr; using :: wmemcmp; using :: wmemcpy;
using :: wmemmove; using :: wmemset; using :: wcsftime;
}
 #line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cwchar"
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cwchar"





#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"

#pragma once









 
  
  
  
 #line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		
 

 
 
 
 
 

 
 

 



  
  

   
   

 
























#line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"

		


		
 
 

		
template<class _Ty> inline
	_Ty *addressof(_Ty& _Val) throw ()
	{	
	return (reinterpret_cast<_Ty *>(
		(&const_cast<char&>(
		reinterpret_cast<const volatile char&>(_Val)))));
	}

		

template<bool,
	class _Ty1,
	class _Ty2>
	struct _If
	{	
	typedef _Ty2 type;
	};

template<class _Ty1,
	class _Ty2>
	struct _If<true, _Ty1, _Ty2>
	{	
	typedef _Ty1 type;
	};

template<class _Ty>
	struct _Always_false
	{	
	static const bool value = false;
	};



template<class _Ty>
	struct _Bool_struct
	{	
	int _Member;
	};

  











   

   
   
  #line 139 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"
#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"

		
		
template<class _Arg,
	class _Result>
	struct unary_function
	{	
	typedef _Arg argument_type;
	typedef _Result result_type;
	};

		
template<class _Arg1,
	class _Arg2,
	class _Result>
	struct binary_function
	{	
	typedef _Arg1 first_argument_type;
	typedef _Arg2 second_argument_type;
	typedef _Result result_type;
	};

		
template<class _Ty>
	struct equal_to
		: public binary_function<_Ty, _Ty, bool>
	{	
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left == _Right);
		}
	};

		
template<class _Ty>
	struct less
		: public binary_function<_Ty, _Ty, bool>
	{	
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left < _Right);
		}
	};
}



namespace std {
	
inline size_t _Hash_seq(const unsigned char *_First, size_t _Count)
	{	
 
	static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
	const size_t _FNV_offset_basis = 14695981039346656037ULL;
	const size_t _FNV_prime = 1099511628211ULL;

 



#line 201 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"

	size_t _Val = _FNV_offset_basis;
	for (size_t _Next = 0; _Next < _Count; ++_Next)
		{	
		_Val ^= (size_t)_First[_Next];
		_Val *= _FNV_prime;
		}

 
	static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
	_Val ^= _Val >> 32;

 

#line 216 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"

	return (_Val);
	}

	
template<class _Kty>
	struct _Bitwise_hash
		: public unary_function<_Kty, size_t>
	{	
	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Hash_seq((const unsigned char *)&_Keyval, sizeof (_Kty)));
		}
	};

	
template<class _Kty>
	struct hash
		: public _Bitwise_hash<_Kty>
	{	
	static const bool _Value = __is_enum(_Kty);
	static_assert(_Value,
		"The C++ Standard doesn't provide a hash for this type.");
	};

template<>
	struct hash<bool>
		: public _Bitwise_hash<bool>
	{	
	};

template<>
	struct hash<char>
		: public _Bitwise_hash<char>
	{	
	};

template<>
	struct hash<signed char>
		: public _Bitwise_hash<signed char>
	{	
	};

template<>
	struct hash<unsigned char>
		: public _Bitwise_hash<unsigned char>
	{	
	};

 











#line 278 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"

 
template<>
	struct hash<wchar_t>
		: public _Bitwise_hash<wchar_t>
	{	
	};
 #line 286 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"

template<>
	struct hash<short>
		: public _Bitwise_hash<short>
	{	
	};

template<>
	struct hash<unsigned short>
		: public _Bitwise_hash<unsigned short>
	{	
	};

template<>
	struct hash<int>
		: public _Bitwise_hash<int>
	{	
	};

template<>
	struct hash<unsigned int>
		: public _Bitwise_hash<unsigned int>
	{	
	};

template<>
	struct hash<long>
		: public _Bitwise_hash<long>
	{	
	};

template<>
	struct hash<unsigned long>
		: public _Bitwise_hash<unsigned long>
	{	
	};

template<>
	struct hash<long long>
		: public _Bitwise_hash<long long>
	{	
	};

template<>
	struct hash<unsigned long long>
		: public _Bitwise_hash<unsigned long long>
	{	
	};

template<>
	struct hash<float>
		: public _Bitwise_hash<float>
	{	
	typedef float _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval)); 
		}
	};

template<>
	struct hash<double>
		: public _Bitwise_hash<double>
	{	
	typedef double _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval)); 
		}
	};

template<>
	struct hash<long double>
		: public _Bitwise_hash<long double>
	{	
	typedef long double _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval)); 
		}
	};

template<class _Ty>
	struct hash<_Ty *>
		: public _Bitwise_hash<_Ty *>
	{	
	};
}
#line 384 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"

namespace std {
namespace tr1 {	
using ::std:: hash;
}	
}




	

 
  

 

#line 402 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"

 

















 







































































































#line 526 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"



























































































































	








	
































	



	



	







































	








	








































	






























































	











































	








































	

 
















#line 957 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"

 





#line 965 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"



 #line 969 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"
 #line 970 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"

 


















#line 991 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"

 





#line 999 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"



 #line 1003 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"
 #line 1004 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"

	

































































































namespace std {
		
template<class = _Nil, class _V0_t = _Nil , class _V1_t = _Nil , class _V2_t = _Nil , class _V3_t = _Nil , class _V4_t = _Nil , class _V5_t = _Nil , class = _Nil>
	struct _Sizeof;

template<>
	struct _Sizeof<_Nil, _Nil , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil>
	{	
	static const size_t value = 0;
	};









template<class _Ty  > struct _Sizeof<_Ty  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil> { static const size_t value = 1 + _Sizeof<>::value; }; template<class _Ty , class _V0_t> struct _Sizeof<_Ty , _V0_t, _Nil , _Nil , _Nil , _Nil , _Nil> { static const size_t value = 1 + _Sizeof<_V0_t>::value; }; template<class _Ty , class _V0_t , class _V1_t> struct _Sizeof<_Ty , _V0_t , _V1_t, _Nil , _Nil , _Nil , _Nil> { static const size_t value = 1 + _Sizeof<_V0_t , _V1_t>::value; }; template<class _Ty , class _V0_t , class _V1_t , class _V2_t> struct _Sizeof<_Ty , _V0_t , _V1_t , _V2_t, _Nil , _Nil , _Nil> { static const size_t value = 1 + _Sizeof<_V0_t , _V1_t , _V2_t>::value; }; template<class _Ty , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Sizeof<_Ty , _V0_t , _V1_t , _V2_t , _V3_t, _Nil , _Nil> { static const size_t value = 1 + _Sizeof<_V0_t , _V1_t , _V2_t , _V3_t>::value; }; template<class _Ty , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Sizeof<_Ty , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t, _Nil> { static const size_t value = 1 + _Sizeof<_V0_t , _V1_t , _V2_t , _V3_t , _V4_t>::value; };

}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1129 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"
#line 1130 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstddef"






#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {








 

		
typedef enum
	{	
	denorm_indeterminate = -1,
	denorm_absent = 0,
	denorm_present = 1}
		float_denorm_style;

		
typedef enum
	{	
	round_indeterminate = -1,
	round_toward_zero = 0,
	round_to_nearest = 1,
	round_toward_infinity = 2,
	round_toward_neg_infinity = 3}
		float_round_style;

		
struct _Num_base
	{	
	static const float_denorm_style has_denorm = (float_denorm_style)(denorm_absent);
	static const bool has_denorm_loss = (bool)(false);
	static const bool has_infinity = (bool)(false);
	static const bool has_quiet_NaN = (bool)(false);
	static const bool has_signaling_NaN = (bool)(false);
	static const bool is_bounded = (bool)(false);
	static const bool is_exact = (bool)(false);
	static const bool is_iec559 = (bool)(false);
	static const bool is_integer = (bool)(false);
	static const bool is_modulo = (bool)(false);
	static const bool is_signed = (bool)(false);
	static const bool is_specialized = (bool)(false);
	static const bool tinyness_before = (bool)(false);
	static const bool traps = (bool)(false);
	static const float_round_style round_style = (float_round_style)(round_toward_zero);
	static const int digits = (int)(0);
	static const int digits10 = (int)(0);

 
	static const int max_digits10 = (int)(0);
 #line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static const int max_exponent = (int)(0);
	static const int max_exponent10 = (int)(0);
	static const int min_exponent = (int)(0);
	static const int min_exponent10 = (int)(0);
	static const int radix = (int)(0);
	};

		
template<class _Ty>
	class numeric_limits
		: public _Num_base
	{	
public:
	static _Ty (min)() throw ()
		{	
		return (_Ty(0));
		}

	static _Ty (max)() throw ()
		{	
		return (_Ty(0));
		}

 
	static _Ty lowest() throw ()
		{	
		return ((min)());
		}
 #line 101 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static _Ty epsilon() throw ()
		{	
		return (_Ty(0));
		}

	static _Ty round_error() throw ()
		{	
		return (_Ty(0));
		}

	static _Ty denorm_min() throw ()
		{	
		return (_Ty(0));
		}

	static _Ty infinity() throw ()
		{	
		return (_Ty(0));
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (_Ty(0));
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (_Ty(0));
		}
	};

template<class _Ty>
	class numeric_limits<const _Ty>
		: public numeric_limits<_Ty>
	{	
	};

template<class _Ty>
	class numeric_limits<volatile _Ty>
		: public numeric_limits<_Ty>
	{	
	};

template<class _Ty>
	class numeric_limits<const volatile _Ty>
		: public numeric_limits<_Ty>
	{	
	};

		
struct _Num_int_base
	: public _Num_base
	{	
	static const bool is_bounded = (bool)(true);
	static const bool is_exact = (bool)(true);
	static const bool is_integer = (bool)(true);
	static const bool is_modulo = (bool)(true);
	static const bool is_specialized = (bool)(true);
	static const int radix = (int)(2);
	};

		
struct _Num_float_base
	: public _Num_base
	{	
	static const float_denorm_style has_denorm = (float_denorm_style)(denorm_present);
	static const bool has_denorm_loss = (bool)(true);
	static const bool has_infinity = (bool)(true);
	static const bool has_quiet_NaN = (bool)(true);
	static const bool has_signaling_NaN = (bool)(true);
	static const bool is_bounded = (bool)(true);
	static const bool is_exact = (bool)(false);
	static const bool is_iec559 = (bool)(true);
	static const bool is_integer = (bool)(false);
	static const bool is_modulo = (bool)(false);
	static const bool is_signed = (bool)(true);
	static const bool is_specialized = (bool)(true);
	static const bool tinyness_before = (bool)(true);
	static const bool traps = (bool)(false);
	static const float_round_style round_style = (float_round_style)(round_to_nearest);
	static const int radix = (int)(2);
	};

		
template<> class numeric_limits<char>
	: public _Num_int_base
	{	
public:
	typedef char _Ty;

	static _Ty (min)() throw ()
		{	
		return ((-128));
		}

	static _Ty (max)() throw ()
		{	
		return (127);
		}

 
	static _Ty lowest() throw ()
		{	
		return ((min)());
		}
 #line 208 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)((-128) != 0);
	static const int digits = (int)(8 - ((-128) != 0 ? 1 : 0));
	static const int digits10 = (int)((8 - ((-128) != 0 ? 1 : 0)) * 301L / 1000);
#line 243 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"
	};

		
template<> class numeric_limits<wchar_t>
	: public _Num_int_base
	{	
public:
	typedef wchar_t _Ty;

	static _Ty (min)() throw ()
		{	
		return ((_Ty)0x0000);
		}

	static _Ty (max)() throw ()
		{	
		return ((_Ty)0xffff);
		}

 
	static _Ty lowest() throw ()
		{	
		return ((min)());
		}
 #line 268 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(0x0000 != 0);
	static const int digits = (int)(8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0));
#line 302 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"
	static const int digits10 = (int)((8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0)) * 301L / 1000);
#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"
	};

		
template<> class numeric_limits<_Bool>
	: public _Num_int_base
	{	
public:
	typedef bool _Ty;

	static _Ty (min)() throw ()
		{	
		return (false);
		}

	static _Ty (max)() throw ()
		{	
		return (true);
		}

 
	static _Ty lowest() throw ()
		{	
		return ((min)());
		}
 #line 329 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_modulo = (bool)(false);
	static const bool is_signed = (bool)(false);
	static const int digits = (int)(1);
	static const int digits10 = (int)(0);
	};

		
template<> class numeric_limits<signed char>
	: public _Num_int_base
	{	
public:
	typedef signed char _Ty;

	static _Ty (min)() throw ()
		{	
		return ((-128));
		}

	static _Ty (max)() throw ()
		{	
		return (127);
		}

 
	static _Ty lowest() throw ()
		{	
		return ((min)());
		}
 #line 389 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(true);
	static const int digits = (int)(8 - 1);
	static const int digits10 = (int)((8 - 1) * 301L / 1000);
	};

		
template<> class numeric_limits<unsigned char>
	: public _Num_int_base
	{	
public:
	typedef unsigned char _Ty;

	static _Ty (min)() throw ()
		{	
		return (0);
		}

	static _Ty (max)() throw ()
		{	
		return (0xff);
		}

 
	static _Ty lowest() throw ()
		{	
		return ((min)());
		}
 #line 448 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(false);
	static const int digits = (int)(8);
	static const int digits10 = (int)(8 * 301L / 1000);
	};

		
template<> class numeric_limits<short>
	: public _Num_int_base
	{	
public:
	typedef short _Ty;

	static _Ty (min)() throw ()
		{	
		return ((-32768));
		}

	static _Ty (max)() throw ()
		{	
		return (32767);
		}

 
	static _Ty lowest() throw ()
		{	
		return ((min)());
		}
 #line 507 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(true);
	static const int digits = (int)(8 * sizeof (short) - 1);
	static const int digits10 = (int)((8 * sizeof (short) - 1) * 301L / 1000);
#line 542 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"
	};

 
		
template<> class numeric_limits<unsigned short>
	: public _Num_int_base
	{	
public:
	typedef unsigned short _Ty;

	static _Ty (min)() throw ()
		{	
		return (0);
		}

	static _Ty (max)() throw ()
		{	
		return (0xffff);
		}

 
	static _Ty lowest() throw ()
		{	
		return ((min)());
		}
 #line 568 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(false);
	static const int digits = (int)(8 * sizeof (unsigned short));
	static const int digits10 = (int)(8 * sizeof (unsigned short) * 301L / 1000);
#line 603 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"
	};
 #line 605 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

 

























































#line 665 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

		
template<> class numeric_limits<int>
	: public _Num_int_base
	{	
public:
	typedef int _Ty;

	static _Ty (min)() throw ()
		{	
		return ((-2147483647 - 1));
		}

	static _Ty (max)() throw ()
		{	
		return (2147483647);
		}

 
	static _Ty lowest() throw ()
		{	
		return ((min)());
		}
 #line 689 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(true);
	static const int digits = (int)(8 * sizeof (int) - 1);
	static const int digits10 = (int)((8 * sizeof (int) - 1) * 301L / 1000);
#line 724 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"
	};

		
template<> class numeric_limits<unsigned int>
	: public _Num_int_base
	{	
public:
	typedef unsigned int _Ty;

	static _Ty (min)() throw ()
		{	
		return (0);
		}

	static _Ty (max)() throw ()
		{	
		return (0xffffffff);
		}

 
	static _Ty lowest() throw ()
		{	
		return ((min)());
		}
 #line 749 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(false);
	static const int digits = (int)(8 * sizeof (unsigned int));
	static const int digits10 = (int)(8 * sizeof (unsigned int) * 301L / 1000);
#line 784 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"
	};

		
template<> class numeric_limits<long>
	: public _Num_int_base
	{	
public:
	typedef long _Ty;

	static _Ty (min)() throw ()
		{	
		return ((-2147483647L - 1));
		}

	static _Ty (max)() throw ()
		{	
		return (2147483647L);
		}

 
	static _Ty lowest() throw ()
		{	
		return ((min)());
		}
 #line 809 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(true);
	static const int digits = (int)(8 * sizeof (long) - 1);
	static const int digits10 = (int)((8 * sizeof (long) - 1) * 301L / 1000);
#line 844 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"
	};

		
template<> class numeric_limits<unsigned long>
	: public _Num_int_base
	{	
public:
	typedef unsigned long _Ty;

	static _Ty (min)() throw ()
		{	
		return (0);
		}

	static _Ty (max)() throw ()
		{	
		return (0xffffffffUL);
		}

 
	static _Ty lowest() throw ()
		{	
		return ((min)());
		}
 #line 869 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(false);
	static const int digits = (int)(8 * sizeof (unsigned long));
	static const int digits10 = (int)(8 * sizeof (unsigned long) * 301L / 1000);
#line 904 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"
	};

 

























































#line 965 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

 
		
template<> class numeric_limits<__int64>
	: public _Num_int_base
	{	
public:
	typedef __int64 _Ty;

	static _Ty (min)() throw ()
		{	
		return (-0x7fffffffffffffff - 1);
		}

	static _Ty (max)() throw ()
		{	
		return (0x7fffffffffffffff);
		}

 
	static _Ty lowest() throw ()
		{	
		return ((min)());
		}
 #line 990 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(true);
	static const int digits = (int)(8 * sizeof (__int64) - 1);
	static const int digits10 = (int)((8 * sizeof (__int64) - 1) * 301L / 1000);
#line 1025 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"
	};

		
template<> class numeric_limits<unsigned __int64>
	: public _Num_int_base
	{	
public:
	typedef unsigned __int64 _Ty;

	static _Ty (min)() throw ()
		{	
		return (0);
		}

	static _Ty (max)() throw ()
		{	
		return (0xffffffffffffffff);
		}

 
	static _Ty lowest() throw ()
		{	
		return ((min)());
		}
 #line 1050 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(false);
	static const int digits = (int)(8 * sizeof (unsigned __int64));
	static const int digits10 = (int)(8 * sizeof (unsigned __int64) * 301L / 1000);
#line 1085 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"
	};
 #line 1087 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

		
template<> class numeric_limits<float>
	: public _Num_float_base
	{	
public:
	typedef float _Ty;

	static _Ty (min)() throw ()
		{	
		return (1.175494351e-38F);
		}

	static _Ty (max)() throw ()
		{	
		return (3.402823466e+38F);
		}

 
	static _Ty lowest() throw ()
		{	
		return (-(max)());
		}
 #line 1111 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static _Ty epsilon() throw ()
		{	
		return (1.192092896e-07F);
		}

	static _Ty round_error() throw ()
		{	
		return (0.5);
		}

	static _Ty denorm_min() throw ()
		{	
		return (:: _FDenorm._Float);
		}

	static _Ty infinity() throw ()
		{	
		return (:: _FInf._Float);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (:: _FNan._Float);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (:: _FSnan._Float);
		}

	static const int digits = (int)(24);
	static const int digits10 = (int)(6);

 
	static const int max_digits10 = (int)(2 + 24 * 301L / 1000);
 #line 1148 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static const int max_exponent = (int)((int)128);
	static const int max_exponent10 = (int)((int)38);
	static const int min_exponent = (int)((int)(-125));
	static const int min_exponent10 = (int)((int)(-37));
	};

		
template<> class numeric_limits<double>
	: public _Num_float_base
	{	
public:
	typedef double _Ty;

	static _Ty (min)() throw ()
		{	
		return (2.2250738585072014e-308);
		}

	static _Ty (max)() throw ()
		{	
		return (1.7976931348623158e+308);
		}

 
	static _Ty lowest() throw ()
		{	
		return (-(max)());
		}
 #line 1178 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static _Ty epsilon() throw ()
		{	
		return (2.2204460492503131e-016);
		}

	static _Ty round_error() throw ()
		{	
		return (0.5);
		}

	static _Ty denorm_min() throw ()
		{	
		return (:: _Denorm._Double);
		}

	static _Ty infinity() throw ()
		{	
		return (:: _Inf._Double);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (:: _Nan._Double);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (:: _Snan._Double);
		}

	static const int digits = (int)(53);
	static const int digits10 = (int)(15);

 
	static const int max_digits10 = (int)(2 + 53 * 301L / 1000);
 #line 1215 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static const int max_exponent = (int)((int)1024);
	static const int max_exponent10 = (int)((int)308);
	static const int min_exponent = (int)((int)(-1021));
	static const int min_exponent10 = (int)((int)(-307));
	};

		
template<> class numeric_limits<long double>
	: public _Num_float_base
	{	
public:
	typedef long double _Ty;

	static _Ty (min)() throw ()
		{	
		return (2.2250738585072014e-308);
		}

	static _Ty (max)() throw ()
		{	
		return (1.7976931348623158e+308);
		}

 
	static _Ty lowest() throw ()
		{	
		return (-(max)());
		}
 #line 1245 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static _Ty epsilon() throw ()
		{	
		return (2.2204460492503131e-016);
		}

	static _Ty round_error() throw ()
		{	
		return (0.5);
		}

	static _Ty denorm_min() throw ()
		{	
		return (:: _LDenorm._Long_double);
		}

	static _Ty infinity() throw ()
		{	
		return (:: _LInf._Long_double);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (:: _LNan._Long_double);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (:: _LSnan._Long_double);
		}

	static const int digits = (int)(53);
	static const int digits10 = (int)(15);

 
	static const int max_digits10 = (int)(2 + 53 * 301L / 1000);
 #line 1282 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"

	static const int max_exponent = (int)((int)1024);
	static const int max_exponent10 = (int)((int)308);
	static const int min_exponent = (int)((int)(-1021));
	static const int min_exponent10 = (int)((int)(-307));
	};

  





















































































































































































































#line 1504 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1509 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"
#line 1510 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\limits"






#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\new"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\exception"

#pragma once






 #pragma pack(push,8)
 #pragma warning(push,3)
 
 










namespace std {

  


  



  



}

 

 #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\eh.h"












#pragma once

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\eh.h"








#pragma pack(push,8)







typedef void (__cdecl *terminate_function)();
typedef void (__cdecl *terminate_handler)();
typedef void (__cdecl *unexpected_function)();
typedef void (__cdecl *unexpected_handler)();





#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\eh.h"








struct _EXCEPTION_POINTERS;

typedef void (__cdecl *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);
#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\eh.h"

__declspec(dllimport) __declspec(noreturn) void __cdecl terminate(void);
__declspec(dllimport) __declspec(noreturn) void __cdecl unexpected(void);

__declspec(dllimport) int __cdecl _is_exception_typeof(  const type_info &_Type,   struct _EXCEPTION_POINTERS * _ExceptionPtr);



__declspec(dllimport) terminate_function __cdecl set_terminate(  terminate_function _NewPtFunc);
extern "C" __declspec(dllimport) terminate_function __cdecl _get_terminate(void);
__declspec(dllimport) unexpected_function __cdecl set_unexpected(  unexpected_function _NewPtFunc);
extern "C" __declspec(dllimport) unexpected_function __cdecl _get_unexpected(void);
#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\eh.h"



__declspec(dllimport) _se_translator_function __cdecl _set_se_translator(  _se_translator_function _NewPtFunc);
#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\eh.h"
__declspec(dllimport) bool __cdecl __uncaught_exception();









#pragma pack(pop)
#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\eh.h"
#line 85 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\eh.h"
#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\exception"
 
 #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"














#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"


extern "C" {
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"




#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
















__declspec(dllimport) void *  __cdecl _memccpy(   void * _Dst,   const void * _Src,   int _Val,   size_t _MaxCount);
  __declspec(dllimport) const void *  __cdecl memchr(   const void * _Buf ,   int _Val,   size_t _MaxCount);
  __declspec(dllimport) int     __cdecl _memicmp(  const void * _Buf1,   const void * _Buf2,   size_t _Size);
  __declspec(dllimport) int     __cdecl _memicmp_l(  const void * _Buf1,   const void * _Buf2,   size_t _Size,   _locale_t _Locale);
  int     __cdecl memcmp(  const void * _Buf1,   const void * _Buf2,   size_t _Size);

 

void *  __cdecl memcpy(  void * _Dst,   const void * _Src,   size_t _Size);

__declspec(dllimport) errno_t  __cdecl memcpy_s(  void * _Dst,   rsize_t _DstSize,   const void * _Src,   rsize_t _MaxCount);





















#line 79 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"










#line 90 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
#line 91 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
         
        
        void *  __cdecl memset(  void * _Dst,   int _Val,   size_t _Size);



__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_memccpy" ". See online help for details.")) __declspec(dllimport) void * __cdecl memccpy(  void * _Dst,   const void * _Src,   int _Val,   size_t _Size);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_memicmp" ". See online help for details.")) __declspec(dllimport) int __cdecl memicmp(  const void * _Buf1,   const void * _Buf2,   size_t _Size);
#line 100 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

#line 102 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

 __declspec(dllimport) errno_t __cdecl _strset_s(  char * _Dst,   size_t _DstSize,   int _Value);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(  char (&_Dest)[_Size],   int _Value) throw() { return _strset_s(_Dest, _Size, _Value); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))  char * __cdecl _strset( char *_Dest,  int _Value);

 __declspec(dllimport) errno_t __cdecl strcpy_s(  char * _Dst,   rsize_t _SizeInBytes,   const char * _Src);
#line 109 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(  char (&_Dest)[_Size],   const char * _Source) throw() { return strcpy_s(_Dest, _Size, _Source); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))  char * __cdecl strcpy( char *_Dest,  const char * _Source);

 __declspec(dllimport) errno_t __cdecl strcat_s(  char * _Dst,   rsize_t _SizeInBytes,   const char * _Src);
#line 114 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Dest)[_Size],   const char * _Source) throw() { return strcat_s(_Dest, _Size, _Source); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))  char * __cdecl strcat( char *_Dest,  const char * _Source);
          int     __cdecl strcmp(  const char * _Str1,   const char * _Str2);
          size_t  __cdecl strlen(  const char * _Str);
  __declspec(dllimport)


size_t  __cdecl strnlen(  const char * _Str,   size_t _MaxCount);

  static __inline


size_t  __cdecl strnlen_s(  const char * _Str,   size_t _MaxCount)
{
    return (_Str==0) ? 0 : strnlen(_Str, _MaxCount);
}
#line 131 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

 __declspec(dllimport) errno_t __cdecl memmove_s(  void * _Dst,   rsize_t _DstSize,   const void * _Src,   rsize_t _MaxCount);
#line 134 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

__declspec(dllimport)  void *  __cdecl memmove(  void * _Dst,   const void * _Src,   size_t _Size);




#line 141 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

  __declspec(dllimport) char *  __cdecl _strdup(  const char * _Src);



#line 147 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

  __declspec(dllimport) const char *  __cdecl strchr(  const char * _Str,   int _Val);
  __declspec(dllimport) int     __cdecl _stricmp(   const char * _Str1,    const char * _Str2);
  __declspec(dllimport) int     __cdecl _strcmpi(   const char * _Str1,    const char * _Str2);
  __declspec(dllimport) int     __cdecl _stricmp_l(   const char * _Str1,    const char * _Str2,   _locale_t _Locale);
  __declspec(dllimport) int     __cdecl strcoll(   const char * _Str1,    const  char * _Str2);
  __declspec(dllimport) int     __cdecl _strcoll_l(   const char * _Str1,    const char * _Str2,   _locale_t _Locale);
  __declspec(dllimport) int     __cdecl _stricoll(   const char * _Str1,    const char * _Str2);
  __declspec(dllimport) int     __cdecl _stricoll_l(   const char * _Str1,    const char * _Str2,   _locale_t _Locale);
  __declspec(dllimport) int     __cdecl _strncoll  (  const char * _Str1,   const char * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int     __cdecl _strncoll_l(  const char * _Str1,   const char * _Str2,   size_t _MaxCount,   _locale_t _Locale);
  __declspec(dllimport) int     __cdecl _strnicoll (  const char * _Str1,   const char * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int     __cdecl _strnicoll_l(  const char * _Str1,   const char * _Str2,   size_t _MaxCount,   _locale_t _Locale);
  __declspec(dllimport) size_t  __cdecl strcspn(   const char * _Str,    const char * _Control);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char *  __cdecl _strerror(  const char * _ErrMsg);
 __declspec(dllimport) errno_t __cdecl _strerror_s(  char * _Buf,   size_t _SizeInBytes,   const char * _ErrMsg);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size],   const char * _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char *  __cdecl strerror(  int);

 __declspec(dllimport) errno_t __cdecl strerror_s(  char * _Buf,   size_t _SizeInBytes,   int _ErrNum);
#line 168 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size],   int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
 __declspec(dllimport) errno_t __cdecl _strlwr_s(  char * _Str,   size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(  char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strlwr( char *_String);
 __declspec(dllimport) errno_t __cdecl _strlwr_s_l(  char * _Str,   size_t _Size,   _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strlwr_l(  char *_String,   _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl strncat_s(  char * _Dst,   rsize_t _SizeInBytes,   const char * _Src,   rsize_t _MaxCount);
#line 178 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(  char (&_Dest)[_Size],   const char * _Source,   size_t _Count) throw() { return strncat_s(_Dest, _Size, _Source, _Count); } }
#pragma warning(push)
#pragma warning(disable:6059)

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl strncat(  char *_Dest,   const char * _Source,   size_t _Count);
#pragma warning(pop)
  __declspec(dllimport) int     __cdecl strncmp(  const char * _Str1,   const char * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int     __cdecl _strnicmp(  const char * _Str1,   const char * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int     __cdecl _strnicmp_l(  const char * _Str1,   const char * _Str2,   size_t _MaxCount,   _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl strncpy_s(  char * _Dst,   rsize_t _SizeInBytes,   const char * _Src,   rsize_t _MaxCount);
#line 190 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Dest)[_Size],   const char * _Source,   size_t _Count) throw() { return strncpy_s(_Dest, _Size, _Source, _Count); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl strncpy(    char *_Dest,   const char * _Source,   size_t _Count);
 __declspec(dllimport) errno_t __cdecl _strnset_s(  char * _Str,   size_t _SizeInBytes,   int _Val,   size_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(  char (&_Dest)[_Size],   int _Val,   size_t _Count) throw() { return _strnset_s(_Dest, _Size, _Val, _Count); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strnset(  char *_Dest,   int _Val,   size_t _Count);
  __declspec(dllimport) const char *  __cdecl strpbrk(  const char * _Str,   const char * _Control);
  __declspec(dllimport) const char *  __cdecl strrchr(  const char * _Str,   int _Ch);
__declspec(dllimport) char *  __cdecl _strrev(  char * _Str);
  __declspec(dllimport) size_t  __cdecl strspn(  const char * _Str,   const char * _Control);
    __declspec(dllimport) const char *  __cdecl strstr(  const char * _Str,   const char * _SubStr);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char *  __cdecl strtok(  char * _Str,   const char * _Delim);

  __declspec(dllimport) char *  __cdecl strtok_s(  char * _Str,   const char * _Delim,     char ** _Context);
#line 204 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
 __declspec(dllimport) errno_t __cdecl _strupr_s(  char * _Str,   size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(  char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strupr( char *_String);
 __declspec(dllimport) errno_t __cdecl _strupr_s_l(  char * _Str,   size_t _Size, _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(  char (&_String)[_Size], _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strupr_l(  char *_String,   _locale_t _Locale);
 __declspec(dllimport) size_t  __cdecl strxfrm (    char * _Dst,   const char * _Src,   size_t _MaxCount);
 __declspec(dllimport) size_t  __cdecl _strxfrm_l(    char * _Dst,   const char * _Src,   size_t _MaxCount,   _locale_t _Locale);


extern "C++" {


  inline char * __cdecl strchr(  char * _Str,   int _Ch)
	{ return (char*)strchr((const char*)_Str, _Ch); }
  inline char * __cdecl strpbrk(  char * _Str,   const char * _Control)
	{ return (char*)strpbrk((const char*)_Str, _Control); }
  inline char * __cdecl strrchr(  char * _Str,   int _Ch)
	{ return (char*)strrchr((const char*)_Str, _Ch); }
    inline char * __cdecl strstr(  char * _Str,   const char * _SubStr)
	{ return (char*)strstr((const char*)_Str, _SubStr); }
#line 226 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"


  inline void * __cdecl memchr(  void * _Pv,   int _C,   size_t _N)
	{ return (void*)memchr((const void*)_Pv, _C, _N); }
#line 231 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"
}
#line 233 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"






#line 240 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strdup" ". See online help for details.")) __declspec(dllimport) char * __cdecl strdup(  const char * _Src);



#line 246 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"


  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strcmpi" ". See online help for details.")) __declspec(dllimport) int __cdecl strcmpi(  const char * _Str1,   const char * _Str2);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_stricmp" ". See online help for details.")) __declspec(dllimport) int __cdecl stricmp(  const char * _Str1,   const char * _Str2);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strlwr" ". See online help for details.")) __declspec(dllimport) char * __cdecl strlwr(  char * _Str);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strnicmp" ". See online help for details.")) __declspec(dllimport) int __cdecl strnicmp(  const char * _Str1,   const char * _Str,   size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strnset" ". See online help for details.")) __declspec(dllimport) char * __cdecl strnset(  char * _Str,   int _Val,   size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strrev" ". See online help for details.")) __declspec(dllimport) char * __cdecl strrev(  char * _Str);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strset" ". See online help for details."))         char * __cdecl strset(  char * _Str,   int _Val);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strupr" ". See online help for details.")) __declspec(dllimport) char * __cdecl strupr(  char * _Str);

#line 258 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"





































































































































































}
#line 425 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

#line 427 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string.h"

#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\exception"

 

#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\exception"

 



































#line 85 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\exception"

 namespace std {





 
#line 94 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\exception"

class __declspec(dllimport) exception
	{   
public:
	  exception();
	 explicit  exception(const char * const &);
	  exception(const char * const &, int);
	  exception(const exception&);
	 exception&  operator=(const exception&);
	 virtual  ~exception() throw ();
	 virtual const char *  what() const;

private:
	 void  _Copy_str(const char *);
	 void  _Tidy();

	const char * _Mywhat;
	bool _Mydofree;
	};

















































































using ::set_terminate; using ::terminate_handler; using ::terminate; using ::set_unexpected; using ::unexpected_handler; using ::unexpected;

typedef void (__cdecl *_Prhand)(const exception&);

__declspec(dllimport) bool __cdecl uncaught_exception();


inline terminate_handler __cdecl get_terminate()
	{	
	return (_get_terminate());
	}

inline unexpected_handler __cdecl get_unexpected()
	{	
	return (_get_unexpected());
	}
#line 211 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\exception"

}

 




















































































































#line 332 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\exception"


namespace std {


#line 338 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\exception"

		
class bad_exception : public exception
	{	
public:
	 bad_exception(const char *_Message = "bad exception")
		throw ()
		: exception(_Message)
		{	
		}

	virtual  ~bad_exception() throw ()
		{	
		}

 





#line 360 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\exception"

	};

		
class bad_alloc : public exception
	{	
public:
	 bad_alloc() throw ()
		: exception("bad allocation", 1)
		{	
		}

	virtual  ~bad_alloc() throw ()
		{	
		}

private:
	friend class bad_array_new_length;

	 bad_alloc(const char *_Message) throw ()
		: exception(_Message, 1)
		{	
		}

 





#line 391 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\exception"

	};


		
class bad_array_new_length
	: public bad_alloc
	{	
public:

	bad_array_new_length() throw ()
		: bad_alloc("bad array new length")
		{	
		}
	};
#line 407 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\exception"


}









#line 420 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\exception"

__declspec(dllimport) void __cdecl __ExceptionPtrCreate(  void* );
__declspec(dllimport) void __cdecl __ExceptionPtrDestroy(  void* );
__declspec(dllimport) void __cdecl __ExceptionPtrCopy(  void*,   const void* );
__declspec(dllimport) void __cdecl __ExceptionPtrAssign(  void*,   const void* );
__declspec(dllimport) bool __cdecl __ExceptionPtrCompare(  const void*,   const void*);
__declspec(dllimport) bool __cdecl __ExceptionPtrToBool(  const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrSwap(  void*,   void*);

__declspec(dllimport) void __cdecl __ExceptionPtrCurrentException(  void*);
__declspec(dllimport) void __cdecl __ExceptionPtrRethrow(  const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrCopyException(  void*,   const void*,   const void*);

namespace std {

class exception_ptr
	{
public:
	exception_ptr()
		{
		__ExceptionPtrCreate(this);
		}
	exception_ptr(nullptr_t)
		{
		__ExceptionPtrCreate(this);
		}
	~exception_ptr() throw ()
		{
		__ExceptionPtrDestroy(this);
		}
	exception_ptr(const exception_ptr& _Rhs)
		{
		__ExceptionPtrCopy(this, &_Rhs);
		}
	exception_ptr& operator=(const exception_ptr& _Rhs)
		{
		__ExceptionPtrAssign(this, &_Rhs);
		return *this;
		}
	exception_ptr& operator=(nullptr_t)
		{
		exception_ptr _Ptr;
		__ExceptionPtrAssign(this, &_Ptr);
		return *this;
		}

	typedef exception_ptr _Myt;

	typedef int ::std:: _Bool_struct<_Myt>::* _Bool_type;

	operator _Bool_type() const throw ()
		{
		return __ExceptionPtrToBool(this) ? (&::std:: _Bool_struct<_Myt>::_Member) : 0;
		}

	void _RethrowException() const
		{
		__ExceptionPtrRethrow(this);
		}

	static exception_ptr _Current_exception()
		{
		exception_ptr _Retval;
		__ExceptionPtrCurrentException(&_Retval);
		return _Retval;
		}
	static exception_ptr _Copy_exception(  void* _Except,   const void* _Ptr)
		{
		exception_ptr _Retval = 0;
		if (!_Ptr)
			{
			
			return _Retval;
			}
		__ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
		return _Retval;
		}
private:
	void* _Data1;
	void* _Data2;
	};

inline void swap(exception_ptr& _Lhs, exception_ptr& _Rhs)
	{
	__ExceptionPtrSwap(&_Lhs, &_Rhs);
	}

inline bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs)
	{
	return __ExceptionPtrCompare(&_Lhs, &_Rhs);
	}

inline bool operator==(nullptr_t, const exception_ptr& _Rhs)
	{
	return !_Rhs;
	}

inline bool operator==(const exception_ptr& _Lhs, nullptr_t)
	{
	return !_Lhs;
	}

inline bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs)
	{
	return !(_Lhs == _Rhs);
	}

inline bool operator!=(nullptr_t _Lhs, const exception_ptr& _Rhs)
	{
	return !(_Lhs == _Rhs);
	}

inline bool operator!=(const exception_ptr& _Lhs, nullptr_t _Rhs)
	{
	return !(_Lhs == _Rhs);
	}

inline exception_ptr current_exception()
	{
	return exception_ptr::_Current_exception();
	}

inline void rethrow_exception(  exception_ptr _P)
	{
	_P._RethrowException();
	}

template <class _E> void *__GetExceptionInfo(_E);

template<class _E> exception_ptr make_exception_ptr(_E _Except)
	{
	return exception_ptr::_Copy_exception(::std:: addressof(_Except), __GetExceptionInfo(_Except));
	}
}







 
 #pragma warning(pop)
 #pragma pack(pop)

#line 566 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\exception"
#line 567 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\exception"





#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\new"

 #pragma pack(push,8)
 #pragma warning(push,3)
 

  








#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\new"

namespace std {

		
 




typedef void (__cdecl * new_handler) ();
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\new"
 #line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\new"

 
struct nothrow_t
	{	
	};

extern const nothrow_t nothrow;	
 #line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\new"

		
__declspec(dllimport) new_handler __cdecl set_new_handler(  new_handler)
	throw ();	

__declspec(dllimport) new_handler __cdecl get_new_handler()
	throw ();	
}

		
void __cdecl operator delete(void *) throw ();
#pragma warning (suppress: 4985)
    void *__cdecl operator new(size_t _Size) throw (...);

 
  
inline void *__cdecl operator new(size_t, void *_Where) throw ()
	{	
	return (_Where);
	}

inline void __cdecl operator delete(void *, void *) throw ()
	{	
	}
 #line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\new"

 
  
inline void *__cdecl operator new[](size_t, void *_Where) throw ()
	{	
	return (_Where);
	}

inline void __cdecl operator delete[](void *, void *) throw ()
	{	
	}
 #line 79 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\new"

void __cdecl operator delete[](void *) throw ();	

    void *__cdecl operator new[](size_t _Size)
	throw (...);	

 
  
    void *__cdecl operator new(size_t _Size, const ::std:: nothrow_t&)
	throw ();

    void *__cdecl operator new[](size_t _Size, const ::std:: nothrow_t&)
	throw ();	

void __cdecl operator delete(void *, const ::std:: nothrow_t&)
	throw ();	

void __cdecl operator delete[](void *, const ::std:: nothrow_t&)
	throw ();	
 #line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\new"


 
using ::std:: new_handler;
 #line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\new"

 
 #pragma warning(pop)
 #pragma pack(pop)

#line 110 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\new"
#line 111 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\new"





#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

#pragma once





#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\utility"

#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iosfwd"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstdio"

#pragma once










 #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"














#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"





#pragma pack(push,8)


extern "C" {
#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
















































#line 80 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"













#line 94 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"





















#line 116 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"













__declspec(dllimport) FILE * __cdecl __iob_func(void);
#line 131 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"





typedef __int64 fpos_t;

#line 139 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"































  __declspec(dllimport) int __cdecl _filbuf(  FILE * _File );
 __declspec(dllimport) int __cdecl _flsbuf(  int _Ch,   FILE * _File);




  __declspec(dllimport) FILE * __cdecl _fsopen(  const char * _Filename,   const char * _Mode,   int _ShFlag);
#line 178 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

__declspec(dllimport) void __cdecl clearerr(  FILE * _File);

 __declspec(dllimport) errno_t __cdecl clearerr_s(  FILE * _File );
#line 183 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl fclose(  FILE * _File);
 __declspec(dllimport) int __cdecl _fcloseall(void);




  __declspec(dllimport) FILE * __cdecl _fdopen(  int _FileHandle,   const char * _Mode);
#line 191 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

  __declspec(dllimport) int __cdecl feof(  FILE * _File);
  __declspec(dllimport) int __cdecl ferror(  FILE * _File);
 __declspec(dllimport) int __cdecl fflush(  FILE * _File);
 __declspec(dllimport) int __cdecl fgetc(  FILE * _File);
 __declspec(dllimport) int __cdecl _fgetchar(void);
 __declspec(dllimport) int __cdecl fgetpos(  FILE * _File ,   fpos_t * _Pos);
 __declspec(dllimport) char * __cdecl fgets(  char * _Buf,   int _MaxCount,   FILE * _File);




  __declspec(dllimport) int __cdecl _fileno(  FILE * _File);
#line 205 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"




#line 210 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

  __declspec(dllimport) char * __cdecl _tempnam(  const char * _DirName,   const char * _FilePrefix);



#line 216 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

 __declspec(dllimport) int __cdecl _flushall(void);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl fopen(  const char * _Filename,   const char * _Mode);

 __declspec(dllimport) errno_t __cdecl fopen_s(  FILE ** _File,   const char * _Filename,   const char * _Mode);
#line 222 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl fprintf(  FILE * _File,     const char * _Format, ...);

 __declspec(dllimport) int __cdecl fprintf_s(  FILE * _File,     const char * _Format, ...);
#line 226 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl fputc(  int _Ch,   FILE * _File);
 __declspec(dllimport) int __cdecl _fputchar(  int _Ch);
 __declspec(dllimport) int __cdecl fputs(  const char * _Str,   FILE * _File);
 __declspec(dllimport) size_t __cdecl fread(  void * _DstBuf,   size_t _ElementSize,   size_t _Count,   FILE * _File);

 __declspec(dllimport) size_t __cdecl fread_s(  void * _DstBuf,   size_t _DstSize,   size_t _ElementSize,   size_t _Count,   FILE * _File);
#line 233 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl freopen(  const char * _Filename,   const char * _Mode,   FILE * _File);

 __declspec(dllimport) errno_t __cdecl freopen_s(  FILE ** _File,   const char * _Filename,   const char * _Mode,   FILE * _OldFile);
#line 237 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl fscanf(  FILE * _File,     const char * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _fscanf_l(  FILE * _File,     const char * _Format,   _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)

 __declspec(dllimport) int __cdecl fscanf_s(  FILE * _File,     const char * _Format, ...);
#line 244 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _fscanf_s_l(  FILE * _File,     const char * _Format,   _locale_t _Locale, ...);
#pragma warning(pop)
 __declspec(dllimport) int __cdecl fsetpos(  FILE * _File,   const fpos_t * _Pos);
 __declspec(dllimport) int __cdecl fseek(  FILE * _File,   long _Offset,   int _Origin);
  __declspec(dllimport) long __cdecl ftell(  FILE * _File);

 __declspec(dllimport) int __cdecl _fseeki64(  FILE * _File,   __int64 _Offset,   int _Origin);
  __declspec(dllimport) __int64 __cdecl _ftelli64(  FILE * _File);

 __declspec(dllimport) size_t __cdecl fwrite(  const void * _Str,   size_t _Size,   size_t _Count,   FILE * _File);
  __declspec(dllimport) int __cdecl getc(  FILE * _File);
  __declspec(dllimport) int __cdecl getchar(void);
  __declspec(dllimport) int __cdecl _getmaxstdio(void);

__declspec(dllimport) char * __cdecl gets_s(  char * _Buf,   rsize_t _Size);
#line 260 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C++" { template <size_t _Size> inline char * __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "gets_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl gets(  char *_Buffer);
  int __cdecl _getw(  FILE * _File);





 __declspec(dllimport) int __cdecl _pclose(  FILE * _File);
  __declspec(dllimport) FILE * __cdecl _popen(  const char * _Command,   const char * _Mode);
#line 271 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl printf(    const char * _Format, ...);

 __declspec(dllimport) int __cdecl printf_s(    const char * _Format, ...);
#line 275 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl putc(  int _Ch,   FILE * _File);
 __declspec(dllimport) int __cdecl putchar(  int _Ch);
 __declspec(dllimport) int __cdecl puts(  const char * _Str);
 __declspec(dllimport) int __cdecl _putw(  int _Word,   FILE * _File);


__declspec(dllimport) int __cdecl remove(  const char * _Filename);
  __declspec(dllimport) int __cdecl rename(  const char * _OldFilename,   const char * _NewFilename);
__declspec(dllimport) int __cdecl _unlink(  const char * _Filename);

__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_unlink" ". See online help for details.")) __declspec(dllimport) int __cdecl unlink(  const char * _Filename);
#line 287 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
#line 288 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
__declspec(dllimport) void __cdecl rewind(  FILE * _File);
 __declspec(dllimport) int __cdecl _rmtmp(void);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl scanf(    const char * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _scanf_l(    const char * _Format,   _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)

 __declspec(dllimport) int __cdecl scanf_s(    const char * _Format, ...);
#line 297 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _scanf_s_l(    const char * _Format,   _locale_t _Locale, ...);
#pragma warning(pop)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl setbuf(  FILE * _File,     char * _Buffer);
 __declspec(dllimport) int __cdecl _setmaxstdio(  int _Max);
 __declspec(dllimport) unsigned int __cdecl _set_output_format(  unsigned int _Format);
 __declspec(dllimport) unsigned int __cdecl _get_output_format(void);
 __declspec(dllimport) int __cdecl setvbuf(  FILE * _File,   char * _Buf,   int _Mode,   size_t _Size);
 __declspec(dllimport) int __cdecl _snprintf_s(  char * _DstBuf,   size_t _SizeInBytes,   size_t _MaxCount,     const char * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl _snprintf_s(  char (&_Dest)[_Size],   size_t _MaxCount,     const char * _Format, ...) throw() { va_list _ArgList; ( __va_start(&_ArgList, _Format) ); return _vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _ArgList); } __pragma(warning(pop)); }

 __declspec(dllimport) int __cdecl sprintf_s(  char * _DstBuf,   size_t _SizeInBytes,     const char * _Format, ...);
#line 309 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl sprintf_s(  char (&_Dest)[_Size],     const char * _Format, ...) throw() { va_list _ArgList; ( __va_start(&_ArgList, _Format) ); return vsprintf_s(_Dest, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
  __declspec(dllimport) int __cdecl _scprintf(    const char * _Format, ...);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl sscanf(  const char * _Src,     const char * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _sscanf_l(  const char * _Src,     const char * _Format,   _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)

 __declspec(dllimport) int __cdecl sscanf_s(  const char * _Src,     const char * _Format, ...);
#line 318 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _sscanf_s_l(  const char * _Src,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snscanf(    const char * _Src,   size_t _MaxCount,     const char * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snscanf_l(    const char * _Src,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snscanf_s(    const char * _Src,   size_t _MaxCount,     const char * _Format, ...);
 __declspec(dllimport) int __cdecl _snscanf_s_l(    const char * _Src,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
#pragma warning(pop)
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl tmpfile(void);

 __declspec(dllimport) errno_t __cdecl tmpfile_s(    FILE ** _File);
 __declspec(dllimport) errno_t __cdecl tmpnam_s(  char * _Buf,   rsize_t _Size);
#line 329 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl tmpnam_s(  char (&_Buf)[_Size]) throw() { return tmpnam_s(_Buf, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl tmpnam(  char *_Buffer);
 __declspec(dllimport) int __cdecl ungetc(  int _Ch,   FILE * _File);
 __declspec(dllimport) int __cdecl vfprintf(  FILE * _File,     const char * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vfprintf_s(  FILE * _File,     const char * _Format, va_list _ArgList);
#line 336 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl vprintf(    const char * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vprintf_s(    const char * _Format, va_list _ArgList);
#line 340 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl vsnprintf(  char * _DstBuf,   size_t _MaxCount,     const char * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vsnprintf_s(  char * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl vsnprintf_s(  char (&_Dest)[_Size],   size_t _MaxCount,     const char * _Format, va_list _Args) throw() { return vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _Args); } }
#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _vsnprintf_s(  char * _DstBuf,   size_t _SizeInBytes,   size_t _MaxCount,     const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl _vsnprintf_s(  char (&_Dest)[_Size],   size_t _MaxCount,     const char * _Format, va_list _Args) throw() { return _vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable:4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snprintf(    char *_Dest,   size_t _Count,     const char * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnprintf(    char *_Dest,   size_t _Count,     const char * _Format, va_list _Args);
#pragma warning(pop)

__declspec(dllimport) int __cdecl vsprintf_s(  char * _DstBuf,   size_t _SizeInBytes,     const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl vsprintf_s(  char (&_Dest)[_Size],     const char * _Format, va_list _Args) throw() { return vsprintf_s(_Dest, _Size, _Format, _Args); } }
#line 355 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"
#pragma warning(push)
#pragma warning(disable:4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl sprintf(  char *_Dest,  const char * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl vsprintf(  char *_Dest,  const char * _Format, va_list _Args);
#pragma warning(pop)
  __declspec(dllimport) int __cdecl _vscprintf(    const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _snprintf_c(  char * _DstBuf,   size_t _MaxCount,     const char * _Format, ...);
 __declspec(dllimport) int __cdecl _vsnprintf_c(  char *_DstBuf,   size_t _MaxCount,     const char * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl _fprintf_p(  FILE * _File,     const char * _Format, ...);
 __declspec(dllimport) int __cdecl _printf_p(    const char * _Format, ...);
 __declspec(dllimport) int __cdecl _sprintf_p(  char * _Dst,   size_t _MaxCount,     const char * _Format, ...);
 __declspec(dllimport) int __cdecl _vfprintf_p(  FILE * _File,     const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vprintf_p(    const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsprintf_p(  char * _Dst,   size_t _MaxCount,     const char * _Format, va_list _ArgList);
  __declspec(dllimport) int __cdecl _scprintf_p(    const char * _Format, ...);
  __declspec(dllimport) int __cdecl _vscprintf_p(    const char * _Format, va_list _ArgList);
__declspec(dllimport) int __cdecl _set_printf_count_output(  int _Value);
__declspec(dllimport) int __cdecl _get_printf_count_output(void);

 __declspec(dllimport) int __cdecl _printf_l(    const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _printf_p_l(    const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _printf_s_l(    const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vprintf_l(    const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vprintf_p_l(    const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vprintf_s_l(    const char * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(dllimport) int __cdecl _fprintf_l(  FILE * _File,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _fprintf_p_l(  FILE * _File,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _fprintf_s_l(  FILE * _File,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vfprintf_l(  FILE * _File,   const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vfprintf_p_l(  FILE * _File,   const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vfprintf_s_l(  FILE * _File,   const char * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _sprintf_l(    char * _DstBuf,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _sprintf_p_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _sprintf_s_l(  char * _DstBuf,   size_t _DstSize,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsprintf_l(    char * _DstBuf,   const char * _Format,   _locale_t, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsprintf_p_l(  char * _DstBuf,   size_t _MaxCount,     const char* _Format,   _locale_t _Locale,  va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsprintf_s_l(  char * _DstBuf,   size_t _DstSize,     const char * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(dllimport) int __cdecl _scprintf_l(    const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _scprintf_p_l(    const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vscprintf_l(    const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vscprintf_p_l(    const char * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snprintf_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snprintf_c_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snprintf_s_l(  char * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnprintf_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsnprintf_c_l(  char * _DstBuf,   size_t _MaxCount, const char *,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsnprintf_s_l(  char * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const char* _Format,  _locale_t _Locale, va_list _ArgList);





































































































































































































































#line 636 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"















#line 652 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"











__declspec(dllimport) void __cdecl _lock_file(  FILE * _File);
__declspec(dllimport) void __cdecl _unlock_file(  FILE * _File);

 __declspec(dllimport) int __cdecl _fclose_nolock(  FILE * _File);
 __declspec(dllimport) int __cdecl _fflush_nolock(  FILE * _File);
 __declspec(dllimport) size_t __cdecl _fread_nolock(  void * _DstBuf,   size_t _ElementSize,   size_t _Count,   FILE * _File);
 __declspec(dllimport) size_t __cdecl _fread_nolock_s(  void * _DstBuf,   size_t _DstSize,   size_t _ElementSize,   size_t _Count,   FILE * _File);
 __declspec(dllimport) int __cdecl _fseek_nolock(  FILE * _File,   long _Offset,   int _Origin);
  __declspec(dllimport) long __cdecl _ftell_nolock(  FILE * _File);
 __declspec(dllimport) int __cdecl _fseeki64_nolock(  FILE * _File,   __int64 _Offset,   int _Origin);
  __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(  FILE * _File);
 __declspec(dllimport) size_t __cdecl _fwrite_nolock(  const void * _DstBuf,   size_t _Size,   size_t _Count,   FILE * _File);
 __declspec(dllimport) int __cdecl _ungetc_nolock(  int _Ch,   FILE * _File);












#line 689 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"











#line 701 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_tempnam" ". See online help for details.")) __declspec(dllimport) char * __cdecl tempnam(  const char * _Directory,   const char * _FilePrefix);



#line 707 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport) int __cdecl fcloseall(void);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fdopen" ". See online help for details.")) __declspec(dllimport) FILE * __cdecl fdopen(  int _FileHandle,   const char * _Format);
 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fgetchar" ". See online help for details.")) __declspec(dllimport) int __cdecl fgetchar(void);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fileno" ". See online help for details.")) __declspec(dllimport) int __cdecl fileno(  FILE * _File);
 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_flushall" ". See online help for details.")) __declspec(dllimport) int __cdecl flushall(void);
 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fputchar" ". See online help for details.")) __declspec(dllimport) int __cdecl fputchar(  int _Ch);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_getw" ". See online help for details.")) __declspec(dllimport) int __cdecl getw(  FILE * _File);
 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_putw" ". See online help for details.")) __declspec(dllimport) int __cdecl putw(  int _Ch,   FILE * _File);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_rmtmp" ". See online help for details.")) __declspec(dllimport) int __cdecl rmtmp(void);

#line 719 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"


}
#line 723 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

#pragma pack(pop)

#line 727 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdio.h"

#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstdio"
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstdio"


 
 
 
 
 
 
 

 
 
 
 

  

typedef FILE _iobuf;

 
namespace std {
using :: _iobuf;

using :: size_t; using :: fpos_t; using :: FILE;
using :: clearerr; using :: fclose; using :: feof;
using :: ferror; using :: fflush; using :: fgetc;
using :: fgetpos; using :: fgets; using :: fopen;
using :: fprintf; using :: fputc; using :: fputs;
using :: fread; using :: freopen; using :: fscanf;
using :: fseek; using :: fsetpos; using :: ftell;
using :: fwrite; using :: getc; using :: getchar;
using :: gets; using :: perror;
using :: putc; using :: putchar;
using :: printf; using :: puts; using :: remove;
using :: rename; using :: rewind; using :: scanf;
using :: setbuf; using :: setvbuf; using :: sprintf;
using :: sscanf; using :: tmpfile; using :: tmpnam;
using :: ungetc; using :: vfprintf; using :: vprintf;
using :: vsprintf;
}
 #line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstdio"
#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstdio"





#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iosfwd"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstring"

#pragma once










 
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstring"

 
namespace std {
using :: size_t; using :: memchr; using :: memcmp;

using :: memcpy; using :: memmove; using :: memset;
using :: strcat; using :: strchr; using :: strcmp;
using :: strcoll; using :: strcpy; using :: strcspn;
using :: strerror; using :: strlen; using :: strncat;
using :: strncmp; using :: strncpy; using :: strpbrk;
using :: strrchr; using :: strspn; using :: strstr;
using :: strtok; using :: strxfrm;
}
 #line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstring"
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cstring"





#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iosfwd"



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"












#pragma once

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"




#pragma pack(push,8)














extern "C" {
#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"

 





typedef void *_HFILE; 

















#line 63 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"





#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"


typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);
typedef int (__cdecl * _CRT_REPORT_HOOKW)(int, wchar_t *, int *);



#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"




#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"




 





 










typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);


#line 107 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"


#line 110 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"

 





































 














typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);


#line 168 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"


#line 171 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"

struct _CrtMemBlockHeader;
typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        size_t lCounts[5];
        size_t lSizes[5];
        size_t lHighWaterCount;
        size_t lTotalCount;
} _CrtMemState;


 















 













#line 214 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"



#line 218 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"



#line 222 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"



#line 226 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"
























































































































































































































































































































































































































































































































































































































































































































































































#line 987 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"


}



extern "C++" {



 







 
#pragma warning(suppress: 4985)
    void * __cdecl operator new[](size_t _Size);


    void * __cdecl operator new(
        size_t _Size,
        int,
        const char *,
        int
        );

#pragma warning(suppress: 4985)
    void * __cdecl operator new[](
        size_t _Size,
        int,
        const char *,
        int
        );

void __cdecl operator delete[](void *);
void __cdecl operator delete(void * _P, int, const char *, int);
void __cdecl operator delete[](void * _P, int, const char *, int);

#line 1030 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"




















































#line 1083 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"

}

#line 1087 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"

#line 1089 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"


#pragma pack(pop)

#line 1094 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdbg.h"

#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iosfwd"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		

typedef _Longlong streamoff;
typedef _Longlong streamsize;

  
  

  



extern __declspec(dllimport)  const streamoff _BADOFF;
  #line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iosfwd"

		
template<class _Statetype>
	class fpos
	{	
	typedef fpos<_Statetype> _Myt;

public:
	 fpos(streamoff _Off = 0)
		: _Myoff(_Off), _Fpos(0), _Mystate()
		{	
		}

	 fpos(_Statetype _State, fpos_t _Fileposition)
		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
		{	
		}

	_Statetype  state() const
		{	
		return (_Mystate);
		}

	void  state(_Statetype _State)
		{	
		_Mystate = _State;
		}

	fpos_t  seekpos() const
		{	
		return (_Fpos);
		}

	 operator streamoff() const
		{	
		return ((streamoff)(_Myoff + ((long long)(_Fpos))));
		}

	streamoff  operator-(const _Myt& _Right) const
		{	
		return ((streamoff)*this - (streamoff)_Right);
		}

	_Myt&  operator+=(streamoff _Off)
		{	
		_Myoff += _Off;
		return (*this);
		}

	_Myt&  operator-=(streamoff _Off)
		{	
		_Myoff -= _Off;
		return (*this);
		}

	_Myt  operator+(streamoff _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt  operator-(streamoff _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	bool  operator==(const _Myt& _Right) const
		{	
		return ((streamoff)*this == (streamoff)_Right);
		}

	bool  operator==(streamoff _Right) const
		{	
		return ((streamoff)*this == _Right);
		}

	bool  operator!=(const _Myt& _Right) const
		{	
		return (!(*this == _Right));
		}

private:
	streamoff _Myoff;	
	fpos_t _Fpos;	
	_Statetype _Mystate;	
	};

 

 
 

typedef fpos<_Mbstatet> streampos;

typedef streampos wstreampos;

		
template<class _Elem,
	class _Int_type>
	struct _Char_traits
	{	
	typedef _Elem char_type;
	typedef _Int_type int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(
		  const _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		for (; 0 < _Count; --_Count, ++_First1, ++_First2)
			if (!eq(*_First1, *_First2))
				return (lt(*_First1, *_First2) ? -1 : +1);
		return (0);
		}

	static size_t __cdecl length(  const _Elem *_First)
		{	
		size_t _Count;
		for (_Count = 0; !eq(*_First, _Elem()); ++_First)
			++_Count;
		return (_Count);
		}

	static _Elem *__cdecl copy(
		  _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		_Elem *_Next = _First1;
		for (; 0 < _Count; --_Count, ++_Next, ++_First2)
			assign(*_Next, *_First2);
		return (_First1);
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Dest_size,
		  const _Elem *_First2, size_t _Count)
		{	
		{ if (!(_Count <= _Dest_size)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); return (0); } };
		return (copy(_First1, _First2, _Count));
		}

	static const _Elem *__cdecl find(
		  const _Elem *_First,
		size_t _Count, const _Elem& _Ch)
		{	
		for (; 0 < _Count; --_Count, ++_First)
			if (eq(*_First, _Ch))
				return (_First);
		return (0);
		}

	static _Elem *__cdecl move(
		  _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		_Elem *_Next = _First1;
		if (_First2 < _Next && _Next < _First2 + _Count)
			for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)
				assign(*--_Next, *--_First2);
		else
			for (; 0 < _Count; --_Count, ++_Next, ++_First2)
				assign(*_Next, *_First2);
		return (_First1);
		}

	static _Elem *__cdecl assign(
		  _Elem *_First,
		size_t _Count, _Elem _Ch)
		{	
		_Elem *_Next = _First;
		for (; 0 < _Count; --_Count, ++_Next)
			assign(*_Next, _Ch);
		return (_First);
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) throw ()
		{	
		_Left = _Right;
		}

	static bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) throw ()
		{	
		return (_Left == _Right);
		}

	static bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) throw ()
		{	
		return (_Left < _Right);
		}

	static _Elem __cdecl to_char_type(
		const int_type& _Meta) throw ()
		{	
		return ((_Elem)_Meta);
		}

	static int_type __cdecl to_int_type(
		const _Elem& _Ch) throw ()
		{	
		return ((int_type)_Ch);
		}

	static bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) throw ()
		{	
		return (_Left == _Right);
		}

	static int_type __cdecl not_eof(
		const int_type& _Meta) throw ()
		{	
		return (_Meta != eof() ? (int_type)_Meta : (int_type)!eof());
		}

	static int_type __cdecl eof() throw ()
		{	
		return ((int_type)(-1));
		}
	};

		
template<class _Elem>
	struct char_traits
		: public _Char_traits<_Elem, long>
	{	
	};

 

















#line 284 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iosfwd"

		
template<>
	struct char_traits<wchar_t>
	{	
	typedef wchar_t _Elem;
	typedef _Elem char_type;	
	typedef wint_t int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: wmemcmp(_First1, _First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: wcslen(_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemcpy(_First1, _First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_words,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::wmemcpy_s((_First1), (_Size_in_words), (_First2), (_Count));
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: wmemchr(_First, _Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemmove(_First1, _First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: wmemset(_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) throw ()
		{	
		_Left = _Right;
		}

	static bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) throw ()
		{	
		return (_Left == _Right);
		}

	static bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) throw ()
		{	
		return (_Left < _Right);
		}

	static _Elem __cdecl to_char_type(
		const int_type& _Meta) throw ()
		{	
		return (_Meta);
		}

	static int_type __cdecl to_int_type(
		const _Elem& _Ch) throw ()
		{	
		return (_Ch);
		}

	static bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) throw ()
		{	
		return (_Left == _Right);
		}

	static int_type __cdecl not_eof(
		const int_type& _Meta) throw ()
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static int_type __cdecl eof() throw ()
		{	
		return ((wint_t)(0xFFFF));
		}
	};

 
		
template<>
	struct char_traits<unsigned short>
	{	
	typedef unsigned short _Elem;
	typedef _Elem char_type;	
	typedef wint_t int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: wmemcmp((const wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: wcslen((const wchar_t *)_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemcpy((wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_words,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::wmemcpy_s(((wchar_t *)_First1), (_Size_in_words), ((const wchar_t *)_First2), (_Count));
#line 433 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iosfwd"
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: wmemchr((const wchar_t *)_First,
				_Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemmove((wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: wmemset((wchar_t *)_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) throw ()
		{	
		_Left = _Right;
		}

	static bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) throw ()
		{	
		return (_Left == _Right);
		}

	static bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) throw ()
		{	
		return (_Left < _Right);
		}

	static _Elem __cdecl to_char_type(const int_type& _Meta) throw ()
		{	
		return (_Meta);
		}

	static int_type __cdecl to_int_type(const _Elem& _Ch) throw ()
		{	
		return (_Ch);
		}

	static bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) throw ()
		{	
		return (_Left == _Right);
		}

	static int_type __cdecl not_eof(const int_type& _Meta) throw ()
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static int_type __cdecl eof() throw ()
		{	
		return ((wint_t)(0xFFFF));
		}
	};
 #line 502 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iosfwd"

		
template<> struct char_traits<char>
	{	
	typedef char _Elem;
	typedef _Elem char_type;
	typedef int int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: memcmp(_First1, _First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: strlen(_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: memcpy(_First1, _First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_bytes,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::memcpy_s((_First1), (_Size_in_bytes), (_First2), (_Count));
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: memchr(_First, _Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: memmove(_First1, _First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: memset(_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) throw ()
		{	
		_Left = _Right;
		}

	static bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) throw ()
		{	
		return (_Left == _Right);
		}

	static bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) throw ()
		{	
		return ((unsigned char)_Left < (unsigned char)_Right);
		}

	static _Elem __cdecl to_char_type(
		const int_type& _Meta) throw ()
		{	
		return ((_Elem)_Meta);
		}

	static int_type __cdecl to_int_type(
		const _Elem& _Ch) throw ()
		{	
		return ((unsigned char)_Ch);
		}

	static bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) throw ()
		{	
		return (_Left == _Right);
		}

	static int_type __cdecl not_eof(
		const int_type& _Meta) throw ()
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static int_type __cdecl eof() throw ()
		{	
		return ((-1));
		}
	};

		
template<class _Ty>
	class allocator;
class ios_base;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ios;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class istreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class ostreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_streambuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_istream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ostream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_iostream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringbuf;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_istringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_ostringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_filebuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ifstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ofstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_fstream;

 
template<class _Elem,
	class _InIt >
	class num_get;
template<class _Elem,
	class _OutIt >
	class num_put;
template<class _Elem>
	class collate;
 #line 673 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iosfwd"

		
typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
	allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
	allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
	allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
	allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;

		
typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
	wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;


 
typedef num_get<char, istreambuf_iterator<char, char_traits<char> > >
	numget;
typedef num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >
	wnumget;
typedef num_put<char, ostreambuf_iterator<char, char_traits<char> > >
	numput;
typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >
	wnumput;
typedef collate<char> ncollate;
typedef collate<wchar_t> wcollate;
 #line 726 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iosfwd"
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 732 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iosfwd"
#line 733 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iosfwd"





#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\utility"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\type_traits"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
 #pragma warning(disable: 4180 4296)

	

		
  

  


  

  

  



  

  

  

  

  


  



  



  



  


  

  



  


  


  


  

  


  

  




  







		









namespace std {
	
template<class _Ty>
	struct _Ptr_traits
	{	
	};

template<class _Ty>
	struct _Ptr_traits<_Ty *>
	{	
	static const bool _Is_const = false;
	static const bool _Is_volatile = false;
	};

template<class _Ty>
	struct _Ptr_traits<const _Ty *>
	{	
	static const bool _Is_const = true;
	static const bool _Is_volatile = false;
	};

template<class _Ty>
	struct _Ptr_traits<volatile _Ty *>
	{	
	static const bool _Is_const = false;
	static const bool _Is_volatile = true;
	};

template<class _Ty>
	struct _Ptr_traits<const volatile _Ty *>
	{	
	static const bool _Is_const = true;
	static const bool _Is_volatile = true;
	};

template<class _Ty>
	struct _Is_funptr
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_memfunptr
		: false_type
	{	
	};






























































template<class _Ret  > struct _Is_funptr<_Ret (*)()> : true_type { }; template<class _Ret, class _Arg0  > struct _Is_memfunptr<_Ret (_Arg0::*)()> : true_type { }; template<class _Ret, class _Arg0  > struct _Is_memfunptr<_Ret (_Arg0::*)() const> : true_type { }; template<class _Ret, class _Arg0  > struct _Is_memfunptr<_Ret (_Arg0::*)() volatile> : true_type { }; template<class _Ret, class _Arg0  > struct _Is_memfunptr<_Ret (_Arg0::*)() const volatile> : true_type { }; template<class _Ret  > struct _Is_funptr<_Ret (*)(...)> : true_type { }; template<class _Ret, class _Arg0  > struct _Is_memfunptr<_Ret (_Arg0::*)(...)> : true_type { }; template<class _Ret, class _Arg0  > struct _Is_memfunptr<_Ret (_Arg0::*)(...) const> : true_type { }; template<class _Ret, class _Arg0  > struct _Is_memfunptr<_Ret (_Arg0::*)(...) volatile> : true_type { }; template<class _Ret, class _Arg0  > struct _Is_memfunptr<_Ret (_Arg0::*)(...) const volatile> : true_type { }; template<class _Ret , class _V0_t> struct _Is_funptr<_Ret (*)(_V0_t)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t) const> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t) volatile> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t) const volatile> : true_type { }; template<class _Ret , class _V0_t> struct _Is_funptr<_Ret (*)(_V0_t...)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t...)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t...) const> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t...) volatile> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t...) const volatile> : true_type { }; template<class _Ret , class _V0_t , class _V1_t> struct _Is_funptr<_Ret (*)(_V0_t , _V1_t)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t) const> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t) volatile> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t) const volatile> : true_type { }; template<class _Ret , class _V0_t , class _V1_t> struct _Is_funptr<_Ret (*)(_V0_t , _V1_t...)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t...)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t...) const> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t...) volatile> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t...) const volatile> : true_type { }; template<class _Ret , class _V0_t , class _V1_t , class _V2_t> struct _Is_funptr<_Ret (*)(_V0_t , _V1_t , _V2_t)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t) const> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t) volatile> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t) const volatile> : true_type { }; template<class _Ret , class _V0_t , class _V1_t , class _V2_t> struct _Is_funptr<_Ret (*)(_V0_t , _V1_t , _V2_t...)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t...)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t...) const> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t...) volatile> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t...) const volatile> : true_type { }; template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Is_funptr<_Ret (*)(_V0_t , _V1_t , _V2_t , _V3_t)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t) const> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t) volatile> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t) const volatile> : true_type { }; template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Is_funptr<_Ret (*)(_V0_t , _V1_t , _V2_t , _V3_t...)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t...)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t...) const> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t...) volatile> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t...) const volatile> : true_type { }; template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Is_funptr<_Ret (*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) const> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) volatile> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) const volatile> : true_type { }; template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Is_funptr<_Ret (*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t...)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t...)> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t...) const> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t...) volatile> : true_type { }; template<class _Ret, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Is_memfunptr<_Ret (_Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t...) const volatile> : true_type { };


	
	
template<class _Ty>
	struct add_const
	{	
	typedef const _Ty type;
	};

template<class _Ty>
	struct add_const<_Ty&>
	{	
	typedef _Ty& type;
	};

	
template<class _Ty>
	struct add_volatile
	{	
	typedef volatile _Ty type;
	};

template<class _Ty>
	struct add_volatile<_Ty&>
	{	
	typedef _Ty& type;
	};

	
template<class _Ty>
	struct add_cv
	{	
	typedef typename add_const<typename add_volatile<_Ty>::type>::type type;
	};

	
template<class _Ty>
	struct add_reference
	{	
	typedef typename remove_reference<_Ty>::type& type;
	};

template<>
	struct add_reference<void>
	{	
	typedef void type;
	};

template<>
	struct add_reference<const void>
	{	
	typedef const void type;
	};

template<>
	struct add_reference<volatile void>
	{	
	typedef volatile void type;
	};

template<>
	struct add_reference<const volatile void>
	{	
	typedef const volatile void type;
	};

 
	
template<class _Ty>
	struct add_lvalue_reference
	{	
	typedef typename add_reference<_Ty>::type type;
	};

	
template<class _Ty>
	struct add_rvalue_reference
	{	
	typedef typename remove_reference<_Ty>::type&& type;
	};

template<class _Ty>
	struct add_rvalue_reference<_Ty&>
	{	
	typedef _Ty& type;
	};

template<>
	struct add_rvalue_reference<void>
	{	
	typedef void type;
	};

template<>
	struct add_rvalue_reference<const void>
	{	
	typedef const void type;
	};

template<>
	struct add_rvalue_reference<volatile void>
	{	
	typedef volatile void type;
	};

template<>
	struct add_rvalue_reference<const volatile void>
	{	
	typedef const volatile void type;
	};

	
template<class _Ty>
	typename add_rvalue_reference<_Ty>::type
		declval(int = 0) throw ();
 #line 327 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\type_traits"

	
template<class _Ty>
	struct remove_extent
	{	
	typedef _Ty type;
	};

template<class _Ty, unsigned int _Ix>
	struct remove_extent<_Ty[_Ix]>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_extent<_Ty[]>
	{	
	typedef _Ty type;
	};

	
template<class _Ty>
	struct remove_all_extents
	{	
	typedef _Ty type;
	};

template<class _Ty, unsigned int _Ix>
	struct remove_all_extents<_Ty[_Ix]>
	{	
	typedef typename remove_all_extents<_Ty>::type type;
	};

template<class _Ty>
	struct remove_all_extents<_Ty[]>
	{	
	typedef typename remove_all_extents<_Ty>::type type;
	};

	
template<class _Ty>
	struct remove_pointer
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_pointer<_Ty *>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_pointer<_Ty *const>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_pointer<_Ty *volatile>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_pointer<_Ty *const volatile>
	{	
	typedef _Ty type;
	};

	
template<class _Ty>
	struct add_pointer
	{	
	typedef typename remove_reference<_Ty>::type *type;
	};

	
	
template<class _Ty>
	struct _Is_void
		: false_type
	{	
	};

template<>
	struct _Is_void<void>
		: true_type
	{	
	};

template<class _Ty>
	struct is_void
		: _Is_void<typename remove_cv<_Ty>::type>
	{	
	};

	
template<class _Ty>
	struct is_array
		: false_type
	{	
	};

template<class _Ty, size_t _Nx>
	struct is_array<_Ty[_Nx]>
		: true_type
	{	
	};

template<class _Ty>
	struct is_array<_Ty[]>
		: true_type
	{	
	};

 
	
template<class _Ty>
	struct is_lvalue_reference
		: false_type
	{	
	};

template<class _Ty>
	struct is_lvalue_reference<_Ty&>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_rvalue_reference
		: false_type
	{	
	};

template<class _Ty>
	struct is_rvalue_reference<_Ty&&>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_reference
		: _Cat_base<is_lvalue_reference<_Ty>::value
		|| is_rvalue_reference<_Ty>::value>
	{	
	};

 












#line 492 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\type_traits"

	
template<class _Ty>
	struct _Is_member_object_pointer
		: false_type
	{	
	};

template<class _Ty1, class _Ty2>
	struct _Is_member_object_pointer<_Ty1 _Ty2::*>
		: _Cat_base<!_Is_memfunptr<_Ty1 _Ty2::*>::value>
	{	
	};

template<class _Ty>
	struct is_member_object_pointer
		: _Is_member_object_pointer<typename remove_cv<_Ty>::type>
	{	
	};

	
template<class _Ty>
	struct is_member_function_pointer
		: _Cat_base<_Is_memfunptr<typename remove_cv<_Ty>::type>::value>
	{	
	};

	
template<class _Ty>
	struct _Is_pointer
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_pointer<_Ty *>
		: _Cat_base<!is_member_object_pointer<_Ty *>::value
		&& !is_member_function_pointer<_Ty *>::value>
	{	
	};

template<class _Ty>
	struct is_pointer
		: _Is_pointer<typename remove_cv<_Ty>::type>
	{	
	};

	
template<class _Ty>
	struct is_union : _Cat_base<__is_union(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_class : _Cat_base<__is_class(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_function
		: _Cat_base<_Is_funptr<typename remove_cv<_Ty>::type *>::value>
	{	
	};

template<class _Ty>
	struct is_function<_Ty&>
		: false_type
	{	
	};

template<class _Ty>
	struct is_function<_Ty&&>
		: false_type
	{	
	};

	
template<class _Ty>
	struct is_arithmetic
		: _Cat_base<is_integral<_Ty>::value
		|| is_floating_point<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_fundamental
		: _Cat_base<is_arithmetic<_Ty>::value
		|| is_void<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_object
		: _Cat_base<!is_function<_Ty>::value
		&& !is_reference<_Ty>::value
		&& !is_void<_Ty>::value>
	{	
	};

	

template<class _From, class _To>
	struct is_convertible
		: _Cat_base<is_void<_From>::value && is_void<_To>::value || __is_convertible_to(_From, _To)>
	{	
	};

	
 



































template<class _Ty>
	struct is_enum
		: _Cat_base<__is_enum(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_compound
		: _Cat_base<!is_fundamental<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_member_pointer
		: _Cat_base<is_member_object_pointer<_Ty>::value
		|| is_member_function_pointer<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_scalar
		: _Cat_base<is_arithmetic<_Ty>::value
		|| is_enum<_Ty>::value
		|| is_pointer<_Ty>::value
		|| is_member_pointer<_Ty>::value>
	{	
	};

template<class _Ty>
	struct is_scalar<_Ty&>
		: false_type
	{	
	};

	
template<class _Ty>
	struct is_const
		: _Cat_base<_Ptr_traits<_Ty *>::_Is_const
		&& !is_function<_Ty>::value>
	{	
	};

template<class _Ty, unsigned int _Nx>
	struct is_const<_Ty[_Nx]>
		: false_type
	{	
	};

template<class _Ty, unsigned int _Nx>
	struct is_const<const _Ty[_Nx]>
		: true_type
	{	
	};

template<class _Ty>
	struct is_const<_Ty&>
		: false_type
	{	
	};

template<class _Ty>
	struct is_const<_Ty&&>
		: false_type
	{	
	};

	
template<class _Ty>
	struct is_volatile
		: _Cat_base<_Ptr_traits<_Ty *>::_Is_volatile
		&& !is_function<_Ty>::value>
	{	
	};

template<class _Ty>
	struct is_volatile<_Ty&>
		: false_type
	{	
	};

template<class _Ty>
	struct is_volatile<_Ty&&>
		: false_type
	{	
	};

	
template<class _Ty>
	struct _Is_pod : _Cat_base<is_void<_Ty>::value || is_scalar<_Ty>::value || __has_trivial_constructor(_Ty) && __is_pod(_Ty)>
	{	
	};

template<class _Ty>
	struct is_pod
		: _Is_pod<typename remove_all_extents<_Ty>::type>
	{	
	};

	
template<class _Ty>
	struct is_empty : _Cat_base<__is_empty(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_polymorphic : _Cat_base<__is_polymorphic(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_abstract : _Cat_base<__is_abstract(_Ty)>
	{	
	};

 
	
template<class _Ty>
	struct is_standard_layout : _Cat_base<__is_standard_layout(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_literal_type : _Cat_base<__is_literal_type(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_trivial : _Cat_base<__is_trivial(_Ty)>
	{	
	};

	
template<class _Ty>
	struct has_virtual_destructor
		: _Cat_base<__has_virtual_destructor(_Ty)>
	{	
	};

		
	
template<class, class _V0_t = _Nil , class _V1_t = _Nil , class _V2_t = _Nil , class _V3_t = _Nil , class _V4_t = _Nil , class _V5_t = _Nil , class = _Nil>
	struct is_constructible;

 











#line 803 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\type_traits"
template<bool, class, class _V0_t = _Nil , class _V1_t = _Nil , class _V2_t = _Nil , class _V3_t = _Nil , class _V4_t = _Nil , class _V5_t = _Nil , class = _Nil>
	struct _Is_constructible;


































template<class _Ty  > struct _Is_constructible<false, _Ty  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil> : false_type { }; template<class _Ty  > struct _Is_constructible<true, _Ty  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil> { template<class _Uty> static auto _Fn(int) -> decltype(_Uty(), true_type()); template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; }; template<class _Ty  > struct is_constructible<_Ty  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil> : _If<is_void<_Ty>::value, true_type, typename _Is_constructible<is_object<_Ty>::value && (!is_scalar<_Ty>::value || _Sizeof<int  >::value <= 2), typename remove_all_extents<_Ty>::type  >::type>::type { }; template<class _Ty , class _V0_t> struct _Is_constructible<false, _Ty , _V0_t, _Nil , _Nil , _Nil , _Nil , _Nil> : false_type { }; template<class _Ty , class _V0_t> struct _Is_constructible<true, _Ty , _V0_t, _Nil , _Nil , _Nil , _Nil , _Nil> { template<class _Uty> static auto _Fn(int) -> decltype(_Uty(::std:: declval<_V0_t>()), true_type()); template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; }; template<class _Ty , class _V0_t> struct is_constructible<_Ty , _V0_t, _Nil , _Nil , _Nil , _Nil , _Nil> : _If<is_void<_Ty>::value, true_type, typename _Is_constructible<is_object<_Ty>::value && (!is_scalar<_Ty>::value || _Sizeof<int , _V0_t>::value <= 2), typename remove_all_extents<_Ty>::type , _V0_t>::type>::type { }; template<class _Ty , class _V0_t , class _V1_t> struct _Is_constructible<false, _Ty , _V0_t , _V1_t, _Nil , _Nil , _Nil , _Nil> : false_type { }; template<class _Ty , class _V0_t , class _V1_t> struct _Is_constructible<true, _Ty , _V0_t , _V1_t, _Nil , _Nil , _Nil , _Nil> { template<class _Uty> static auto _Fn(int) -> decltype(_Uty(::std:: declval<_V0_t>() , ::std:: declval<_V1_t>()), true_type()); template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; }; template<class _Ty , class _V0_t , class _V1_t> struct is_constructible<_Ty , _V0_t , _V1_t, _Nil , _Nil , _Nil , _Nil> : _If<is_void<_Ty>::value, true_type, typename _Is_constructible<is_object<_Ty>::value && (!is_scalar<_Ty>::value || _Sizeof<int , _V0_t , _V1_t>::value <= 2), typename remove_all_extents<_Ty>::type , _V0_t , _V1_t>::type>::type { }; template<class _Ty , class _V0_t , class _V1_t , class _V2_t> struct _Is_constructible<false, _Ty , _V0_t , _V1_t , _V2_t, _Nil , _Nil , _Nil> : false_type { }; template<class _Ty , class _V0_t , class _V1_t , class _V2_t> struct _Is_constructible<true, _Ty , _V0_t , _V1_t , _V2_t, _Nil , _Nil , _Nil> { template<class _Uty> static auto _Fn(int) -> decltype(_Uty(::std:: declval<_V0_t>() , ::std:: declval<_V1_t>() , ::std:: declval<_V2_t>()), true_type()); template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; }; template<class _Ty , class _V0_t , class _V1_t , class _V2_t> struct is_constructible<_Ty , _V0_t , _V1_t , _V2_t, _Nil , _Nil , _Nil> : _If<is_void<_Ty>::value, true_type, typename _Is_constructible<is_object<_Ty>::value && (!is_scalar<_Ty>::value || _Sizeof<int , _V0_t , _V1_t , _V2_t>::value <= 2), typename remove_all_extents<_Ty>::type , _V0_t , _V1_t , _V2_t>::type>::type { }; template<class _Ty , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Is_constructible<false, _Ty , _V0_t , _V1_t , _V2_t , _V3_t, _Nil , _Nil> : false_type { }; template<class _Ty , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Is_constructible<true, _Ty , _V0_t , _V1_t , _V2_t , _V3_t, _Nil , _Nil> { template<class _Uty> static auto _Fn(int) -> decltype(_Uty(::std:: declval<_V0_t>() , ::std:: declval<_V1_t>() , ::std:: declval<_V2_t>() , ::std:: declval<_V3_t>()), true_type()); template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; }; template<class _Ty , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct is_constructible<_Ty , _V0_t , _V1_t , _V2_t , _V3_t, _Nil , _Nil> : _If<is_void<_Ty>::value, true_type, typename _Is_constructible<is_object<_Ty>::value && (!is_scalar<_Ty>::value || _Sizeof<int , _V0_t , _V1_t , _V2_t , _V3_t>::value <= 2), typename remove_all_extents<_Ty>::type , _V0_t , _V1_t , _V2_t , _V3_t>::type>::type { }; template<class _Ty , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Is_constructible<false, _Ty , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t, _Nil> : false_type { }; template<class _Ty , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Is_constructible<true, _Ty , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t, _Nil> { template<class _Uty> static auto _Fn(int) -> decltype(_Uty(::std:: declval<_V0_t>() , ::std:: declval<_V1_t>() , ::std:: declval<_V2_t>() , ::std:: declval<_V3_t>() , ::std:: declval<_V4_t>()), true_type()); template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; }; template<class _Ty , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct is_constructible<_Ty , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t, _Nil> : _If<is_void<_Ty>::value, true_type, typename _Is_constructible<is_object<_Ty>::value && (!is_scalar<_Ty>::value || _Sizeof<int , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t>::value <= 2), typename remove_all_extents<_Ty>::type , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t>::type>::type { };

 #line 842 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\type_traits"

	
template<class _Ty>
	struct is_copy_constructible
		: _Cat_base<!is_array<_Ty>::value
			&& is_constructible<
				typename remove_volatile<_Ty>::type,
				typename add_lvalue_reference<
				typename add_const<
				typename remove_volatile<_Ty>::type>::type>::type>::value>
	{	
	};

	
template<class _Ty>
	struct has_copy_constructor
		: is_copy_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_default_constructible
		: is_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct has_default_constructor
		: is_default_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_move_constructible
		: _Cat_base<!is_array<_Ty>::value
			&& is_constructible<
				typename remove_volatile<_Ty>::type,
				typename add_rvalue_reference<
				typename remove_cv<_Ty>::type>::type>::value>
	{	
	};

	
template<class _Ty>
	struct has_move_constructor
		: is_move_constructible<_Ty>::type
	{	
	};

	
template<bool,
	class _To,
	class _From>
	struct _Is_assignable
		: false_type
	{	
	};

template<class _To,
	class _From>
	struct _Is_assignable<true, _To, _From>
	{	
	template<class _Uty>
		static auto _Fn(int)
			-> decltype((declval<_Uty>() = declval<_From>()), true_type());

	template<class _Uty>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<_To>(0)) type;
	};

template<class _To,
	class _From>
	struct is_assignable
		: _If<is_void<_To>::value && is_void<_From>::value
			|| is_scalar<_To>::value && is_scalar<_From>::value,
			true_type,
			typename _Is_assignable<
				is_object<typename remove_reference<_To>::type>::value
				&& !is_array<typename remove_reference<_To>::type>::value
				&& is_object<typename remove_reference<_From>::type>::value
				&& !is_array<typename remove_reference<_From>::type>::value,
				_To, _From>::type>::type

	{	
	};

	
template<class _Ty>
	struct is_copy_assignable
		: is_assignable<typename add_lvalue_reference<
				typename remove_volatile<_Ty>::type>::type,
			typename add_lvalue_reference<
				typename add_const<
					typename remove_volatile<_Ty>::type>::type>::type>::type
	{	
	};

	
template<class _Ty>
	struct has_copy_assign
		: is_copy_assignable<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_move_assignable
		: is_assignable<typename add_lvalue_reference<
				typename remove_volatile<_Ty>::type>::type,
			typename remove_volatile<_Ty>::type>::type
	{	
	};

template<class _Ty>
	struct has_move_assign
		: is_move_assignable<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_destructible
		: true_type	

	{	
	};

		
	

 















#line 995 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\type_traits"
template<class, class = _Nil, class _V0_t = _Nil , class _V1_t = _Nil , class _V2_t = _Nil , class _V3_t = _Nil , class _V4_t = _Nil , class _V5_t = _Nil , class = _Nil>
	struct is_trivially_constructible;













template<class _Ty, class _Xarg0  > struct is_trivially_constructible<_Ty, _Xarg0  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil> : is_constructible<_Ty, _Xarg0  > { }; template<class _Ty, class _Xarg0 , class _V0_t> struct is_trivially_constructible<_Ty, _Xarg0 , _V0_t, _Nil , _Nil , _Nil , _Nil , _Nil> : is_constructible<_Ty, _Xarg0 , _V0_t> { }; template<class _Ty, class _Xarg0 , class _V0_t , class _V1_t> struct is_trivially_constructible<_Ty, _Xarg0 , _V0_t , _V1_t, _Nil , _Nil , _Nil , _Nil> : is_constructible<_Ty, _Xarg0 , _V0_t , _V1_t> { }; template<class _Ty, class _Xarg0 , class _V0_t , class _V1_t , class _V2_t> struct is_trivially_constructible<_Ty, _Xarg0 , _V0_t , _V1_t , _V2_t, _Nil , _Nil , _Nil> : is_constructible<_Ty, _Xarg0 , _V0_t , _V1_t , _V2_t> { }; template<class _Ty, class _Xarg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct is_trivially_constructible<_Ty, _Xarg0 , _V0_t , _V1_t , _V2_t , _V3_t, _Nil , _Nil> : is_constructible<_Ty, _Xarg0 , _V0_t , _V1_t , _V2_t , _V3_t> { }; template<class _Ty, class _Xarg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct is_trivially_constructible<_Ty, _Xarg0 , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t, _Nil> : is_constructible<_Ty, _Xarg0 , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t> { };


template<class _Ty>
	struct is_trivially_constructible<_Ty, _Ty, _Nil , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil>
		: _Cat_base<is_pod<typename remove_reference<_Ty>::type>::value || !is_array<_Ty>::value && __is_trivially_copyable(typename remove_reference<_Ty>::type)>

	{	
	};

template<class _Ty>
	struct is_trivially_constructible<_Ty, _Nil, _Nil , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil>
		: _Cat_base<is_pod<_Ty>::value || !is_array<_Ty>::value && __has_trivial_constructor(_Ty)>

	{	
	};
 #line 1027 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\type_traits"

	
template<class _Ty>
	struct is_trivially_copy_constructible
		: _Cat_base<is_pod<typename remove_reference<_Ty>::type>::value || !is_array<_Ty>::value && __is_trivially_copyable(typename remove_reference<_Ty>::type)>





	{	
	};

	
template<class _Ty>
	struct is_trivially_copyable
		: is_trivially_copy_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct has_trivial_copy_constructor
		: _Cat_base<is_pod<typename remove_reference<_Ty>::type>::value || !is_array<_Ty>::value && __is_trivially_copyable(typename remove_reference<_Ty>::type)>

	{	
	};

	
template<class _Ty>
	struct is_trivially_default_constructible
		: is_trivially_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct has_trivial_default_constructor
		: is_trivially_default_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_move_constructible
		: _Cat_base<is_pod<typename remove_reference<_Ty>::type>::value || !is_array<_Ty>::value && __has_trivial_move_constructor(_Ty)>
	{	
	};

	
template<class _Ty>
	struct has_trivial_move_constructor
		: is_trivially_move_constructible<_Ty>::type
	{	
	};

	
template<class _To,
	class _From>
	struct is_trivially_assignable
		: is_assignable<_To, _From>::type	

	{	
	};

	
template<class _Ty>
	struct is_trivially_copy_assignable
		: _Cat_base<is_pod<typename remove_reference<_Ty>::type>::value || __has_trivial_assign(typename remove_reference<_Ty>::type)>





	{	
	};

	
template<class _Ty>
	struct has_trivial_copy_assign
		: is_trivially_copy_assignable<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_move_assignable
		: _Cat_base<__has_trivial_move_assign(_Ty)>
	{	
	};

	
template<class _Ty>
	struct has_trivial_move_assign
		: is_trivially_move_assignable<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_destructible
		: _Cat_base<is_pod<typename remove_reference<_Ty>::type>::value || __has_trivial_destructor(typename remove_reference<_Ty>::type)>
	{	
	};

		
	

 















#line 1152 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\type_traits"
template<class, class = _Nil, class _V0_t = _Nil , class _V1_t = _Nil , class _V2_t = _Nil , class _V3_t = _Nil , class _V4_t = _Nil , class _V5_t = _Nil , class = _Nil>
	struct is_nothrow_constructible;












template<class _Ty, class _Xarg0  > struct is_nothrow_constructible<_Ty, _Xarg0  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil> : is_constructible<_Ty, _Xarg0  > { }; template<class _Ty, class _Xarg0 , class _V0_t> struct is_nothrow_constructible<_Ty, _Xarg0 , _V0_t, _Nil , _Nil , _Nil , _Nil , _Nil> : is_constructible<_Ty, _Xarg0 , _V0_t> { }; template<class _Ty, class _Xarg0 , class _V0_t , class _V1_t> struct is_nothrow_constructible<_Ty, _Xarg0 , _V0_t , _V1_t, _Nil , _Nil , _Nil , _Nil> : is_constructible<_Ty, _Xarg0 , _V0_t , _V1_t> { }; template<class _Ty, class _Xarg0 , class _V0_t , class _V1_t , class _V2_t> struct is_nothrow_constructible<_Ty, _Xarg0 , _V0_t , _V1_t , _V2_t, _Nil , _Nil , _Nil> : is_constructible<_Ty, _Xarg0 , _V0_t , _V1_t , _V2_t> { }; template<class _Ty, class _Xarg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct is_nothrow_constructible<_Ty, _Xarg0 , _V0_t , _V1_t , _V2_t , _V3_t, _Nil , _Nil> : is_constructible<_Ty, _Xarg0 , _V0_t , _V1_t , _V2_t , _V3_t> { }; template<class _Ty, class _Xarg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct is_nothrow_constructible<_Ty, _Xarg0 , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t, _Nil> : is_constructible<_Ty, _Xarg0 , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t> { };


template<class _Ty>
	struct is_nothrow_constructible<_Ty, _Ty, _Nil , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil>
		: _Cat_base<is_pod<typename remove_reference<_Ty>::type>::value || __has_nothrow_copy(typename remove_reference<_Ty>::type)>

	{	
	};

template<class _Ty>
	struct is_nothrow_constructible<_Ty, _Nil, _Nil , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil>
		: _Cat_base<is_pod<_Ty>::value || __has_nothrow_constructor(_Ty)>

	{	
	};
 #line 1183 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\type_traits"

	
template<class _Ty>
	struct is_nothrow_copy_constructible
		: _Cat_base<!is_array<_Ty>::value
			&& is_nothrow_constructible<
				typename remove_volatile<_Ty>::type,
				typename add_lvalue_reference<
				typename add_const<
					typename remove_volatile<_Ty>::type>::type>::type>::value>
	{	
	};

	
template<class _Ty>
	struct has_nothrow_copy_constructor
		: _Cat_base<is_pod<typename remove_reference<_Ty>::type>::value || __has_nothrow_copy(typename remove_reference<_Ty>::type)>

	{	
	};

	
template<class _Ty>
	struct is_nothrow_default_constructible
		: is_nothrow_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct has_nothrow_default_constructor
		: is_nothrow_default_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_nothrow_move_constructible
		: _Cat_base<!is_array<_Ty>::value
			&& is_nothrow_constructible<
				typename remove_volatile<_Ty>::type,
				typename add_rvalue_reference<
				typename remove_volatile<_Ty>::type>::type>::value>
	{	
	};

	
template<class _Ty>
	struct has_nothrow_move_constructor
		: is_nothrow_move_constructible<_Ty>::type
	{	
	};

	
template<class _To,
	class _From>
	struct is_nothrow_assignable
		: is_assignable<_To, _From>::type	

	{	
	};

	
template<class _Ty>
	struct is_nothrow_copy_assignable
		: _Cat_base<is_pod<typename remove_reference<_Ty>::type>::value || __has_nothrow_assign(typename remove_reference<_Ty>::type)>





	{	
	};

	
template<class _Ty>
	struct has_nothrow_copy_assign
		: is_nothrow_copy_assignable<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_nothrow_move_assignable
		: _Cat_base<__has_nothrow_move_assign(_Ty)>
	{	
	};

	
template<class _Ty>
	struct has_nothrow_move_assign
		: is_nothrow_move_assignable<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_nothrow_destructible
		: true_type	

	{	
	};
 #line 1286 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\type_traits"

	
template<class _Ty>
	struct has_trivial_constructor : _Cat_base<is_pod<_Ty>::value || !is_array<_Ty>::value && __has_trivial_constructor(_Ty)>
	{	
	};

	
template<class _Ty>
	struct has_trivial_copy : _Cat_base<is_pod<typename remove_reference<_Ty>::type>::value || !is_array<_Ty>::value && __is_trivially_copyable(typename remove_reference<_Ty>::type)>
	{	
	};

	
template<class _Ty>
	struct has_trivial_assign : _Cat_base<is_pod<typename remove_reference<_Ty>::type>::value || __has_trivial_assign(typename remove_reference<_Ty>::type)>
	{	
	};

	
template<class _Ty>
	struct has_trivial_destructor
		: _Cat_base<is_pod<typename remove_reference<_Ty>::type>::value || __has_trivial_destructor(typename remove_reference<_Ty>::type)>
	{	
	};

	
template<class _Ty>
	struct has_nothrow_constructor : _Cat_base<is_pod<_Ty>::value || __has_nothrow_constructor(_Ty)>
	{	
	};

	
template<class _Ty>
	struct has_nothrow_copy : _Cat_base<is_pod<typename remove_reference<_Ty>::type>::value || __has_nothrow_copy(typename remove_reference<_Ty>::type)>
	{	
	};

	
template<class _Ty>
	struct has_nothrow_assign : _Cat_base<is_pod<typename remove_reference<_Ty>::type>::value || __has_nothrow_assign(typename remove_reference<_Ty>::type)>
	{	
	};

	
template<class _Ty>
	struct _Has_signed_vals
		: _Cat_base<(typename remove_cv<_Ty>::type)(-1)
		< (typename remove_cv<_Ty>::type)(0)>
	{	
	};

template<class _Ty>
	struct is_signed
		: _Cat_base<is_floating_point<_Ty>::value || is_integral<_Ty>::value
		&& _Has_signed_vals<
			typename _If<is_integral<_Ty>::value, _Ty, int>::type>::value>
	{	
	};

	
template<class _Ty>
	struct is_unsigned
		: _Cat_base<is_integral<_Ty>::value
		&& !_Has_signed_vals<
			typename _If<is_integral<_Ty>::value, _Ty, int>::type>::value>
	{	
	};

	
template<class _Ty>
	struct _Change_sign
	{	
	static_assert(
		((is_integral<_Ty>::value || is_enum<_Ty>::value)
			&& !is_same<_Ty, bool>::value),
		"make_signed<T>/make_unsigned<T> require that T shall be a (possibly "
		"cv-qualified) integral type or enumeration but not a bool type.");

	typedef
		typename _If<is_same<_Ty, signed char>::value
			|| is_same<_Ty, unsigned char     >::value, signed char,
		typename _If<is_same<_Ty, short       >::value
			|| is_same<_Ty, unsigned short    >::value, short,
		typename _If<is_same<_Ty, int         >::value
			|| is_same<_Ty, unsigned int      >::value, int,
		typename _If<is_same<_Ty, long        >::value
			|| is_same<_Ty, unsigned long     >::value, long,
		typename _If<is_same<_Ty, long long   >::value
			|| is_same<_Ty, unsigned long long>::value, long long,
		typename _If<sizeof (_Ty) == sizeof (signed char), signed char,
		typename _If<sizeof (_Ty) == sizeof (short      ), short,
		typename _If<sizeof (_Ty) == sizeof (int        ), int,
		typename _If<sizeof (_Ty) == sizeof (long       ), long,
			long long
		>::type>::type>::type>::type>::type>::type>::type>::type>::type
			_Signed;

	typedef
		typename _If<is_same<_Signed, signed char>::value, unsigned char,
		typename _If<is_same<_Signed, short      >::value, unsigned short,
		typename _If<is_same<_Signed, int        >::value, unsigned int,
		typename _If<is_same<_Signed, long       >::value, unsigned long,
			unsigned long long
		>::type>::type>::type>::type
			_Unsigned;
	};

template<class _Ty>
	struct _Change_sign<const _Ty>
	{	
	typedef const typename _Change_sign<_Ty>::_Signed _Signed;
	typedef const typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

template<class _Ty>
	struct _Change_sign<volatile _Ty>
	{	
	typedef volatile typename _Change_sign<_Ty>::_Signed _Signed;
	typedef volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

template<class _Ty>
	struct _Change_sign<const volatile _Ty>
	{	
	typedef const volatile typename _Change_sign<_Ty>::_Signed _Signed;
	typedef const volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

	
template<class _Ty>
	struct make_signed
	{	
	typedef typename _Change_sign<_Ty>::_Signed type;
	};

	
template<class _Ty>
	struct make_unsigned
	{	
	typedef typename _Change_sign<_Ty>::_Unsigned type;
	};

	
 
template<class _Ty>
	struct _Get_align
	{	
	_Ty _Elt0;
	char _Elt1;
	_Ty _Elt2;

	_Get_align();	
	};


 #line 1443 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\type_traits"

template<class _Ty>
	struct alignment_of
		: integral_constant<size_t, (sizeof (_Get_align<_Ty>) - 2 * sizeof (_Ty))>
	{	
	};

template<class _Ty>
	struct alignment_of<_Ty&>
		: integral_constant<size_t, (sizeof (_Get_align<_Ty *>) - 2 * sizeof (_Ty *))>
	{	
	};

	




template<class _Ty,
	size_t _Len>
	union _Align_type
	{	
	_Ty _Val;
	char _Pad[_Len];
	};

template<size_t _Len,
	size_t _Align,
	class _Ty,
	bool _Ok>
	struct _Aligned;

template<size_t _Len,
	size_t _Align,
	class _Ty>
	struct _Aligned<_Len, _Align, _Ty, true>
	{	
	typedef _Align_type<_Ty, _Len> type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, double, false>
	{	
 
	typedef _Align_type<max_align_t, _Len> type;

 

#line 1493 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\type_traits"
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, int, false>
	{	
	typedef typename _Aligned<_Len, _Align, double, _Align <= (sizeof (_Get_align<double>) - 2 * sizeof (double))>::type type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, short, false>
	{	
	typedef typename _Aligned<_Len, _Align, int, _Align <= (sizeof (_Get_align<int>) - 2 * sizeof (int))>::type type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, char, false>
	{	
	typedef typename _Aligned<_Len, _Align, short, _Align <= (sizeof (_Get_align<short>) - 2 * sizeof (short))>::type type;
	};

template<size_t _Len,
	size_t _Align = alignment_of<max_align_t>::value>
	struct aligned_storage
	{	
	typedef typename _Aligned<_Len, _Align, char, _Align <= (sizeof (_Get_align<char>) - 2 * sizeof (char))>::type type;
	};




 
	
template<size_t _Len, class = _Nil, class _V0_t = _Nil , class _V1_t = _Nil , class _V2_t = _Nil , class _V3_t = _Nil , class _V4_t = _Nil , class _V5_t = _Nil , class = _Nil>
	struct aligned_union;

template<size_t _Len>
	struct aligned_union<_Len, _Nil, _Nil , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil>
	{	
	typedef typename aligned_storage<_Len, (sizeof (_Get_align<char>) - 2 * sizeof (char))>::type type;
	};















template<size_t _Len, class _Xty0  > struct aligned_union<_Len, _Xty0  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil> { typedef union { typename aligned_storage<_Len, (sizeof (_Get_align<_Xty0>) - 2 * sizeof (_Xty0))>::type _Obj1; typename aligned_union<_Len  >::type _Obj2; } type; }; template<size_t _Len, class _Xty0 , class _V0_t> struct aligned_union<_Len, _Xty0 , _V0_t, _Nil , _Nil , _Nil , _Nil , _Nil> { typedef union { typename aligned_storage<_Len, (sizeof (_Get_align<_Xty0>) - 2 * sizeof (_Xty0))>::type _Obj1; typename aligned_union<_Len , _V0_t>::type _Obj2; } type; }; template<size_t _Len, class _Xty0 , class _V0_t , class _V1_t> struct aligned_union<_Len, _Xty0 , _V0_t , _V1_t, _Nil , _Nil , _Nil , _Nil> { typedef union { typename aligned_storage<_Len, (sizeof (_Get_align<_Xty0>) - 2 * sizeof (_Xty0))>::type _Obj1; typename aligned_union<_Len , _V0_t , _V1_t>::type _Obj2; } type; }; template<size_t _Len, class _Xty0 , class _V0_t , class _V1_t , class _V2_t> struct aligned_union<_Len, _Xty0 , _V0_t , _V1_t , _V2_t, _Nil , _Nil , _Nil> { typedef union { typename aligned_storage<_Len, (sizeof (_Get_align<_Xty0>) - 2 * sizeof (_Xty0))>::type _Obj1; typename aligned_union<_Len , _V0_t , _V1_t , _V2_t>::type _Obj2; } type; }; template<size_t _Len, class _Xty0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct aligned_union<_Len, _Xty0 , _V0_t , _V1_t , _V2_t , _V3_t, _Nil , _Nil> { typedef union { typename aligned_storage<_Len, (sizeof (_Get_align<_Xty0>) - 2 * sizeof (_Xty0))>::type _Obj1; typename aligned_union<_Len , _V0_t , _V1_t , _V2_t , _V3_t>::type _Obj2; } type; }; template<size_t _Len, class _Xty0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct aligned_union<_Len, _Xty0 , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t, _Nil> { typedef union { typename aligned_storage<_Len, (sizeof (_Get_align<_Xty0>) - 2 * sizeof (_Xty0))>::type _Obj1; typename aligned_union<_Len , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t>::type _Obj2; } type; };


template<class _Ty>
	struct underlying_type
	{	
	typedef __underlying_type(_Ty) type;
	};
 #line 1560 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\type_traits"

	
template<class _Ty>
	struct rank
		: integral_constant<size_t, 0>
	{	
	};

template<class _Ty, unsigned int _Ix>
	struct rank<_Ty[_Ix]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	
	};

template<class _Ty>
	struct rank<_Ty[]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	
	};

	
template<class _Ty, unsigned int _Nx>
	struct _Extent
		: integral_constant<size_t, 0>
	{	
	};

template<class _Ty, unsigned int _Ix>
	struct _Extent<_Ty[_Ix], 0>
		: integral_constant<size_t, _Ix>
	{	
	};

template<class _Ty, unsigned int _Nx, unsigned int _Ix>
	struct _Extent<_Ty[_Ix], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	
	};

template<class _Ty, unsigned int _Nx>
	struct _Extent<_Ty[], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	
	};

template<class _Ty, unsigned int _Nx = 0>
	struct extent
		: _Extent<_Ty, _Nx>
	{	
	};

	
template<class _Base, class _Der>
	struct is_base_of : _Cat_base<__is_base_of(_Base, _Der)>
	{	
	};

	
template<class _Ty>
	struct decay
	{	
	typedef typename remove_reference<_Ty>::type _Ty1;

	typedef typename _If<is_array<_Ty1>::value,
		typename remove_extent<_Ty1>::type *,
		typename _If<is_function<_Ty1>::value,
			typename add_pointer<_Ty1>::type,
			typename remove_cv<_Ty1>::type>::type>::type type;
	};

namespace tr1 {	
using ::std:: add_const;
using ::std:: add_cv;
using ::std:: add_pointer;
using ::std:: add_reference;	
using ::std:: add_volatile;
using ::std:: aligned_storage;
using ::std:: alignment_of;
using ::std:: conditional;
using ::std:: decay;
using ::std:: enable_if;
using ::std:: extent;
using ::std:: false_type;
using ::std:: has_nothrow_assign;	
using ::std:: has_nothrow_constructor;	
using ::std:: has_nothrow_copy;	
using ::std:: has_trivial_assign;
using ::std:: has_trivial_constructor;	
using ::std:: has_trivial_copy;	
using ::std:: has_trivial_destructor;	
using ::std:: has_virtual_destructor;
using ::std:: integral_constant;
using ::std:: is_abstract;
using ::std:: is_arithmetic;
using ::std:: is_array;
using ::std:: is_base_of;
using ::std:: is_class;
using ::std:: is_compound;
using ::std:: is_const;
using ::std:: is_convertible;
using ::std:: is_empty;
using ::std:: is_enum;
using ::std:: is_floating_point;
using ::std:: is_function;
using ::std:: is_fundamental;
using ::std:: is_integral;
using ::std:: is_member_function_pointer;
using ::std:: is_member_object_pointer;
using ::std:: is_member_pointer;
using ::std:: is_object;
using ::std:: is_pod;
using ::std:: is_pointer;
using ::std:: is_polymorphic;
using ::std:: is_reference;	
using ::std:: is_same;
using ::std:: is_scalar;
using ::std:: is_signed;
using ::std:: is_union;
using ::std:: is_unsigned;
using ::std:: is_void;
using ::std:: is_volatile;
using ::std:: make_signed;
using ::std:: make_unsigned;
using ::std:: rank;
using ::std:: remove_all_extents;
using ::std:: remove_const;
using ::std:: remove_cv;
using ::std:: remove_extent;
using ::std:: remove_pointer;
using ::std:: remove_reference;
using ::std:: remove_volatile;
using ::std:: true_type;
	}	

		
template<bool,
	class _Ty0,
	class _Ty1>
	struct _Common_type
	{	
	typedef void type;
	};

template<class _Ty0,
	class _Ty1>
	struct _Common_type<true, _Ty0, _Ty1>
	{	
	typedef decltype(_Always_false<_Ty0>::value
		? declval<_Ty0>() : declval<_Ty1>()) type;
	};

		
template<class, class = _Nil, class _V0_t = _Nil , class _V1_t = _Nil , class _V2_t = _Nil , class _V3_t = _Nil , class _V4_t = _Nil , class _V5_t = _Nil , class = _Nil>
	struct common_type;

template<class _Xty0>
	struct common_type<_Xty0, _Nil, _Nil , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil>
	{	
	typedef _Xty0 type;
	};














template<class _Xty0, class _Xty1  > struct common_type<_Xty0, _Xty1  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil> { typedef typename _Common_type<_Is_numeric<_Xty0>::value && _Is_numeric<_Xty1>::value, _Xty0, _Xty1>::type _Xty01; typedef typename common_type<_Xty01  >::type type; }; template<class _Xty0, class _Xty1 , class _V0_t> struct common_type<_Xty0, _Xty1 , _V0_t, _Nil , _Nil , _Nil , _Nil , _Nil> { typedef typename _Common_type<_Is_numeric<_Xty0>::value && _Is_numeric<_Xty1>::value, _Xty0, _Xty1>::type _Xty01; typedef typename common_type<_Xty01 , _V0_t>::type type; }; template<class _Xty0, class _Xty1 , class _V0_t , class _V1_t> struct common_type<_Xty0, _Xty1 , _V0_t , _V1_t, _Nil , _Nil , _Nil , _Nil> { typedef typename _Common_type<_Is_numeric<_Xty0>::value && _Is_numeric<_Xty1>::value, _Xty0, _Xty1>::type _Xty01; typedef typename common_type<_Xty01 , _V0_t , _V1_t>::type type; }; template<class _Xty0, class _Xty1 , class _V0_t , class _V1_t , class _V2_t> struct common_type<_Xty0, _Xty1 , _V0_t , _V1_t , _V2_t, _Nil , _Nil , _Nil> { typedef typename _Common_type<_Is_numeric<_Xty0>::value && _Is_numeric<_Xty1>::value, _Xty0, _Xty1>::type _Xty01; typedef typename common_type<_Xty01 , _V0_t , _V1_t , _V2_t>::type type; }; template<class _Xty0, class _Xty1 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct common_type<_Xty0, _Xty1 , _V0_t , _V1_t , _V2_t , _V3_t, _Nil , _Nil> { typedef typename _Common_type<_Is_numeric<_Xty0>::value && _Is_numeric<_Xty1>::value, _Xty0, _Xty1>::type _Xty01; typedef typename common_type<_Xty01 , _V0_t , _V1_t , _V2_t , _V3_t>::type type; }; template<class _Xty0, class _Xty1 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct common_type<_Xty0, _Xty1 , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t, _Nil> { typedef typename _Common_type<_Is_numeric<_Xty0>::value && _Is_numeric<_Xty1>::value, _Xty0, _Xty1>::type _Xty01; typedef typename common_type<_Xty01 , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t>::type type; };


	
template<class _Ty>
	class reference_wrapper;

template<class _Ty>
	struct _Unrefwrap_helper
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct _Unrefwrap_helper<reference_wrapper<_Ty> >
	{	
	typedef _Ty& type;
	};

template<class _Ty>
	struct _Unrefwrap
	{	
	typedef typename decay<_Ty>::type _Ty1;
	typedef typename _Unrefwrap_helper<_Ty1>::type type;
	};

	
template<class _Ty>
	struct identity
	{	
	typedef _Ty type;

	const _Ty& operator()(const _Ty& _Left) const
		{	
		return (_Left);
		}
	};

	
template<class _Ty> inline
	_Ty&& forward(typename remove_reference<_Ty>::type& _Arg)
	{	
	return (static_cast<_Ty&&>(_Arg));
	}

template<class _Ty> inline
	_Ty&& forward(typename remove_reference<_Ty>::type&& _Arg) throw ()
	{	
	static_assert(!is_lvalue_reference<_Ty>::value, "bad forward call");
	return (static_cast<_Ty&&>(_Arg));
	}

		
template<class _Ty> inline
	typename remove_reference<_Ty>::type&&
		move(_Ty&& _Arg) throw ()
	{	
	return ((typename remove_reference<_Ty>::type&&)_Arg);
	}

		
template<class _Ty> inline
	typename remove_reference<_Ty>::type&&
		_Move(_Ty&& _Arg) throw ()
	{	
	return ((typename remove_reference<_Ty>::type&&)_Arg);
	}

		
template<class _Ty> inline
	typename _If<!has_nothrow_move_constructor<_Ty>::value
		&& has_copy_constructor<_Ty>::value,
			const _Ty&, _Ty&&>::type
	move_if_noexcept(_Ty& _Arg) throw ()
	{	
	return (::std:: move(_Arg));
	}

 	
template<class _Ty> inline
	typename decay<_Ty>::type _Decay_copy(_Ty&& _Arg)
	{	
	return (::std:: forward<_Ty>(_Arg));
	}
}

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xrefwrap"

#pragma once






 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4180)

namespace std {
template<class _Ty>
	class reference_wrapper;

template<class, class = _Nil, class = _Nil, class = _Nil, class _V0_t = _Nil , class _V1_t = _Nil , class _V2_t = _Nil , class _V3_t = _Nil , class _V4_t = _Nil , class _V5_t = _Nil , class = _Nil>
	struct _Fun_class_base;

template<class _Ret,
	class _Farg0>
	struct _Fun_class_base<_Ret, _Farg0, _Nil, _Nil, _Nil , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil>
		: public unary_function<_Farg0, _Ret>
	{	
	typedef _Farg0 _Arg0;
	};

template<class _Ret,
	class _Farg0,
	class _Farg1>
	struct _Fun_class_base<_Ret, _Farg0, _Farg1, _Nil, _Nil , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil>
		: public binary_function<_Farg0, _Farg1, _Ret>
	{	
	typedef _Farg0 _Arg0;
	};













template<class _Ret, class _Farg0, class _Farg1, class _Farg2  > struct _Fun_class_base<_Ret, _Farg0, _Farg1, _Farg2  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil> { typedef _Farg0 _Arg0; }; template<class _Ret, class _Farg0, class _Farg1, class _Farg2 , class _V0_t> struct _Fun_class_base<_Ret, _Farg0, _Farg1, _Farg2 , _V0_t, _Nil , _Nil , _Nil , _Nil , _Nil> { typedef _Farg0 _Arg0; }; template<class _Ret, class _Farg0, class _Farg1, class _Farg2 , class _V0_t , class _V1_t> struct _Fun_class_base<_Ret, _Farg0, _Farg1, _Farg2 , _V0_t , _V1_t, _Nil , _Nil , _Nil , _Nil> { typedef _Farg0 _Arg0; }; template<class _Ret, class _Farg0, class _Farg1, class _Farg2 , class _V0_t , class _V1_t , class _V2_t> struct _Fun_class_base<_Ret, _Farg0, _Farg1, _Farg2 , _V0_t , _V1_t , _V2_t, _Nil , _Nil , _Nil> { typedef _Farg0 _Arg0; }; template<class _Ret, class _Farg0, class _Farg1, class _Farg2 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Fun_class_base<_Ret, _Farg0, _Farg1, _Farg2 , _V0_t , _V1_t , _V2_t , _V3_t, _Nil , _Nil> { typedef _Farg0 _Arg0; }; template<class _Ret, class _Farg0, class _Farg1, class _Farg2 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Fun_class_base<_Ret, _Farg0, _Farg1, _Farg2 , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t, _Nil> { typedef _Farg0 _Arg0; };



		
template<class _Fty>
	struct _Get_callable_type
	{	
	template<class _Uty>
		static auto _Fn(int)
			-> typename decltype(::std:: declval<_Uty>()());

	template<class _Uty>
		static auto _Fn(_Wrap_int)
			-> _Fty;

	typedef decltype(_Fn<_Fty>(0)) type;
	};

template<bool,
	class _Fty, class = _Nil, class _V0_t = _Nil , class _V1_t = _Nil , class _V2_t = _Nil , class _V3_t = _Nil , class _V4_t = _Nil , class _V5_t = _Nil , class = _Nil>
	struct _Result_type;

template<class _Fty>
	struct _Result_type<false, _Fty, _Nil, _Nil , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil>
	{	
	typedef typename _Get_callable_type<_Fty>::type type;
	};


















template<class _Fty  > struct _Result_type<true, _Fty  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef typename _Fty::result_type type; }; template<class _Fty, class _Xarg0  > struct _Result_type<false, _Fty, _Xarg0  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil> { typedef decltype(::std:: declval<_Fty>()( ::std:: declval<_Xarg0>()  )) type; }; template<class _Fty , class _V0_t> struct _Result_type<true, _Fty , _V0_t, _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef typename _Fty::result_type type; }; template<class _Fty, class _Xarg0 , class _V0_t> struct _Result_type<false, _Fty, _Xarg0 , _V0_t, _Nil , _Nil , _Nil , _Nil , _Nil> { typedef decltype(::std:: declval<_Fty>()( ::std:: declval<_Xarg0>() , ::std:: declval<_V0_t>())) type; }; template<class _Fty , class _V0_t , class _V1_t> struct _Result_type<true, _Fty , _V0_t , _V1_t, _Nil , _Nil , _Nil , _Nil, _Nil> { typedef typename _Fty::result_type type; }; template<class _Fty, class _Xarg0 , class _V0_t , class _V1_t> struct _Result_type<false, _Fty, _Xarg0 , _V0_t , _V1_t, _Nil , _Nil , _Nil , _Nil> { typedef decltype(::std:: declval<_Fty>()( ::std:: declval<_Xarg0>() , ::std:: declval<_V0_t>() , ::std:: declval<_V1_t>())) type; }; template<class _Fty , class _V0_t , class _V1_t , class _V2_t> struct _Result_type<true, _Fty , _V0_t , _V1_t , _V2_t, _Nil , _Nil , _Nil, _Nil> { typedef typename _Fty::result_type type; }; template<class _Fty, class _Xarg0 , class _V0_t , class _V1_t , class _V2_t> struct _Result_type<false, _Fty, _Xarg0 , _V0_t , _V1_t , _V2_t, _Nil , _Nil , _Nil> { typedef decltype(::std:: declval<_Fty>()( ::std:: declval<_Xarg0>() , ::std:: declval<_V0_t>() , ::std:: declval<_V1_t>() , ::std:: declval<_V2_t>())) type; }; template<class _Fty , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Result_type<true, _Fty , _V0_t , _V1_t , _V2_t , _V3_t, _Nil , _Nil, _Nil> { typedef typename _Fty::result_type type; }; template<class _Fty, class _Xarg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Result_type<false, _Fty, _Xarg0 , _V0_t , _V1_t , _V2_t , _V3_t, _Nil , _Nil> { typedef decltype(::std:: declval<_Fty>()( ::std:: declval<_Xarg0>() , ::std:: declval<_V0_t>() , ::std:: declval<_V1_t>() , ::std:: declval<_V2_t>() , ::std:: declval<_V3_t>())) type; }; template<class _Fty , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Result_type<true, _Fty , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t, _Nil, _Nil> { typedef typename _Fty::result_type type; }; template<class _Fty, class _Xarg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Result_type<false, _Fty, _Xarg0 , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t, _Nil> { typedef decltype(::std:: declval<_Fty>()( ::std:: declval<_Xarg0>() , ::std:: declval<_V0_t>() , ::std:: declval<_V1_t>() , ::std:: declval<_V2_t>() , ::std:: declval<_V3_t>() , ::std:: declval<_V4_t>())) type; };


template<class _Fty, class _V0_t = _Nil , class _V1_t = _Nil , class _V2_t = _Nil , class _V3_t = _Nil , class _V4_t = _Nil , class _V5_t = _Nil , class = _Nil>
	struct _Result_ofx;

template<class _Fty, class _V0_t = _Nil , class _V1_t = _Nil , class _V2_t = _Nil , class _V3_t = _Nil , class _V4_t = _Nil , class _V5_t = _Nil , class = _Nil,
	class _Obj = _Nil,
	class _Xarg0 = _Nil>
	struct _Result_of
	{	
	typedef typename _Result_ofx<_Fty, _V0_t , _V1_t , _V2_t , _V3_t , _V4_t , _V5_t>::type type;
	};












template<class _Fty  > struct _Result_ofx<_Fty  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil> { static const bool value = _Has_result_type<_Fty>::type::value; typedef typename _Result_type< _Result_ofx<_Fty  >::value, _Fty  >::type type; }; template<class _Fty , class _V0_t> struct _Result_ofx<_Fty , _V0_t, _Nil , _Nil , _Nil , _Nil , _Nil> { static const bool value = _Has_result_type<_Fty>::type::value; typedef typename _Result_type< _Result_ofx<_Fty , _V0_t>::value, _Fty , _V0_t>::type type; }; template<class _Fty , class _V0_t , class _V1_t> struct _Result_ofx<_Fty , _V0_t , _V1_t, _Nil , _Nil , _Nil , _Nil> { static const bool value = _Has_result_type<_Fty>::type::value; typedef typename _Result_type< _Result_ofx<_Fty , _V0_t , _V1_t>::value, _Fty , _V0_t , _V1_t>::type type; }; template<class _Fty , class _V0_t , class _V1_t , class _V2_t> struct _Result_ofx<_Fty , _V0_t , _V1_t , _V2_t, _Nil , _Nil , _Nil> { static const bool value = _Has_result_type<_Fty>::type::value; typedef typename _Result_type< _Result_ofx<_Fty , _V0_t , _V1_t , _V2_t>::value, _Fty , _V0_t , _V1_t , _V2_t>::type type; }; template<class _Fty , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Result_ofx<_Fty , _V0_t , _V1_t , _V2_t , _V3_t, _Nil , _Nil> { static const bool value = _Has_result_type<_Fty>::type::value; typedef typename _Result_type< _Result_ofx<_Fty , _V0_t , _V1_t , _V2_t , _V3_t>::value, _Fty , _V0_t , _V1_t , _V2_t , _V3_t>::type type; }; template<class _Fty , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Result_ofx<_Fty , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t, _Nil> { static const bool value = _Has_result_type<_Fty>::type::value; typedef typename _Result_type< _Result_ofx<_Fty , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t>::value, _Fty , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t>::type type; };
































template<class _Ret    > struct _Result_of<_Ret (__cdecl &)()  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret    > struct _Result_of<_Ret (__cdecl *)()  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret    > struct _Result_of<_Ret (__cdecl * const)()  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret , class _V0_t , class _Vx0_t> struct _Result_of<_Ret (__cdecl &)(_V0_t) , _Vx0_t, _Nil , _Nil , _Nil , _Nil , _Nil, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret , class _V0_t , class _Vx0_t> struct _Result_of<_Ret (__cdecl *)(_V0_t) , _Vx0_t, _Nil , _Nil , _Nil , _Nil , _Nil, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret , class _V0_t , class _Vx0_t> struct _Result_of<_Ret (__cdecl * const)(_V0_t) , _Vx0_t, _Nil , _Nil , _Nil , _Nil , _Nil, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret , class _V0_t , class _V1_t , class _Vx0_t , class _Vx1_t> struct _Result_of<_Ret (__cdecl &)(_V0_t , _V1_t) , _Vx0_t , _Vx1_t, _Nil , _Nil , _Nil , _Nil, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret , class _V0_t , class _V1_t , class _Vx0_t , class _Vx1_t> struct _Result_of<_Ret (__cdecl *)(_V0_t , _V1_t) , _Vx0_t , _Vx1_t, _Nil , _Nil , _Nil , _Nil, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret , class _V0_t , class _V1_t , class _Vx0_t , class _Vx1_t> struct _Result_of<_Ret (__cdecl * const)(_V0_t , _V1_t) , _Vx0_t , _Vx1_t, _Nil , _Nil , _Nil , _Nil, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _Vx0_t , class _Vx1_t , class _Vx2_t> struct _Result_of<_Ret (__cdecl &)(_V0_t , _V1_t , _V2_t) , _Vx0_t , _Vx1_t , _Vx2_t, _Nil , _Nil , _Nil, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _Vx0_t , class _Vx1_t , class _Vx2_t> struct _Result_of<_Ret (__cdecl *)(_V0_t , _V1_t , _V2_t) , _Vx0_t , _Vx1_t , _Vx2_t, _Nil , _Nil , _Nil, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _Vx0_t , class _Vx1_t , class _Vx2_t> struct _Result_of<_Ret (__cdecl * const)(_V0_t , _V1_t , _V2_t) , _Vx0_t , _Vx1_t , _Vx2_t, _Nil , _Nil , _Nil, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t> struct _Result_of<_Ret (__cdecl &)(_V0_t , _V1_t , _V2_t , _V3_t) , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t, _Nil , _Nil, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t> struct _Result_of<_Ret (__cdecl *)(_V0_t , _V1_t , _V2_t , _V3_t) , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t, _Nil , _Nil, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t> struct _Result_of<_Ret (__cdecl * const)(_V0_t , _V1_t , _V2_t , _V3_t) , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t, _Nil , _Nil, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t , class _Vx4_t> struct _Result_of<_Ret (__cdecl &)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t , _Vx4_t, _Nil, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t , class _Vx4_t> struct _Result_of<_Ret (__cdecl *)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t , _Vx4_t, _Nil, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t , class _Vx4_t> struct _Result_of<_Ret (__cdecl * const)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t , _Vx4_t, _Nil, _Nil, _Nil> { typedef _Ret type; };




template<class _Ret,
	class _Ty,
	class _Obj>
	struct _Result_of<_Ret _Ty::*, _Obj, _Nil, _Nil , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil>
	{	
		
	typedef _Ret& type;
	};

template<class _Ret,
	class _Ty,
	class _Obj>
	struct _Result_of<_Ret _Ty::* const, _Obj, _Nil, _Nil , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil>
	{	
		
	typedef _Ret& type;
	};

template<class _Ret,
	class _Ty,
	class _Obj>
	struct _Result_of<_Ret _Ty::*, const _Obj, _Nil, _Nil , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil>
	{	
		
	typedef const _Ret& type;
	};

template<class _Ret,
	class _Ty,
	class _Obj>
	struct _Result_of<_Ret _Ty::* const, const _Obj, _Nil, _Nil , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil>
	{	
		
	typedef const _Ret& type;
	};




























template<class _Ret, class _Ty, class _Tyx    > struct _Result_of<_Ret (__thiscall _Ty::*)() , _Tyx&  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx    > struct _Result_of<_Ret (__thiscall _Ty::* const)() , _Tyx&  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _Vx0_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t) , _Tyx& , _Vx0_t, _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _Vx0_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t) , _Tyx& , _Vx0_t, _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _Vx0_t , class _Vx1_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t , _V1_t) , _Tyx& , _Vx0_t , _Vx1_t, _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _Vx0_t , class _Vx1_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t , _V1_t) , _Tyx& , _Vx0_t , _Vx1_t, _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _Vx0_t , class _Vx1_t , class _Vx2_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t , _V1_t , _V2_t) , _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t, _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _Vx0_t , class _Vx1_t , class _Vx2_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t , _V1_t , _V2_t) , _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t, _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t , _V1_t , _V2_t , _V3_t) , _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t, _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t , _V1_t , _V2_t , _V3_t) , _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t, _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t , class _Vx4_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) , _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t , _Vx4_t, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t , class _Vx4_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) , _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t , _Vx4_t, _Nil, _Nil> { typedef _Ret type; };
template<class _Ret, class _Ty, class _Tyx    > struct _Result_of<_Ret (__thiscall _Ty::*)() const, _Tyx&  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx    > struct _Result_of<_Ret (__thiscall _Ty::* const)() const, _Tyx&  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _Vx0_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t) const, _Tyx& , _Vx0_t, _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _Vx0_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t) const, _Tyx& , _Vx0_t, _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _Vx0_t , class _Vx1_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t , _V1_t) const, _Tyx& , _Vx0_t , _Vx1_t, _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _Vx0_t , class _Vx1_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t , _V1_t) const, _Tyx& , _Vx0_t , _Vx1_t, _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _Vx0_t , class _Vx1_t , class _Vx2_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t , _V1_t , _V2_t) const, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t, _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _Vx0_t , class _Vx1_t , class _Vx2_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t , _V1_t , _V2_t) const, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t, _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t , _V1_t , _V2_t , _V3_t) const, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t, _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t , _V1_t , _V2_t , _V3_t) const, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t, _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t , class _Vx4_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) const, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t , _Vx4_t, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t , class _Vx4_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) const, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t , _Vx4_t, _Nil, _Nil> { typedef _Ret type; };
template<class _Ret, class _Ty, class _Tyx    > struct _Result_of<_Ret (__thiscall _Ty::*)() volatile, _Tyx&  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx    > struct _Result_of<_Ret (__thiscall _Ty::* const)() volatile, _Tyx&  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _Vx0_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t) volatile, _Tyx& , _Vx0_t, _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _Vx0_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t) volatile, _Tyx& , _Vx0_t, _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _Vx0_t , class _Vx1_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t , _V1_t) volatile, _Tyx& , _Vx0_t , _Vx1_t, _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _Vx0_t , class _Vx1_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t , _V1_t) volatile, _Tyx& , _Vx0_t , _Vx1_t, _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _Vx0_t , class _Vx1_t , class _Vx2_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t , _V1_t , _V2_t) volatile, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t, _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _Vx0_t , class _Vx1_t , class _Vx2_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t , _V1_t , _V2_t) volatile, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t, _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t , _V1_t , _V2_t , _V3_t) volatile, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t, _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t , _V1_t , _V2_t , _V3_t) volatile, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t, _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t , class _Vx4_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) volatile, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t , _Vx4_t, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t , class _Vx4_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) volatile, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t , _Vx4_t, _Nil, _Nil> { typedef _Ret type; };
template<class _Ret, class _Ty, class _Tyx    > struct _Result_of<_Ret (__thiscall _Ty::*)() const volatile, _Tyx&  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx    > struct _Result_of<_Ret (__thiscall _Ty::* const)() const volatile, _Tyx&  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _Vx0_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t) const volatile, _Tyx& , _Vx0_t, _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _Vx0_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t) const volatile, _Tyx& , _Vx0_t, _Nil , _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _Vx0_t , class _Vx1_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t , _V1_t) const volatile, _Tyx& , _Vx0_t , _Vx1_t, _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _Vx0_t , class _Vx1_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t , _V1_t) const volatile, _Tyx& , _Vx0_t , _Vx1_t, _Nil , _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _Vx0_t , class _Vx1_t , class _Vx2_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t , _V1_t , _V2_t) const volatile, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t, _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _Vx0_t , class _Vx1_t , class _Vx2_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t , _V1_t , _V2_t) const volatile, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t, _Nil , _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t , _V1_t , _V2_t , _V3_t) const volatile, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t, _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t , _V1_t , _V2_t , _V3_t) const volatile, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t, _Nil , _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t , class _Vx4_t> struct _Result_of<_Ret (__thiscall _Ty::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) const volatile, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t , _Vx4_t, _Nil, _Nil> { typedef _Ret type; }; template<class _Ret, class _Ty, class _Tyx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t , class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t , class _Vx4_t> struct _Result_of<_Ret (__thiscall _Ty::* const)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) const volatile, _Tyx& , _Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t , _Vx4_t, _Nil, _Nil> { typedef _Ret type; };




template<class _Fty>
	struct _Result_of0;











template<class _Fty  > struct _Result_of0<_Fty  ()> { typedef typename _Result_of<_Fty  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil, _Nil, _Nil>::type type; }; template<class _Fty , class _V0_t> struct _Result_of0<_Fty  (_V0_t)> { typedef typename _Result_of<_Fty , typename remove_reference<_V0_t>::type&, _Nil , _Nil , _Nil , _Nil , _Nil, _Nil, _Nil>::type type; }; template<class _Fty , class _V0_t , class _V1_t> struct _Result_of0<_Fty  (_V0_t , _V1_t)> { typedef typename _Result_of<_Fty , typename remove_reference<_V0_t>::type& , typename remove_reference<_V1_t>::type&, _Nil , _Nil , _Nil , _Nil, _Nil, _Nil>::type type; }; template<class _Fty , class _V0_t , class _V1_t , class _V2_t> struct _Result_of0<_Fty  (_V0_t , _V1_t , _V2_t)> { typedef typename _Result_of<_Fty , typename remove_reference<_V0_t>::type& , typename remove_reference<_V1_t>::type& , typename remove_reference<_V2_t>::type&, _Nil , _Nil , _Nil, _Nil, _Nil>::type type; }; template<class _Fty , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Result_of0<_Fty  (_V0_t , _V1_t , _V2_t , _V3_t)> { typedef typename _Result_of<_Fty , typename remove_reference<_V0_t>::type& , typename remove_reference<_V1_t>::type& , typename remove_reference<_V2_t>::type& , typename remove_reference<_V3_t>::type&, _Nil , _Nil, _Nil, _Nil>::type type; }; template<class _Fty , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Result_of0<_Fty  (_V0_t , _V1_t , _V2_t , _V3_t , _V4_t)> { typedef typename _Result_of<_Fty , typename remove_reference<_V0_t>::type& , typename remove_reference<_V1_t>::type& , typename remove_reference<_V2_t>::type& , typename remove_reference<_V3_t>::type& , typename remove_reference<_V4_t>::type&, _Nil, _Nil, _Nil>::type type; };


	
template<class _Fty>
	struct result_of
	{	
	typedef typename _Result_of0<_Fty>::type type;
	};



	
template<class _Ret,
	class _Arg0>
	struct _Pmd_caller
	{	
	template<class _Pmd,
		class _Farg0>
		static _Ret _Call_pmd(_Pmd _Pm, _Farg0&& _Fx0, true_type)
		{	
		return ((_Ret)(_Fx0.*_Pm));
		}

	template<class _Pmd,
		class _Farg0>
		static _Ret _Call_pmd(_Pmd _Pm, _Farg0&& _Fx0, false_type)
		{	
		return ((*_Fx0).*_Pm);
		}

	template<class _Pmd,
		class _Farg0>
		static _Ret _Apply_pmd(_Pmd _Pm, _Farg0&& _Fx0)
		{	
		typedef typename remove_reference<_Arg0>::type _Arg0_bare;
		typedef typename remove_reference<_Farg0>::type _Farg0_bare;
		typedef _Cat_base<is_same<_Arg0_bare, _Farg0_bare>::value
			|| is_base_of<_Arg0_bare, _Farg0_bare>::value
				&& is_same<typename add_reference<_Farg0_bare>::type,
					_Farg0>::value> _Is_obj;

		return (_Call_pmd<_Pmd, _Farg0&&>(_Pm,
			::std:: forward<_Farg0>(_Fx0), _Is_obj()));
		}
	};

	
template<class _Ty,
	bool _Indirect>
	struct _Callable_base;

template<class _Ty>
	struct _Callable_base<_Ty, false>
	{	
	enum {_EEN_INDIRECT = 0};	
	typedef _Ty _MyTy;
	typedef const _Ty& _MyCnstTy;

	_Callable_base(const _Callable_base& _Right)
		: _Object(_Right._Object)
		{	
		}

	_Callable_base(_Callable_base&& _Right)
		: _Object(::std:: forward<_Ty>(_Right._Object))
		{	
		}

	template<class _Ty2>
		_Callable_base(_Ty2&& _Val)
		: _Object(::std:: forward<_Ty2>(_Val))
		{	
		}

	const _Ty& _Get() const
		{	
		return (_Object);
		}

	_Ty& _Get()
		{	
		return (_Object);
		}

private:
	_Callable_base& operator=(const _Callable_base&);

	_Ty _Object;
};

template<class _Ty>
	struct _Callable_base<_Ty, true>
	{	
		
	enum {_EEN_INDIRECT = 1};	
	typedef _Ty _MyTy;
	typedef _Ty& _MyCnstTy;

	_Callable_base(_Ty& _Val)
		: _Ptr(::std:: addressof(_Val))
		{	
		}

	_MyCnstTy _Get() const
		{	
		return (*_Ptr);
		}

	_Ty& _Get()
		{	
		return (*_Ptr);
		}

	void _Reset(_Ty& _Val)
		{	
		_Ptr = ::std:: addressof(_Val);
		}

private:
	_Ty *_Ptr;
};

	
template<class _Ty,
	class _Memty,
	bool _Indirect = false>
	struct _Callable_pmd
		: _Callable_base<_Ty, _Indirect>
	{	
	_Callable_pmd(const _Callable_pmd& _Right)
		: _Callable_base<_Ty, _Indirect>(_Right._Get())
		{	
		}

	_Callable_pmd(_Ty& _Val)
		: _Callable_base<_Ty, _Indirect>(_Val)
		{	
		}

	template<class _Ret,
		class _Arg0>
		_Ret _ApplyX(_Arg0&& _A0) const
		{	
		return (_Pmd_caller<_Ret, _Memty>::
			_Apply_pmd(this->_Get(), ::std:: forward<_Arg0>(_A0)));
		}
	};

	
template<class _Ty,
	bool _Indirect = false>
	struct _Callable_obj
		: _Callable_base<_Ty, _Indirect>
	{	
	typedef _Callable_base<_Ty, _Indirect> _Mybase;

	_Callable_obj(_Callable_obj& _Right)
		: _Mybase(_Right._Get())
		{	
		}

	_Callable_obj(_Callable_obj&& _Right)
		: _Mybase(::std:: forward<_Ty>(_Right._Get()))
		{	
		}

	template<class _Ty2>
		_Callable_obj(_Ty2&& _Val)
		: _Mybase(::std:: forward<_Ty2>(_Val))
		{	
		}














template<class _Ret  > _Ret _ApplyX() { return (this->_Get()()); } template<class _Ret  > _Ret _ApplyX() const { return (this->_Get()()); } template<class _Ret , class _V0_t> _Ret _ApplyX(_V0_t&& _V0) { return (this->_Get()(::std:: forward<_V0_t>(_V0))); } template<class _Ret , class _V0_t> _Ret _ApplyX(_V0_t&& _V0) const { return (this->_Get()(::std:: forward<_V0_t>(_V0))); } template<class _Ret , class _V0_t , class _V1_t> _Ret _ApplyX(_V0_t&& _V0 , _V1_t&& _V1) { return (this->_Get()(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1))); } template<class _Ret , class _V0_t , class _V1_t> _Ret _ApplyX(_V0_t&& _V0 , _V1_t&& _V1) const { return (this->_Get()(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1))); } template<class _Ret , class _V0_t , class _V1_t , class _V2_t> _Ret _ApplyX(_V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2) { return (this->_Get()(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2))); } template<class _Ret , class _V0_t , class _V1_t , class _V2_t> _Ret _ApplyX(_V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2) const { return (this->_Get()(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2))); } template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _V3_t> _Ret _ApplyX(_V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3) { return (this->_Get()(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3))); } template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _V3_t> _Ret _ApplyX(_V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3) const { return (this->_Get()(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3))); } template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> _Ret _ApplyX(_V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3 , _V4_t&& _V4) { return (this->_Get()(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3) , ::std:: forward<_V4_t>(_V4))); } template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> _Ret _ApplyX(_V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3 , _V4_t&& _V4) const { return (this->_Get()(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3) , ::std:: forward<_V4_t>(_V4))); }

	};

	
template<class _Ret,
	class _Arg0>
	struct _Pmf_caller
	{	
	typedef _Arg0 _Funobj;





















template<class _Pmf, class _Farg0  > static _Ret _Call_pmf(_Pmf _Pm, _Farg0 _Fx0, true_type  ) { typedef typename _Copy_cv<_Arg0, _Farg0>::type _Funobj_cv; return (((_Funobj_cv)_Fx0.*_Pm)()); } template<class _Pmf, class _Farg0  > static _Ret _Call_pmf(_Pmf _Pm, _Farg0&& _Fx0, false_type  ) { return (((*_Fx0).*_Pm)()); } template<class _Pmf, class _Farg0 , class _V0_t> static _Ret _Call_pmf(_Pmf _Pm, _Farg0 _Fx0, true_type , _V0_t&& _V0) { typedef typename _Copy_cv<_Arg0, _Farg0>::type _Funobj_cv; return (((_Funobj_cv)_Fx0.*_Pm)(::std:: forward<_V0_t>(_V0))); } template<class _Pmf, class _Farg0 , class _V0_t> static _Ret _Call_pmf(_Pmf _Pm, _Farg0&& _Fx0, false_type , _V0_t&& _V0) { return (((*_Fx0).*_Pm)(::std:: forward<_V0_t>(_V0))); } template<class _Pmf, class _Farg0 , class _V0_t , class _V1_t> static _Ret _Call_pmf(_Pmf _Pm, _Farg0 _Fx0, true_type , _V0_t&& _V0 , _V1_t&& _V1) { typedef typename _Copy_cv<_Arg0, _Farg0>::type _Funobj_cv; return (((_Funobj_cv)_Fx0.*_Pm)(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1))); } template<class _Pmf, class _Farg0 , class _V0_t , class _V1_t> static _Ret _Call_pmf(_Pmf _Pm, _Farg0&& _Fx0, false_type , _V0_t&& _V0 , _V1_t&& _V1) { return (((*_Fx0).*_Pm)(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1))); } template<class _Pmf, class _Farg0 , class _V0_t , class _V1_t , class _V2_t> static _Ret _Call_pmf(_Pmf _Pm, _Farg0 _Fx0, true_type , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2) { typedef typename _Copy_cv<_Arg0, _Farg0>::type _Funobj_cv; return (((_Funobj_cv)_Fx0.*_Pm)(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2))); } template<class _Pmf, class _Farg0 , class _V0_t , class _V1_t , class _V2_t> static _Ret _Call_pmf(_Pmf _Pm, _Farg0&& _Fx0, false_type , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2) { return (((*_Fx0).*_Pm)(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2))); } template<class _Pmf, class _Farg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> static _Ret _Call_pmf(_Pmf _Pm, _Farg0 _Fx0, true_type , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3) { typedef typename _Copy_cv<_Arg0, _Farg0>::type _Funobj_cv; return (((_Funobj_cv)_Fx0.*_Pm)(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3))); } template<class _Pmf, class _Farg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> static _Ret _Call_pmf(_Pmf _Pm, _Farg0&& _Fx0, false_type , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3) { return (((*_Fx0).*_Pm)(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3))); } template<class _Pmf, class _Farg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> static _Ret _Call_pmf(_Pmf _Pm, _Farg0 _Fx0, true_type , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3 , _V4_t&& _V4) { typedef typename _Copy_cv<_Arg0, _Farg0>::type _Funobj_cv; return (((_Funobj_cv)_Fx0.*_Pm)(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3) , ::std:: forward<_V4_t>(_V4))); } template<class _Pmf, class _Farg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> static _Ret _Call_pmf(_Pmf _Pm, _Farg0&& _Fx0, false_type , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3 , _V4_t&& _V4) { return (((*_Fx0).*_Pm)(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3) , ::std:: forward<_V4_t>(_V4))); }





















template<class _Pmf, class _Farg0  > static _Ret _Apply_pmf(_Pmf _Pm, _Farg0&& _Fx0  ) { typedef typename remove_reference<_Arg0>::type _Arg0_bare0; typedef typename remove_cv<_Arg0_bare0>::type _Arg0_bare; typedef typename remove_reference<_Farg0>::type _Farg0_bare; typedef _Cat_base<is_same<_Arg0_bare, _Farg0_bare>::value || is_base_of<_Arg0_bare, _Farg0_bare>::value && is_same<typename add_reference<_Farg0_bare>::type, _Farg0>::value> _Is_obj; return (_Call_pmf<_Pmf, _Farg0&&  >( _Pm, ::std:: forward<_Farg0>(_Fx0), _Is_obj()  )); } template<class _Pmf, class _Farg0 , class _V0_t> static _Ret _Apply_pmf(_Pmf _Pm, _Farg0&& _Fx0 , _V0_t&& _V0) { typedef typename remove_reference<_Arg0>::type _Arg0_bare0; typedef typename remove_cv<_Arg0_bare0>::type _Arg0_bare; typedef typename remove_reference<_Farg0>::type _Farg0_bare; typedef _Cat_base<is_same<_Arg0_bare, _Farg0_bare>::value || is_base_of<_Arg0_bare, _Farg0_bare>::value && is_same<typename add_reference<_Farg0_bare>::type, _Farg0>::value> _Is_obj; return (_Call_pmf<_Pmf, _Farg0&& , _V0_t&&>( _Pm, ::std:: forward<_Farg0>(_Fx0), _Is_obj() , ::std:: forward<_V0_t>(_V0))); } template<class _Pmf, class _Farg0 , class _V0_t , class _V1_t> static _Ret _Apply_pmf(_Pmf _Pm, _Farg0&& _Fx0 , _V0_t&& _V0 , _V1_t&& _V1) { typedef typename remove_reference<_Arg0>::type _Arg0_bare0; typedef typename remove_cv<_Arg0_bare0>::type _Arg0_bare; typedef typename remove_reference<_Farg0>::type _Farg0_bare; typedef _Cat_base<is_same<_Arg0_bare, _Farg0_bare>::value || is_base_of<_Arg0_bare, _Farg0_bare>::value && is_same<typename add_reference<_Farg0_bare>::type, _Farg0>::value> _Is_obj; return (_Call_pmf<_Pmf, _Farg0&& , _V0_t&& , _V1_t&&>( _Pm, ::std:: forward<_Farg0>(_Fx0), _Is_obj() , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1))); } template<class _Pmf, class _Farg0 , class _V0_t , class _V1_t , class _V2_t> static _Ret _Apply_pmf(_Pmf _Pm, _Farg0&& _Fx0 , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2) { typedef typename remove_reference<_Arg0>::type _Arg0_bare0; typedef typename remove_cv<_Arg0_bare0>::type _Arg0_bare; typedef typename remove_reference<_Farg0>::type _Farg0_bare; typedef _Cat_base<is_same<_Arg0_bare, _Farg0_bare>::value || is_base_of<_Arg0_bare, _Farg0_bare>::value && is_same<typename add_reference<_Farg0_bare>::type, _Farg0>::value> _Is_obj; return (_Call_pmf<_Pmf, _Farg0&& , _V0_t&& , _V1_t&& , _V2_t&&>( _Pm, ::std:: forward<_Farg0>(_Fx0), _Is_obj() , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2))); } template<class _Pmf, class _Farg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> static _Ret _Apply_pmf(_Pmf _Pm, _Farg0&& _Fx0 , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3) { typedef typename remove_reference<_Arg0>::type _Arg0_bare0; typedef typename remove_cv<_Arg0_bare0>::type _Arg0_bare; typedef typename remove_reference<_Farg0>::type _Farg0_bare; typedef _Cat_base<is_same<_Arg0_bare, _Farg0_bare>::value || is_base_of<_Arg0_bare, _Farg0_bare>::value && is_same<typename add_reference<_Farg0_bare>::type, _Farg0>::value> _Is_obj; return (_Call_pmf<_Pmf, _Farg0&& , _V0_t&& , _V1_t&& , _V2_t&& , _V3_t&&>( _Pm, ::std:: forward<_Farg0>(_Fx0), _Is_obj() , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3))); } template<class _Pmf, class _Farg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> static _Ret _Apply_pmf(_Pmf _Pm, _Farg0&& _Fx0 , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3 , _V4_t&& _V4) { typedef typename remove_reference<_Arg0>::type _Arg0_bare0; typedef typename remove_cv<_Arg0_bare0>::type _Arg0_bare; typedef typename remove_reference<_Farg0>::type _Farg0_bare; typedef _Cat_base<is_same<_Arg0_bare, _Farg0_bare>::value || is_base_of<_Arg0_bare, _Farg0_bare>::value && is_same<typename add_reference<_Farg0_bare>::type, _Farg0>::value> _Is_obj; return (_Call_pmf<_Pmf, _Farg0&& , _V0_t&& , _V1_t&& , _V2_t&& , _V3_t&& , _V4_t&&>( _Pm, ::std:: forward<_Farg0>(_Fx0), _Is_obj() , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3) , ::std:: forward<_V4_t>(_V4))); }

	};

	
template<class _Ty,
	class _Memty,
	bool _Indirect = false>
	struct _Callable_pmf
		: _Callable_base<_Ty, _Indirect>
	{	
	_Callable_pmf(const _Callable_pmf& _Right)
		: _Callable_base<_Ty, _Indirect>(_Right._Get())
		{	
		}

	_Callable_pmf(_Ty& _Val)
		: _Callable_base<_Ty, _Indirect>(_Val)
		{	
		}












template<class _Ret, class _Xarg0  > _Ret _ApplyX(_Xarg0&& _Arg0  ) const { return (_Pmf_caller<_Ret, _Memty>:: _Apply_pmf(this->_Get(), ::std:: forward<_Xarg0>(_Arg0)  )); } template<class _Ret, class _Xarg0 , class _V0_t> _Ret _ApplyX(_Xarg0&& _Arg0 , _V0_t&& _V0) const { return (_Pmf_caller<_Ret, _Memty>:: _Apply_pmf(this->_Get(), ::std:: forward<_Xarg0>(_Arg0) , ::std:: forward<_V0_t>(_V0))); } template<class _Ret, class _Xarg0 , class _V0_t , class _V1_t> _Ret _ApplyX(_Xarg0&& _Arg0 , _V0_t&& _V0 , _V1_t&& _V1) const { return (_Pmf_caller<_Ret, _Memty>:: _Apply_pmf(this->_Get(), ::std:: forward<_Xarg0>(_Arg0) , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1))); } template<class _Ret, class _Xarg0 , class _V0_t , class _V1_t , class _V2_t> _Ret _ApplyX(_Xarg0&& _Arg0 , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2) const { return (_Pmf_caller<_Ret, _Memty>:: _Apply_pmf(this->_Get(), ::std:: forward<_Xarg0>(_Arg0) , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2))); } template<class _Ret, class _Xarg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> _Ret _ApplyX(_Xarg0&& _Arg0 , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3) const { return (_Pmf_caller<_Ret, _Memty>:: _Apply_pmf(this->_Get(), ::std:: forward<_Xarg0>(_Arg0) , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3))); } template<class _Ret, class _Xarg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> _Ret _ApplyX(_Xarg0&& _Arg0 , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3 , _V4_t&& _V4) const { return (_Pmf_caller<_Ret, _Memty>:: _Apply_pmf(this->_Get(), ::std:: forward<_Xarg0>(_Arg0) , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3) , ::std:: forward<_V4_t>(_V4))); }

	};

	
template<class _Ty,
	bool _Indirect = false>
	struct _Callable_fun
		: _Callable_base<_Ty, _Indirect>
	{	
	_Callable_fun(const _Callable_fun& _Right)
		: _Callable_base<_Ty, _Indirect>(_Right._Get())
		{	
		}

	_Callable_fun(_Ty& _Val)
		: _Callable_base<_Ty, _Indirect>(_Val)
		{	
		}









template<class _Ret  > _Ret _ApplyX() const { return (this->_Get()()); } template<class _Ret , class _V0_t> _Ret _ApplyX(_V0_t&& _V0) const { return (this->_Get()(::std:: forward<_V0_t>(_V0))); } template<class _Ret , class _V0_t , class _V1_t> _Ret _ApplyX(_V0_t&& _V0 , _V1_t&& _V1) const { return (this->_Get()(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1))); } template<class _Ret , class _V0_t , class _V1_t , class _V2_t> _Ret _ApplyX(_V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2) const { return (this->_Get()(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2))); } template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _V3_t> _Ret _ApplyX(_V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3) const { return (this->_Get()(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3))); } template<class _Ret , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> _Ret _ApplyX(_V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3 , _V4_t&& _V4) const { return (this->_Get()(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3) , ::std:: forward<_V4_t>(_V4))); }

	};

	
template<class _Callable>
	struct _Call_wrapper_base
	{	
	typedef typename _Callable::_MyTy _MyTy;
	typedef typename _Callable::_MyCnstTy _MyCnstTy;

	_Call_wrapper_base(_MyTy& _Val)
		: _Callee(_Val)
		{	
		}

	void _Reset(_MyTy& _Val)
		{	
		_Callee._Reset(_Val);
		}

	_MyCnstTy _Get() const
		{	
		return (_Callee._Get());
		}

	_MyCnstTy _Get()
		{	
		return (_Callee._Get());
		}

	_Callable _Callee;
	};

	
template<class _Callable,
	bool _Is_abstract = false>
	struct _Call_wrapper
	: _Call_wrapper_base<_Callable>
	{	
	typedef _Call_wrapper_base<_Callable> _Mybase;

	_Call_wrapper(typename _Call_wrapper_base<_Callable>::_MyTy& _Val)
		: _Call_wrapper_base<_Callable>(_Val)
		{	
		}













 typename result_of< typename _Callable::_MyTy()>::type operator()() const { typedef typename result_of< typename _Callable::_MyTy()>::type _Ret; return (this->_Callee.template _ApplyX<_Ret>()); } template<class _V0_t> typename result_of< typename _Callable::_MyTy(_V0_t)>::type operator()(_V0_t&& _V0) const { typedef typename result_of< typename _Callable::_MyTy(_V0_t)>::type _Ret; return (this->_Callee.template _ApplyX<_Ret>(::std:: forward<_V0_t>(_V0))); } template<class _V0_t , class _V1_t> typename result_of< typename _Callable::_MyTy(_V0_t , _V1_t)>::type operator()(_V0_t&& _V0 , _V1_t&& _V1) const { typedef typename result_of< typename _Callable::_MyTy(_V0_t , _V1_t)>::type _Ret; return (this->_Callee.template _ApplyX<_Ret>(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1))); } template<class _V0_t , class _V1_t , class _V2_t> typename result_of< typename _Callable::_MyTy(_V0_t , _V1_t , _V2_t)>::type operator()(_V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2) const { typedef typename result_of< typename _Callable::_MyTy(_V0_t , _V1_t , _V2_t)>::type _Ret; return (this->_Callee.template _ApplyX<_Ret>(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2))); } template<class _V0_t , class _V1_t , class _V2_t , class _V3_t> typename result_of< typename _Callable::_MyTy(_V0_t , _V1_t , _V2_t , _V3_t)>::type operator()(_V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3) const { typedef typename result_of< typename _Callable::_MyTy(_V0_t , _V1_t , _V2_t , _V3_t)>::type _Ret; return (this->_Callee.template _ApplyX<_Ret>(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3))); } template<class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> typename result_of< typename _Callable::_MyTy(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t)>::type operator()(_V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3 , _V4_t&& _V4) const { typedef typename result_of< typename _Callable::_MyTy(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t)>::type _Ret; return (this->_Callee.template _ApplyX<_Ret>(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3) , ::std:: forward<_V4_t>(_V4))); }

	};

template<class _Callable>
	struct _Call_wrapper<_Callable, true>
	: _Call_wrapper_base<_Callable>
	{	
	typedef _Call_wrapper_base<_Callable> _Mybase;

	_Call_wrapper(typename _Call_wrapper_base<_Callable>::_MyTy& _Val)
		: _Call_wrapper_base<_Callable>(_Val)
		{	
		}
	};

		
template<class _Ty>
	struct _Has_result_and_arg_type
		{ template<class _Uty> static auto _Fn(int, typename remove_reference<typename _Uty::argument_type>::type * = 0, typename remove_reference<typename _Uty::result_type>::type * = 0, typename remove_reference<typename _Uty::result_type>::type * = 0) -> true_type; template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; };

		
template<class _Ty>
	struct _Has_result_and_2arg_type
		{ template<class _Uty> static auto _Fn(int, typename remove_reference<typename _Uty::first_argument_type>::type * = 0, typename remove_reference<typename _Uty::second_argument_type>::type * = 0, typename remove_reference<typename _Uty::result_type>::type * = 0) -> true_type; template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; };

	
template<class _Ty,
	bool>
	struct _Refwrap_result0
	{	
	typedef typename _Ty::result_type result_type;
	};

template<class _Ty>
	struct _Refwrap_result0<_Ty, false>
	{	
	};


template<class _Ty,
	bool>
	struct _Refwrap_result1_helper
		: _Refwrap_result0<_Ty, _Has_result_type<_Ty>::type::value>
	{	
	};

template<class _Ty>
	struct _Refwrap_result1_helper<_Ty, true>
		: unary_function<typename _Ty::argument_type,
			typename _Ty::result_type>
	{	
	};

	
template<class _Ty,
	bool>
	struct _Refwrap_result1
		: _Refwrap_result0<_Ty, _Has_result_type<_Ty>::type::value>
	{	
	};

template<class _Ty>
	struct _Refwrap_result1<_Ty, true>
		: _Refwrap_result1_helper<_Ty,
			is_base_of<unary_function<
				typename _Ty::argument_type,
				typename _Ty::result_type>, _Ty>::value>
	{	
	};

	
template<class _Ty,
	bool>
	struct _Refwrap_result2_helper
		: _Refwrap_result1<_Ty, _Has_result_and_arg_type<_Ty>::type::value>
	{	
	};

template<class _Ty>
	struct _Refwrap_result2_helper<_Ty, true>
		: binary_function<typename _Ty::first_argument_type,
			typename _Ty::second_argument_type,
			typename _Ty::result_type>,
		_Refwrap_result1<_Ty, _Has_result_and_arg_type<_Ty>::type::value>
	{	
	};

	
template<class _Ty,
	bool>
	struct _Refwrap_result2
		: _Refwrap_result1<_Ty, _Has_result_and_arg_type<_Ty>::type::value>
	{	
	};

template<class _Ty>
	struct _Refwrap_result2<_Ty, true>
		: _Refwrap_result2_helper<_Ty,
			is_base_of<binary_function<
				typename _Ty::first_argument_type,
				typename _Ty::second_argument_type,
				typename _Ty::result_type>, _Ty>::value>
	{	
	};

	
template<class _Ty>
	struct _Refwrap_impl
		: _Call_wrapper<_Callable_obj<_Ty, true>,
			is_abstract<_Ty>::value>,
			_Refwrap_result2<_Ty, _Has_result_and_2arg_type<_Ty>::type::value>
	{	
	_Refwrap_impl(_Ty& _Val)
		: _Call_wrapper<_Callable_obj<_Ty, true>,
			is_abstract<_Ty>::value>(_Val)
		{	
		}
	};

template<class _Rx,
	class _Arg0>
	struct _Refwrap_impl<_Rx _Arg0::*>
		: _Call_wrapper<_Callable_pmd<_Rx _Arg0::*const, _Arg0, false> >
	{	
	typedef _Rx _Arg0::*const _Fty;
	typedef _Rx result_type;

	_Refwrap_impl(_Fty _Val)
		: _Call_wrapper<_Callable_pmd<_Fty, _Arg0, false> >(_Val)
		{	
		}
	};

template<class _Rx,
	class _Arg0>
	struct _Refwrap_impl<_Rx _Arg0::*const>
		: _Call_wrapper<_Callable_pmd<_Rx _Arg0::*, _Arg0, false> >
	{	
	typedef _Rx _Arg0::*_Fty;
	typedef _Rx result_type;
	_Refwrap_impl(_Fty _Val)
		: _Call_wrapper<_Callable_pmd<_Fty, _Arg0, false> >(_Val)
		{	
		}
	};

	
	



















































template<class _Rx  > struct _Refwrap_impl<_Rx __cdecl ()> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *)(), false> >, _Fun_class_base<_Rx  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl *_Fty)(); typedef _Rx result_type; _Refwrap_impl(_Fty _Val) : _Call_wrapper<_Callable_fun<_Fty, false> >(_Val) { } }; template<class _Rx  > struct _Refwrap_impl<_Rx(__cdecl *)()> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *)(), true> >, _Fun_class_base<_Rx  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl *_Fty)(); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx  > struct _Refwrap_impl<_Rx(__cdecl * const)()> : _Call_wrapper<_Callable_fun< _Rx(__cdecl * const)(), true> >, _Fun_class_base<_Rx  , _Nil , _Nil , _Nil , _Nil , _Nil , _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl * const _Fty)(); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx , class _V0_t> struct _Refwrap_impl<_Rx __cdecl (_V0_t)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *)(_V0_t), false> >, _Fun_class_base<_Rx , _V0_t, _Nil , _Nil , _Nil , _Nil , _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl *_Fty)(_V0_t); typedef _Rx result_type; _Refwrap_impl(_Fty _Val) : _Call_wrapper<_Callable_fun<_Fty, false> >(_Val) { } }; template<class _Rx , class _V0_t> struct _Refwrap_impl<_Rx(__cdecl *)(_V0_t)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *)(_V0_t), true> >, _Fun_class_base<_Rx , _V0_t, _Nil , _Nil , _Nil , _Nil , _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl *_Fty)(_V0_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx , class _V0_t> struct _Refwrap_impl<_Rx(__cdecl * const)(_V0_t)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl * const)(_V0_t), true> >, _Fun_class_base<_Rx , _V0_t, _Nil , _Nil , _Nil , _Nil , _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl * const _Fty)(_V0_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx , class _V0_t , class _V1_t> struct _Refwrap_impl<_Rx __cdecl (_V0_t , _V1_t)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *)(_V0_t , _V1_t), false> >, _Fun_class_base<_Rx , _V0_t , _V1_t, _Nil , _Nil , _Nil , _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl *_Fty)(_V0_t , _V1_t); typedef _Rx result_type; _Refwrap_impl(_Fty _Val) : _Call_wrapper<_Callable_fun<_Fty, false> >(_Val) { } }; template<class _Rx , class _V0_t , class _V1_t> struct _Refwrap_impl<_Rx(__cdecl *)(_V0_t , _V1_t)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *)(_V0_t , _V1_t), true> >, _Fun_class_base<_Rx , _V0_t , _V1_t, _Nil , _Nil , _Nil , _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl *_Fty)(_V0_t , _V1_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx , class _V0_t , class _V1_t> struct _Refwrap_impl<_Rx(__cdecl * const)(_V0_t , _V1_t)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl * const)(_V0_t , _V1_t), true> >, _Fun_class_base<_Rx , _V0_t , _V1_t, _Nil , _Nil , _Nil , _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl * const _Fty)(_V0_t , _V1_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx , class _V0_t , class _V1_t , class _V2_t> struct _Refwrap_impl<_Rx __cdecl (_V0_t , _V1_t , _V2_t)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *)(_V0_t , _V1_t , _V2_t), false> >, _Fun_class_base<_Rx , _V0_t , _V1_t , _V2_t, _Nil , _Nil , _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl *_Fty)(_V0_t , _V1_t , _V2_t); typedef _Rx result_type; _Refwrap_impl(_Fty _Val) : _Call_wrapper<_Callable_fun<_Fty, false> >(_Val) { } }; template<class _Rx , class _V0_t , class _V1_t , class _V2_t> struct _Refwrap_impl<_Rx(__cdecl *)(_V0_t , _V1_t , _V2_t)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *)(_V0_t , _V1_t , _V2_t), true> >, _Fun_class_base<_Rx , _V0_t , _V1_t , _V2_t, _Nil , _Nil , _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl *_Fty)(_V0_t , _V1_t , _V2_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx , class _V0_t , class _V1_t , class _V2_t> struct _Refwrap_impl<_Rx(__cdecl * const)(_V0_t , _V1_t , _V2_t)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl * const)(_V0_t , _V1_t , _V2_t), true> >, _Fun_class_base<_Rx , _V0_t , _V1_t , _V2_t, _Nil , _Nil , _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl * const _Fty)(_V0_t , _V1_t , _V2_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Refwrap_impl<_Rx __cdecl (_V0_t , _V1_t , _V2_t , _V3_t)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *)(_V0_t , _V1_t , _V2_t , _V3_t), false> >, _Fun_class_base<_Rx , _V0_t , _V1_t , _V2_t , _V3_t, _Nil , _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl *_Fty)(_V0_t , _V1_t , _V2_t , _V3_t); typedef _Rx result_type; _Refwrap_impl(_Fty _Val) : _Call_wrapper<_Callable_fun<_Fty, false> >(_Val) { } }; template<class _Rx , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Refwrap_impl<_Rx(__cdecl *)(_V0_t , _V1_t , _V2_t , _V3_t)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *)(_V0_t , _V1_t , _V2_t , _V3_t), true> >, _Fun_class_base<_Rx , _V0_t , _V1_t , _V2_t , _V3_t, _Nil , _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl *_Fty)(_V0_t , _V1_t , _V2_t , _V3_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Refwrap_impl<_Rx(__cdecl * const)(_V0_t , _V1_t , _V2_t , _V3_t)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl * const)(_V0_t , _V1_t , _V2_t , _V3_t), true> >, _Fun_class_base<_Rx , _V0_t , _V1_t , _V2_t , _V3_t, _Nil , _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl * const _Fty)(_V0_t , _V1_t , _V2_t , _V3_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Refwrap_impl<_Rx __cdecl (_V0_t , _V1_t , _V2_t , _V3_t , _V4_t)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t), false> >, _Fun_class_base<_Rx , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t, _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl *_Fty)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t); typedef _Rx result_type; _Refwrap_impl(_Fty _Val) : _Call_wrapper<_Callable_fun<_Fty, false> >(_Val) { } }; template<class _Rx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Refwrap_impl<_Rx(__cdecl *)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t), true> >, _Fun_class_base<_Rx , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t, _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl *_Fty)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Refwrap_impl<_Rx(__cdecl * const)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl * const)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t), true> >, _Fun_class_base<_Rx , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t, _Nil, _Nil, _Nil, _Nil> { typedef _Rx(__cdecl * const _Fty)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } };



	





































template<class _Rx, class _Arg0  > struct _Refwrap_impl<_Rx( _Arg0::*)() > : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)() , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0  > { typedef _Rx( _Arg0::* _Fty)(); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0  > struct _Refwrap_impl<_Rx( _Arg0::* const)() > : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)() , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0  > { typedef _Rx( _Arg0::* const _Fty)() ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t) > : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t) > : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t , _V1_t) > : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t , _V1_t) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t , _V1_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t , _V1_t) > : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t , _V1_t) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t , _V1_t) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t) > : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t , _V1_t , _V2_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t) > : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t , _V1_t , _V2_t) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t) > : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t , _V3_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t , _V1_t , _V2_t , _V3_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t , _V3_t) > : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t , _V3_t) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t , _V3_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t , _V1_t , _V2_t , _V3_t) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) > : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) > : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } };
template<class _Rx, class _Arg0  > struct _Refwrap_impl<_Rx( _Arg0::*)() const> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)() const, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0  > { typedef _Rx( _Arg0::* _Fty)(); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0  > struct _Refwrap_impl<_Rx( _Arg0::* const)() const> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)() const, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0  > { typedef _Rx( _Arg0::* const _Fty)() const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t) const> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t) const, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t) const> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t) const, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t , _V1_t) const> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t , _V1_t) const, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t , _V1_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t , _V1_t) const> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t , _V1_t) const, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t , _V1_t) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t) const> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t) const, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t , _V1_t , _V2_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t) const> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t) const, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t , _V1_t , _V2_t) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t) const> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t) const, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t , _V3_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t , _V1_t , _V2_t , _V3_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t , _V3_t) const> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t , _V3_t) const, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t , _V3_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t , _V1_t , _V2_t , _V3_t) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) const> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) const, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) const> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) const, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } };
template<class _Rx, class _Arg0  > struct _Refwrap_impl<_Rx( _Arg0::*)() volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)() volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0  > { typedef _Rx( _Arg0::* _Fty)(); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0  > struct _Refwrap_impl<_Rx( _Arg0::* const)() volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)() volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0  > { typedef _Rx( _Arg0::* const _Fty)() volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t) volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t) volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t) volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t) volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t , _V1_t) volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t , _V1_t) volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t , _V1_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t , _V1_t) volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t , _V1_t) volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t , _V1_t) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t) volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t) volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t , _V1_t , _V2_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t) volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t) volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t , _V1_t , _V2_t) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t) volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t) volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t , _V3_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t , _V1_t , _V2_t , _V3_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t , _V3_t) volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t , _V3_t) volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t , _V3_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t , _V1_t , _V2_t , _V3_t) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } };
template<class _Rx, class _Arg0  > struct _Refwrap_impl<_Rx( _Arg0::*)() const volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)() const volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0  > { typedef _Rx( _Arg0::* _Fty)(); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0  > struct _Refwrap_impl<_Rx( _Arg0::* const)() const volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)() const volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0  > { typedef _Rx( _Arg0::* const _Fty)() const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t) const volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t) const volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t , _V1_t) const volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t , _V1_t) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t , _V1_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t , _V1_t) const volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t , _V1_t) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t , _V1_t) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t) const volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t , _V1_t , _V2_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t) const volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t , _V1_t , _V2_t) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t) const volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t , _V3_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t , _V1_t , _V2_t , _V3_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t , _V3_t) const volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t , _V3_t) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t , _V3_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t , _V1_t , _V2_t , _V3_t) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Refwrap_impl<_Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) const volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::*)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t> { typedef _Rx( _Arg0::* _Fty)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0 , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> struct _Refwrap_impl<_Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) const volatile> : _Call_wrapper<_Callable_pmf< _Rx( _Arg0::* const)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 , _V0_t , _V1_t , _V2_t , _V3_t , _V4_t> { typedef _Rx( _Arg0::* const _Fty)(_V0_t , _V1_t , _V2_t , _V3_t , _V4_t) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } };




	
template<class _Ty>
	class reference_wrapper
	: public _Refwrap_impl<_Ty>
	{	
public:
	typedef _Refwrap_impl<_Ty> _MyBase;
	typedef _Ty type;

	reference_wrapper(_Ty& _Val) throw ()
		: _MyBase(_Val)
		{	
		}

	operator _Ty&() const throw ()
		{	
		return (this->_Get());
		}

	_Ty& get() const throw ()
		{	
		return (this->_Get());
		}
	};

	
template<class _Ty>
	reference_wrapper<_Ty>
		ref(_Ty& _Val) throw ()
	{	
	return (reference_wrapper<_Ty>(_Val));
	}

template<class _Ty>
	void ref(const _Ty&& _Val);	

template<class _Ty>
	reference_wrapper<_Ty>
		ref(reference_wrapper<_Ty> _Val) throw ()
	{	
	return (_Val);
	}

template<class _Ty>
	reference_wrapper<const _Ty>
		cref(const _Ty& _Val) throw ()
	{	
	return (reference_wrapper<const _Ty>(_Val));
	}




template<class _Ty>
	reference_wrapper<const _Ty>
		cref(reference_wrapper<const _Ty> _Val) throw ()
	{	
	return (_Val);
	}

namespace tr1 {	
using ::std:: cref;
using ::std:: ref;
using ::std:: reference_wrapper;
using ::std:: result_of;
	}	
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 925 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xrefwrap"
#line 926 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xrefwrap"





#line 1821 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\type_traits"
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1825 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\type_traits"
#line 1826 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\type_traits"






#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\utility"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4180 4512)

namespace std {
		
template<class _Ty> inline
	void swap(_Ty&, _Ty&);

template<class _FwdIt1,
	class _FwdIt2> inline
	void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
	{	
	swap(*_Left, *_Right);
	}

		
template<class _Ty,
	size_t _Size> inline
	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
	{	
	if (&_Left != &_Right)
		{	
		_Ty *_First1 = _Left;
		_Ty *_Last1 = _First1 + _Size;
		_Ty *_First2 = _Right;
		for (; _First1 != _Last1; ++_First1, ++_First2)
			::std:: iter_swap(_First1, _First2);
		}
	}

template<class _Ty> inline
	void swap(_Ty& _Left, _Ty& _Right)
	{	
	_Ty _Tmp = _Move(_Left);
	_Left = _Move(_Right);
	_Right = _Move(_Tmp);
	}

		
template<class _Ty> inline
	void _Swap_adl(_Ty& _Left, _Ty& _Right)
	{	
	swap(_Left, _Right);
	}

		
struct piecewise_construct_t
	{	
	};

const piecewise_construct_t piecewise_construct =
	piecewise_construct_t();

		
template<class _Ty1,
	class _Ty2>
	struct pair;

template<class = _Nil, class _V0_t = _Nil , class _V1_t = _Nil , class _V2_t = _Nil , class _V3_t = _Nil , class _V4_t = _Nil , class _V5_t = _Nil , class = _Nil>
	class tuple;

template<class _Ty1,
	class _Ty2>
	struct pair
	{	
	typedef pair<_Ty1, _Ty2> _Myt;
	typedef _Ty1 first_type;
	typedef _Ty2 second_type;

	pair()
		: first(), second()
		{	
		}

	pair(const _Ty1& _Val1, const _Ty2& _Val2)
		: first(_Val1), second(_Val2)
		{	
		}

	template<class _Other1,
		class _Other2>
		pair(const pair<_Other1, _Other2>& _Right,
			typename enable_if<is_convertible<const _Other1&, _Ty1>::value
				&& is_convertible<const _Other2&, _Ty2>::value,
				void>::type ** = 0)
		: first(_Right.first), second(_Right.second)
		{	
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Swap_adl(first, _Right.first);
			_Swap_adl(second, _Right.second);
			}
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		first = _Right.first;
		second = _Right.second;
		return (*this);
		}

 
	template<class _Other1,
		class _Other2>
		_Myt& operator=(const pair<_Other1, _Other2>& _Right)
		{	
		first = _Right.first;
		second = _Right.second;
		return (*this);
		}
 #line 129 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\utility"

	template<class _Other1,
		class _Other2>
		pair(_Other1&& _Val1, _Other2&& _Val2,
			typename enable_if<is_convertible<_Other1, _Ty1>::value
				&& is_convertible<_Other2, _Ty2>::value,
				void>::type ** = 0)
		: first(::std:: forward<_Other1>(_Val1)),
				second(::std:: forward<_Other2>(_Val2))
		{	
		}









 pair(piecewise_construct_t, tuple<>, tuple<>); template<class _V0_t> pair(piecewise_construct_t, tuple<_V0_t>, tuple<>); template<class _V0_t , class _V1_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t>, tuple<>); template<class _V0_t , class _V1_t , class _V2_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t>, tuple<>); template<class _V0_t , class _V1_t , class _V2_t , class _V3_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t , _V3_t>, tuple<>); template<class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t , _V3_t , _V4_t>, tuple<>);










template<class _Vx0_t> pair(piecewise_construct_t, tuple<>, tuple<_Vx0_t>); template<class _Vx0_t , class _Vx1_t> pair(piecewise_construct_t, tuple<>, tuple<_Vx0_t , _Vx1_t>); template<class _Vx0_t , class _Vx1_t , class _Vx2_t> pair(piecewise_construct_t, tuple<>, tuple<_Vx0_t , _Vx1_t , _Vx2_t>); template<class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t> pair(piecewise_construct_t, tuple<>, tuple<_Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t>); template<class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t , class _Vx4_t> pair(piecewise_construct_t, tuple<>, tuple<_Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t , _Vx4_t>);










template<class _V0_t, class _Vx0_t> pair(piecewise_construct_t, tuple<_V0_t>, tuple<_Vx0_t>); template<class _V0_t , class _V1_t, class _Vx0_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t>, tuple<_Vx0_t>); template<class _V0_t , class _V1_t , class _V2_t, class _Vx0_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t>, tuple<_Vx0_t>); template<class _V0_t , class _V1_t , class _V2_t , class _V3_t, class _Vx0_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t , _V3_t>, tuple<_Vx0_t>); template<class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t, class _Vx0_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t , _V3_t , _V4_t>, tuple<_Vx0_t>); template<class _V0_t, class _Vx0_t , class _Vx1_t> pair(piecewise_construct_t, tuple<_V0_t>, tuple<_Vx0_t , _Vx1_t>); template<class _V0_t , class _V1_t, class _Vx0_t , class _Vx1_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t>, tuple<_Vx0_t , _Vx1_t>); template<class _V0_t , class _V1_t , class _V2_t, class _Vx0_t , class _Vx1_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t>, tuple<_Vx0_t , _Vx1_t>); template<class _V0_t , class _V1_t , class _V2_t , class _V3_t, class _Vx0_t , class _Vx1_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t , _V3_t>, tuple<_Vx0_t , _Vx1_t>); template<class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t, class _Vx0_t , class _Vx1_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t , _V3_t , _V4_t>, tuple<_Vx0_t , _Vx1_t>); template<class _V0_t, class _Vx0_t , class _Vx1_t , class _Vx2_t> pair(piecewise_construct_t, tuple<_V0_t>, tuple<_Vx0_t , _Vx1_t , _Vx2_t>); template<class _V0_t , class _V1_t, class _Vx0_t , class _Vx1_t , class _Vx2_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t>, tuple<_Vx0_t , _Vx1_t , _Vx2_t>); template<class _V0_t , class _V1_t , class _V2_t, class _Vx0_t , class _Vx1_t , class _Vx2_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t>, tuple<_Vx0_t , _Vx1_t , _Vx2_t>); template<class _V0_t , class _V1_t , class _V2_t , class _V3_t, class _Vx0_t , class _Vx1_t , class _Vx2_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t , _V3_t>, tuple<_Vx0_t , _Vx1_t , _Vx2_t>); template<class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t, class _Vx0_t , class _Vx1_t , class _Vx2_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t , _V3_t , _V4_t>, tuple<_Vx0_t , _Vx1_t , _Vx2_t>); template<class _V0_t, class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t> pair(piecewise_construct_t, tuple<_V0_t>, tuple<_Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t>); template<class _V0_t , class _V1_t, class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t>, tuple<_Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t>); template<class _V0_t , class _V1_t , class _V2_t, class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t>, tuple<_Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t>); template<class _V0_t , class _V1_t , class _V2_t , class _V3_t, class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t , _V3_t>, tuple<_Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t>); template<class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t, class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t , _V3_t , _V4_t>, tuple<_Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t>); template<class _V0_t, class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t , class _Vx4_t> pair(piecewise_construct_t, tuple<_V0_t>, tuple<_Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t , _Vx4_t>); template<class _V0_t , class _V1_t, class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t , class _Vx4_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t>, tuple<_Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t , _Vx4_t>); template<class _V0_t , class _V1_t , class _V2_t, class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t , class _Vx4_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t>, tuple<_Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t , _Vx4_t>); template<class _V0_t , class _V1_t , class _V2_t , class _V3_t, class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t , class _Vx4_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t , _V3_t>, tuple<_Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t , _Vx4_t>); template<class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t, class _Vx0_t , class _Vx1_t , class _Vx2_t , class _Vx3_t , class _Vx4_t> pair(piecewise_construct_t, tuple<_V0_t , _V1_t , _V2_t , _V3_t , _V4_t>, tuple<_Vx0_t , _Vx1_t , _Vx2_t , _Vx3_t , _Vx4_t>);


	template<class _Other1,
		class _Other2>
		pair(pair<_Other1, _Other2>&& _Right,
			typename enable_if<is_convertible<_Other1, _Ty1>::value
				&& is_convertible<_Other2, _Ty2>::value,
				void>::type ** = 0)
		: first(::std:: forward<_Other1>(_Right.first)),
			second(::std:: forward<_Other2>(_Right.second))
		{	
		}

	template<class _Other1,
		class _Other2>
		_Myt& operator=(pair<_Other1, _Other2>&& _Right)
		{	
		first = ::std:: forward<_Other1>(_Right.first);
		second = ::std:: forward<_Other2>(_Right.second);
		return (*this);
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		first = ::std:: forward<_Ty1>(_Right.first);
		second = ::std:: forward<_Ty2>(_Right.second);
		return (*this);
		}

	_Ty1 first;	
	_Ty2 second;	
	};

		

template<class _Ty1,
	class _Ty2> inline
	void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)
	{	
	_Left.swap(_Right);
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator==(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Left.first == _Right.first && _Left.second == _Right.second);
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator!=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator<(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Left.first < _Right.first ||
		!(_Right.first < _Left.first) && _Left.second < _Right.second);
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator>(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator<=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator>=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Left < _Right));
	}

	

template<class _Ty1,
	class _Ty2> inline
	pair<typename _Unrefwrap<_Ty1>::type,
		typename _Unrefwrap<_Ty2>::type>
		make_pair(_Ty1&& _Val1, _Ty2&& _Val2)
	{	
	typedef pair<typename _Unrefwrap<_Ty1>::type,
		typename _Unrefwrap<_Ty2>::type> _Mypair;
	return (_Mypair(::std:: forward<_Ty1>(_Val1),
		::std:: forward<_Ty2>(_Val2)));
	}

		
	namespace rel_ops
		{	
template<class _Ty> inline
	bool operator!=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty> inline
	bool operator>(const _Ty& _Left, const _Ty& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty> inline
	bool operator<=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty> inline
	bool operator>=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Left < _Right));
	}
		}
}

namespace std {
	
template<class _Tuple>
	struct tuple_size;
template<size_t _Idx,
	class _Tuple>
	struct tuple_element;
template<class _Ty1,
	class _Ty2>
	struct tuple_size<pair<_Ty1, _Ty2> >
	{	
	static const int value = 2;
	};

template<int _Idx,
	class _Ty>
	struct _Pair_data;
template<class _Ty1,
	class _Ty2>
	struct _Pair_data<0, pair<_Ty1, _Ty2> >
	{	
	typedef typename add_lvalue_reference<const _Ty1>::type _Ctype;
	typedef typename add_lvalue_reference<_Ty1>::type _Rtype;
	typedef typename add_rvalue_reference<_Ty1>::type _RRtype;

	static _Rtype _Val(pair<_Ty1, _Ty2>& _Pr)
		{	
		return (_Pr.first);
		}

	static _Ctype _Val(const pair<_Ty1, _Ty2>& _Pr)
		{	
		return (_Pr.first);
		}

	static _RRtype _Val(pair<_Ty1, _Ty2>&& _Pr)
		{	
		return (::std:: forward<_Ty1>(_Pr.first));
		}
	};

template<class _Ty1,
	class _Ty2>
	struct _Pair_data<1, pair<_Ty1, _Ty2> >
	{	
	typedef typename add_lvalue_reference<const _Ty2>::type _Ctype;
	typedef typename add_lvalue_reference<_Ty2>::type _Rtype;
	typedef typename add_rvalue_reference<_Ty2>::type _RRtype;

	static _Rtype _Val(pair<_Ty1, _Ty2>& _Pr)
		{	
		return (_Pr.second);
		}

	static _Ctype _Val(const pair<_Ty1, _Ty2>& _Pr)
		{	
		return (_Pr.second);
		}

	static _RRtype _Val(pair<_Ty1, _Ty2>&& _Pr)
		{	
		return (::std:: forward<_Ty2>(_Pr.second));
		}
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_element<0, pair<_Ty1, _Ty2> >
	{	
	typedef _Ty1 type;
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_element<1, pair<_Ty1, _Ty2> >
	{	
	typedef _Ty2 type;
	};

template<int _Idx,
	class _Ty1,
	class _Ty2> inline
	typename _Pair_data<_Idx, pair<_Ty1, _Ty2> >::_Rtype
		get(pair<_Ty1, _Ty2>& _Pr) throw ()
	{	
	return (_Pair_data<_Idx, pair<_Ty1, _Ty2> >::_Val(_Pr));
	}

template<int _Idx,
	class _Ty1,
	class _Ty2> inline
	typename _Pair_data<_Idx, pair<_Ty1, _Ty2> >::_Ctype
		get(const pair<_Ty1, _Ty2>& _Pr) throw ()
	{	
	return (_Pair_data<_Idx, pair<_Ty1, _Ty2> >::_Val(_Pr));
	}

template<int _Idx,
	class _Ty1,
	class _Ty2> inline
	typename _Pair_data<_Idx, pair<_Ty1, _Ty2> >::_RRtype
		get(pair<_Ty1, _Ty2>&& _Pr) throw ()
	{	
	typedef typename _Pair_data<_Idx, pair<_Ty1, _Ty2> >::_RRtype
		_RRtype;
	return (::std:: forward<_RRtype>(
		_Pair_data<_Idx, pair<_Ty1, _Ty2> >::_Val(_Pr)));
	}
}

namespace std {
namespace tr1 {	
using ::std:: get;
using ::std:: tuple_element;
using ::std:: tuple_size;
}	
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 428 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\utility"
#line 429 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\utility"






















#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		

 












#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"
  
 #line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

		
struct __declspec(dllimport) _Container_base0
	{	
	void _Orphan_all()
		{	
		}

	void _Swap_all(_Container_base0&)
		{	
		}
	};

struct _Iterator_base0
	{	
	void _Adopt(const void *)
		{	
		}

	const _Container_base0 *_Getcont() const
		{	
		return (0);
		}
	};

struct _Container_base12;
struct _Iterator_base12;

		
struct _Container_proxy
	{	
	_Container_proxy()
		: _Mycont(0), _Myfirstiter(0)
		{	
		}

	const _Container_base12 *_Mycont;
	_Iterator_base12 *_Myfirstiter;
	};

struct __declspec(dllimport) _Container_base12
	{	
public:
	_Container_base12()
		: _Myproxy(0)
		{	
		}

	_Container_base12(const _Container_base12&)
		: _Myproxy(0)
		{	
		}

	_Container_base12& operator=(const _Container_base12&)
		{	
		return (*this);
		}

	~_Container_base12() throw ()
		{	
		_Orphan_all();
		}

	_Iterator_base12 **_Getpfirst() const
		{	
		return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);
		}

	void _Orphan_all();	
	void _Swap_all(_Container_base12&);	

	_Container_proxy *_Myproxy;
	};

struct _Iterator_base12
	{	
public:
	_Iterator_base12()
		: _Myproxy(0), _Mynextiter(0)
		{	
		}

	_Iterator_base12(const _Iterator_base12& _Right)
		: _Myproxy(0), _Mynextiter(0)
		{	
		*this = _Right;
		}

	_Iterator_base12& operator=(const _Iterator_base12& _Right)
		{	
		if (_Myproxy == _Right._Myproxy)
			;
		else if (_Right._Myproxy != 0)
			_Adopt(_Right._Myproxy->_Mycont);
		else
			{	
			_Lockit _Lock(3);
			_Orphan_me();
			}
		return (*this);
		}

	~_Iterator_base12() throw ()
		{	
 


#line 142 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"
		}

	void _Adopt(const _Container_base12 *_Parent)
		{	
		if (_Parent == 0)
			{	
			_Lockit _Lock(3);
			_Orphan_me();
			}
		else
			{	
			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

 









#line 166 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"
			_Myproxy = _Parent_proxy;
 #line 168 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"
			}
		}

	void _Clrcont()
		{	
		_Myproxy = 0;
		}

	const _Container_base12 *_Getcont() const
		{	
		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);
		}

	_Iterator_base12 **_Getpnext()
		{	
		return (&_Mynextiter);
		}

	void _Orphan_me()
		{	
 











#line 201 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"
		}

	_Container_proxy *_Myproxy;
	_Iterator_base12 *_Mynextiter;
	};

		
inline void _Container_base12::_Orphan_all()
	{	
 









#line 221 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"
	}

inline void _Container_base12::_Swap_all(_Container_base12& _Right)
	{	
 

#line 228 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

	_Container_proxy *_Temp = _Myproxy;
	_Myproxy = _Right._Myproxy;
	_Right._Myproxy = _Temp;

	if (_Myproxy != 0)
		_Myproxy->_Mycont = (_Container_base12 *)this;
	if (_Right._Myproxy != 0)
		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
	}

 
typedef _Container_base0 _Container_base;
typedef _Iterator_base0 _Iterator_base;

 


#line 247 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

		

		
 


		
template<class _Ty>
	struct _Get_unchecked_type
		{ template<class _Uty> static auto _Fn(int) -> typename _Uty::_Unchecked_type; template<class _Uty> static auto _Fn(_Wrap_int) -> _Ty; typedef decltype(_Fn<_Ty>(0)) type; };
#line 259 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

		
template<class _Ty>
	struct _Is_checked_helper
		{ template<class _Uty> static auto _Fn(int, typename remove_reference<typename _Uty::_Unchecked_type>::type * = 0, typename remove_reference<typename _Uty::_Unchecked_type>::type * = 0, typename remove_reference<typename _Uty::_Unchecked_type>::type * = 0) -> true_type; template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; };

		
template<class _Iter> inline
	typename _Is_checked_helper<_Iter>::type _Is_checked(_Iter)
	{	
	return (typename _Is_checked_helper<_Iter>::type());
	}

		
template<class _Iter> inline
	_Iter _Unchecked(_Iter _Src)
	{	
	return (_Src);
	}

		
template<class _Iter,
	class _UIter> inline
	_Iter& _Rechecked(_Iter& _Dest, _UIter _Src)
	{	
	_Dest = _Src;
	return (_Dest);
	}

		
		
struct input_iterator_tag
	{	
	};

struct output_iterator_tag
	{	
	};

struct forward_iterator_tag
	: public input_iterator_tag, output_iterator_tag
	{	
	};

struct bidirectional_iterator_tag
	: public forward_iterator_tag
	{	
	};

struct random_access_iterator_tag
	: public bidirectional_iterator_tag
	{	
	};

		
struct _Nonscalar_ptr_iterator_tag
	{	
	};
struct _Scalar_ptr_iterator_tag
	{	
	};

		
template<class _Category,
	class _Ty,
	class _Diff = ptrdiff_t,
	class _Pointer = _Ty *,
	class _Reference = _Ty&>
	struct iterator
	{	
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;
	typedef _Diff distance_type;	
	typedef _Pointer pointer;
	typedef _Reference reference;
	};

template<class _Category,
	class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference,
	class _Base>
	struct _Iterator012
		: public _Base
	{	
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;
	typedef _Diff distance_type;	
	typedef _Pointer pointer;
	typedef _Reference reference;
	};

struct _Outit
	: public iterator<output_iterator_tag, void, void,
		void, void>
	{	
	};

		
template<class _Iter>
	struct iterator_traits
	{	
	typedef typename _Iter::iterator_category iterator_category;
	typedef typename _Iter::value_type value_type;
	typedef typename _Iter::difference_type difference_type;
	typedef difference_type distance_type;	
	typedef typename _Iter::pointer pointer;
	typedef typename _Iter::reference reference;
	};

template<class _Ty>
	struct iterator_traits<_Ty *>
	{	
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;
	typedef ptrdiff_t distance_type;	
	typedef _Ty *pointer;
	typedef _Ty& reference;
	};

template<class _Ty>
	struct iterator_traits<const _Ty *>
	{	
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;
	typedef ptrdiff_t distance_type;	
	typedef const _Ty *pointer;
	typedef const _Ty& reference;
	};

		
template<class _Iter> inline
	typename iterator_traits<_Iter>::iterator_category
		_Iter_cat(const _Iter&)
	{	
	typename iterator_traits<_Iter>::iterator_category _Cat;
	return (_Cat);
	}

		
template<class _Iter1,
	class _Iter2> inline
	_Nonscalar_ptr_iterator_tag _Ptr_cat(_Iter1&, _Iter2&)
	{	
	_Nonscalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

template<class _Elem1,
	class _Elem2>
	struct _Ptr_cat_helper
	{	
	typedef _Nonscalar_ptr_iterator_tag type;
	};

template<class _Elem>
	struct _Ptr_cat_helper<_Elem, _Elem>
	{	
	typedef typename _If<is_scalar<_Elem>::value,
		_Scalar_ptr_iterator_tag,
		_Nonscalar_ptr_iterator_tag>::type type;
	};

template<class _Anything>
	struct _Ptr_cat_helper<_Anything *, const _Anything *>
	{	
	typedef _Scalar_ptr_iterator_tag type;
	};

template<class _Elem1,
	class _Elem2> inline
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type
		_Ptr_cat(_Elem1 *, _Elem2 *)
	{	
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
	return (_Cat);
	}

template<class _Elem1,
	class _Elem2> inline
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type
		_Ptr_cat(const _Elem1 *, _Elem2 *)
	{	
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
	return (_Cat);
	}

		

 
  
  
  
  
  
  
  
  

 















































































































































































































































#line 704 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

		
		

template<class _Iter> inline
	typename iterator_traits<_Iter>::value_type *_Val_type(_Iter)
	{	
	return (0);
	}

		
template<class _InIt,
	class _Diff> inline
	void _Advance(_InIt& _Where, _Diff _Off, input_iterator_tag)
	{	
 


#line 723 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

	for (; 0 < _Off; --_Off)
		++_Where;
	}

template<class _FwdIt,
	class _Diff> inline
	void _Advance(_FwdIt& _Where, _Diff _Off, forward_iterator_tag)
	{	
 


#line 736 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

	for (; 0 < _Off; --_Off)
		++_Where;
	}

template<class _BidIt,
	class _Diff> inline
	void _Advance(_BidIt& _Where, _Diff _Off, bidirectional_iterator_tag)
	{	
	for (; 0 < _Off; --_Off)
		++_Where;
	for (; _Off < 0; ++_Off)
		--_Where;
	}

template<class _RanIt,
	class _Diff> inline
	void _Advance(_RanIt& _Where, _Diff _Off, random_access_iterator_tag)
	{	
	_Where += _Off;
	}

template<class _InIt,
	class _Diff> inline
	void advance(_InIt& _Where, _Diff _Off)
	{	
	_Advance(_Where, _Off, _Iter_cat(_Where));
	}

		

template<class _Iter> inline
	typename iterator_traits<_Iter>::difference_type
		*_Dist_type(_Iter)
	{	
	return (0);
	}

		
template<class _InIt,
	class _Diff> inline
		void _Distance2(_InIt _First, _InIt _Last, _Diff& _Off,
			input_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _FwdIt,
	class _Diff> inline
		void _Distance2(_FwdIt _First, _FwdIt _Last, _Diff& _Off,
			forward_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _BidIt,
	class _Diff> inline
		void _Distance2(_BidIt _First, _BidIt _Last, _Diff& _Off,
			bidirectional_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _RanIt,
	class _Diff> inline
		void _Distance2(_RanIt _First, _RanIt _Last, _Diff& _Off,
			random_access_iterator_tag)
	{	
 





#line 814 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

	_Off += _Last - _First;
	}

template<class _InIt> inline
	typename iterator_traits<_InIt>::difference_type
		distance(_InIt _First, _InIt _Last)
	{	
	typename iterator_traits<_InIt>::difference_type _Off = 0;
	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	return (_Off);
	}

template<class _InIt,
	class _Diff> inline
		void _Distance(_InIt _First, _InIt _Last, _Diff& _Off)
	{	
	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	}

 
		
template<class _FwdIt> inline
	_FwdIt next(_FwdIt _First,
		typename iterator_traits<_FwdIt>::difference_type _Off = 1)
	{	
	static_assert((is_base_of<forward_iterator_tag,
		typename iterator_traits<_FwdIt>::iterator_category>::value),
		"next requires forward iterator");

	::std:: advance(_First, _Off);
	return (_First);
	}

		
template<class _BidIt> inline
	_BidIt prev(_BidIt _First,
		typename iterator_traits<_BidIt>::difference_type _Off = 1)
	{	
	static_assert((is_base_of<bidirectional_iterator_tag,
		typename iterator_traits<_BidIt>::iterator_category>::value),
		"prev requires bidirectional iterator");

	::std:: advance(_First, -_Off);
	return (_First);
	}

template<class _Container>
	auto inline begin(_Container& _Cont) -> decltype(_Cont.begin())
	{	
	return (_Cont.begin());
	}

template<class _Container>
	auto inline begin(const _Container& _Cont) -> decltype(_Cont.begin())
	{	
	return (_Cont.begin());
	}

template<class _Container>
	auto inline end(_Container& _Cont) -> decltype(_Cont.end())
	{	
	return (_Cont.end());
	}

template<class _Container>
	auto inline end(const _Container& _Cont) -> decltype(_Cont.end())
	{	
	return (_Cont.end());
	}

template<class _Ty,
	size_t _Size> inline
	_Ty *begin(_Ty (&_Array)[_Size])
	{	
	return (_Array);
	}

template<class _Ty,
	size_t _Size> inline
	_Ty *end(_Ty (&_Array)[_Size])
	{	
	return (_Array + _Size);
	}
 #line 899 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

		
template<class _Ty>
	struct pointer_traits;

template<class _RanIt,
	class _Base>
	class _Revranit
		: public _Base
	{	
public:
	typedef _Revranit<_RanIt, _Base> _Myt;
 	typedef typename _Base::difference_type difference_type;
	typedef typename _Base::pointer pointer;
	typedef typename _Base::reference reference;
	typedef _RanIt iterator_type;

	_Revranit()
		{	
		}

	explicit _Revranit(_RanIt _Right)
		: current(_Right)
		{	
		}

	template<class _RanIt2,
		class _Base2>
		_Revranit(const _Revranit<_RanIt2, _Base2>& _Right)
		: current(_Right.base())
		{	
		}

	_RanIt base() const
		{	
		return (current);
		}

	reference operator*() const
		{	
		_RanIt _Tmp = current;
		return (*--_Tmp);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
		--current;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		++current;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	template<class _RanIt2,
		class _Base2>
		bool _Equal(const _Revranit<_RanIt2, _Base2>& _Right) const
		{	
		return (current == _Right.base());
		}



	_Myt& operator+=(difference_type _Off)
		{	
		current -= _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		return (_Myt(current - _Off));
		}

	_Myt& operator-=(difference_type _Off)
		{	
		current += _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	
		return (_Myt(current + _Off));
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	template<class _RanIt2,
		class _Base2>
		bool _Less(const _Revranit<_RanIt2, _Base2>& _Right) const
		{	
		return (_Right.base() < current);
		}

	difference_type operator-(const _Myt& _Right) const
		{	
		return (_Right.base() - current);
		}

protected:
	_RanIt current;	
	};

		
template<class _RanIt,
	class _Base,
	class _Diff> inline
	_Revranit<_RanIt, _Base>
		operator+(_Diff _Off,
		const _Revranit<_RanIt, _Base>& _Right)
	{	
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2>
	auto inline operator-(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
			-> decltype(_Right.base() - _Left.base())
	{	
	return (_Right.base() - _Left.base());
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator==(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	
	return (_Left._Equal(_Right));
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator!=(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator<(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	
	return (_Left._Less(_Right));
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator>(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator<=(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator>=(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	
	return (!(_Left < _Right));
	}

		
template<class _RanIt>
	class reverse_iterator
		: public _Revranit<_RanIt, iterator<
			typename iterator_traits<_RanIt>::iterator_category,
			typename iterator_traits<_RanIt>::value_type,
			typename iterator_traits<_RanIt>::difference_type,
			typename iterator_traits<_RanIt>::pointer,
			typename iterator_traits<_RanIt>::reference> >
	{	
	typedef reverse_iterator<_RanIt> _Myt;
	typedef _Revranit<_RanIt, iterator<
		typename iterator_traits<_RanIt>::iterator_category,
		typename iterator_traits<_RanIt>::value_type,
		typename iterator_traits<_RanIt>::difference_type,
		typename iterator_traits<_RanIt>::pointer,
		typename iterator_traits<_RanIt>::reference> > _Mybase;

public:
 	typedef typename iterator_traits<_RanIt>::difference_type difference_type;
	typedef typename iterator_traits<_RanIt>::pointer pointer;
	typedef typename iterator_traits<_RanIt>::reference reference;
	typedef _RanIt iterator_type;

	reverse_iterator()
		{	
		}

	explicit reverse_iterator(_RanIt _Right)
		: _Mybase(_Right)
		{	
		}

	template<class _Other>
		reverse_iterator(const reverse_iterator<_Other>& _Right)
		: _Mybase(_Right.base())
		{	
		}

	template<class _Other>
		_Myt& operator=(const reverse_iterator<_Other>& _Right)
		{	
		this->current = _Right.base();
		return (*this);
		}

	reverse_iterator(_Mybase _Right)
		: _Mybase(_Right)
		{	
		}

	_Myt& operator++()
		{	
		++*((_Mybase *)this);
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		--*((_Mybase *)this);
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myt& operator+=(difference_type _Off)
		{	
		*((_Mybase *)this) += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt& operator-=(difference_type _Off)
		{	
		*((_Mybase *)this) -= _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}
	};

template<class _RanIt>
	struct _Is_checked_helper<reverse_iterator<_RanIt> >
		: public _Is_checked_helper<_RanIt>
	{	
	};

		
template<class _RanIt,
	class _Diff> inline
	reverse_iterator<_RanIt> operator+(_Diff _Off,
		const reverse_iterator<_RanIt>& _Right)
	{	
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _RanIt2>
	auto inline operator-(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
			-> decltype(_Right.base() - _Left.base())
	{	
	return (_Right.base() - _Left.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator==(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Equal(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator!=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Less(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left < _Right));
	}

		
template<class _Ty,
	size_t _Size>
	class _Array_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			_Ty,
			ptrdiff_t,
			const _Ty *,
			const _Ty&,
			_Iterator_base>
	{	
public:
	typedef _Array_const_iterator<_Ty, _Size> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef _Ty value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef const _Ty *pointer;
	typedef const _Ty& reference;
	enum {_EEN_SIZE = _Size};	
	enum {_EEN_IDL =
		0};	

 
	_Array_const_iterator()
		{	
		_Ptr = 0;
		}

	explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
		{	
		_Ptr = _Parg + _Off;
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Ptr);
		}

	reference operator*() const
		{	
		return (*_Ptr);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++_Ptr;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--_Ptr;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		_Ptr += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	
		return (_Ptr - _Right._Ptr);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	
		return (_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	
		return (_Ptr < _Right._Ptr);
		}

	bool operator>(const _Myiter& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	
		return (!(*this < _Right));
		}

	pointer _Ptr;	

 








































































































































































































#line 1640 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"
	};

template<class _Ty,
	size_t _Size> inline
	typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type
		_Unchecked(_Array_const_iterator<_Ty, _Size> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Ty,
	size_t _Size> inline
	_Array_const_iterator<_Ty, _Size>&
		_Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,
			typename _Array_const_iterator<_Ty, _Size>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Ty,
	size_t _Size> inline
	_Array_const_iterator<_Ty, _Size> operator+(
		typename _Array_const_iterator<_Ty, _Size>::difference_type _Off,
		_Array_const_iterator<_Ty, _Size> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Ty,
	size_t _Size>
	class _Array_iterator
		: public _Array_const_iterator<_Ty, _Size>
	{	
public:
	typedef _Array_iterator<_Ty, _Size> _Myiter;
	typedef _Array_const_iterator<_Ty, _Size> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef _Ty value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef _Ty *pointer;
	typedef _Ty& reference;

	_Array_iterator()
		{	
		}

	explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
		: _Mybase(_Parg, _Off)
		{	
		}
	enum {_EEN_SIZE = _Size};	
	enum {_EEN_IDL =
		0};	

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		((_Mybase *)this)->_Rechecked(_Right);
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return ((pointer)((_Mybase *)this)->_Unchecked());
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Ty,
	size_t _Size> inline
	typename _Array_iterator<_Ty, _Size>::_Unchecked_type
		_Unchecked(_Array_iterator<_Ty, _Size> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Ty,
	size_t _Size> inline
	_Array_iterator<_Ty, _Size>&
		_Rechecked(_Array_iterator<_Ty, _Size>& _Iter,
			typename _Array_iterator<_Ty, _Size>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Ty,
	size_t _Size> inline
	_Array_iterator<_Ty, _Size> operator+(
		typename _Array_iterator<_Ty, _Size>::difference_type _Off,
		_Array_iterator<_Ty, _Size> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _RanIt>
	class move_iterator
	{	
public:
	typedef move_iterator<_RanIt> _Myt;
 	typedef typename iterator_traits<_RanIt>::iterator_category
		iterator_category;
 	typedef typename iterator_traits<_RanIt>::value_type
		value_type;
 	typedef typename iterator_traits<_RanIt>::difference_type
		difference_type;
	typedef _RanIt pointer;
	typedef value_type&& reference;
	typedef _RanIt iterator_type;

	move_iterator()
		{	
		}

	explicit move_iterator(iterator_type _Right)
		: current(_Right)
		{	
		}

	template<class _RanIt2>
		move_iterator(const move_iterator<_RanIt2>& _Right)
		: current(_Right.base())
		{	
		}

	template<class _RanIt2>
		_Myt& operator=(const move_iterator<_RanIt2>& _Right)
		{	
		current = _Right.base();
		return (*this);
		}

	_RanIt base() const
		{	
		return (current);
		}

	reference operator*() const
		{	
		return (::std:: move(*current));
		}

	pointer operator->() const
		{	
		return (current);
		}

	_Myt& operator++()
		{	
		++current;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		--current;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	template<class _RanIt2>
		bool _Equal(const move_iterator<_RanIt2>& _Right) const
		{	
		return (current == _Right.base());
		}



	_Myt& operator+=(difference_type _Off)
		{	
		current += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		return (_Myt(current + _Off));
		}

	_Myt& operator-=(difference_type _Off)
		{	
		current -= _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	
		return (_Myt(current - _Off));
		}

	reference operator[](difference_type _Off) const
		{	
		return (::std:: move(current[_Off]));
		}

	template<class _RanIt2>
		bool _Less(const move_iterator<_RanIt2>& _Right) const
		{	
		return (current < _Right.base());
		}

	difference_type operator-(const _Myt& _Right) const
		{	
		return (current - _Right.base());
		}

protected:
	iterator_type current;	
	};

template<class _RanIt>
	struct _Is_checked_helper<move_iterator<_RanIt> >
		: public _Is_checked_helper<_RanIt>
	{	
	};

		
template<class _RanIt,
	class _Diff> inline
	move_iterator<_RanIt>
		operator+(_Diff _Off,
		const move_iterator<_RanIt>& _Right)
	{	
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _RanIt2>
	auto inline operator-(
		move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
			-> decltype(_Left.base() - _Right.base())
	{	
	return (_Left.base() - _Right.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator==(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Equal(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator!=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Less(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left < _Right));
	}

		
template<class _RanIt> inline
	move_iterator<_RanIt> make_move_iterator(_RanIt _Iter)
	{	
	return (move_iterator<_RanIt>(_Iter));
	}

		
		
template<class _Ty> inline

	 

	const _Ty& (max)(const _Ty& _Left, const _Ty& _Right)
	{	
	return (((_Left) < (_Right)) ? _Right : _Left);
	}

		
template<class _Ty,
	class _Pr> inline
	const _Ty& (max)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
	{	
	return (_Pred(_Left, _Right) ? _Right : _Left);
	}

		
template<class _Ty> inline

	 

	const _Ty& (min)(const _Ty& _Left, const _Ty& _Right)
	{	
	return (((_Right) < (_Left)) ? _Right : _Left);
	}

		
template<class _Ty,
	class _Pr> inline
	const _Ty& (min)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
	{	
	return (_Pred(_Right, _Left) ? _Right : _Left);
	}

		
template<class _Ty> inline
	pair<const _Ty&, const _Ty&>
		minmax(const _Ty& _Left, const _Ty& _Right)
	{	
	return (_Right < _Left
		? pair<const _Ty&, const _Ty&>(_Right, _Left)
		: pair<const _Ty&, const _Ty&>(_Left, _Right));
	}

		
template<class _Ty,
	class _Pr> inline
	pair<const _Ty&, const _Ty&>
		minmax(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
	{	
	return (_Pred(_Right, _Left)
		? pair<const _Ty&, const _Ty&>(_Right, _Left)
		: pair<const _Ty&, const _Ty&>(_Left, _Right));
	}

		
template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	for (; _First != _Last; ++_Dest, ++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	return (_Copy_impl(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 
template<class _InIt,
	class _OutIt> inline
	_OutIt copy(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	return (_Rechecked(_Dest,
		_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest))));
	}

 



































































#line 2193 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

 
		
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, input_iterator_tag)
	{	
	*_Dest = *_First;	
	while (0 < --_Count)
		*++_Dest = *++_First;
	return (++_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, forward_iterator_tag)
	{	
	for (; 0 < _Count; --_Count, ++_Dest, ++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	return (_Copy_n(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest)
	{	
	return (_Copy_n(_First, _Count,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest)
	{	
	if (_Count <= 0)
		return (_Dest);
	else
		return (_Rechecked(_Dest,
			_Copy_n(_Unchecked(_First), _Count,
				_Unchecked(_Dest))));
	}

 





















































































































#line 2383 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"
 #line 2384 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

		
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	while (_First != _Last)
		*--_Dest = *--_Last;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_backward(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest - _Count, &*_First,
		_Count * sizeof (*_First));
	return (_Dest - _Count);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	return (_Copy_backward(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	return (_Rechecked(_Dest,
		_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest))));
	}

 





























#line 2458 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

		
template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	for (; _First != _Last; ++_Dest, ++_First)
		*_Dest = ::std:: move(*_First);
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	return (_Move(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 
template<class _InIt,
	class _OutIt> inline
	_OutIt move(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	return (_Rechecked(_Dest,
		_Move(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest))));
	}

 






























































#line 2565 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

		
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	while (_First != _Last)
		*--_Dest = ::std:: move(*--_Last);
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_backward(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest - _Count, &*_First,
		_Count * sizeof (*_First));
	return (_Dest - _Count);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	return (_Move_backward(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	return (_Rechecked(_Dest,
		_Move_backward(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest))));
	}

 





























#line 2639 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

		
template<class _FwdIt,
	class _Ty> inline
	void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	for (; _First != _Last; ++_First)
		*_First = _Val;
	}

inline void _Fill(char *_First, char *_Last, char _Val)
	{	
	:: memset(_First, _Val, _Last - _First);
	}

inline void _Fill(signed char *_First, signed char *_Last, signed char _Val)
	{	
	:: memset(_First, _Val, _Last - _First);
	}

inline void _Fill(unsigned char *_First, unsigned char *_Last, unsigned char _Val)
	{	
	:: memset(_First, _Val, _Last - _First);
	}

template<class _FwdIt,
	class _Ty> inline
	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	;
	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
	}

		
template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
	{	
	for (; 0 < _Count; --_Count, ++_Dest)
		*_Dest = _Val;
	return (_Dest);
	}

inline char *_Fill_n(char *_Dest, size_t _Count, char _Val)
	{	
	:: memset(_Dest, _Val, _Count);
	return (_Dest + _Count);
	}

inline signed char *_Fill_n(signed char *_Dest, size_t _Count,
	signed char _Val)
	{	
	:: memset(_Dest, _Val, _Count);
	return (_Dest + _Count);
	}

inline unsigned char *_Fill_n(unsigned char *_Dest, size_t _Count,
	unsigned char _Val)
	{	
	:: memset(_Dest, _Val, _Count);
	return (_Dest + _Count);
	}

 
template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
	{	
	return (_Rechecked(_Dest, _Fill_n(_Unchecked(_Dest), _Count, _Val)));
	}

 






























































#line 2776 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

		
template<class _InIt1,
	class _InIt2> inline
	pair<_InIt1, _InIt2>
		_Mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2)
	{	
	for (; _First1 != _Last1 && *_First1 == *_First2; )
		++_First1, ++_First2;
	return (pair<_InIt1, _InIt2>(_First1, _First2));
	}

 
template<class _InIt1,
	class _InIt2> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2)
	{	
	pair<typename _Get_unchecked_type<_InIt1>::type, _InIt2> _Ans(
		_Mismatch(_Unchecked(_First1), _Unchecked(_Last1),
			_First2));
	return (pair<_InIt1, _InIt2>(
		_Rechecked(_First1, _Ans.first),
		_Ans.second));
	}

 





















































#line 2859 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		_Mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _Pred(*_First1, *_First2); )
		++_First1, ++_First2;
	return (pair<_InIt1, _InIt2>(_First1, _First2));
	}

 
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr _Pred)
	{	
	pair<typename _Get_unchecked_type<_InIt1>::type, _InIt2> _Ans(
		_Mismatch(_Unchecked(_First1), _Unchecked(_Last1),
			_First2, _Pred));
	return (pair<_InIt1, _InIt2>(
		_Rechecked(_First1, _Ans.first),
		_Ans.second));
	}

 


























































#line 2949 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

		
template<class _InIt1,
	class _InIt2> inline
	bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{	
	for (; _First1 != _Last1; ++_First1, ++_First2)
		if (!(*_First1 == *_First2))
			return (false);
	return (true);
	}

inline bool _Equal(const char *_First1, const char *_Last1,
	const char *_First2)
	{	
	return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

inline bool _Equal(const signed char *_First1, const signed char *_Last1,
	const signed char *_First2)
	{	
	return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1,
	const unsigned char *_First2)
	{	
	return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

 
template<class _InIt1,
	class _InIt2> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2)
	{	
	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2)));
	}

 









































#line 3032 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred)
	{	
	for (; _First1 != _Last1; ++_First1, ++_First2)
		if (!_Pred(*_First1, *_First2))
			return (false);
	return (true);
	}

 
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred)
	{	
	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Pred));
	}

 













































#line 3104 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

		
template<class _InIt1,
	class _InIt2> inline
	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (((*_First1) < (*_First2)))
			return (true);
		else if (*_First2 < *_First1)
			return (false);
	return (_First1 == _Last1 && _First2 != _Last2);
	}

inline bool _Lexicographical_compare(
	const unsigned char *_First1, const unsigned char *_Last1,
	const unsigned char *_First2, const unsigned char *_Last2)
	{	
	ptrdiff_t _Num1 = _Last1 - _First1;
	ptrdiff_t _Num2 = _Last2 - _First2;
	int _Ans = :: memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
	return (_Ans < 0 || _Ans == 0 && _Num1 < _Num2);
	}

 









#line 3140 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

template<class _InIt1,
	class _InIt2> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	;
	;
	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2)));
	}

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (_Pred(*_First1, *_First2))
			return (true);
		else if (_Pred(*_First2, *_First1))
			return (false);
	return (_First1 == _Last1 && _First2 != _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	;
	;
	;
	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
	}

		
template<class _InIt,
	class _Ty> inline
	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			break;
	return (_First);
	}

inline const char *_Find(const char *_First, const char *_Last, int _Val)
	{	
	_First = (const char *):: memchr(_First, _Val, _Last - _First);
	return (_First == 0 ? _Last : _First);
	}

inline const signed char *_Find(const signed char *_First,
	const signed char *_Last, int _Val)
	{	
	_First = (const signed char *):: memchr(_First, _Val,
		_Last - _First);
	return (_First == 0 ? _Last : _First);
	}

inline const unsigned char *_Find(const unsigned char *_First,
	const unsigned char *_Last, int _Val)
	{	
	_First = (const unsigned char *):: memchr(_First, _Val,
		_Last - _First);
	return (_First == 0 ? _Last : _First);
	}

template<class _InIt,
	class _Ty> inline
	_InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	;
	return (_Rechecked(_First,
		_Find(_Unchecked(_First), _Unchecked(_Last), _Val)));
	}

		
template<class _InIt,
	class _Ty,
	class _Pr> inline
	_InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First, _Val))
			break;
	return (_First);
	}

		
template<class _InIt,
	class _Ty> inline
	typename iterator_traits<_InIt>::difference_type
		_Count_np(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	typename iterator_traits<_InIt>::difference_type _Count = 0;

	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			++_Count;
	return (_Count);
	}

template<class _InIt,
	class _Ty> inline
	typename iterator_traits<_InIt>::difference_type
		count(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	;
	return (_Count_np(_Unchecked(_First), _Unchecked(_Last), _Val));
	}

		
template<class _InIt,
	class _Ty,
	class _Pr> inline
	typename iterator_traits<_InIt>::difference_type
		_Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
	{	
	typename iterator_traits<_InIt>::difference_type _Count = 0;

	for (; _First != _Last; ++_First)
		if (_Pred(*_First, _Val))
			++_Count;
	return (_Count);
	}

 
		
template<class _FwdIt1,
	class _FwdIt2> inline
	bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2)
	{	
	for (; _First1 != _Last1; ++_First1, ++_First2)
		if (!(*_First1 == *_First2))
			break;	
	if (_First1 != _Last1)
		{	
		_FwdIt2 _Last2 = _First2;
		advance(_Last2, distance(_First1, _Last1));
		for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
			if (_Next1 == _Find(_First1, _Next1, *_Next1))
				{	
				typename iterator_traits<_FwdIt2>::difference_type _Count =
					_Count_np(_First2, _Last2, *_Next1);
				if (_Count == 0
					|| _Count != _Count_np(_Next1, _Last1, *_Next1))
					return (false);	
				}
		}
	return (true);
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2)
	{	
	;
	return _Is_permutation(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2));
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred)
	{	
	for (; _First1 != _Last1; ++_First1, ++_First2)
		if (!_Pred(*_First1, *_First2))
			break;	
	if (_First1 != _Last1)
		{	
		_FwdIt2 _Last2 = _First2;
		advance(_Last2, distance(_First1, _Last1));
		for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
			if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
				{	
				typename iterator_traits<_FwdIt2>::difference_type _Count =
					_Count_pr(_First2, _Last2, *_Next1, _Pred);
				if (_Count == 0
					|| _Count != _Count_pr(_Next1, _Last1, *_Next1, _Pred))
					return (false);	
				}
		}
	return (true);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred)
	{	
	;
	;
	return _Is_permutation(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Pred);
	}
 #line 3348 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

		
template<class _BidIt> inline
	void _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)
	{	
	for (; _First != _Last && _First != --_Last; ++_First)
		::std:: iter_swap(_First, _Last);
	}

template<class _BidIt> inline
	void reverse(_BidIt _First, _BidIt _Last)
	{	
	;
	_Reverse(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
	}

		
template<class _FwdIt> inline
	void _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		forward_iterator_tag)
	{	
	for (_FwdIt _Next = _Mid; ; )
		{	
		::std:: iter_swap(_First, _Next);
		if (++_First == _Mid)
			if (++_Next == _Last)
				break;	
			else
				_Mid = _Next;	
		else if (++_Next == _Last)
			_Next = _Mid;	
		}
	}

template<class _BidIt> inline
	void _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		bidirectional_iterator_tag)
	{	
	::std:: reverse(_First, _Mid);
	::std:: reverse(_Mid, _Last);
	::std:: reverse(_First, _Last);
	}

template<class _RanIt,
	class _Diff,
	class _Ty> inline
	void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Diff *, _Ty *)
	{	
	_Diff _Shift = _Mid - _First;
	_Diff _Count = _Last - _First;

	for (_Diff _Factor = _Shift; _Factor != 0; )
		{	
		_Diff _Tmp = _Count % _Factor;
		_Count = _Factor;
		_Factor = _Tmp;
		}

	if (_Count < _Last - _First)
		for (; 0 < _Count; --_Count)
			{	
			_RanIt _Hole = _First + _Count;
			_RanIt _Next = _Hole;
			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;
			for (; ; )
				{	
				iter_swap(_Next, _Next1);
				_Next = _Next1;
				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
					: _First + (_Shift - (_Last - _Next1));
				if (_Next1 == _Hole)
					break;
				}
			}
	}

template<class _RanIt> inline
	void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last,
		random_access_iterator_tag)
	{	
	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));
	}

template<class _FwdIt> inline
	_FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
	{	
	;
	;
	if (_First != _Mid && _Mid != _Last)
		_Rotate(_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last),
			_Iter_cat(_First));
	::std:: advance(_First, ::std:: distance(_Mid, _Last));
	return (_First);
	}

	
template<class _Diff, class _Urng>
	class _Rng_from_urng
	{	
public:
 
	typedef typename make_unsigned<_Diff>::type _Ty0;
	typedef typename _Urng::result_type _Ty1;

	typedef typename _If<sizeof (_Ty1) < sizeof (_Ty0),
		_Ty0, _Ty1>::type _Udiff;

 

#line 3458 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

	explicit _Rng_from_urng(_Urng& _Func)
		: _Ref(_Func), _Bits(8 * sizeof (_Udiff)), _Bmask(_Udiff(-1))
		{	
		for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
			--_Bits;
		}

	_Diff operator()(_Diff _Index)
		{	
		for (; ; )
			{	
			_Udiff _Ret = 0;	
			_Udiff _Mask = 0;	

			while (_Mask < _Udiff(_Index - 1))
				{	
				_Ret <<= _Bits;
				_Ret |= _Get_bits();
				_Mask <<= _Bits;
				_Mask |= _Bmask;
				}

			
			if (_Ret / _Index < _Mask / _Index
				|| _Mask % _Index == _Udiff(_Index - 1))
				return (_Ret % _Index);
			}
		}

	_Udiff _Get_all_bits()
		{	
		_Udiff _Ret = 0;

		for (size_t _Num = 0; _Num < 8 * sizeof (_Udiff);
			_Num += _Bits)
			{	
			_Ret <<= _Bits;
			_Ret |= _Get_bits();
			}

		return (_Ret);
		}

private:
	_Udiff _Get_bits()
		{	
		for (; ; )
			{	
			_Udiff _Val = _Ref() - (_Urng::min)();

			if (_Val <= _Bmask)
				return (_Val);
			}
		}

	_Urng& _Ref;	
	size_t _Bits;	
	_Udiff _Bmask;	

	_Rng_from_urng(const _Rng_from_urng&);	
	_Rng_from_urng& operator=(const _Rng_from_urng&);	
	};

		
template<class _Elem>
	class __declspec(dllimport) _Yarn
	{	
public:
	typedef _Yarn<_Elem> _Myt;

	 _Yarn()
		: _Myptr(0), _Nul(0)
		{	
		}

	 _Yarn(const _Myt& _Right)
		: _Myptr(0), _Nul(0)
		{	
		*this = _Right;
		}

	 _Yarn(const _Elem *_Right)
		: _Myptr(0), _Nul(0)
		{	
		*this = _Right;
		}

	_Myt&  operator=(const _Myt& _Right)
		{	
		return (*this = _Right._Myptr);
		}

	_Myt&  operator=(const _Elem *_Right)
		{	
		if (_Myptr != _Right)
			{	
			_Tidy();

			if (_Right != 0)
				{	
				const _Elem *_Ptr = _Right;
				while (*_Ptr != (_Elem)0)
					++_Ptr;
				size_t _Count = ((const char *)++_Ptr - (const char *)_Right);

 




				_Myptr = (_Elem *):: malloc(_Count);
 #line 3571 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

				if (_Myptr != 0)
					:: memcpy(_Myptr, _Right, _Count);
				}
			}
		return (*this);
		}

	 ~_Yarn() throw ()
		{	
		_Tidy();
		}

	bool  empty() const
		{	
		return (_Myptr == 0);
		}

	const _Elem * c_str() const
		{	
		return (_Myptr != 0 ? _Myptr : &_Nul);
		}

	bool  _Empty() const
		{	
		return (_Myptr == 0);
		}

	const _Elem * _C_str() const
		{	
		return (_Myptr != 0 ? _Myptr : &_Nul);
		}

private:
	void  _Tidy()
		{	
		if (_Myptr != 0)

 



			:: free(_Myptr);
 #line 3615 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

		_Myptr = 0;
		}

	_Elem *_Myptr;	
	_Elem _Nul;		
	};

	
template<class _Ty,
	class _Alloc>
	struct _Has_allocator_type
	{	
	template<class _Uty>
		static auto _Fn(int)
			-> is_convertible<_Alloc,
				typename _Uty::allocator_type>;
	template<class _Uty>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<_Ty>(0)) type;
	};

		
struct allocator_arg_t
	{	
	};

const allocator_arg_t allocator_arg = allocator_arg_t();

__declspec(dllimport) __declspec(noreturn) void __cdecl _Xbad_alloc();
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xinvalid_argument(  const char *);
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xlength_error(  const char *);
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xout_of_range(  const char *);
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xoverflow_error(  const char *);
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xruntime_error(  const char *);
}

 
namespace std {
		
template<class _Ty,
	class _Alloc>
	struct uses_allocator
		: _Has_allocator_type<_Ty, _Alloc>::type
	{	
	};
}	
 #line 3665 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 3670 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"
#line 3671 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xutility"























#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4100 4345)

namespace std {
		
template<class _Ty> inline
	_Ty *_Allocate(size_t _Count, _Ty *)
	{	
	void *_Ptr = 0;

	if (_Count == 0)
		;
	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)
		_Xbad_alloc();	

	return ((_Ty *)_Ptr);
	}

		
template<class _Ty1,
	class _Ty2> inline
	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
	{	
	void *_Vptr = _Ptr;
	::new (_Vptr) _Ty1(::std:: forward<_Ty2>(_Val));
	}

template<class _Ty1> inline
	void _Construct(_Ty1 *_Ptr)
	{	
	void *_Vptr = _Ptr;

	::new (_Vptr) _Ty1();
	}

		
template<class _Ty> inline
	void _Destroy(_Ty *_Ptr)
	{	
	_Ptr->~_Ty();
	}

template<> inline
	void _Destroy(char *)
	{	
	}

template<> inline
	void _Destroy(wchar_t *)
	{	
	}

 
template<> inline
	void _Destroy(unsigned short *)
	{	
	}
 #line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

		
template<class _Alloc> inline
	void _Destroy_range(typename _Alloc::pointer _First,
		typename _Alloc::pointer _Last, _Alloc& _Al)
	{	
	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
	}

template<class _Alloc> inline
	void _Destroy_range(typename _Alloc::pointer _First,
		typename _Alloc::pointer _Last, _Alloc& _Al,
		_Nonscalar_ptr_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		_Al.destroy(_First);
	}

template<class _Alloc> inline
	void _Destroy_range(typename _Alloc::pointer _First,
		typename _Alloc::pointer _Last, _Alloc& _Al,
		_Scalar_ptr_iterator_tag)
	{	
	}

		
template<class _Alty>
	struct _Is_simple_alloc
		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
		&& is_same<typename _Alty::pointer,
			typename _Alty::value_type *>::value
		&& is_same<typename _Alty::const_pointer,
			const typename _Alty::value_type *>::value
		&& is_same<typename _Alty::reference,
			typename _Alty::value_type&>::value
		&& is_same<typename _Alty::const_reference,
			const typename _Alty::value_type&>::value>
	{	
	};

		
template<class _Value_type>
	struct _Simple_types
	{	
	typedef _Value_type value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef value_type *pointer;
	typedef const value_type *const_pointer;
	typedef value_type& reference;
	typedef const value_type& const_reference;
	};

 
		
template<class _Alty,
	class _Pointer>
	struct _Get_voidptr
	{	
	typedef typename _Alty::template rebind<void>::other _Alvoid;
	typedef typename _Alvoid::pointer type;
	};

template<class _Alty,
	class _Ty>
	struct _Get_voidptr<_Alty, _Ty *>
	{	
	typedef void *type;
	};

		
template<class _Iter>
	struct _Is_iterator
	: public integral_constant<bool, !is_integral<_Iter>::value>
	{	
	};

		
template<class _Ty>
	struct pointer_traits;

template<class _Ty>
	struct _Get_first_parameter
	{	
	typedef typename _Ty::element_type type;
	};

		
template<class _Newfirst,
	class _Ty>
	struct _Replace_first_parameter
	{	
	typedef typename _Ty::template rebind<_Newfirst>::other type;
	};

		
template<class _Ty>
	struct _Get_element_type
	{ template<class _Uty> static auto _Fn(int) -> typename _Uty::element_type; template<class _Uty> static auto _Fn(_Wrap_int) -> typename _Get_first_parameter<_Ty>::type; typedef decltype(_Fn<_Ty>(0)) type; };
#line 175 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_ptr_difference_type
	{ template<class _Uty> static auto _Fn(int) -> typename _Uty::difference_type; template<class _Uty> static auto _Fn(_Wrap_int) -> ptrdiff_t; typedef decltype(_Fn<_Ty>(0)) type; };
#line 181 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

		
template<class _Ty,
	class _Other>
	struct _Get_rebind_type
	{ template<class _Uty> static auto _Fn(int) -> typename _Uty::template rebind<_Other>::other; template<class _Uty> static auto _Fn(_Wrap_int) -> typename _Replace_first_parameter<_Other , _Uty>::type; typedef decltype(_Fn<_Ty>(0)) type; };
#line 188 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

		
template<class _Ty>
	struct pointer_traits
	{	
	typedef pointer_traits<_Ty> other;

	typedef typename _Get_element_type<_Ty>::type element_type;
	typedef _Ty pointer;
	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;

	template<class _Other>
		struct rebind
		{	
		typedef typename _Get_rebind_type<_Ty, _Other>::type other;
		};

	static pointer pointer_to(element_type& _Val)
		{	
		return (_Ty::pointer_to(_Val));
		}
	};

		
template<class _Ty>
	struct pointer_traits<_Ty *>
	{	
	typedef pointer_traits<_Ty *> other;

	typedef _Ty element_type;
	typedef _Ty *pointer;
	typedef ptrdiff_t difference_type;

	template<class _Other>
		struct rebind
		{	
		typedef _Other *other;
		};

	typedef typename _If<is_void<_Ty>::value,
		char&,
		typename add_reference<_Ty>::type>::type _Reftype;

	static pointer pointer_to(_Reftype _Val)
		{	
		return (::std:: addressof(_Val));
		}
	};

		
template<class _Ty>
	struct _Get_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> typename _Uty::pointer; template<class _Uty> static auto _Fn(_Wrap_int) -> typename _Ty::value_type *; typedef decltype(_Fn<_Ty>(0)) type; };
#line 242 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_const_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> typename _Uty::const_pointer; template<class _Uty> static auto _Fn(_Wrap_int) -> typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const typename _Ty::value_type>::other; typedef decltype(_Fn<_Ty>(0)) type; };
#line 249 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_void_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> typename _Uty::void_pointer; template<class _Uty> static auto _Fn(_Wrap_int) -> typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<void>::other; typedef decltype(_Fn<_Ty>(0)) type; };
#line 256 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_const_void_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> typename _Uty::const_void_pointer; template<class _Uty> static auto _Fn(_Wrap_int) -> typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const void>::other; typedef decltype(_Fn<_Ty>(0)) type; };
#line 263 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_difference_type
	{ template<class _Uty> static auto _Fn(int) -> typename _Uty::difference_type; template<class _Uty> static auto _Fn(_Wrap_int) -> typename _Get_ptr_difference_type< typename _Get_pointer_type<_Ty>::type>::type; typedef decltype(_Fn<_Ty>(0)) type; };
#line 270 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_size_type
	{ template<class _Uty> static auto _Fn(int) -> typename _Uty::size_type; template<class _Uty> static auto _Fn(_Wrap_int) -> typename make_unsigned< typename _Get_difference_type<_Ty>::type>::type; typedef decltype(_Fn<_Ty>(0)) type; };
#line 277 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_copy
	{ template<class _Uty> static auto _Fn(int) -> typename _Uty::propagate_on_container_copy_assignment; template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; };
#line 283 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_move
	{ template<class _Uty> static auto _Fn(int) -> typename _Uty::propagate_on_container_move_assignment; template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; };
#line 289 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_swap
	{ template<class _Uty> static auto _Fn(int) -> typename _Uty::propagate_on_container_swap; template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; };
#line 295 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

		
struct _Alloc_allocate
	{	
		

	template<class _Alloc,
		class _Size_type,
		class _Const_void_pointer>
		static auto _Fn(int, _Alloc& _Al,
			_Size_type _Count,
			_Const_void_pointer _Hint)
			-> decltype(_Al.allocate(_Count, _Hint))
		{	
		return (_Al.allocate(_Count, _Hint));
		}

	template<class _Alloc,
		class _Size_type,
		class _Const_void_pointer>
		static auto _Fn(_Wrap_int, _Alloc& _Al,
			_Size_type _Count,
			_Const_void_pointer)
			-> decltype(_Al.allocate(_Count))
		{	
		return (_Al.allocate(_Count));
		}
	};

		
struct _Alloc_construct
	{	
		






















template<class _Ty, class _Objty  > static auto _Fn(int, _Ty& _Al, _Objty *_Ptr  ) -> decltype( _Al.construct(_Ptr  )) { _Al.construct(_Ptr  ); } template<class _Ty, class _Objty  > static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr  ) -> void { ::new (static_cast<void *>(_Ptr)) _Objty(); } template<class _Ty, class _Objty , class _V0_t> static auto _Fn(int, _Ty& _Al, _Objty *_Ptr , _V0_t&& _V0) -> decltype( _Al.construct(_Ptr , ::std:: forward<_V0_t>(_V0))) { _Al.construct(_Ptr , ::std:: forward<_V0_t>(_V0)); } template<class _Ty, class _Objty , class _V0_t> static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr , _V0_t&& _V0) -> void { ::new (static_cast<void *>(_Ptr)) _Objty(::std:: forward<_V0_t>(_V0)); } template<class _Ty, class _Objty , class _V0_t , class _V1_t> static auto _Fn(int, _Ty& _Al, _Objty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1) -> decltype( _Al.construct(_Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1))) { _Al.construct(_Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1)); } template<class _Ty, class _Objty , class _V0_t , class _V1_t> static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1) -> void { ::new (static_cast<void *>(_Ptr)) _Objty(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1)); } template<class _Ty, class _Objty , class _V0_t , class _V1_t , class _V2_t> static auto _Fn(int, _Ty& _Al, _Objty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2) -> decltype( _Al.construct(_Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2))) { _Al.construct(_Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2)); } template<class _Ty, class _Objty , class _V0_t , class _V1_t , class _V2_t> static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2) -> void { ::new (static_cast<void *>(_Ptr)) _Objty(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2)); } template<class _Ty, class _Objty , class _V0_t , class _V1_t , class _V2_t , class _V3_t> static auto _Fn(int, _Ty& _Al, _Objty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3) -> decltype( _Al.construct(_Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3))) { _Al.construct(_Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3)); } template<class _Ty, class _Objty , class _V0_t , class _V1_t , class _V2_t , class _V3_t> static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3) -> void { ::new (static_cast<void *>(_Ptr)) _Objty(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3)); } template<class _Ty, class _Objty , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> static auto _Fn(int, _Ty& _Al, _Objty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3 , _V4_t&& _V4) -> decltype( _Al.construct(_Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3) , ::std:: forward<_V4_t>(_V4))) { _Al.construct(_Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3) , ::std:: forward<_V4_t>(_V4)); } template<class _Ty, class _Objty , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3 , _V4_t&& _V4) -> void { ::new (static_cast<void *>(_Ptr)) _Objty(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3) , ::std:: forward<_V4_t>(_V4)); }

	};

		
struct _Alloc_destroy
	{	
	template<class _Ty,
		class _Objty>
		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
			-> decltype(_Al.destroy(_Ptr))
		{	
		_Al.destroy(_Ptr);
		}

	template<class _Ty,
		class _Objty>
		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
			-> void
		{	
		_Ptr->~_Objty();
		}
	};

		
struct _Alloc_max_size
	{	
	template<class _Ty>
		static auto _Fn(int, const _Ty& _Al)
			-> decltype(_Al.max_size())
		{	
		return (_Al.max_size());
		}

	template<class _Ty>
		static auto _Fn(_Wrap_int, const _Ty&)
			-> typename _Get_size_type<_Ty>::type
		{	
		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
		}
	};

		
struct _Alloc_select
	{	
		

	template<class _Ty>
		static auto _Fn(int, const _Ty& _Al)
			-> decltype((_Ty)_Al.select_on_container_copy_construction())
		{	
		return (_Al.select_on_container_copy_construction());
		}

	template<class _Ty>
		static auto _Fn(_Wrap_int, const _Ty& _Al)
			-> _Ty
		{	
		return (_Al);
		}
	};

		
template<class _Alloc>
	struct allocator_traits
	{	
	typedef allocator_traits<_Alloc> other;

	typedef _Alloc allocator_type;
	typedef typename _Alloc::value_type value_type;

	typedef typename _Get_pointer_type<_Alloc>::type
		pointer;
	typedef typename _Get_const_pointer_type<_Alloc>::type
		const_pointer;
	typedef typename _Get_void_pointer_type<_Alloc>::type
		void_pointer;
	typedef typename _Get_const_void_pointer_type<_Alloc>::type
		const_void_pointer;

	typedef typename _Get_size_type<_Alloc>::type size_type;
	typedef typename _Get_difference_type<_Alloc>::type difference_type;

	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
		propagate_on_container_copy_assignment;
	typedef typename _Get_propagate_on_container_move<_Alloc>::type
		propagate_on_container_move_assignment;
	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
		propagate_on_container_swap;

	template<class _Other>
		struct rebind_alloc
		{	
		typedef typename _Get_rebind_type<_Alloc, _Other>::type other;
		};

	template<class _Other>
		struct rebind_traits
		{	
			
		typedef typename rebind_alloc<_Other>::other _Other_alloc;
		typedef allocator_traits<_Other_alloc> other;
		};

	static pointer allocate(_Alloc& _Al, size_type _Count)
		{	
		return (_Al.allocate(_Count));
		}

	static pointer allocate(_Alloc& _Al, size_type _Count,
		const_void_pointer _Hint)
		{	
		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
		}

	static void deallocate(_Alloc& _Al,
		pointer _Ptr, size_type _Count)
		{	
		_Al.deallocate(_Ptr, _Count);
		}










template<class _Ty  > static void construct(_Alloc& _Al, _Ty *_Ptr  ) { _Alloc_construct::_Fn(0, _Al, _Ptr  ); } template<class _Ty , class _V0_t> static void construct(_Alloc& _Al, _Ty *_Ptr , _V0_t&& _V0) { _Alloc_construct::_Fn(0, _Al, _Ptr , ::std:: forward<_V0_t>(_V0)); } template<class _Ty , class _V0_t , class _V1_t> static void construct(_Alloc& _Al, _Ty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1) { _Alloc_construct::_Fn(0, _Al, _Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1)); } template<class _Ty , class _V0_t , class _V1_t , class _V2_t> static void construct(_Alloc& _Al, _Ty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2) { _Alloc_construct::_Fn(0, _Al, _Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2)); } template<class _Ty , class _V0_t , class _V1_t , class _V2_t , class _V3_t> static void construct(_Alloc& _Al, _Ty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3) { _Alloc_construct::_Fn(0, _Al, _Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3)); } template<class _Ty , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> static void construct(_Alloc& _Al, _Ty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3 , _V4_t&& _V4) { _Alloc_construct::_Fn(0, _Al, _Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3) , ::std:: forward<_V4_t>(_V4)); }


	template<class _Ty>
		static void destroy(_Alloc& _Al, _Ty *_Ptr)
		{	
		_Alloc_destroy::_Fn(0, _Al, _Ptr);
		}

	static size_type max_size(const _Alloc& _Al)
		{	
		return (_Alloc_max_size::_Fn(0, _Al));
		}

	static _Alloc select_on_container_copy_construction(
		const _Alloc& _Al)
		{	
		return (_Alloc_select::_Fn(0, _Al));
		}
	};
 #line 501 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

		
template<class _Ty>
	struct _Allocator_base
	{	
	typedef _Ty value_type;
	};

		
template<class _Ty>
	struct _Allocator_base<const _Ty>
	{	
	typedef _Ty value_type;
	};

		
template<class _Ty>
	class allocator
		: public _Allocator_base<_Ty>
	{	
public:
	typedef allocator<_Ty> other;

	typedef _Allocator_base<_Ty> _Mybase;
	typedef typename _Mybase::value_type value_type;

	typedef value_type *pointer;
	typedef const value_type *const_pointer;
	typedef void *void_pointer;
	typedef const void *const_void_pointer;

	typedef value_type& reference;
	typedef const value_type& const_reference;

	typedef size_t size_type;
	typedef ptrdiff_t difference_type;

 
	typedef false_type propagate_on_container_copy_assignment;
	typedef false_type propagate_on_container_move_assignment;
	typedef false_type propagate_on_container_swap;

	allocator<_Ty> select_on_container_copy_construction() const
		{	
		return (*this);
		}
 #line 548 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

	template<class _Other>
		struct rebind
		{	
		typedef allocator<_Other> other;
		};

	pointer address(reference _Val) const throw ()
		{	
		return (::std:: addressof(_Val));
		}

	const_pointer address(const_reference _Val) const throw ()
		{	
		return (::std:: addressof(_Val));
		}

	allocator() throw ()
		{	
		}

	allocator(const allocator<_Ty>&) throw ()
		{	
		}

	template<class _Other>
		allocator(const allocator<_Other>&) throw ()
		{	
		}

	template<class _Other>
		allocator<_Ty>& operator=(const allocator<_Other>&)
		{	
		return (*this);
		}

	void deallocate(pointer _Ptr, size_type)
		{	
		::operator delete(_Ptr);
		}

	pointer allocate(size_type _Count)
		{	
		return (_Allocate(_Count, (pointer)0));
		}

	pointer allocate(size_type _Count, const void *)
		{	
		return (allocate(_Count));
		}

	void construct(_Ty *_Ptr)
		{	
		::new ((void *)_Ptr) _Ty();
		}

	void construct(_Ty *_Ptr, const _Ty& _Val)
		{	
		::new ((void *)_Ptr) _Ty(_Val);
		}









template<class _Objty  > void construct(_Objty *_Ptr  ) { ::new ((void *)_Ptr) _Objty(); } template<class _Objty , class _V0_t> void construct(_Objty *_Ptr , _V0_t&& _V0) { ::new ((void *)_Ptr) _Objty(::std:: forward<_V0_t>(_V0)); } template<class _Objty , class _V0_t , class _V1_t> void construct(_Objty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1) { ::new ((void *)_Ptr) _Objty(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1)); } template<class _Objty , class _V0_t , class _V1_t , class _V2_t> void construct(_Objty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2) { ::new ((void *)_Ptr) _Objty(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2)); } template<class _Objty , class _V0_t , class _V1_t , class _V2_t , class _V3_t> void construct(_Objty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3) { ::new ((void *)_Ptr) _Objty(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3)); } template<class _Objty , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> void construct(_Objty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3 , _V4_t&& _V4) { ::new ((void *)_Ptr) _Objty(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3) , ::std:: forward<_V4_t>(_V4)); }


	template<class _Uty>
		void destroy(_Uty *_Ptr)
		{	
		_Ptr->~_Uty();
		}

	size_t max_size() const throw ()
		{	
		return ((size_t)(-1) / sizeof (_Ty));
		}
	};

		
template<>
	class allocator<void>
	{	
public:
	typedef allocator<void> other;

	typedef void value_type;

	typedef void *pointer;
	typedef const void *const_pointer;
	typedef void *void_pointer;
	typedef const void *const_void_pointer;

	template<class _Other>
		struct rebind
		{	
		typedef allocator<_Other> other;
		};

	allocator() throw ()
		{	
		}

	allocator(const allocator<void>&) throw ()
		{	
		}

	template<class _Other>
		allocator(const allocator<_Other>&) throw ()
		{	
		}

	template<class _Other>
		allocator<void>& operator=(const allocator<_Other>&)
		{	
		return (*this);
		}
	};

template<class _Ty,
	class _Other> inline
	bool operator==(const allocator<_Ty>&,
		const allocator<_Other>&) throw ()
	{	
	return (true);
	}

template<class _Ty,
	class _Other> inline
	bool operator!=(const allocator<_Ty>& _Left,
		const allocator<_Other>& _Right) throw ()
	{	
	return (!(_Left == _Right));
	}

 
		
template<class _Ty>
	struct allocator_traits<allocator<_Ty> >
	{	
	typedef allocator<_Ty> _Alloc;

	typedef allocator_traits<_Alloc> other;

	typedef _Alloc allocator_type;
	typedef typename _Alloc::value_type value_type;

	typedef value_type *pointer;
	typedef const value_type *const_pointer;
	typedef void *void_pointer;
	typedef const void *const_void_pointer;

	typedef size_t size_type;
	typedef ptrdiff_t difference_type;

	typedef false_type propagate_on_container_copy_assignment;
	typedef false_type propagate_on_container_move_assignment;
	typedef false_type propagate_on_container_swap;

	template<class _Other>
		struct rebind_alloc
		{	
		typedef allocator<_Other> other;
		};

	template<class _Other>
		struct rebind_traits
		{	
			
		typedef allocator_traits<allocator<_Other> > other;
		};

	static pointer allocate(_Alloc& _Al, size_type _Count)
		{	
		return (_Al.allocate(_Count));
		}

	static pointer allocate(_Alloc& _Al, size_type _Count,
		const_void_pointer _Hint)
		{	
		return (_Al.allocate(_Count, _Hint));
		}

	static void deallocate(_Alloc& _Al,
		pointer _Ptr, size_type _Count)
		{	
		_Al.deallocate(_Ptr, _Count);
		}










template<class _Objty  > static void construct(_Alloc& _Al, _Objty *_Ptr  ) { _Al.construct(_Ptr  ); } template<class _Objty , class _V0_t> static void construct(_Alloc& _Al, _Objty *_Ptr , _V0_t&& _V0) { _Al.construct(_Ptr , ::std:: forward<_V0_t>(_V0)); } template<class _Objty , class _V0_t , class _V1_t> static void construct(_Alloc& _Al, _Objty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1) { _Al.construct(_Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1)); } template<class _Objty , class _V0_t , class _V1_t , class _V2_t> static void construct(_Alloc& _Al, _Objty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2) { _Al.construct(_Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2)); } template<class _Objty , class _V0_t , class _V1_t , class _V2_t , class _V3_t> static void construct(_Alloc& _Al, _Objty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3) { _Al.construct(_Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3)); } template<class _Objty , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> static void construct(_Alloc& _Al, _Objty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3 , _V4_t&& _V4) { _Al.construct(_Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3) , ::std:: forward<_V4_t>(_V4)); }


	template<class _Uty>
		static void destroy(_Alloc& _Al, _Uty *_Ptr)
		{	
		_Al.destroy(_Ptr);
		}

	static size_type max_size(const _Alloc& _Al)
		{	
		return (_Al.max_size());
		}

	static _Alloc select_on_container_copy_construction(
		const _Alloc& _Al)
		{	
		return (_Al.select_on_container_copy_construction());
		}
	};
 #line 772 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

		
template<class _Alloc>
	struct _Wrap_alloc
		: public _Alloc
	{	
	typedef _Wrap_alloc<_Alloc> other;

	typedef _Alloc _Mybase;
	typedef allocator_traits<_Alloc> _Mytraits;

	typedef typename _Mytraits::value_type value_type;

	typedef typename _Mytraits::pointer pointer;
	typedef typename _Mytraits::const_pointer const_pointer;
	typedef typename _Mytraits::void_pointer void_pointer;
	typedef typename _Mytraits::const_void_pointer const_void_pointer;

	typedef typename _If<is_void<value_type>::value,
		int, value_type>::type& reference;
	typedef typename _If<is_void<const value_type>::value,
		const int, const value_type>::type& const_reference;

	typedef typename _Mytraits::size_type size_type;
	typedef typename _Mytraits::difference_type difference_type;

	typedef typename _Mytraits::propagate_on_container_copy_assignment
		propagate_on_container_copy_assignment;
	typedef typename _Mytraits::propagate_on_container_move_assignment
		propagate_on_container_move_assignment;
	typedef typename _Mytraits::propagate_on_container_swap
		propagate_on_container_swap;

	_Wrap_alloc select_on_container_copy_construction() const
		{	
		return (_Mytraits::select_on_container_copy_construction(*this));
		}

	template<class _Other>
		struct rebind
		{	
		typedef typename _Mytraits::template rebind_alloc<_Other>::other
			_Other_alloc;
		typedef _Wrap_alloc<_Other_alloc> other;
		};

	pointer address(reference _Val) const
		{	
		return (::std:: addressof(_Val));
		}

	const_pointer address(const_reference _Val) const
		{	
		return (::std:: addressof(_Val));
		}

	_Wrap_alloc() throw ()
		: _Mybase()
		{	
		}

	_Wrap_alloc(const _Mybase& _Right) throw ()
		: _Mybase(_Right)
		{	
		}

	_Wrap_alloc(const _Wrap_alloc& _Right) throw ()
		: _Mybase(_Right)
		{	
		}

	template<class _Other>
		_Wrap_alloc(const _Other& _Right) throw ()
		: _Mybase(_Right)
		{	
		}

	template<class _Other>
		_Wrap_alloc(_Other& _Right) throw ()
		: _Mybase(_Right)
		{	
		}

	_Wrap_alloc& operator=(const _Mybase& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	_Wrap_alloc& operator=(const _Wrap_alloc& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	template<class _Other>
		_Wrap_alloc& operator=(const _Other& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	pointer allocate(size_type _Count)
		{	
		return (_Mybase::allocate(_Count));
		}

	pointer allocate(size_type _Count,
		const_void_pointer _Hint)
		{	
		return (_Mytraits::allocate(*this, _Count, _Hint));
		}

	void deallocate(pointer _Ptr, size_type _Count)
		{	
		_Mybase::deallocate(_Ptr, _Count);
		}

	void construct(value_type *_Ptr)
		{	
		_Mytraits::construct(*this, _Ptr);
		}









template<class _Ty  > void construct(_Ty *_Ptr  ) { _Mytraits::construct(*this, _Ptr  ); } template<class _Ty , class _V0_t> void construct(_Ty *_Ptr , _V0_t&& _V0) { _Mytraits::construct(*this, _Ptr , ::std:: forward<_V0_t>(_V0)); } template<class _Ty , class _V0_t , class _V1_t> void construct(_Ty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1) { _Mytraits::construct(*this, _Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1)); } template<class _Ty , class _V0_t , class _V1_t , class _V2_t> void construct(_Ty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2) { _Mytraits::construct(*this, _Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2)); } template<class _Ty , class _V0_t , class _V1_t , class _V2_t , class _V3_t> void construct(_Ty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3) { _Mytraits::construct(*this, _Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3)); } template<class _Ty , class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> void construct(_Ty *_Ptr , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3 , _V4_t&& _V4) { _Mytraits::construct(*this, _Ptr , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3) , ::std:: forward<_V4_t>(_V4)); }


	template<class _Ty>
		void destroy(_Ty *_Ptr)
		{	
		_Mytraits::destroy(*this, _Ptr);
		}

	size_type max_size() const throw ()
		{	
		return (_Mytraits::max_size(*this));
		}
	};

template<class _Ty,
	class _Other> inline
	bool operator==(const _Wrap_alloc<_Ty>& _Left,
		const _Wrap_alloc<_Other>& _Right) throw ()
	{	
	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));
	}

template<class _Ty,
	class _Other> inline
	bool operator!=(const _Wrap_alloc<_Ty>& _Left,
		const _Wrap_alloc<_Other>& _Right) throw ()
	{	
	return (!(_Left == _Right));
	}
}

		
 
 
 #line 939 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

  
   #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xatomic0.h"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {
 
  
 #line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xatomic0.h"

		
typedef enum memory_order {
	memory_order_relaxed,
	memory_order_consume,
	memory_order_acquire,
	memory_order_release,
	memory_order_acq_rel,
	memory_order_seq_cst
	} memory_order;

typedef _Uint32t _Uint4_t;
typedef _Uint4_t _Atomic_integral_t;

	
	




  
  
  
  
  

  
   

   
	
   #line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xatomic0.h"

  







#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xatomic0.h"

  
   
  #line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xatomic0.h"

  

#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xatomic0.h"

		

typedef long _Atomic_flag_t;

  
  
  

		
inline _Uint4_t _Atomic_load_4(volatile _Uint4_t *, memory_order);
inline int _Atomic_compare_exchange_weak_4(
	volatile _Uint4_t *, _Uint4_t *, _Uint4_t, memory_order, memory_order);
inline _Uint4_t _Atomic_fetch_add_4(
	volatile _Uint4_t *, _Uint4_t, memory_order);
inline _Uint4_t _Atomic_fetch_sub_4(
	volatile _Uint4_t *, _Uint4_t, memory_order);

__declspec(dllimport) _Uint4_t __cdecl _Atomic_load_4_locking(volatile _Atomic_flag_t *,
	_Uint4_t *, memory_order);
__declspec(dllimport) int __cdecl _Atomic_compare_exchange_weak_4_locking(
	volatile _Atomic_flag_t *, _Uint4_t *, _Uint4_t *, _Uint4_t,
		memory_order, memory_order);
__declspec(dllimport) _Uint4_t __cdecl _Atomic_fetch_add_4_locking(volatile _Atomic_flag_t *,
	_Uint4_t *, _Uint4_t, memory_order);
__declspec(dllimport) _Uint4_t __cdecl _Atomic_fetch_sub_4_locking(volatile _Atomic_flag_t *,
	_Uint4_t *, _Uint4_t, memory_order);

 















































































































#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xatomic0.h"
typedef _Atomic_integral_t _Atomic_counter_t;

  
inline _Atomic_integral_t
	_Get_atomic_count(const _Atomic_counter_t& _Counter)
	{	
	return (_Counter);
	}

inline void _Init_atomic_counter(_Atomic_counter_t& _Counter,
	_Atomic_integral_t _Value)
	{	
	_Counter = _Value;
	}

inline _Atomic_integral_t _Inc_atomic_counter_explicit(
	_Atomic_counter_t& _Counter, memory_order _Order)
	{	
	return (_Atomic_fetch_add_4(&_Counter, 1, _Order) + 1);
	}

inline _Atomic_integral_t _Inc_atomic_counter(_Atomic_counter_t& _Counter)
	{	
	return (_Inc_atomic_counter_explicit(_Counter, memory_order_seq_cst));
	}

inline _Atomic_integral_t _Dec_atomic_counter_explicit(
	_Atomic_counter_t& _Counter, memory_order _Order)
	{	
	return (_Atomic_fetch_sub_4(&_Counter, 1, _Order) - 1);
	}

inline _Atomic_integral_t _Dec_atomic_counter(_Atomic_counter_t& _Counter)
	{	
	return (_Dec_atomic_counter_explicit(_Counter, memory_order_seq_cst));
	}

inline _Atomic_integral_t _Load_atomic_counter_explicit(
	_Atomic_counter_t& _Counter, memory_order _Order)
	{	
	return (_Atomic_load_4(&_Counter, _Order));
	}

inline _Atomic_integral_t _Load_atomic_counter(_Atomic_counter_t& _Counter)
	{	
	return (_Load_atomic_counter_explicit(_Counter, memory_order_seq_cst));
	}

inline _Atomic_integral_t _Compare_increment_atomic_counter_explicit(
	_Atomic_counter_t& _Counter,
	_Atomic_integral_t _Expected,
	memory_order _Order)
	{	
	return (_Atomic_compare_exchange_weak_4(
		&_Counter, &_Expected, _Expected + 1,
		_Order, _Order));
	}

inline _Atomic_integral_t _Compare_increment_atomic_counter(
	_Atomic_counter_t& _Counter, _Atomic_integral_t _Expected)
	{	
	return (_Compare_increment_atomic_counter_explicit(
		_Counter, _Expected, memory_order_seq_cst));
	}

  































#line 305 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xatomic0.h"
 #line 306 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xatomic0.h"

		
extern "C" {
__declspec(dllimport) void __cdecl _Lock_shared_ptr_spin_lock();
__declspec(dllimport) void __cdecl _Unlock_shared_ptr_spin_lock();
}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 317 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xatomic0.h"
#line 318 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xatomic0.h"





#line 942 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"
   

   
   
  




#line 952 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 957 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"
#line 958 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory0"






















#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4700)

namespace std {
		
template<class _Ty> inline
	pair<_Ty *, ptrdiff_t>

		get_temporary_buffer(ptrdiff_t _Count) throw ()

	{	
	_Ty *_Pbuf;

	if (_Count < 0)
		_Count = 0;
	else if (((size_t)(-1) / sizeof (_Ty) < _Count))
		_Xbad_alloc();	
	for (_Pbuf = 0; 0 < _Count; _Count /= 2)
		if ((_Pbuf = (_Ty *)operator new(
			(size_t)_Count * sizeof (_Ty), nothrow)) != 0)
			break;

	return (pair<_Ty *, ptrdiff_t>(_Pbuf, _Count));
	}

		
template<class _Ty> inline
	void return_temporary_buffer(_Ty *_Pbuf)
	{	
	operator delete(_Pbuf);
	}

		
template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, input_iterator_tag)
	{	
	_FwdIt _Next = _Dest;

	try {
	_Construct(&*_Dest, *_First);	
	while (0 < --_Count)
		_Construct(&*++_Dest, *++_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Destroy(&*_Next);
	throw;
	}
	return (++_Dest);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, forward_iterator_tag)
	{	
	_FwdIt _Next = _Dest;

	try {
	for (; 0 < _Count; --_Count, ++_Dest, ++_First)
		_Construct(&*_Dest, *_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Destroy(&*_Next);
	throw;
	}
	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	return (_Uninitialized_copy_n(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest)
	{	
	return (_Uninitialized_copy_n(_First, _Count,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 
template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest)
	{	
	if (_Count <= 0)
		return (_Dest);
	else
		return (_Rechecked(_Dest,
			_Uninitialized_copy_n(_First, _Count,
				_Unchecked(_Dest))));
	}

 





















































































































#line 249 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory"

		
template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, ++_First)
		_Construct(&*_Dest, *_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Destroy(&*_Next);
	throw;
	}
	return (_Dest);
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest)
	{	
	return (_Uninitialized_copy0(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 
template<class _InIt,
	class _FwdIt> inline
	_FwdIt uninitialized_copy(_InIt _First, _InIt _Last,
		_FwdIt _Dest)
	{	
	return (_Rechecked(_Dest,
		_Uninitialized_copy0(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest))));
	}

 






























































#line 364 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory"

		
template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al, _Nonscalar_ptr_iterator_tag)
	{	
	;
	;
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, ++_First)
		_Al.construct(_Dest, *_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Al.destroy(_Next);
	throw;
	}
	return (_Dest);
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al, _Scalar_ptr_iterator_tag)
	{	
	return (_Uninit_copy(_First, _Last, _Dest,
		_Al, _Nonscalar_ptr_iterator_tag()));
	}

template<class _Ty1,
	class _Ty2> inline
	_Ty2 *_Uninit_copy(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
		_Wrap_alloc<allocator<_Ty2> >&, _Scalar_ptr_iterator_tag)
	{	
	;
	;
	size_t _Count = (size_t)(_Last - _First);
	return ((_Ty2 *):: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First)) + _Count);	
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (_Uninit_copy(_First, _Last, _Dest, _Al,
		_Ptr_cat(_First, _Dest)));
	}

		
template<class _InIt,
	class _FwdIt,
	class _Alloc,
	class _Valty> inline
	_FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al, _Valty *, _Nonscalar_ptr_iterator_tag)
	{	
	;
	;
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, ++_First)
		_Al.construct(_Dest, (_Valty&&)*_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Al.destroy(_Next);
	throw;
	}
	return (_Dest);
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc,
	class _Valty> inline
	_FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al, _Valty *, _Scalar_ptr_iterator_tag)
	{	
	return (_Uninit_move(_First, _Last, _Dest,
		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));
	}

template<class _Ty1,
	class _Ty2,
	class _Valty> inline
	_Ty2 *_Uninit_move(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
		_Wrap_alloc<allocator<_Ty2> >&, _Valty *, _Scalar_ptr_iterator_tag)
	{	
	;
	;
	size_t _Count = (size_t)(_Last - _First);
	return ((_Ty2 *):: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First)) + _Count);	
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (_Uninit_move(_First, _Last, _Dest, _Al,
		_Val_type(_First), _Ptr_cat(_First, _Dest)));
	}

		
template<class _FwdIt,
	class _Tval> inline
	void _Uninit_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val,
		_Nonscalar_ptr_iterator_tag)
	{	
	;
	_FwdIt _Next = _First;

	try {
	for (; _First != _Last; ++_First)
		_Construct(&*_First, _Val);
	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Destroy(&*_Next);
	throw;
	}
	}

template<class _Ty,
	class _Tval> inline
	void _Uninit_fill(_Ty *_First, _Ty *_Last, const _Tval& _Val,
		_Scalar_ptr_iterator_tag)
	{	
	::std:: fill(_First, _Last, _Val);
	}

template<class _FwdIt,
	class _Tval> inline
	void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
	{	
	_Uninit_fill(_First, _Last, _Val, _Ptr_cat(_First, _First));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val,
		_Nonscalar_ptr_iterator_tag)
	{	
 


#line 521 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory"

	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, ++_First)
		_Construct(&*_First, _Val);
	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Destroy(&*_Next);
	throw;
	}

	return (_First);
	}

template<class _Ty,
	class _Diff,
	class _Tval> inline
	_Ty *_Uninit_fill_n(_Ty *_First, _Diff _Count, const _Tval& _Val,
		_Scalar_ptr_iterator_tag)
	{	
	return (_Fill_n(_First, _Count, _Val));
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val)
	{	
	return (_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat(_First, _First)));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc,
	class _Valty> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval *_Pval, _Wrap_alloc<_Alloc>& _Al,
			_Valty *, _Nonscalar_ptr_iterator_tag)
	{	
 


#line 568 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory"

	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, ++_First)
		_Al.construct(_First, *_Pval);
	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Al.destroy(_Next);
	throw;
	}
	}

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc,
	class _Valty> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval *_Pval, _Wrap_alloc<_Alloc>& _Al,
			_Valty *, _Scalar_ptr_iterator_tag)
	{	
	_Uninit_fill_n(_First, _Count,
		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());
	}

template<class _Ty,
	class _Diff,
	class _Tval,
	class _Valty> inline
	void _Uninit_fill_n(_Ty *_First, _Diff _Count,
		const _Tval *_Pval, _Wrap_alloc<allocator<_Ty> >&,
			_Valty *, _Scalar_ptr_iterator_tag)
	{	
	_Fill_n(_First, _Count, *_Pval);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc> inline
	void _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval *_Pval, _Alloc& _Al)
	{	
	_Uninit_fill_n(_First, _Count, _Pval, _Al,
		_Val_type(_First), _Ptr_cat(_First, _First));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Alloc,
	class _Valty> inline
	void _Uninit_def_fill_n(_FwdIt _First, _Diff _Count,
		_Wrap_alloc<_Alloc>& _Al, _Valty *, _Nonscalar_ptr_iterator_tag)
	{	
 


#line 628 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory"

	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, ++_First)

		_Al.construct(_First);

	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Al.destroy(_Next);
	throw;
	}
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc,
	class _Valty> inline
	void _Uninit_def_fill_n(_FwdIt _First, _Diff _Count,
		_Wrap_alloc<_Alloc>& _Al, _Valty *, _Scalar_ptr_iterator_tag)
	{	
	_Uninit_def_fill_n(_First, _Count,
		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());
	}

template<class _Ty,
	class _Diff,
	class _Valty> inline
	void _Uninit_def_fill_n(_Ty *_First, _Diff _Count,
		_Wrap_alloc<allocator<_Ty> >&, _Valty *, _Scalar_ptr_iterator_tag)
	{	
	_Fill_n(_First, _Count, (_Valty)0);
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	void _Uninitialized_default_fill_n(_FwdIt _First, _Diff _Count,
		_Alloc& _Al)
	{	
	_Uninit_def_fill_n(_First, _Count, _Al,
		_Val_type(_First), _Ptr_cat(_First, _First));
	}

		
template<class _OutIt,
	class _Ty>
	class raw_storage_iterator
		: public _Outit
	{	
public:
	typedef _OutIt iterator_type;	
	typedef _OutIt iter_type;	
	typedef _Ty element_type;	

	explicit raw_storage_iterator(_OutIt _First)
		: _Next(_First)
		{	
		}

	raw_storage_iterator<_OutIt, _Ty>& operator*()
		{	
		return (*this);
		}

	raw_storage_iterator<_OutIt, _Ty>& operator=(const _Ty& _Val)
		{	
		_Construct(&*_Next, _Val);
		return (*this);
		}

	raw_storage_iterator<_OutIt, _Ty>& operator++()
		{	
		++_Next;
		return (*this);
		}

	raw_storage_iterator<_OutIt, _Ty> operator++(int)
		{	
		raw_storage_iterator<_OutIt, _Ty> _Ans = *this;
		++_Next;
		return (_Ans);
		}

private:
	_OutIt _Next;	
	};

		
template<class _Ty>
	class _Temp_iterator
		: public _Outit
	{	
public:
	typedef _Ty *_Pty;

	_Temp_iterator(ptrdiff_t _Count = 0)
		{	
		_Buf._Begin = 0;
		_Buf._Current = 0;
		_Buf._Hiwater = 0;
		_Buf._Size = _Count;	
		_Pbuf = &_Buf;
		}

	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)
		{	
		_Buf._Begin = 0;	
		_Buf._Current = 0;
		_Buf._Hiwater = 0;
		_Buf._Size = 0;
		*this = _Right;
		}

	~_Temp_iterator() throw ()
		{	
		if (_Buf._Begin != 0)
			{	
			for (_Pty _Next = _Buf._Begin;
				_Next != _Buf._Hiwater; ++_Next)
				_Destroy(&*_Next);
			::std:: return_temporary_buffer(_Buf._Begin);
			}
		}

	_Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
		{	
		_Pbuf = _Right._Pbuf;
		return (*this);
		}

	_Temp_iterator<_Ty>& operator=(const _Ty& _Val)
		{	
		if (_Pbuf->_Current < _Pbuf->_Hiwater)
			*_Pbuf->_Current++ = _Val;	
		else
			{	
			_Pty _Ptr = &*_Pbuf->_Current;
			_Construct(_Ptr, _Val);
			_Pbuf->_Hiwater = ++_Pbuf->_Current;
			}
		return (*this);
		}

	_Temp_iterator<_Ty>& operator=(_Ty&& _Val)
		{	
		if (_Pbuf->_Current < _Pbuf->_Hiwater)
			*_Pbuf->_Current++ =
				::std:: forward<_Ty>(_Val);	
		else
			{	
			_Pty _Ptr = &*_Pbuf->_Current;
			_Construct(_Ptr, ::std:: forward<_Ty>(_Val));
			_Pbuf->_Hiwater = ++_Pbuf->_Current;
			}
		return (*this);
		}

	_Temp_iterator<_Ty>& operator*()
		{	
		return (*this);
		}

	_Temp_iterator<_Ty>& operator++()
		{	
		return (*this);
		}

	_Temp_iterator<_Ty>& operator++(int)
		{	
		return (*this);
		}

	_Temp_iterator<_Ty>& _Init()
		{	
		_Pbuf->_Current = _Pbuf->_Begin;
		return (*this);
		}

	_Pty _First() const
		{	
		return (_Pbuf->_Begin);
		}

	_Pty _Last() const
		{	
		return (_Pbuf->_Current);
		}

	ptrdiff_t _Maxlen()
		{	
		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)
			{	
			pair<_Pty, ptrdiff_t> _Pair =

				::std:: get_temporary_buffer<_Ty>(_Pbuf->_Size);

			_Pbuf->_Begin = _Pair.first;
			_Pbuf->_Current = _Pair.first;
			_Pbuf->_Hiwater = _Pair.first;
			_Pbuf->_Size = _Pair.second;
			}
		return (_Pbuf->_Size);
		}

private:
	struct _Bufpar
		{	
		_Pty _Begin;	
		_Pty _Current;	
		_Pty _Hiwater;	
		ptrdiff_t _Size;	
		};
	_Bufpar _Buf;	
	_Bufpar *_Pbuf;	
	};

		
template<class _Ty>
	class auto_ptr;

template<class _Ty>
	struct auto_ptr_ref
		{	
	explicit auto_ptr_ref(_Ty *_Right)
		: _Ref(_Right)
		{	
		}

	_Ty *_Ref;	
	};

template<class _Ty>
	class auto_ptr
		{	
public:
	typedef auto_ptr<_Ty> _Myt;
	typedef _Ty element_type;

	explicit auto_ptr(_Ty *_Ptr = 0) throw ()
		: _Myptr(_Ptr)
		{	
		}

	auto_ptr(_Myt& _Right) throw ()
		: _Myptr(_Right.release())
		{	
		}

	auto_ptr(auto_ptr_ref<_Ty> _Right) throw ()
		{	
		_Ty *_Ptr = _Right._Ref;
		_Right._Ref = 0;	
		_Myptr = _Ptr;	
		}

	template<class _Other>
		operator auto_ptr<_Other>() throw ()
		{	
		return (auto_ptr<_Other>(*this));
		}

	template<class _Other>
		operator auto_ptr_ref<_Other>() throw ()
		{	
		_Other *_Cvtptr = _Myptr;	
		auto_ptr_ref<_Other> _Ans(_Cvtptr);
		_Myptr = 0;	
		return (_Ans);
		}

	template<class _Other>
		_Myt& operator=(auto_ptr<_Other>& _Right) throw ()
		{	
		reset(_Right.release());
		return (*this);
		}

	template<class _Other>
		auto_ptr(auto_ptr<_Other>& _Right) throw ()
		: _Myptr(_Right.release())
		{	
		}

	_Myt& operator=(_Myt& _Right) throw ()
		{	
		reset(_Right.release());
		return (*this);
		}

	_Myt& operator=(auto_ptr_ref<_Ty> _Right) throw ()
		{	
		_Ty *_Ptr = _Right._Ref;
		_Right._Ref = 0;	
		reset(_Ptr);	
		return (*this);
		}

	~auto_ptr() throw ()
		{	
		delete _Myptr;
		}

	_Ty& operator*() const throw ()
		{	
 


#line 938 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory"

		return (*get());
		}

	_Ty *operator->() const throw ()
		{	
 


#line 948 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory"

		return (get());
		}

	_Ty *get() const throw ()
		{	
		return (_Myptr);
		}

	_Ty *release() throw ()
		{	
		_Ty *_Tmp = _Myptr;
		_Myptr = 0;
		return (_Tmp);
		}

	void reset(_Ty *_Ptr = 0)
		{	
		if (_Ptr != _Myptr)
			delete _Myptr;
		_Myptr = _Ptr;
		}

private:
	_Ty *_Myptr;	
	};
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 980 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory"
#line 981 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xmemory"





#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
 #pragma warning(disable: 4244)

namespace std {
		
const int _ISORT_MAX = 32;	

		
template<class _InIt,
	class _Fn1> inline
	void _For_each(_InIt _First, _InIt _Last, _Fn1& _Func)
	{	
	for (; _First != _Last; ++_First)
		_Func(*_First);
	}

template<class _InIt,
	class _Fn1> inline
	_Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)
	{	
	;
	;
	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

	return (::std:: move(_Func));
	}

		
template<class _InIt,
	class _Pr> inline
	_InIt _Find_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			break;
	return (_First);
	}

template<class _InIt,
	class _Pr> inline
	_InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_Rechecked(_First,
		_Find_if(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _FwdIt> inline
	_FwdIt _Adjacent_find(_FwdIt _First, _FwdIt _Last)
	{	
	if (_First != _Last)
		for (_FwdIt _Firstb; (_Firstb = _First), ++_First != _Last; )
			if (*_Firstb == *_First)
				return (_Firstb);
	return (_Last);
	}

template<class _FwdIt> inline
	_FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last)
	{	
	;
	return (_Rechecked(_First,
		_Adjacent_find(_Unchecked(_First), _Unchecked(_Last))));
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	if (_First != _Last)
		for (_FwdIt _Firstb; (_Firstb = _First), ++_First != _Last; )
			if (_Pred(*_Firstb, *_First))
				return (_Firstb);
	return (_Last);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_Rechecked(_First,
		_Adjacent_find(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _InIt,
	class _Pr> inline
	typename iterator_traits<_InIt>::difference_type
		_Count_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	typename iterator_traits<_InIt>::difference_type _Count = 0;

	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			++_Count;
	return (_Count);
	}

template<class _InIt,
	class _Pr> inline
	typename iterator_traits<_InIt>::difference_type
		count_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_Count_if(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

 
		
template<class _InIt,
	class _Pr> inline
	bool _All_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			return (false);
	return (true);
	}

template<class _InIt,
	class _Pr> inline
	bool all_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_All_of(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		
template<class _InIt,
	class _Pr> inline
	bool _Any_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			return (true);
	return (false);
	}

template<class _InIt,
	class _Pr> inline
	bool any_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_Any_of(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		
template<class _InIt,
	class _Pr> inline
	bool _None_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			return (false);
	return (true);
	}

template<class _InIt,
	class _Pr> inline
	bool none_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_None_of(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		
template<class _InIt,
	class _Pr> inline
	_InIt _Find_if_not(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			break;
	return (_First);
	}

template<class _InIt,
	class _Pr> inline
	_InIt find_if_not(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_Rechecked(_First,
		_Find_if_not(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			*_Dest++ = *_First;
	return (_Dest);
	}

 
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred)
	{	
	return (_Copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred));
	}

 















































#line 279 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutIt1, _OutIt2>
		_Partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			*_Dest1++ = *_First;
		else
			*_Dest2++ = *_First;
	return (pair<_OutIt1, _OutIt2>( _Dest1, _Dest2));
	}

 
template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutIt1, _OutIt2>
		partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred)
	{	
	return (pair<_OutIt1, _OutIt2>(
		_Partition_copy(_Unchecked(_First), _Unchecked(_Last),
			_Dest1, _Dest2, _Pred)));
	}

 





































































































































#line 446 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _InIt,
	class _Pr> inline
	bool _Is_partitioned(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			break;	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			return (false);	
	return (true);
	}

template<class _InIt,
	class _Pr> inline
	bool is_partitioned(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_Is_partitioned(_Unchecked(_First), _Unchecked(_Last),
		_Pred));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Pr> inline
	_FwdIt _Partition_point(_FwdIt _First, _FwdIt _Last, _Pr _Pred, _Diff *)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	while (0 < _Count)
		{	
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (_Pred(*_Mid))
			{	
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else
			_Count = _Count2;
		}
	return (_First);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt partition_point(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_Rechecked(_First,
		_Partition_point(_Unchecked(_First), _Unchecked(_Last), _Pred,
			_Dist_type(_First))));
	}
 #line 507 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Diff1,
	class _Diff2> inline
	_FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Diff1 *, _Diff2 *)
	{	
	_Diff1 _Count1 = 0;
	_Distance(_First1, _Last1, _Count1);
	_Diff2 _Count2 = 0;
	_Distance(_First2, _Last2, _Count2);

	for (; _Count2 <= _Count1; ++_First1, --_Count1)
		{	
		_FwdIt1 _Mid1 = _First1;
		for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, ++_Mid2)
			if (_Mid2 == _Last2)
				return (_First1);
			else if (!(*_Mid1 == *_Mid2))
				break;
		}
	return (_Last1);
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	;
	;
	return (_Rechecked(_First1,
		_Search(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2),
			_Dist_type(_First1), _Dist_type(_First2))));
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Diff1,
	class _Diff2,
	class _Pr> inline
	_FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *)
	{	
	_Diff1 _Count1 = 0;
	_Distance(_First1, _Last1, _Count1);
	_Diff2 _Count2 = 0;
	_Distance(_First2, _Last2, _Count2);

	for (; _Count2 <= _Count1; ++_First1, --_Count1)
		{	
		_FwdIt1 _Mid1 = _First1;
		for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, ++_Mid2)
			if (_Mid2 == _Last2)
				return (_First1);
			else if (!_Pred(*_Mid1, *_Mid2))
				break;
		}
	return (_Last1);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
	;
	;
	;
	return (_Rechecked(_First1,
		_Search(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred,
			_Dist_type(_First1), _Dist_type(_First2))));
	}

		
template<class _FwdIt1,
	class _Diff2,
	class _Ty> inline
	_FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val, forward_iterator_tag)
	{	
	if (_Count <= 0)
		return (_First1);

	for (; _First1 != _Last1; ++_First1)
		if (*_First1 == _Val)
			{	
			_FwdIt1 _Mid1 = _First1;

			for (_Diff2 _Count1 = _Count; ; )
				if (--_Count1 == 0)
					return (_First1);	
				else if (++_Mid1 == _Last1)
					return (_Last1);	
				else if (!(*_Mid1 == _Val))
					break;	

			_First1 = _Mid1;	
			}
	return (_Last1);
	}

template<class _FwdIt1,
	class _Diff2,
	class _Ty> inline
	_FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val, random_access_iterator_tag)
	{	
	if (_Count <= 0)
		return (_First1);

	_FwdIt1 _Oldfirst1 = _First1;
	for (_Diff2 _Inc = 0; _Count <= _Last1 - _Oldfirst1; )
		{	
		_First1 = _Oldfirst1 + _Inc;
		if (*_First1 == _Val)
			{	
			_Diff2 _Count1 = _Count;
			_FwdIt1 _Mid1 = _First1;

			for (; _Oldfirst1 != _First1 && _First1[-1] == _Val; --_First1)
				--_Count1;	

			if (_Count1 <= _Last1 - _Mid1)
				for (; ; )	
					if (--_Count1 == 0)
						return (_First1);	
					else if (!(*++_Mid1 == _Val))
						break;	

			_Oldfirst1 = ++_Mid1;	
			_Inc = 0;
			}
		else
			{	
			_Oldfirst1 = _First1 + 1;
			_Inc = _Count - 1;
			}
		}
	return (_Last1);
	}

template<class _FwdIt1,
	class _Diff2,
	class _Ty> inline
	_FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val)
	{	
	;
	return (_Rechecked(_First1,
		_Search_n(_Unchecked(_First1), _Unchecked(_Last1), _Count, _Val,
			_Iter_cat(_First1))));
	}

		
template<class _FwdIt1,
	class _Diff2,
	class _Ty,
	class _Pr> inline
	_FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val, _Pr _Pred, forward_iterator_tag)
	{	
	if (_Count <= 0)
		return (_First1);

	for (; _First1 != _Last1; ++_First1)
		if (_Pred(*_First1, _Val))
			{	
			_FwdIt1 _Mid1 = _First1;

			for (_Diff2 _Count1 = _Count; ; )
				if (--_Count1 == 0)
					return (_First1);	
				else if (++_Mid1 == _Last1)
					return (_Last1);	
				else if (!_Pred(*_Mid1, _Val))
					break;	

			_First1 = _Mid1;	
			}
	return (_Last1);
	}

template<class _FwdIt1,
	class _Diff2,
	class _Ty,
	class _Pr> inline
	_FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val, _Pr _Pred, random_access_iterator_tag)
	{	
	if (_Count <= 0)
		return (_First1);

	_FwdIt1 _Oldfirst1 = _First1;
	for (_Diff2 _Inc = 0; _Count <= _Last1 - _Oldfirst1; )
		{	
		_First1 = _Oldfirst1 + _Inc;
		if (_Pred(*_First1, _Val))
			{	
			_Diff2 _Count1 = _Count;
			_FwdIt1 _Mid1 = _First1;

			for (; _Oldfirst1 != _First1 && _Pred(_First1[-1], _Val);
				--_First1)
				--_Count1;	

			if (_Count1 <= _Last1 - _Mid1)
				for (; ; )	
					if (--_Count1 == 0)
						return (_First1);	
					else if (!_Pred(*++_Mid1, _Val))
						break;	

			_Oldfirst1 = ++_Mid1;	
			_Inc = 0;
			}
		else
			{	
			_Oldfirst1 = _First1 + 1;
			_Inc = _Count - 1;
			}
		}
	return (_Last1);
	}

template<class _FwdIt1,
	class _Diff2,
	class _Ty,
	class _Pr> inline
	_FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
		_Diff2 _Count, const _Ty& _Val, _Pr _Pred)
	{	
	;
	;
	return (_Rechecked(_First1,
		_Search_n(_Unchecked(_First1), _Unchecked(_Last1), _Count, _Val,
			_Pred, _Iter_cat(_First1))));
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Diff1,
	class _Diff2> inline
	_FwdIt1 _Find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Diff1 *, _Diff2 *)
	{	
	_Diff1 _Count1 = 0;
	_Distance(_First1, _Last1, _Count1);
	_Diff2 _Count2 = 0;
	_Distance(_First2, _Last2, _Count2);
	_FwdIt1 _Ans = _Last1;

	if (0 < _Count2)
		for (; _Count2 <= _Count1; ++_First1, --_Count1)
			{	
			_FwdIt1 _Mid1 = _First1;
			for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1)
				if (!(*_Mid1 == *_Mid2))
					break;
				else if (++_Mid2 == _Last2)
					{	
					_Ans = _First1;
					break;
					}
			}
	return (_Ans);
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	;
	;
	return (_Rechecked(_First1,
		_Find_end(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2),
			_Dist_type(_First1), _Dist_type(_First2))));
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Diff1,
	class _Diff2,
	class _Pr> inline
	_FwdIt1 _Find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *)
	{	
	_Diff1 _Count1 = 0;
	_Distance(_First1, _Last1, _Count1);
	_Diff2 _Count2 = 0;
	_Distance(_First2, _Last2, _Count2);
	_FwdIt1 _Ans = _Last1;

	if (0 < _Count2)
		for (; _Count2 <= _Count1; ++_First1, --_Count1)
			{	
			_FwdIt1 _Mid1 = _First1;
			for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1)
				if (!_Pred(*_Mid1, *_Mid2))
					break;
				else if (++_Mid2 == _Last2)
					{	
					_Ans = _First1;
					break;
					}
			}
	return (_Ans);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
	;
	;
	;
	return (_Rechecked(_First1,
		_Find_end(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred,
			_Dist_type(_First1), _Dist_type(_First2))));
	}

		
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 _Find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	for (; _First1 != _Last1; ++_First1)
		for (_FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2)
			if (*_First1 == *_Mid2)
				return (_First1);
	return (_First1);
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	;
	;
	return (_Rechecked(_First1,
		_Find_first_of(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2))));
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 _Find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
	for (; _First1 != _Last1; ++_First1)
		for (_FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2)
			if (_Pred(*_First1, *_Mid2))
				return (_First1);
	return (_First1);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
	;
	;
	;
	return (_Rechecked(_First1,
		_Find_first_of(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred)));
	}

		
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest)
	{	
	for (; _First1 != _Last1; ++_First1, ++_Dest)
		::std:: iter_swap(_First1, _Dest);
	return (_Dest);
	}

 
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest)
	{	
	return (_Swap_ranges(_Unchecked(_First1), _Unchecked(_Last1),
		_Dest));
	}

 
































































#line 981 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func)
	{	
	for (; _First != _Last; ++_First, ++_Dest)
		*_Dest = _Func(*_First);
	return (_Dest);
	}

 
template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt transform(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func)
	{	
	if (_First != _Last)
		return (_Transform(_Unchecked(_First), _Unchecked(_Last),
			_Dest, _Func));
	return (_Dest);
	}

 











































































#line 1084 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{	
	for (; _First1 != _Last1; ++_First1, ++_First2, ++_Dest)
		*_Dest = _Func(*_First1, *_First2);
	return (_Dest);
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt transform(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{	
	if (_First1 != _Last1)
		return (_Transform(_Unchecked(_First1), _Unchecked(_Last1),
			_First2, _Dest, _Func));
	return (_Dest);
	}

 











































































































































#line 1253 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _FwdIt,
	class _Ty> inline
	void _Replace(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Oldval, const _Ty& _Newval)
	{	
	for (; _First != _Last; ++_First)
		if (*_First == _Oldval)
			*_First = _Newval;
	}

template<class _FwdIt,
	class _Ty> inline
	void replace(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Oldval, const _Ty& _Newval)
	{	
	;
	_Replace(_Unchecked(_First), _Unchecked(_Last),
		_Oldval, _Newval);
	}

		
template<class _FwdIt,
	class _Pr,
	class _Ty> inline
	void _Replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			*_First = _Val;
	}

template<class _FwdIt,
	class _Pr,
	class _Ty> inline
	void replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val)
	{	
	;
	;
	_Replace_if(_Unchecked(_First), _Unchecked(_Last),
		_Pred, _Val);
	}

		
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval)
	{	
	for (; _First != _Last; ++_First, ++_Dest)
		*_Dest = *_First == _Oldval ? _Newval : *_First;
	return (_Dest);
	}

 
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval)
	{	
	return (_Replace_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Oldval, _Newval));
	}

 











































































#line 1397 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val)
	{	
	for (; _First != _Last; ++_First, ++_Dest)
		*_Dest = _Pred(*_First) ? _Val : *_First;
	return (_Dest);
	}

 
template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val)
	{	
	return (_Replace_copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred, _Val));
	}

 


















































































#line 1507 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _FwdIt,
	class _Fn0> inline
	void _Generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
	{	
	for (; _First != _Last; ++_First)
		*_First = _Func();
	}

template<class _FwdIt,
	class _Fn0> inline
	void generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
	{	
	;
	;
	_Generate(_Unchecked(_First), _Unchecked(_Last), _Func);
	}

		
template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	_OutIt _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{	
	for (; 0 < _Count; --_Count, ++_Dest)
		*_Dest = _Func();
	return (_Dest);
	}

 
template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	_OutIt generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{	
	return (_Generate_n(_Dest, _Count, _Func));
	}

 

































































#line 1613 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val)
	{	
	for (; _First != _Last; ++_First)
		if (!(*_First == _Val))
			*_Dest++ = *_First;
	return (_Dest);
	}

 
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val)
	{	
	return (_Remove_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Val));
	}

 

















































#line 1689 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Remove_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			*_Dest++ = *_First;
	return (_Dest);
	}

 
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt remove_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	
	return (_Remove_copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred));
	}

 


















































#line 1766 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _FwdIt,
	class _Ty> inline
	_FwdIt _Remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	_FwdIt _Next = _First;
	for (++_First; _First != _Last; ++_First)
		if (!(*_First == _Val))
			*_Next++ = _Move(*_First);
	return (_Next);
	}

template<class _FwdIt,
	class _Ty> inline
	_FwdIt remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	_First = ::std:: find(_First, _Last, _Val);
	if (_First == _Last)
		return (_First);	
	else
		return (_Rechecked(_First,
			_Remove(_Unchecked(_First), _Unchecked(_Last), _Val)));
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_FwdIt _Next = _First;
	for (++_First; _First != _Last; ++_First)
	if (!_Pred(*_First))
		*_Next++ = _Move(*_First);
	return (_Next);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_First = ::std:: find_if(_First, _Last, _Pred);
	if (_First == _Last)
		return (_First);	
	else
		return (_Rechecked(_First,
			_Remove_if(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _FwdIt> inline
	_FwdIt _Unique(_FwdIt _First, _FwdIt _Last)
	{	
	if (_First != _Last)
		for (_FwdIt _Firstb; (_Firstb = _First), ++_First != _Last; )
			if (*_Firstb == *_First)
				{	
				for (; ++_First != _Last; )
					if (!(*_Firstb == *_First))
						*++_Firstb = _Move(*_First);
				return (++_Firstb);
				}
	return (_Last);
	}

template<class _FwdIt> inline
	_FwdIt unique(_FwdIt _First, _FwdIt _Last)
	{	
	;
	return (_Rechecked(_First,
		_Unique(_Unchecked(_First), _Unchecked(_Last))));
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	if (_First != _Last)
		for (_FwdIt _Firstb; (_Firstb = _First), ++_First != _Last; )
			if (_Pred(*_Firstb, *_First))
				{	
				for (; ++_First != _Last; )
					if (!_Pred(*_Firstb, *_First))
						*++_Firstb = _Move(*_First);
				return (++_Firstb);
				}
	return (_Last);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_Rechecked(_First,
		_Unique(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Ty *)
	{	
	_Ty _Val = *_First;
	for (*_Dest++ = _Val; ++_First != _Last; )
		if (!(_Val == *_First))
			{	
			_Val = *_First;
			*_Dest++ = _Val;
			}
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, input_iterator_tag)
	{	
	return (_Unique_copy(_First, _Last, _Dest,
		_Val_type(_First)));
	}

template<class _FwdIt,
	class _OutIt> inline
	_OutIt _Unique_copy(_FwdIt _First, _FwdIt _Last,
		_OutIt _Dest, forward_iterator_tag)
	{	
	_FwdIt _Firstb = _First;
	for (*_Dest++ = *_Firstb; ++_First != _Last; )
		if (!(*_Firstb == *_First))
			{	
			_Firstb = _First;
			*_Dest++ = *_Firstb;
			}
	return (_Dest);
	}

 
template<class _InIt,
	class _OutIt> inline
	_OutIt unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	return (_First == _Last ? _Dest :
		_Unique_copy(_Unchecked(_First), _Unchecked(_Last),
			_Dest, _Iter_cat(_First)));
	}

 











































#line 1963 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _InIt,
	class _OutIt,
	class _Ty,
	class _Pr> inline
	_OutIt _Unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, _Ty *)
	{	
	_Ty _Val = *_First;

	for (*_Dest++ = _Val; ++_First != _Last; )
		if (!_Pred(_Val, *_First))
			{	
			_Val = *_First;
			*_Dest++ = _Val;
			}
	return (_Dest);
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, input_iterator_tag)
	{	
	return (_Unique_copy(_First, _Last, _Dest, _Pred,
		_Val_type(_First)));
	}

template<class _FwdIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy(_FwdIt _First, _FwdIt _Last,
		_OutIt _Dest, _Pr _Pred, forward_iterator_tag)
	{	
	_FwdIt _Firstb = _First;

	for (*_Dest++ = *_Firstb; ++_First != _Last; )
		if (!_Pred(*_Firstb, *_First))
			{	
			_Firstb = _First;
			*_Dest++ = *_Firstb;
			}
	return (_Dest);
	}

 
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	
	return (_First == _Last ? _Dest :
		_Unique_copy(_Unchecked(_First), _Unchecked(_Last),
			_Dest, _Pred, _Iter_cat(_First)));
	}

 















































#line 2071 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest)
	{	
	for (; _First != _Last; ++_Dest)
		*_Dest = *--_Last;
	return (_Dest);
	}

 
template<class _BidIt,
	class _OutIt> inline
	_OutIt reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest)
	{	
	return (_Reverse_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest));
	}

 


































































#line 2161 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _FwdIt,
	class _OutIt> inline
	_OutIt rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		_OutIt _Dest)
	{	
	_Dest = ::std:: copy(_Mid, _Last, _Dest);
	return (::std:: copy(_First, _Mid, _Dest));
	}

		
template<class _RanIt,
	class _Fn1,
	class _Diff> inline
	void _Random_shuffle(_RanIt _First, _RanIt _Last, _Fn1& _Func, _Diff *)
	{	
	_RanIt _Next = _First;
	for (_Diff _Index = 2; ++_Next != _Last; ++_Index)
		{	
		_Diff _Off = _Func(_Index);

 






#line 2191 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

#line 2193 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		::std:: iter_swap(_Next, _First + _Off);
		}
	}

template<class _RanIt,
	class _Fn1> inline
	void random_shuffle(_RanIt _First, _RanIt _Last, _Fn1&& _Func)
	{	
	;
	;
	if (_First != _Last)
		_Random_shuffle(_Unchecked(_First), _Unchecked(_Last), _Func,
			_Dist_type(_First));
	}

		
template<class _RanIt,
	class _Urng> inline
	void shuffle(_RanIt _First, _RanIt _Last, _Urng&& _Func)
	{	
	typedef typename iterator_traits<_RanIt>::difference_type _Diff;
	typedef typename remove_reference<_Urng>::type _Urng0;
	_Rng_from_urng<_Diff, _Urng0> _Rng(_Func);
	::std:: random_shuffle(_First, _Last, _Rng);
	}

	
struct _Rand_urng_from_func
	{	
	typedef unsigned int result_type;

	static result_type (min)()
		{	
		return (0);
		}

	static result_type (max)()
		{	
		return (0x7fff);
		}

	result_type operator()()
		{	
		return (:: rand());
		}
	};

		
template<class _RanIt> inline
	void random_shuffle(_RanIt _First, _RanIt _Last)
	{	
	_Rand_urng_from_func _Func;
	::std:: shuffle(_First, _Last, _Func);
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Partition(_FwdIt _First, _FwdIt _Last, _Pr _Pred,
		forward_iterator_tag)
	{	
	while (_First != _Last && _Pred(*_First))
		++_First;	

	if (_First == _Last)
		return (_First);	

	for (_FwdIt _Next = ::std:: next(_First); _Next != _Last; ++_Next)
		if (_Pred(*_Next))
			::std:: iter_swap(_First++, _Next);	

	return (_First);
	}

template<class _BidIt,
	class _Pr> inline
	_BidIt _Partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
		bidirectional_iterator_tag)
	{	
	for (; ; ++_First)
		{	
		for (; _First != _Last && _Pred(*_First); ++_First)
			;	
		if (_First == _Last)
			break;	

		for (; _First != --_Last && !_Pred(*_Last); )
			;	
		if (_First == _Last)
			break;	

		::std:: iter_swap(_First, _Last);	
		}
	return (_First);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt partition(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_Rechecked(_First,
		_Partition(_Unchecked(_First), _Unchecked(_Last), _Pred,
			_Iter_cat(_First))));
	}

		
template<class _BidIt,
	class _Pr,
	class _Diff,
	class _Ty> inline
	_BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
		_Diff _Count, _Temp_iterator<_Ty>& _Tempbuf)
	{	
	if (_Count == 0)
		return (_First);
	else if (_Count == 1)
		return (_Pred(*_First) ? _Last : _First);
	else if (_Count <= _Tempbuf._Maxlen())
		{	
		_BidIt _Next = _First;
		for (_Tempbuf._Init(); _First != _Last; ++_First)
			if (_Pred(*_First))
				*_Next++ = _Move(*_First);
			else
				*_Tempbuf++ = _Move(*_First);

		_Move(_Tempbuf._First(), _Tempbuf._Last(), _Next);	
		return (_Next);
		}
	else
		{	
		_BidIt _Mid = _First;
		::std:: advance(_Mid, _Count / 2);

		_BidIt _Left = _Stable_partition(_First, _Mid, _Pred,
			_Count / 2, _Tempbuf);	
		_BidIt _Right = _Stable_partition(_Mid, _Last, _Pred,
			_Count - _Count / 2, _Tempbuf);	

		_Diff _Count1 = 0;
		_Distance(_Left, _Mid, _Count1);
		_Diff _Count2 = 0;
		_Distance(_Mid, _Right, _Count2);

		return (_Buffered_rotate(_Left, _Mid, _Right,
			_Count1, _Count2, _Tempbuf));	
		}
	}

template<class _BidIt,
	class _Pr,
	class _Diff,
	class _Ty> inline
	_BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
		_Diff *, _Ty *)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	_Temp_iterator<_Ty> _Tempbuf(_Count);
	return (_Stable_partition(_First, _Last, _Pred, _Count, _Tempbuf));
	}

template<class _BidIt,
	class _Pr> inline
	_BidIt stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_First == _Last ? _First
		: _Rechecked(_First,
			_Stable_partition(_Unchecked(_First), _Unchecked(_Last),
				_Pred, _Dist_type(_First), _Val_type(_First))));
	}

 


































#line 2406 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"
  
  
 #line 2409 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _RanIt,
	class _Diff,
	class _Ty> inline
	void _Push_heap(_RanIt _First, _Diff _Hole,
		_Diff _Top, _Ty&& _Val)
	{	
	for (_Diff _Idx = (_Hole - 1) / 2;
		_Top < _Hole && ((*(_First + _Idx)) < (_Val));
		_Idx = (_Hole - 1) / 2)
		{	
		*(_First + _Hole) = _Move(*(_First + _Idx));
		_Hole = _Idx;
		}

	*(_First + _Hole) = _Move(_Val);	
	}

template<class _RanIt,
	class _Diff,
	class _Ty> inline
	void _Push_heap_0(_RanIt _First, _RanIt _Last, _Diff *, _Ty *)
	{	
	_Diff _Count = _Last - _First;
	if (0 < _Count)
		{	
		_Ty _Val = _Move(*_Last);
		_Push_heap(_First, _Count, _Diff(0), _Move(_Val));
		}
	}

template<class _RanIt> inline
	void push_heap(_RanIt _First, _RanIt _Last)
	{	
	;
	if (_First != _Last)
		{	
		--_Last;
		;
		_Push_heap_0(_Unchecked(_First), _Unchecked(_Last),
			_Dist_type(_First), _Val_type(_First));
		}
	}

		
template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Push_heap(_RanIt _First, _Diff _Hole,
		_Diff _Top, _Ty&& _Val, _Pr _Pred)
	{	
	for (_Diff _Idx = (_Hole - 1) / 2;
		_Top < _Hole && _Pred(*(_First + _Idx), _Val);
		_Idx = (_Hole - 1) / 2)
		{	
		*(_First + _Hole) = _Move(*(_First + _Idx));
		_Hole = _Idx;
		}

	*(_First + _Hole) = _Move(_Val);	
	}

template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Push_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty *)
	{	
	_Diff _Count = _Last - _First;
	if (0 < _Count)
		{	
		_Ty _Val = _Move(*_Last);
		_Push_heap(_First, _Count, _Diff(0), _Move(_Val), _Pred);
		}
	}

template<class _RanIt,
	class _Pr> inline
	void push_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	;
	;
	if (_First != _Last)
		{	
		--_Last;
		;
		_Push_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
			_Dist_type(_First), _Val_type(_First));
		}
	}

		
template<class _RanIt,
	class _Diff,
	class _Ty> inline
	void _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom,
		_Ty&& _Val)
	{	
	_Diff _Top = _Hole;
	_Diff _Idx = 2 * _Hole + 2;

	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)
		{	
		if (((*(_First + _Idx)) < (*(_First + (_Idx - 1)))))
			--_Idx;
		*(_First + _Hole) = _Move(*(_First + _Idx));
		_Hole = _Idx;
		}

	if (_Idx == _Bottom)
		{	
		*(_First + _Hole) = _Move(*(_First + (_Bottom - 1)));
		_Hole = _Bottom - 1;
		}
	_Push_heap(_First, _Hole, _Top, _Move(_Val));
	}

template<class _RanIt,
	class _Diff,
	class _Ty> inline
	void _Pop_heap(_RanIt _First, _RanIt _Last, _RanIt _Dest,
		_Ty&& _Val, _Diff *)
	{	
	*_Dest = _Move(*_First);
	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
		_Move(_Val));
	}

template<class _RanIt,
	class _Ty> inline
	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Ty *)
	{	
	_Ty _Val = _Move(*(_Last - 1));
	_Pop_heap(_First, _Last - 1, _Last - 1,
		_Move(_Val), _Dist_type(_First));
	}

template<class _RanIt> inline
	void _Pop_heap(_RanIt _First, _RanIt _Last)
	{	
	_Pop_heap_0(_Unchecked(_First), _Unchecked(_Last),
		_Val_type(_First));
	}

template<class _RanIt> inline
	void pop_heap(_RanIt _First, _RanIt _Last)
	{	
	;
	;
	if (1 < _Last - _First)
		_Pop_heap(_Unchecked(_First), _Unchecked(_Last));
	}

		
template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom,
		_Ty&& _Val, _Pr _Pred)
	{	
	_Diff _Top = _Hole;
	_Diff _Idx = 2 * _Hole + 2;

	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)
		{	
		if (_Pred(*(_First + _Idx), *(_First + (_Idx - 1))))
			--_Idx;
		*(_First + _Hole) = _Move(*(_First + _Idx));
		_Hole = _Idx;
		}

	if (_Idx == _Bottom)
		{	
		*(_First + _Hole) = _Move(*(_First + (_Bottom - 1)));
		_Hole = _Bottom - 1;
		}
	_Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);
	}

template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Pop_heap(_RanIt _First, _RanIt _Last, _RanIt _Dest,
		_Ty&& _Val, _Pr _Pred, _Diff *)
	{	
	*_Dest = _Move(*_First);
	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
		_Move(_Val), _Pred);
	}

template<class _RanIt,
	class _Ty,
	class _Pr> inline
	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
	{	
	_Ty _Val = _Move(*(_Last - 1));
	_Pop_heap(_First, _Last - 1, _Last - 1,
		_Move(_Val), _Pred, _Dist_type(_First));
	}

template<class _RanIt,
	class _Pr> inline
	void _Pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Pop_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
		_Val_type(_First));
	}

template<class _RanIt,
	class _Pr> inline
	void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	;
	;
	;
	if (1 < _Last - _First)
		_Pop_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);
	}

		
template<class _RanIt,
	class _Diff,
	class _Ty> inline
	void _Make_heap(_RanIt _First, _RanIt _Last, _Diff *, _Ty *)
	{	
	_Diff _Bottom = _Last - _First;

	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )
		{	
		--_Hole;
		_Ty _Val = _Move(*(_First + _Hole));
		_Adjust_heap(_First, _Hole, _Bottom,
			_Move(_Val));
		}
	}

template<class _RanIt> inline
	void make_heap(_RanIt _First, _RanIt _Last)
	{	
	;
	if (1 < _Last - _First)
		_Make_heap(_Unchecked(_First), _Unchecked(_Last),
			_Dist_type(_First), _Val_type(_First));
	}

		
template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty *)
	{	
	_Diff _Bottom = _Last - _First;
	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )
		{	
		--_Hole;
		_Ty _Val = _Move(*(_First + _Hole));
		_Adjust_heap(_First, _Hole, _Bottom,
			_Move(_Val), _Pred);
		}
	}

template<class _RanIt,
	class _Pr> inline
	void make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	;
	;
	if (1 < _Last - _First)
		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
			_Dist_type(_First), _Val_type(_First));
	}

		
template<class _RanIt> inline
	void _Sort_heap(_RanIt _First, _RanIt _Last)
	{	
	for (; 1 < _Last - _First; --_Last)
		_Pop_heap(_First, _Last);
	}

template<class _RanIt> inline
	void sort_heap(_RanIt _First, _RanIt _Last)
	{	
	;
	;
	_Sort_heap(_Unchecked(_First), _Unchecked(_Last));
	}

		
template<class _RanIt,
	class _Pr> inline
	void _Sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	for (; 1 < _Last - _First; --_Last)
		_Pop_heap(_First, _Last, _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	;
	;
	;
	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);
	}

		
template<class _FwdIt,
	class _Ty,
	class _Diff> inline
	_FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Diff *)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);

	while (0 < _Count)
		{	
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (*_Mid < _Val)

			{	
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else
			_Count = _Count2;
		}
	return (_First);
	}

template<class _FwdIt,
	class _Ty> inline
	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	

	return (_Rechecked(_First,
		_Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val,
			_Dist_type(_First))));
	}

		
template<class _FwdIt,
	class _Ty,
	class _Diff,
	class _Pr> inline
	_FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred, _Diff *)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);

	while (0 < _Count)
		{	
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (_Pred(*_Mid, _Val))

			{	
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else
			_Count = _Count2;
		}
	return (_First);
	}

template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	

	return (_Rechecked(_First,
		_Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
			_Dist_type(_First))));
	}

		
template<class _FwdIt,
	class _Ty,
	class _Diff> inline
	_FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Diff *)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);

	while (0 < _Count)
		{	
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (!(_Val < *_Mid))

			{	
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else
			_Count = _Count2;
		}
	return (_First);
	}

template<class _FwdIt,
	class _Ty> inline
	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	

	return (_Rechecked(_First,
		_Upper_bound(_Unchecked(_First), _Unchecked(_Last), _Val,
			_Dist_type(_First))));
	}

		
template<class _FwdIt,
	class _Ty,
	class _Diff,
	class _Pr> inline
	_FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred, _Diff *)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);

	while (0 < _Count)
		{	
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (!_Pred(_Val, *_Mid))

			{	
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else
			_Count = _Count2;
		}
	return (_First);
	}

template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	

	return (_Rechecked(_First,
		_Upper_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
			_Dist_type(_First))));
	}

		
template<class _FwdIt,
	class _Ty,
	class _Diff> inline
	pair<_FwdIt, _FwdIt>
		_Equal_range(_FwdIt _First, _FwdIt _Last,
			const _Ty& _Val, _Diff *)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);

	while (0 < _Count)
		{	
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (((*_Mid) < (_Val)))
			{	
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else if (_Val < *_Mid)
			_Count = _Count2;	
		else
			{	
			_FwdIt _First2 = ::std:: lower_bound(_First, _Mid, _Val);
			::std:: advance(_First, _Count);
			_FwdIt _Last2 = ::std:: upper_bound(++_Mid, _First, _Val);
			return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
			}
		}

	return (pair<_FwdIt, _FwdIt>(_First, _First));	
	}

template<class _FwdIt,
	class _Ty> inline
	pair<_FwdIt, _FwdIt>
		equal_range(_FwdIt _First, _FwdIt _Last,
			const _Ty& _Val)
	{	
	;
	pair<typename _Get_unchecked_type<_FwdIt>::type, typename _Get_unchecked_type<_FwdIt>::type> _Ans(
		_Equal_range(_Unchecked(_First), _Unchecked(_Last),
			_Val, _Dist_type(_First)));
	return (pair<_FwdIt, _FwdIt>(
		_Rechecked(_First, _Ans.first),
		_Rechecked(_Last, _Ans.second)));
	}

		
template<class _FwdIt,
	class _Ty,
	class _Diff,
	class _Pr> inline
	pair<_FwdIt, _FwdIt>
		_Equal_range(_FwdIt _First, _FwdIt _Last,
			const _Ty& _Val, _Pr _Pred, _Diff *)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);

	while (0 < _Count)
		{	
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (_Pred(*_Mid, _Val))
			{	
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else if (_Pred(_Val, *_Mid))
			_Count = _Count2;	
		else
			{	
			_FwdIt _First2 = ::std:: lower_bound(_First, _Mid, _Val, _Pred);
			::std:: advance(_First, _Count);
			_FwdIt _Last2 = ::std:: upper_bound(++_Mid, _First, _Val, _Pred);
			return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
			}
		}

	return (pair<_FwdIt, _FwdIt>(_First, _First));	
	}

template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	pair<_FwdIt, _FwdIt>
		equal_range(_FwdIt _First, _FwdIt _Last,
			const _Ty& _Val, _Pr _Pred)
	{	
	;
	pair<typename _Get_unchecked_type<_FwdIt>::type, typename _Get_unchecked_type<_FwdIt>::type> _Ans(
		_Equal_range(_Unchecked(_First), _Unchecked(_Last),
			_Val, _Pred, _Dist_type(_First)));
	return (pair<_FwdIt, _FwdIt>(
		_Rechecked(_First, _Ans.first),
		_Rechecked(_Last, _Ans.second)));
	}

		
template<class _FwdIt,
	class _Ty> inline
	bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	_First = ::std:: lower_bound(_First, _Last, _Val);
	return (_First != _Last && !(_Val < *_First));
	}

		
template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	bool binary_search(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	
	_First = ::std:: lower_bound(_First, _Last, _Val, _Pred);
	return (_First != _Last && !_Pred(_Val, *_First));
	}

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Merge0(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)
		if (((*_First2) < (*_First1)))
			{	
			*_Dest = *_First2;
			++_First2;
			}
		else
			{	
			*_Dest = *_First1;
			++_First1;
			}

	_Dest = _Copy_impl(_First1, _Last1, _Dest);	
	return (_Copy_impl(_First2, _Last2, _Dest));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	
	return (_Merge0(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest));
	}

 






















































































#line 3126 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge0(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)
		if (_Pred(*_First2, *_First1))
			{	
			*_Dest = *_First2;
			++_First2;
			}
		else
			{	
			*_Dest = *_First1;
			++_First1;
			}

	_Dest = _Copy_impl(_First1, _Last1, _Dest);	
	return (_Copy_impl(_First2, _Last2, _Dest));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	
	return (_Merge0(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred));
	}

 





























































































#line 3261 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _BidIt,
	class _Diff,
	class _Ty> inline
	_BidIt _Buffered_rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff _Count1, _Diff _Count2, _Temp_iterator<_Ty>& _Tempbuf)
	{	
	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
		{	
		_Move(_First, _Mid, _Tempbuf._Init());
		_Move(_Mid, _Last, _First);
		return (_Move_backward(_Tempbuf._First(), _Tempbuf._Last(),
			_Last));
		}
	else if (_Count2 <= _Tempbuf._Maxlen())
		{	
		_Move(_Mid, _Last, _Tempbuf._Init());
		_Move_backward(_First, _Mid, _Last);
		return (_Move(_Tempbuf._First(), _Tempbuf._Last(), _First));
		}
	else
		{	
		::std:: rotate(_First, _Mid, _Last);
		::std:: advance(_First, _Count2);
		return (_First);
		}
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)
		if (((*_First2) < (*_First1)))
			{	
			*_Dest = _Move(*_First2);
			++_First2;
			}
		else
			{	
			*_Dest = _Move(*_First1);
			++_First1;
			}

	_Dest = _Move(_First1, _Last1, _Dest);	
	return (_Move(_First2, _Last2, _Dest));
	}

template<class _BidIt1,
	class _BidIt2,
	class _BidIt3> inline
	_BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
	{	
	for (; ; )
		if (_First1 == _Last1)
			return (_Move_backward(_First2, _Last2, _Dest));
		else if (_First2 == _Last2)
			return (_Move_backward(_First1, _Last1, _Dest));
		else if (((*--_Last2) < (*--_Last1)))
			{	
			*--_Dest = _Move(*_Last1);
			++_Last2;
			}
		else
			{	
			*--_Dest = _Move(*_Last2);
			++_Last1;
			}
	}

template<class _BidIt,
	class _Diff,
	class _Ty> inline
	void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff _Count1, _Diff _Count2,
			_Temp_iterator<_Ty>& _Tempbuf)
	{	
	if (_Count1 + _Count2 == 2)
		{	
		if (((*_Mid) < (*_First)))
			::std:: iter_swap(_First, _Mid);
		}
	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
		{	
		_Move(_First, _Mid, _Tempbuf._Init());
		_Merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);
		}
	else if (_Count2 <= _Tempbuf._Maxlen())
		{	
		_Move(_Mid, _Last, _Tempbuf._Init());
		_Merge_backward(_First, _Mid,
			_Tempbuf._First(), _Tempbuf._Last(), _Last);
		}
	else
		{	
		_BidIt _Firstn, _Lastn;
		_Diff _Count1n, _Count2n;

		if (_Count2 < _Count1)
			{	
			_Count1n = _Count1 / 2, _Count2n = 0;
			_Firstn = _First;
			::std:: advance(_Firstn, _Count1n);
			_Lastn = ::std:: lower_bound(_Mid, _Last, *_Firstn);
			_Distance(_Mid, _Lastn, _Count2n);
			}
		else
			{	
			_Count1n = 0, _Count2n = _Count2 / 2;
			_Lastn = _Mid;
			::std:: advance(_Lastn, _Count2n);
			_Firstn = ::std:: upper_bound(_First, _Mid, *_Lastn);
			_Distance(_First, _Firstn, _Count1n);
			}

		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
			_Count1 - _Count1n, _Count2n, _Tempbuf);	
		_Buffered_merge(_First, _Firstn, _Midn,
			_Count1n, _Count2n, _Tempbuf);	
		_Buffered_merge(_Midn, _Lastn, _Last,
			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty> inline
	void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff *, _Ty *)
	{	
	_Diff _Count1 = 0;
	_Distance(_First, _Mid, _Count1);
	_Diff _Count2 = 0;
	_Distance(_Mid, _Last, _Count2);
	_Temp_iterator<_Ty> _Tempbuf(_Count1 < _Count2 ? _Count1 : _Count2);
	_Buffered_merge(_First, _Mid, _Last,
		_Count1, _Count2, _Tempbuf);
	}

template<class _BidIt> inline
	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
	{	
	;
	;
	if (_First != _Mid && _Mid != _Last)
		_Inplace_merge(
			_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last),
			_Dist_type(_First), _Val_type(_First));
	}

		
template<class _BidIt1,
	class _BidIt2,
	class _BidIt3,
	class _Pr> inline
	_BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
	{	
	for (; ; )
		if (_First1 == _Last1)
			return (_Move_backward(_First2, _Last2, _Dest));
		else if (_First2 == _Last2)
			return (_Move_backward(_First1, _Last1, _Dest));
		else if (_Pred(*--_Last2, *--_Last1))
			{	
			*--_Dest = _Move(*_Last1);
			++_Last2;
			}
		else
			{	
			*--_Dest = _Move(*_Last2);
			++_Last1;
			}
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)
		if (_Pred(*_First2, *_First1))
			{	
			*_Dest = _Move(*_First2);
			++_First2;
			}
		else
			{	
			*_Dest = _Move(*_First1);
			++_First1;
			}

	_Dest = _Move(_First1, _Last1, _Dest);	
	return (_Move(_First2, _Last2, _Dest));
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff _Count1, _Diff _Count2,
			_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
	{	
	if (_Count1 + _Count2 == 2)
		{	
		if (_Pred(*_Mid, *_First))
			::std:: iter_swap(_First, _Mid);
		}
	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
		{	
		_Move(_First, _Mid, _Tempbuf._Init());
		_Merge(_Tempbuf._First(), _Tempbuf._Last(),
			_Mid, _Last, _First, _Pred);
		}
	else if (_Count2 <= _Tempbuf._Maxlen())
		{	
		_Move(_Mid, _Last, _Tempbuf._Init());
		_Merge_backward(_First, _Mid,
			_Tempbuf._First(), _Tempbuf._Last(), _Last, _Pred);
		}
	else
		{	
		_BidIt _Firstn, _Lastn;
		_Diff _Count1n, _Count2n;
		if (_Count2 < _Count1)
			{	
			_Count1n = _Count1 / 2, _Count2n = 0;
			_Firstn = _First;
			::std:: advance(_Firstn, _Count1n);
			_Lastn = ::std:: lower_bound(_Mid, _Last, *_Firstn, _Pred);
			_Distance(_Mid, _Lastn, _Count2n);
			}
		else
			{	
			_Count1n = 0, _Count2n = _Count2 / 2;
			_Lastn = _Mid;
			::std:: advance(_Lastn, _Count2n);
			_Firstn = ::std:: upper_bound(_First, _Mid, *_Lastn, _Pred);
			_Distance(_First, _Firstn, _Count1n);
			}
		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
			_Count1 - _Count1n, _Count2n, _Tempbuf);	
		_Buffered_merge(_First, _Firstn, _Midn,
			_Count1n, _Count2n, _Tempbuf, _Pred);	
		_Buffered_merge(_Midn, _Lastn, _Last,
			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred,
		_Diff *, _Ty *)
	{	
	_Diff _Count1 = 0;
	_Distance(_First, _Mid, _Count1);
	_Diff _Count2 = 0;
	_Distance(_Mid, _Last, _Count2);
	_Temp_iterator<_Ty> _Tempbuf(_Count1 < _Count2 ? _Count1 : _Count2);
	_Buffered_merge(_First, _Mid, _Last,
		_Count1, _Count2, _Tempbuf, _Pred);
	}

template<class _BidIt,
	class _Pr> inline
	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
	{	
	;
	;
	if (_First != _Mid && _Mid != _Last)
		_Inplace_merge(
			_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred,
			_Dist_type(_First), _Val_type(_First));
	}

		
template<class _BidIt,
	class _Ty> inline
	void _Insertion_sort1(_BidIt _First, _BidIt _Last, _Ty *)
	{	
	if (_First != _Last)
		for (_BidIt _Next = _First; ++_Next != _Last; )
			{	
			_BidIt _Next1 = _Next;
			_Ty _Val = _Move(*_Next);

			if (((_Val) < (*_First)))
				{	
				_Move_backward(_First, _Next, ++_Next1);
				*_First = _Move(_Val);
				}
			else
				{	
				for (_BidIt _First1 = _Next1;
					((_Val) < (*--_First1));
					_Next1 = _First1)
					*_Next1 = _Move(*_First1);	
				*_Next1 = _Move(_Val);	
				}
			}
	}

template<class _BidIt> inline
	void _Insertion_sort(_BidIt _First, _BidIt _Last)
	{	
	_Insertion_sort1(_First, _Last, _Val_type(_First));
	}

template<class _RanIt> inline
	void _Med3(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{	
	if (((*_Mid) < (*_First)))
		::std:: iter_swap(_Mid, _First);
	if (((*_Last) < (*_Mid)))
		{	
		::std:: iter_swap(_Last, _Mid);
		if (((*_Mid) < (*_First)))
			::std:: iter_swap(_Mid, _First);
		}
	}

template<class _RanIt> inline
	void _Median(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{	
	if (40 < _Last - _First)
		{	
		size_t _Step = (_Last - _First + 1) / 8;
		_Med3(_First, _First + _Step, _First + 2 * _Step);
		_Med3(_Mid - _Step, _Mid, _Mid + _Step);
		_Med3(_Last - 2 * _Step, _Last - _Step, _Last);
		_Med3(_First + _Step, _Mid, _Last - _Step);
		}
	else
		_Med3(_First, _Mid, _Last);
	}

template<class _RanIt> inline
	pair<_RanIt, _RanIt>
		_Unguarded_partition(_RanIt _First, _RanIt _Last)
	{	
	_RanIt _Mid = _First + (_Last - _First) / 2;	
	_Median(_First, _Mid, _Last - 1);
	_RanIt _Pfirst = _Mid;
	_RanIt _Plast = _Pfirst + 1;

	while (_First < _Pfirst
		&& !((*(_Pfirst - 1)) < (*_Pfirst))
		&& !(*_Pfirst < *(_Pfirst - 1)))
		--_Pfirst;
	while (_Plast < _Last
		&& !((*_Plast) < (*_Pfirst))
		&& !(*_Pfirst < *_Plast))
		++_Plast;

	_RanIt _Gfirst = _Plast;
	_RanIt _Glast = _Pfirst;

	for (; ; )
		{	
		for (; _Gfirst < _Last; ++_Gfirst)
			if (((*_Pfirst) < (*_Gfirst)))
				;
			else if (*_Gfirst < *_Pfirst)
				break;
			else
				::std:: iter_swap(_Plast++, _Gfirst);
		for (; _First < _Glast; --_Glast)
			if (((*(_Glast - 1)) < (*_Pfirst)))
				;
			else if (*_Pfirst < *(_Glast - 1))
				break;
			else
				::std:: iter_swap(--_Pfirst, _Glast - 1);
		if (_Glast == _First && _Gfirst == _Last)
			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

		if (_Glast == _First)
			{	
			if (_Plast != _Gfirst)
				::std:: iter_swap(_Pfirst, _Plast);
			++_Plast;
			::std:: iter_swap(_Pfirst++, _Gfirst++);
			}
		else if (_Gfirst == _Last)
			{	
			if (--_Glast != --_Pfirst)
				::std:: iter_swap(_Glast, _Pfirst);
			::std:: iter_swap(_Pfirst, --_Plast);
			}
		else
			::std:: iter_swap(_Gfirst++, --_Glast);
		}
	}

template<class _RanIt,
	class _Diff> inline
	void _Sort(_RanIt _First, _RanIt _Last, _Diff _Ideal)
	{	
	_Diff _Count;
	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )
		{	
		pair<_RanIt, _RanIt> _Mid =
			_Unguarded_partition(_First, _Last);
		_Ideal /= 2, _Ideal += _Ideal / 2;	

		if (_Mid.first - _First < _Last - _Mid.second)
			{	
			_Sort(_First, _Mid.first, _Ideal);
			_First = _Mid.second;
			}
		else
			{	
			_Sort(_Mid.second, _Last, _Ideal);
			_Last = _Mid.first;
			}
		}

	if (_ISORT_MAX < _Count)
		{	
		::std:: make_heap(_First, _Last);
		::std:: sort_heap(_First, _Last);
		}
	else if (1 < _Count)
		_Insertion_sort(_First, _Last);	
	}

template<class _RanIt> inline
	void sort(_RanIt _First, _RanIt _Last)
	{	
	;
	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First);
	}

		
template<class _BidIt,
	class _Pr,
	class _Ty> inline
	void _Insertion_sort1(_BidIt _First, _BidIt _Last, _Pr _Pred, _Ty *)
	{	
	if (_First != _Last)
		for (_BidIt _Next = _First; ++_Next != _Last; )
			{	
			_BidIt _Next1 = _Next;
			_Ty _Val = _Move(*_Next);

			if (_Pred(_Val, *_First))
				{	
				_Move_backward(_First, _Next, ++_Next1);
				*_First = _Move(_Val);
				}
			else
				{	
				for (_BidIt _First1 = _Next1;
					_Pred(_Val, *--_First1);
					_Next1 = _First1)
					*_Next1 = _Move(*_First1);	
				*_Next1 = _Move(_Val);	
				}
			}
	}

template<class _BidIt,
	class _Pr> inline
	void _Insertion_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));
	}

template<class _RanIt,
	class _Pr> inline
	void _Med3(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	
	if (_Pred(*_Mid, *_First))
		::std:: iter_swap(_Mid, _First);
	if (_Pred(*_Last, *_Mid))
		{	
		::std:: iter_swap(_Last, _Mid);
		if (_Pred(*_Mid, *_First))
			::std:: iter_swap(_Mid, _First);
		}
	}

template<class _RanIt,
	class _Pr> inline
	void _Median(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	
	if (40 < _Last - _First)
		{	
		size_t _Step = (_Last - _First + 1) / 8;
		_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);
		_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);
		_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);
		_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);
		}
	else
		_Med3(_First, _Mid, _Last, _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	pair<_RanIt, _RanIt>
		_Unguarded_partition(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_RanIt _Mid = _First + (_Last - _First) / 2;
	_Median(_First, _Mid, _Last - 1, _Pred);
	_RanIt _Pfirst = _Mid;
	_RanIt _Plast = _Pfirst + 1;

	while (_First < _Pfirst
		&& !_Pred(*(_Pfirst - 1), *_Pfirst)
		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))
		--_Pfirst;
	while (_Plast < _Last
		&& !_Pred(*_Plast, *_Pfirst)
		&& !_Pred(*_Pfirst, *_Plast))
		++_Plast;

	_RanIt _Gfirst = _Plast;
	_RanIt _Glast = _Pfirst;

	for (; ; )
		{	
		for (; _Gfirst < _Last; ++_Gfirst)
			if (_Pred(*_Pfirst, *_Gfirst))
				;
			else if (_Pred(*_Gfirst, *_Pfirst))
				break;
			else
				::std:: iter_swap(_Plast++, _Gfirst);
		for (; _First < _Glast; --_Glast)
			if (_Pred(*(_Glast - 1), *_Pfirst))
				;
			else if (_Pred(*_Pfirst, *(_Glast - 1)))
				break;
			else
				::std:: iter_swap(--_Pfirst, _Glast - 1);
		if (_Glast == _First && _Gfirst == _Last)
			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

		if (_Glast == _First)
			{	
			if (_Plast != _Gfirst)
				::std:: iter_swap(_Pfirst, _Plast);
			++_Plast;
			::std:: iter_swap(_Pfirst++, _Gfirst++);
			}
		else if (_Gfirst == _Last)
			{	
			if (--_Glast != --_Pfirst)
				::std:: iter_swap(_Glast, _Pfirst);
			::std:: iter_swap(_Pfirst, --_Plast);
			}
		else
			::std:: iter_swap(_Gfirst++, --_Glast);
		}
	}

template<class _RanIt,
	class _Diff,
	class _Pr> inline
	void _Sort(_RanIt _First, _RanIt _Last, _Diff _Ideal, _Pr _Pred)
	{	
	_Diff _Count;
	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )
		{	
		pair<_RanIt, _RanIt> _Mid =
			_Unguarded_partition(_First, _Last, _Pred);
		_Ideal /= 2, _Ideal += _Ideal / 2;	

		if (_Mid.first - _First < _Last - _Mid.second)
			{	
			_Sort(_First, _Mid.first, _Ideal, _Pred);
			_First = _Mid.second;
			}
		else
			{	
			_Sort(_Mid.second, _Last, _Ideal, _Pred);
			_Last = _Mid.first;
			}
		}

	if (_ISORT_MAX < _Count)
		{	
		::std:: make_heap(_First, _Last, _Pred);
		::std:: sort_heap(_First, _Last, _Pred);
		}
	else if (1 < _Count)
		_Insertion_sort(_First, _Last, _Pred);	
	}

template<class _RanIt,
	class _Pr> inline
	void sort(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	;
	;
	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);
	}

		
template<class _BidIt,
	class _OutIt,
	class _Diff> inline
	void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count)
	{	
	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)
		{	
		_BidIt _Mid1 = _First;
		::std:: advance(_Mid1, _Chunk);
		_BidIt _Mid2 = _Mid1;
		::std:: advance(_Mid2, _Chunk);

		_Dest = _Merge(_First, _Mid1, _Mid1, _Mid2, _Dest);
		_First = _Mid2;
		}

	if (_Count <= _Chunk)
		_Move(_First, _Last, _Dest);	
	else
		{	
		_BidIt _Mid = _First;
		::std:: advance(_Mid, _Chunk);

		_Merge(_First, _Mid, _Mid, _Last, _Dest);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty> inline
	void _Buffered_merge_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf)
	{	
	_BidIt _Mid = _First;
	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)
		{	
		_BidIt _Midend = _Mid;
		::std:: advance(_Midend, (int)_ISORT_MAX);

		_Insertion_sort(_Mid, _Midend);
		_Mid = _Midend;
		}
	_Insertion_sort(_Mid, _Last);	

	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)
		{	
		_Chunked_merge(_First, _Last, _Tempbuf._Init(),
			_Chunk, _Count);
		_Chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
			_Chunk *= 2, _Count);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty> inline
	void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf)
	{	
	if (_Count <= _ISORT_MAX)
		_Insertion_sort(_First, _Last);	
	else
		{	
		_Diff _Count2 = (_Count + 1) / 2;
		_BidIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (_Count2 <= _Tempbuf._Maxlen())
			{	
			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);
			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);
			}
		else
			{	
			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);
			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);
			}

		_Buffered_merge(_First, _Mid, _Last,
			_Count2, _Count - _Count2, _Tempbuf);	
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty> inline
	void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff *, _Ty *)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);
	_Stable_sort(_First, _Last, _Count, _Tempbuf);
	}

template<class _BidIt> inline
	void stable_sort(_BidIt _First, _BidIt _Last)
	{	
	;
	if (_First != _Last)
		_Stable_sort(_Unchecked(_First), _Unchecked(_Last),
			_Dist_type(_First), _Val_type(_First));
	}

		
template<class _BidIt,
	class _OutIt,
	class _Diff,
	class _Pr> inline
	void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count, _Pr _Pred)
	{	
	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)
		{	
		_BidIt _Mid1 = _First;
		::std:: advance(_Mid1, _Chunk);
		_BidIt _Mid2 = _Mid1;
		::std:: advance(_Mid2, _Chunk);

		_Dest = _Merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);
		_First = _Mid2;
		}

	if (_Count <= _Chunk)
		_Move(_First, _Last, _Dest);	
	else
		{	
		_BidIt _Mid1 = _First;
		::std:: advance(_Mid1, _Chunk);

		_Merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Buffered_merge_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
	{	
	_BidIt _Mid = _First;
	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)
		{	
		_BidIt _Midn = _Mid;
		::std:: advance(_Midn, (int)_ISORT_MAX);

		_Insertion_sort(_Mid, _Midn, _Pred);
		_Mid = _Midn;
		}
	_Insertion_sort(_Mid, _Last, _Pred);	

	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)
		{	
		_Chunked_merge(_First, _Last, _Tempbuf._Init(),
			_Chunk, _Count, _Pred);
		_Chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
			_Chunk *= 2, _Count, _Pred);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
	{	
	if (_Count <= _ISORT_MAX)
		_Insertion_sort(_First, _Last, _Pred);	
	else
		{	
		_Diff _Count2 = (_Count + 1) / 2;
		_BidIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (_Count2 <= _Tempbuf._Maxlen())
			{	
			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
				_Tempbuf, _Pred);
			}
		else
			{	
			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);
			}

		_Buffered_merge(_First, _Mid, _Last,
			_Count2, _Count - _Count2, _Tempbuf, _Pred);	
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff *, _Ty *, _Pr _Pred)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);
	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);
	}

template<class _BidIt,
	class _Pr> inline
	void stable_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	;
	;
	if (_First != _Last)
		_Stable_sort(_Unchecked(_First), _Unchecked(_Last),
			_Dist_type(_First), _Val_type(_First), _Pred);
	}

		
template<class _RanIt,
	class _Ty> inline
	void _Partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Ty *)
	{	
	;
	;
	::std:: make_heap(_First, _Mid);

	for (_RanIt _Next = _Mid; _Next < _Last; ++_Next)
		if (((*_Next) < (*_First)))
			{	
			_Ty _Val = _Move(*_Next);
			_Pop_heap(_First, _Mid, _Next, _Move(_Val),
				_Dist_type(_First));
			}
	::std:: sort_heap(_First, _Mid);
	}

template<class _RanIt> inline
	void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{	
	_Partial_sort(
		_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last),
		_Val_type(_First));
	}

		
template<class _RanIt,
	class _Ty,
	class _Pr> inline
	void _Partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last,
		_Pr _Pred, _Ty *)
	{	
	;
	;
	;
	::std:: make_heap(_First, _Mid, _Pred);

	for (_RanIt _Next = _Mid; _Next < _Last; ++_Next)
		if (_Pred(*_Next, *_First))
			{	
			_Ty _Val = _Move(*_Next);
			_Pop_heap(_First, _Mid, _Next, _Move(_Val), _Pred,
				_Dist_type(_First));
			}
	::std:: sort_heap(_First, _Mid, _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	
	_Partial_sort(
		_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred,
		_Val_type(_First));
	}

		
template<class _InIt,
	class _RanIt,
	class _Diff,
	class _Ty> inline
	_RanIt _Partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2, _Diff *, _Ty *)
	{	
	_RanIt _Mid2 = _First2;
	for (; _First1 != _Last1 && _Mid2 != _Last2; ++_First1, ++_Mid2)
		*_Mid2 = *_First1;	
	::std:: make_heap(_First2, _Mid2);

	for (; _First1 != _Last1; ++_First1)
		if (((*_First1) < (*_First2)))
			_Adjust_heap(_First2, _Diff(0), _Diff(_Mid2 - _First2),
				_Ty(*_First1));	

	::std:: sort_heap(_First2, _Mid2);
	return (_Mid2);
	}

template<class _InIt,
	class _RanIt> inline
	_RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2)
	{	
	;
	;
	return (_First1 == _Last1 || _First2 == _Last2 ? _First2
		: _Rechecked(_First2,
			_Partial_sort_copy(
				_Unchecked(_First1), _Unchecked(_Last1),
				_Unchecked(_First2), _Unchecked(_Last2),
				_Dist_type(_First2), _Val_type(_First1))));
	}

		
template<class _InIt,
	class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_RanIt _Partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2, _Pr _Pred, _Diff *, _Ty *)
	{	
	_RanIt _Mid2 = _First2;
	for (; _First1 != _Last1 && _Mid2 != _Last2; ++_First1, ++_Mid2)
		*_Mid2 = *_First1;	
	::std:: make_heap(_First2, _Mid2, _Pred);

	for (; _First1 != _Last1; ++_First1)
		if (_Pred(*_First1, *_First2))
			_Adjust_heap(_First2, _Diff(0), _Diff(_Mid2 - _First2),
				_Ty(*_First1), _Pred);	

	::std:: sort_heap(_First2, _Mid2, _Pred);
	return (_Mid2);
	}

template<class _InIt,
	class _RanIt,
	class _Pr> inline
	_RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2, _Pr _Pred)
	{	
	;
	;
	;
	return (_First1 == _Last1 || _First2 == _Last2 ? _First2
		: _Rechecked(_First2,
			_Partial_sort_copy(
				_Unchecked(_First1), _Unchecked(_Last1),
				_Unchecked(_First2), _Unchecked(_Last2), _Pred,
				_Dist_type(_First2), _Val_type(_First1))));
	}

		
template<class _RanIt> inline
	void _Nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
	{	
	for (; _ISORT_MAX < _Last - _First; )
		{	
		pair<_RanIt, _RanIt> _Mid =
			_Unguarded_partition(_First, _Last);

		if (_Mid.second <= _Nth)
			_First = _Mid.second;
		else if (_Mid.first <= _Nth)
			return;	
		else
			_Last = _Mid.first;
		}

	_Insertion_sort(_First, _Last);	
	}

template<class _RanIt> inline
	void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
	{	
	;
	_Nth_element(
		_Unchecked(_First), _Unchecked(_Nth), _Unchecked(_Last));
	}

		
template<class _RanIt,
	class _Pr> inline
	void _Nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
	{	
	for (; _ISORT_MAX < _Last - _First; )
		{	
		pair<_RanIt, _RanIt> _Mid =
			_Unguarded_partition(_First, _Last, _Pred);

		if (_Mid.second <= _Nth)
			_First = _Mid.second;
		else if (_Mid.first <= _Nth)
			return;	
		else
			_Last = _Mid.first;
		}

	_Insertion_sort(_First, _Last, _Pred);	
	}

template<class _RanIt,
	class _Pr> inline
	void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
	{	
	;
	;
	_Nth_element(
		_Unchecked(_First), _Unchecked(_Nth), _Unchecked(_Last), _Pred);
	}

		
template<class _InIt1,
	class _InIt2> inline
	bool _Includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (((*_First2) < (*_First1)))
			return (false);
		else if (*_First1 < *_First2)
			++_First1;
		else
			{	
			++_First1;
			++_First2;
			}
	return (_First2 == _Last2);
	}

template<class _InIt1,
	class _InIt2> inline
	bool includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	;
	;
	return (_Includes(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2)));
	}

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Pred(*_First2, *_First1))
			return (false);
		else if (_Pred(*_First1, *_First2))
			++_First1;
		else
			{	
			++_First1;
			++_First2;
			}
	return (_First2 == _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	;
	;
	return (_Includes(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
	}

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (((*_First1) < (*_First2)))
			{	
			*_Dest++ = *_First1;
			++_First1;
			}
		else if (*_First2 < *_First1)
			{	
			*_Dest++ = *_First2;
			++_First2;
			}
		else
			{	
			*_Dest++ = *_First1;
			++_First1;
			++_First2;
			}
	_Dest = ::std:: copy(_First1, _Last1, _Dest);
	return (::std:: copy(_First2, _Last2, _Dest));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	
	return (_Set_union(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest));
	}

 





















































#line 4441 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Pred(*_First1, *_First2))
			{	
			*_Dest++ = *_First1;
			++_First1;
			}
		else if (_Pred(*_First2, *_First1))
			{	
			*_Dest++ = *_First2;
			++_First2;
			}
		else
			{	
			*_Dest++ = *_First1;
			++_First1;
			++_First2;
			}
	_Dest = ::std:: copy(_First1, _Last1, _Dest);
	return (::std:: copy(_First2, _Last2, _Dest));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return (_Set_union(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred));
	}

 

























































#line 4543 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (((*_First1) < (*_First2)))
			++_First1;
		else if (*_First2 < *_First1)
			++_First2;
		else
			{	
			*_Dest++ = *_First1++;
			++_First2;
			}
	return (_Dest);
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return (_Set_intersection(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest));
	}

 





















































#line 4631 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Pred(*_First1, *_First2))
			++_First1;
		else if (_Pred(*_First2, *_First1))
			++_First2;
		else
			{	
			*_Dest++ = *_First1++;
			++_First2;
			}
	return (_Dest);
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	return (_Set_intersection(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred));
	}

 

























































#line 4725 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (((*_First1) < (*_First2)))
			{	
			*_Dest++ = *_First1;
			++_First1;
			}
		else if (*_First2 < *_First1)
			++_First2;
		else
			{	
			++_First1;
			++_First2;
			}
	return (::std:: copy(_First1, _Last1, _Dest));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	
	return (_Set_difference(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest));
	}

 























































#line 4820 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Pred(*_First1, *_First2))
			{	
			*_Dest++ = *_First1;
			++_First1;
			}
		else if (_Pred(*_First2, *_First1))
			++_First2;
		else
			{	
			++_First1;
			++_First2;
			}
	return (::std:: copy(_First1, _Last1, _Dest));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	
	return (_Set_difference(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred));
	}

 



























































#line 4921 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (((*_First1) < (*_First2)))
			{	
			*_Dest++ = *_First1;
			++_First1;
			}
		else if (*_First2 < *_First1)
			{	
			*_Dest++ = *_First2;
			++_First2;
			}
		else
			{	
			++_First1;
			++_First2;
			}
	_Dest = ::std:: copy(_First1, _Last1, _Dest);
	return (::std:: copy(_First2, _Last2, _Dest));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	
	return (_Set_symmetric_difference(
		_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest));
	}

 
























































#line 5022 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Pred(*_First1, *_First2))
			{	
			*_Dest++ = *_First1;
			++_First1;
			}
		else if (_Pred(*_First2, *_First1))
			{	
			*_Dest++ = *_First2;
			++_First2;
			}
		else
			{	
			++_First1;
			++_First2;
			}
	_Dest = ::std:: copy(_First1, _Last1, _Dest);
	return (::std:: copy(_First2, _Last2, _Dest));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	
	return (_Set_symmetric_difference(
		_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred));
	}

 




























































#line 5129 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _FwdIt> inline
	_FwdIt _Max_element(_FwdIt _First, _FwdIt _Last)
	{	
	_FwdIt _Found = _First;
	if (_First != _Last)
		for (; ++_First != _Last; )
			if (((*_Found) < (*_First)))
				_Found = _First;
	return (_Found);
	}

template<class _FwdIt> inline
	_FwdIt max_element(_FwdIt _First, _FwdIt _Last)
	{	
	;
	return (_Rechecked(_First,
		_Max_element(_Unchecked(_First), _Unchecked(_Last))));
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_FwdIt _Found = _First;
	if (_First != _Last)
		for (; ++_First != _Last; )
			if (_Pred(*_Found, *_First))
				_Found = _First;
	return (_Found);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_Rechecked(_First,
		_Max_element(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _FwdIt> inline
	_FwdIt _Min_element(_FwdIt _First, _FwdIt _Last)
	{	
	_FwdIt _Found = _First;
	if (_First != _Last)
		for (; ++_First != _Last; )
			if (((*_First) < (*_Found)))
				_Found = _First;
	return (_Found);
	}

template<class _FwdIt> inline
	_FwdIt min_element(_FwdIt _First, _FwdIt _Last)
	{	
	;
	return (_Rechecked(_First,
		_Min_element(_Unchecked(_First), _Unchecked(_Last))));
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_FwdIt _Found = _First;
	if (_First != _Last)
		for (; ++_First != _Last; )
			if (_Pred(*_First, *_Found))
				_Found = _First;
	return (_Found);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_Rechecked(_First,
		_Min_element(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

 
		
template<class _FwdIt> inline
	pair<_FwdIt, _FwdIt>
		_Minmax_element(_FwdIt _First, _FwdIt _Last)
	{	
	pair<_FwdIt, _FwdIt> _Found(_First, _First);

	if (_First != _Last)
		for (; ++_First != _Last; )
			{	
			_FwdIt _Next = _First;
			if (++_Next == _Last)
				{	
				if (((*_First) < (*_Found.first)))
					_Found.first = _First;
				else if (((*_Found.second) < (*_First)))
					_Found.second = _First;
				}
			else
				{	
				if (((*_Next) < (*_First)))
					{	
					if (((*_Next) < (*_Found.first)))
						_Found.first = _Next;
					if (((*_Found.second) < (*_First)))
						_Found.second = _First;
					}
				else
					{	
					if (((*_First) < (*_Found.first)))
						_Found.first = _First;
					if (((*_Found.second) < (*_Next)))
						_Found.second = _Next;
					}
				_First = _Next;
				}
			}
	return (_Found);
	}

template<class _FwdIt> inline
	pair<_FwdIt, _FwdIt>
		minmax_element(_FwdIt _First, _FwdIt _Last)
	{	
	;
	pair<typename _Get_unchecked_type<_FwdIt>::type, typename _Get_unchecked_type<_FwdIt>::type> _Ans(
		_Minmax_element(_Unchecked(_First), _Unchecked(_Last)));
	return (pair<_FwdIt, _FwdIt>(
		_Rechecked(_First, _Ans.first),
		_Rechecked(_Last, _Ans.second)));
	}

		
template<class _FwdIt,
	class _Pr> inline
	pair<_FwdIt, _FwdIt>
		_Minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	pair<_FwdIt, _FwdIt> _Found(_First, _First);

	if (_First != _Last)
		for (; ++_First != _Last; )
			{	
			_FwdIt _Next = _First;
			if (++_Next == _Last)
				{	
				if (_Pred(*_First, *_Found.first))
					_Found.first = _First;
				else if (_Pred(*_Found.second, *_First))
					_Found.second = _First;
				}
			else
				{	
				if (_Pred(*_Next, *_First))
					{	
					if (_Pred(*_Next, *_Found.first))
						_Found.first = _Next;
					if (_Pred(*_Found.second, *_First))
						_Found.second = _First;
					}
				else
					{	
					if (_Pred(*_First, *_Found.first))
						_Found.first = _First;
					if (_Pred(*_Found.second, *_Next))
						_Found.second = _Next;
					}
				_First = _Next;
				}
			}
	return (_Found);
	}

template<class _FwdIt,
	class _Pr> inline
	pair<_FwdIt, _FwdIt>
		minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	;
	;
	pair<typename _Get_unchecked_type<_FwdIt>::type, typename _Get_unchecked_type<_FwdIt>::type> _Ans(
		_Minmax_element(_Unchecked(_First), _Unchecked(_Last), _Pred));
	return (pair<_FwdIt, _FwdIt>(
		_Rechecked(_First, _Ans.first),
		_Rechecked(_Last, _Ans.second)));
	}
 #line 5324 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"

		
template<class _BidIt> inline
	bool _Next_permutation(_BidIt _First, _BidIt _Last)
	{	
	_BidIt _Next = _Last;
	if (_First == _Last || _First == --_Next)
		return (false);

	for (; ; )
		{	
		_BidIt _Next1 = _Next;
		if (((*--_Next) < (*_Next1)))
			{	
			_BidIt _Mid = _Last;
			for (; !((*_Next) < (*--_Mid)); )
				;
			::std:: iter_swap(_Next, _Mid);
			::std:: reverse(_Next1, _Last);
			return (true);
			}

		if (_Next == _First)
			{	
			::std:: reverse(_First, _Last);
			return (false);
			}
		}
	}

template<class _BidIt> inline
	bool next_permutation(_BidIt _First, _BidIt _Last)
	{	
	;
	return (_Next_permutation(_Unchecked(_First), _Unchecked(_Last)));
	}

		
template<class _BidIt,
	class _Pr> inline
	bool _Next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_BidIt _Next = _Last;
	if (_First == _Last || _First == --_Next)
		return (false);

	for (; ; )
		{	
		_BidIt _Next1 = _Next;
		if (_Pred(*--_Next, *_Next1))
			{	
			_BidIt _Mid = _Last;
			for (; !_Pred(*_Next, *--_Mid); )
				;
			::std:: iter_swap(_Next, _Mid);
			::std:: reverse(_Next1, _Last);
			return (true);
			}

		if (_Next == _First)
			{	
			::std:: reverse(_First, _Last);
			return (false);
			}
		}
	}

template<class _BidIt,
	class _Pr> inline
	bool next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_Next_permutation(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		
template<class _BidIt> inline
	bool _Prev_permutation(_BidIt _First, _BidIt _Last)
	{	
	_BidIt _Next = _Last;
	if (_First == _Last || _First == --_Next)
		return (false);
	for (; ; )
		{	
		_BidIt _Next1 = _Next;
		if (((*_Next1) < (*--_Next)))
			{	
			_BidIt _Mid = _Last;
			for (; !((*--_Mid) < (*_Next)); )
				;
			::std:: iter_swap(_Next, _Mid);
			::std:: reverse(_Next1, _Last);
			return (true);
			}

		if (_Next == _First)
			{	
			::std:: reverse(_First, _Last);
			return (false);
			}
		}
	}

template<class _BidIt> inline
	bool prev_permutation(_BidIt _First, _BidIt _Last)
	{	
	;
	return (_Prev_permutation(_Unchecked(_First), _Unchecked(_Last)));
	}

		
template<class _BidIt,
	class _Pr> inline
	bool _Prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_BidIt _Next = _Last;
	if (_First == _Last || _First == --_Next)
		return (false);

	for (; ; )
		{	
		_BidIt _Next1 = _Next;
		if (_Pred(*_Next1, *--_Next))
			{	
			_BidIt _Mid = _Last;
			for (; !_Pred(*--_Mid, *_Next); )
				;
			::std:: iter_swap(_Next, _Mid);
			::std:: reverse(_Next1, _Last);
			return (true);
			}

		if (_Next == _First)
			{	
			::std:: reverse(_First, _Last);
			return (false);
			}
		}
	}

template<class _BidIt,
	class _Pr> inline
	bool prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_Prev_permutation(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

 
		
template<class _RanIt,
	class _Diff> inline
	_RanIt _Is_heap_until(_RanIt _First, _RanIt _Last, _Diff *)
	{	
	_Diff _Size = _Last - _First;

	if (2 <= _Size)
		for (_Diff _Off = 0; ++_Off < _Size; )
			if (((*(_First + (_Off - 1) / 2)) < (*(_First + _Off))))
				return (_First + _Off);
	return (_Last);
	}

template<class _RanIt>
	_RanIt is_heap_until(_RanIt _First, _RanIt _Last)
	{	
	;
	return (_Rechecked(_First,
		_Is_heap_until(_Unchecked(_First), _Unchecked(_Last),
			_Dist_type(_First))));
	}

template<class _RanIt>
	bool is_heap(_RanIt _First, _RanIt _Last)
	{	
	return (_Is_heap_until(_First, _Last, _Dist_type(_First))
		== _Last);
	}

		
template<class _RanIt,
	class _Diff,
	class _Pr> inline
	_RanIt _Is_heap_until(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *)
	{	
	_Diff _Size = _Last - _First;

	if (2 <= _Size)
		for (_Diff _Off = 0; ++_Off < _Size; )
			if (_Pred(*(_First + (_Off - 1) / 2), *(_First + _Off)))
#line 5517 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"
				return (_First + _Off);
	return (_Last);
	}

template<class _RanIt,
	class _Pr>
	_RanIt is_heap_until(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_Rechecked(_First,
		_Is_heap_until(_Unchecked(_First), _Unchecked(_Last), _Pred,
			_Dist_type(_First))));
	}

template<class _RanIt,
	class _Pr>
	bool is_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	return (_Is_heap_until(_First, _Last, _Pred, _Dist_type(_First))
		== _Last);
	}

		
template<class _FwdIt> inline
	_FwdIt _Is_sorted_until(_FwdIt _First, _FwdIt _Last)
	{	
	if (_First != _Last)
		for (_FwdIt _Next = _First; ++_Next != _Last; ++_First)
			if (((*_Next) < (*_First)))
				return (_Next);
	return (_Last);
	}

template<class _FwdIt> inline
	_FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last)
	{	
	;
	return (_Rechecked(_First,
		_Is_sorted_until(_Unchecked(_First), _Unchecked(_Last))));
	}

template<class _FwdIt> inline
	bool is_sorted(_FwdIt _First, _FwdIt _Last)
	{	
	return (::std:: is_sorted_until(_First, _Last) == _Last);
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Is_sorted_until(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	if (_First != _Last)
		for (_FwdIt _Next = _First; ++_Next != _Last; ++_First)
			if (_Pred(*_Next, *_First))
				return (_Next);
	return (_Last);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	;
	;
	return (_Rechecked(_First,
		_Is_sorted_until(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

template<class _FwdIt,
	class _Pr> inline
	bool is_sorted(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	return (::std:: is_sorted_until(_First, _Last, _Pred) == _Last);
	}
 #line 5594 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 5599 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"
#line 5600 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\algorithm"























#line 56 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"

#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"


















































































































































































































































































































































































































































#line 58 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvstd.hpp"


















































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"


















































































































































































































































































































































































































































#line 52 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvstd.hpp"


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cctype"

#pragma once










 #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ctype.h"













#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ctype.h"


extern "C" {
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ctype.h"











































#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ctype.h"










                                













  __declspec(dllimport) int __cdecl _isctype(  int _C,   int _Type);
  __declspec(dllimport) int __cdecl _isctype_l(  int _C,   int _Type,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isalpha(  int _C);
  __declspec(dllimport) int __cdecl _isalpha_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isupper(  int _C);
  __declspec(dllimport) int __cdecl _isupper_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl islower(  int _C);
  __declspec(dllimport) int __cdecl _islower_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isdigit(  int _C);
  __declspec(dllimport) int __cdecl _isdigit_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isxdigit(  int _C);
  __declspec(dllimport) int __cdecl _isxdigit_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isspace(  int _C);
  __declspec(dllimport) int __cdecl _isspace_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl ispunct(  int _C);
  __declspec(dllimport) int __cdecl _ispunct_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isalnum(  int _C);
  __declspec(dllimport) int __cdecl _isalnum_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isprint(  int _C);
  __declspec(dllimport) int __cdecl _isprint_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isgraph(  int _C);
  __declspec(dllimport) int __cdecl _isgraph_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iscntrl(  int _C);
  __declspec(dllimport) int __cdecl _iscntrl_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl toupper(  int _C);
   __declspec(dllimport) int __cdecl tolower(  int _C);
   __declspec(dllimport) int __cdecl _tolower(  int _C);
  __declspec(dllimport) int __cdecl _tolower_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl _toupper(  int _C);
  __declspec(dllimport) int __cdecl _toupper_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl __isascii(  int _C);
  __declspec(dllimport) int __cdecl __toascii(  int _C);
  __declspec(dllimport) int __cdecl __iscsymf(  int _C);
  __declspec(dllimport) int __cdecl __iscsym(  int _C);

#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ctype.h"





















































































#line 214 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ctype.h"












































#line 259 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ctype.h"






#line 266 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ctype.h"





























































































#line 360 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ctype.h"
















#line 377 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ctype.h"

#line 379 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ctype.h"


}
#line 383 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ctype.h"

#line 385 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ctype.h"
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cctype"
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cctype"

 
namespace std {
using :: isalnum; using :: isalpha; using :: iscntrl;
using :: isdigit; using :: isgraph; using :: islower;
using :: isprint; using :: ispunct; using :: isspace;
using :: isupper; using :: isxdigit; using :: tolower;
using :: toupper;
}
 #line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cctype"

	














#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cctype"





#line 55 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvstd.hpp"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iterator"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\istream"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ostream"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ios"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocnum"

#pragma once







#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\streambuf"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xiosbase"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

#pragma once





#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdexcept"

#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
 #pragma warning(disable: 4127)

  #pragma warning(disable: 4251)

template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Ax = allocator<_Elem> >
	class basic_string;

  
  
  

		
template<class _Mystr>
	class _String_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			typename _Mystr::value_type,
			typename _Mystr::difference_type,
			typename _Mystr::const_pointer,
			typename _Mystr::const_reference,
			_Iterator_base>
	{	
public:
	typedef _String_const_iterator<_Mystr> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Mystr::value_type value_type;
	typedef typename _Mystr::difference_type difference_type;
	typedef typename _Mystr::const_pointer pointer;
	typedef typename _Mystr::const_reference reference;

	_String_const_iterator()
		{	
		this->_Ptr = 0;
		}

	_String_const_iterator(pointer _Parg, const _Container_base *_Pstring)
		{	
		this->_Adopt(_Pstring);
		this->_Ptr = _Parg;
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr));
		}

	reference operator*() const
		{	
 










#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"





#line 90 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		;

		return (*this->_Ptr);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 









#line 114 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"




#line 119 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		++this->_Ptr;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 








#line 143 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"



#line 147 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		--this->_Ptr;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
 










#line 173 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"





#line 179 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		_Ptr += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr - _Right._Ptr);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr < _Right._Ptr);
		}

	bool operator>(const _Myiter& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	
		return (!(*this < _Right));
		}

 










#line 256 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"






#line 263 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"
	void _Compat(const _Myiter&) const
		{	
		}
 #line 267 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

	pointer _Ptr;	
	};

template<class _Mystr> inline
	typename _String_const_iterator<_Mystr>::_Unchecked_type
		_Unchecked(_String_const_iterator<_Mystr> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mystr> inline
	_String_const_iterator<_Mystr>
		_Rechecked(_String_const_iterator<_Mystr>& _Iter,
			typename _String_const_iterator<_Mystr>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Mystr> inline
	_String_const_iterator<_Mystr> operator+(
		typename _String_const_iterator<_Mystr>
			::difference_type _Off,
		_String_const_iterator<_Mystr> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Mystr>
	class _String_iterator
		: public _String_const_iterator<_Mystr>
	{	
public:
	typedef _String_iterator<_Mystr> _Myiter;
	typedef _String_const_iterator<_Mystr> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Mystr::value_type value_type;
	typedef typename _Mystr::difference_type difference_type;
	typedef typename _Mystr::pointer pointer;
	typedef typename _Mystr::reference reference;

	_String_iterator()
		{	
		}

	_String_iterator(pointer _Parg, const _Container_base *_Pstring)
		: _Mybase(_Parg, _Pstring)
		{	
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr));
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return ((_Mybase)*this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Mystr> inline
	typename _String_iterator<_Mystr>::_Unchecked_type
		_Unchecked(_String_iterator<_Mystr> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mystr> inline
	_String_iterator<_Mystr>
		_Rechecked(_String_iterator<_Mystr>& _Iter,
			typename _String_iterator<_Mystr>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Mystr> inline
	_String_iterator<_Mystr> operator+(
		typename _String_iterator<_Mystr>
			::difference_type _Off,
		_String_iterator<_Mystr> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference>
	struct _String_iter_types
	{	
	typedef _Value_type value_type;
	typedef _Size_type size_type;
	typedef _Difference_type difference_type;
	typedef _Pointer pointer;
	typedef _Const_pointer const_pointer;
	typedef _Reference reference;
	typedef _Const_reference const_reference;
	};

template<class _Ty,
	class _Alloc0>
	struct _String_base_types
	{	
	typedef _Alloc0 _Alloc;
	typedef _String_base_types<_Ty, _Alloc> _Myt;

 
	typedef _Wrap_alloc<_Alloc> _Alty0;
	typedef typename _Alty0::template rebind<_Ty>::other _Alty;

 

#line 461 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

	typedef typename _Alty::pointer _Tptr;
	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;

	typedef typename _If<_Is_simple_alloc<_Alty>::value,
		_Simple_types<typename _Alty::value_type>,
		_String_iter_types<typename _Alty::value_type,
			typename _Alty::size_type,
			typename _Alty::difference_type,
			typename _Alty::pointer,
			typename _Alty::const_pointer,
			typename _Alty::reference,
			typename _Alty::const_reference> >::type
		_Val_types;
	};

		
template<class _Val_types>
	class _String_val
		: public _Container_base
	{	
public:
	typedef _String_val<_Val_types> _Myt;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _String_iterator<_Myt> iterator;
	typedef _String_const_iterator<_Myt> const_iterator;

	_String_val()
		{	
		_Mysize = 0;
		_Myres = 0;
		}

	enum
		{	
		_BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
			: 16 / sizeof (value_type)};
	enum
		{	
		_ALLOC_MASK = sizeof (value_type) <= 1 ? 15
			: sizeof (value_type) <= 2 ? 7
			: sizeof (value_type) <= 4 ? 3
			: sizeof (value_type) <= 8 ? 1 : 0};

	value_type *_Myptr()
		{	
		return (this->_BUF_SIZE <= this->_Myres
			? ::std:: addressof(*this->_Bx._Ptr)
			: this->_Bx._Buf);
		}

	const value_type *_Myptr() const
		{	
		return (this->_BUF_SIZE <= this->_Myres
			? ::std:: addressof(*this->_Bx._Ptr)
			: this->_Bx._Buf);
		}

	union _Bxty
		{	
		value_type _Buf[_BUF_SIZE];
		pointer _Ptr;
		char _Alias[_BUF_SIZE];	
		} _Bx;

	size_type _Mysize;	
	size_type _Myres;	
	};

		
template<bool _Al_has_storage,
	class _Alloc_types>
	class _String_alloc
		: public _String_val<typename _Alloc_types::_Val_types>
	{	
public:
	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
	typedef typename _Alloc_types::_Alloc _Alloc;

	typedef typename _Alloc_types::_Alty _Alty;

 
	_String_alloc(const _Alloc& _Al = _Alloc())
		: _Alval(_Al)
		{	
		}

	void _Change_alloc(const _Alty& _Al)
		{	
		_Alval = _Al;
		}

	void _Swap_alloc(_Myt& _Right)
		{	
		_Swap_adl(this->_Alval, _Right._Alval);
		}

 










































#line 610 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

	_Alty& _Getal()
		{	
		return (_Alval);
		}

	const _Alty& _Getal() const
		{	
		return (_Alval);
		}

	_Alty _Alval;	
	};

template<class _Alloc_types>
	class _String_alloc<false, _Alloc_types>
		: public _String_val<typename _Alloc_types::_Val_types>
	{	
public:
	typedef _String_alloc<false, _Alloc_types> _Myt;
	typedef typename _Alloc_types::_Alloc _Alloc;

	typedef typename _Alloc_types::_Alty _Alty;

 
	_String_alloc(const _Alloc& = _Alloc())
		{	
		}

	void _Change_alloc(const _Alty&)
		{	
		}

	void _Swap_alloc(_Myt&)
		{	
		}

 





































#line 686 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

	_Alty _Getal() const
		{	
		return (_Alty());
		}
	};

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_string
		: public _String_alloc<!is_empty<_Alloc>::value,
			_String_base_types<_Elem, _Alloc> >
	{	
public:
	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
	typedef _String_alloc<!is_empty<_Alloc>::value,
		_String_base_types<_Elem, _Alloc> > _Mybase;
	typedef _Traits traits_type;
	typedef _Alloc allocator_type;

	typedef typename _Mybase::_Alty _Alty;

	typedef typename _Mybase::value_type value_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;

	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;

	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	basic_string(const _Myt& _Right)

 
		: _Mybase(_Right._Getal().select_on_container_copy_construction())

 

#line 732 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		{	
		_Tidy();
		assign(_Right, 0, npos);
		}

 
	basic_string(const _Myt& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Right, 0, npos);
		}
 #line 746 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

	basic_string()
		: _Mybase()
		{	
		_Tidy();
		}

	explicit basic_string(const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		}

	basic_string(const _Myt& _Right, size_type _Roff,
		size_type _Count = npos)
		: _Mybase(_Right._Getal())
		{	
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
		const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	basic_string(const _Elem *_Ptr, size_type _Count)
		: _Mybase()
		{	
		_Tidy();
		assign(_Ptr, _Count);
		}

	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ptr, _Count);
		}

	basic_string(const _Elem *_Ptr)
		: _Mybase()
		{	
		_Tidy();
		assign(_Ptr);
		}

	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ptr);
		}

	basic_string(size_type _Count, _Elem _Ch)
		: _Mybase()
		{	
		_Tidy();
		assign(_Count, _Ch);
		}

	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Count, _Ch);
		}

	template<class _Iter>
		basic_string(_Iter _First, _Iter _Last,
			typename enable_if<_Is_iterator<_Iter>::value,
				void>::type ** = 0)
		: _Mybase()
		{	
		_Tidy();
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
			typename enable_if<_Is_iterator<_Iter>::value,
				void>::type ** = 0)
		: _Mybase(_Al)
		{	
		_Tidy();
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Construct(_Iter _First,
			_Iter _Last, input_iterator_tag)
		{	
		try {
		for (; _First != _Last; ++_First)
			append((size_type)1, (_Elem)*_First);
		} catch (...) {
		_Tidy(true);
		throw;
		}
		}

	template<class _Iter>
		void _Construct(_Iter _First,
			_Iter _Last, forward_iterator_tag)
		{	
		;
		size_type _Count = 0;
		_Distance(_First, _Last, _Count);
		reserve(_Count);

		try {
		for (; _First != _Last; ++_First)
			append((size_type)1, (_Elem)*_First);
		} catch (...) {
		_Tidy(true);
		throw;
		}
		}

	basic_string(const_pointer _First, const_pointer _Last)
		: _Mybase()
		{	
		;
		_Tidy();
		if (_First != _Last)
			assign(&*_First, _Last - _First);
		}

	basic_string(const_pointer _First, const_pointer _Last,
		const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		;
		_Tidy();
		if (_First != _Last)
			assign(&*_First, _Last - _First);
		}

	basic_string(const_iterator _First, const_iterator _Last)
		: _Mybase()
		{	
		;
		_Tidy();
		if (_First != _Last)
			assign(&*_First, _Last - _First);
		}

	basic_string(_Myt&& _Right) throw ()
		: _Mybase(_Right._Getal())
		{	
		_Tidy();
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	basic_string(_Myt&& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		if (this->_Getal() != _Right._Getal())
			assign(_Right.begin(), _Right.end());
		else
			_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right) throw ()
		{	
		if (this != &_Right)
			{	
			_Tidy(true);

 
			if (this->_Getal() != _Right._Getal()
				&& _Alty::propagate_on_container_move_assignment::value)
				this->_Change_alloc(_Right._Getal());
 #line 923 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

			if (this->_Getal() != _Right._Getal())
				assign(_Right.begin(), _Right.end());
			else
				_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	_Myt& assign(_Myt&& _Right) throw ()
		{	
		if (this == &_Right)
			;
		else if (get_allocator() != _Right.get_allocator()
			&& this->_BUF_SIZE <= _Right._Myres)
			*this = _Right;
		else
			{	
			_Tidy(true);
			_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (_Right._Myres < this->_BUF_SIZE)
			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
				_Right._Mysize + 1);
		else
			{	
			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
			_Right._Bx._Ptr = pointer();
			}
		this->_Mysize = _Right._Mysize;
		this->_Myres = _Right._Myres;
		_Right._Tidy();
		}

	~basic_string() throw ()
		{	
		_Tidy(true);
		}

	 static const size_type npos;	

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
 
			if (this->_Getal() != _Right._Getal()
				&& _Alty::propagate_on_container_copy_assignment::value)
				{	
				_Tidy(true);
				this->_Change_alloc(_Right._Getal());
				}
 #line 981 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

			assign(_Right);
			}
		return (*this);
		}

	_Myt& operator=(const _Elem *_Ptr)
		{	
		return (assign(_Ptr));
		}

	_Myt& operator=(_Elem _Ch)
		{	
		return (assign(1, _Ch));
		}

	_Myt& operator+=(const _Myt& _Right)
		{	
		return (append(_Right));
		}

	_Myt& operator+=(const _Elem *_Ptr)
		{	
		return (append(_Ptr));
		}

	_Myt& operator+=(_Elem _Ch)
		{	
		return (append((size_type)1, _Ch));
		}

	_Myt& append(const _Myt& _Right)
		{	
		return (append(_Right, 0, npos));
		}

	_Myt& append(const _Myt& _Right,
		size_type _Roff, size_type _Count)
		{	
		if (_Right.size() < _Roff)
			_Xran();	
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	
		if (npos - this->_Mysize <= _Count)
			_Xlen();	

		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
			{	
			_Traits::copy(this->_Myptr() + this->_Mysize,
				_Right._Myptr() + _Roff, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& append(const _Elem *_Ptr, size_type _Count)
		{	
 


#line 1043 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		if (_Inside(_Ptr))
			return (append(*this,
				_Ptr - this->_Myptr(), _Count));	
		if (npos - this->_Mysize <= _Count)
			_Xlen();	

		size_type _Num;
		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
			{	
			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& append(const _Elem *_Ptr)
		{	
		;
		return (append(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt& append(size_type _Count, _Elem _Ch)
		{	
		if (npos - this->_Mysize <= _Count)
			_Xlen();	

		size_type _Num;
		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
			{	
			_Chassign(this->_Mysize, _Count, _Ch);
			_Eos(_Num);
			}
		return (*this);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		append(_Iter _First, _Iter _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& append(const_pointer _First, const_pointer _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& append(const_iterator _First, const_iterator _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& assign(const _Myt& _Right)
		{	
		return (assign(_Right, 0, npos));
		}

	_Myt& assign(const _Myt& _Right,
		size_type _Roff, size_type _Count)
		{	
		if (_Right.size() < _Roff)
			_Xran();	
		size_type _Num = _Right.size() - _Roff;
		if (_Count < _Num)
			_Num = _Count;	

		if (this == &_Right)
			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	
		else if (_Grow(_Num))
			{	
			_Traits::copy(this->_Myptr(),
				_Right._Myptr() + _Roff, _Num);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& assign(const _Elem *_Ptr, size_type _Count)
		{	
 


#line 1128 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		if (_Inside(_Ptr))
			return (assign(*this,
				_Ptr - this->_Myptr(), _Count));	

		if (_Grow(_Count))
			{	
			_Traits::copy(this->_Myptr(), _Ptr, _Count);
			_Eos(_Count);
			}
		return (*this);
		}

	_Myt& assign(const _Elem *_Ptr)
		{	
		;
		return (assign(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt& assign(size_type _Count, _Elem _Ch)
		{	
		if (_Count == npos)
			_Xlen();	

		if (_Grow(_Count))
			{	
			_Chassign(0, _Count, _Ch);
			_Eos(_Count);
			}
		return (*this);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		assign(_Iter _First, _Iter _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& assign(const_pointer _First, const_pointer _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& assign(const_iterator _First, const_iterator _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& insert(size_type _Off, const _Myt& _Right)
		{	
		return (insert(_Off, _Right, 0, npos));
		}

	_Myt& insert(size_type _Off,
		const _Myt& _Right, size_type _Roff, size_type _Count)
		{	
		if (this->_Mysize < _Off || _Right.size() < _Roff)
			_Xran();	
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	
		if (npos - this->_Mysize <= _Count)
			_Xlen();	

		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize - _Off);	
			if (this == &_Right)
				_Traits::move(this->_Myptr() + _Off,
					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
						_Count);	
			else
				_Traits::copy(this->_Myptr() + _Off,
					_Right._Myptr() + _Roff, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& insert(size_type _Off,
		const _Elem *_Ptr, size_type _Count)
		{	
 


#line 1218 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		if (_Inside(_Ptr))
			return (insert(_Off, *this,
				_Ptr - this->_Myptr(), _Count));	
		if (this->_Mysize < _Off)
			_Xran();	
		if (npos - this->_Mysize <= _Count)
			_Xlen();	
		size_type _Num;
		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize - _Off);	
			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& insert(size_type _Off, const _Elem *_Ptr)
		{	
		;
		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt& insert(size_type _Off,
		size_type _Count, _Elem _Ch)
		{	
		if (this->_Mysize < _Off)
			_Xran();	
		if (npos - this->_Mysize <= _Count)
			_Xlen();	
		size_type _Num;
		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize - _Off);	
			_Chassign(_Off, _Count, _Ch);	
			_Eos(_Num);
			}
		return (*this);
		}

	iterator insert(const_iterator _Where)
		{	
		return (insert(_Where, _Elem()));
		}

	iterator insert(const_iterator _Where, _Elem _Ch)
		{	
		size_type _Off = _Pdif(_Where, begin());
		insert(_Off, 1, _Ch);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
		{	
		size_type _Off = _Pdif(_Where, begin());
		insert(_Off, _Count, _Ch);
		return (begin() + _Off);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			iterator>::type
		insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	
		size_type _Off = _Pdif(_Where, begin());
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where,
		const_pointer _First, const_pointer _Last)
		{	
		size_type _Off = _Pdif(_Where, begin());
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where,
		const_iterator _First, const_iterator _Last)
		{	
		size_type _Off = _Pdif(_Where, begin());
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	_Myt& erase(size_type _Off = 0)
		{	
		if (this->_Mysize < _Off)
			_Xran();	
		_Eos(_Off);
		return (*this);
		}

	_Myt& erase(size_type _Off, size_type _Count)
		{	
		if (this->_Mysize < _Off)
			_Xran();	
		if (this->_Mysize - _Off <= _Count)
			_Eos(_Off);	
		else if (0 < _Count)
			{	
			value_type *_Ptr = this->_Myptr() + _Off;
			size_type _Newsize = this->_Mysize - _Count;
			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
			_Eos(_Newsize);
			}
		return (*this);
		}

	iterator erase(const_iterator _Where)
		{	
		size_type _Count = _Pdif(_Where, begin());
		erase(_Count, 1);
		return (iterator(this->_Myptr() + _Count, this));
		}

	iterator erase(const_iterator _First, const_iterator _Last)
		{	
		;
		size_type _Count = _Pdif(_First, begin());
		erase(_Count, _Pdif(_Last, _First));
		return (iterator(this->_Myptr() + _Count, this));
		}

	void clear() throw ()
		{	
		_Eos(0);
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
		{	
		return (replace(_Off, _N0, _Right, 0, npos));
		}

	_Myt& replace(size_type _Off,
		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
		{	
		if (this->_Mysize < _Off || _Right.size() < _Roff)
			_Xran();	
		if (this->_Mysize - _Off < _N0)
			_N0 = this->_Mysize - _Off;	
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	
		if (npos - _Count <= this->_Mysize - _N0)
			_Xlen();	

		size_type _Nm = this->_Mysize - _N0 - _Off;	
		size_type _Newsize = this->_Mysize + _Count - _N0;
		if (this->_Mysize < _Newsize)
			_Grow(_Newsize);

		if (this != &_Right)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::copy(this->_Myptr() + _Off,
				_Right._Myptr() + _Roff, _Count);	
			}
		else if (_Count <= _N0)
			{	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _Count);	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			}
		else if (_Roff <= _Off)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _Count);	
			}
		else if (_Off + _N0 <= _Roff)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + (_Roff + _Count - _N0),
				_Count);	
			}
		else
			{	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _N0);	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off + _N0,
				this->_Myptr() + _Roff + _Count,
				_Count - _N0);	
			}

		_Eos(_Newsize);
		return (*this);
		}

	_Myt& replace(size_type _Off,
		size_type _N0, const _Elem *_Ptr, size_type _Count)
		{	
 


#line 1426 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		if (_Inside(_Ptr))
			return (replace(_Off, _N0, *this,
				_Ptr - this->_Myptr(),
				_Count));	
		if (this->_Mysize < _Off)
			_Xran();	
		if (this->_Mysize - _Off < _N0)
			_N0 = this->_Mysize - _Off;	
		if (npos - _Count <= this->_Mysize - _N0)
			_Xlen();	
		size_type _Nm = this->_Mysize - _N0 - _Off;

		if (_Count < _N0)
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0,
				_Nm);	
		size_type _Num;
		if ((0 < _Count || 0 < _N0)
			&& _Grow(_Num = this->_Mysize + _Count - _N0))
			{	
			if (_N0 < _Count)
				_Traits::move(this->_Myptr() + _Off + _Count,
					this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
		{	
		;
		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt& replace(size_type _Off,
		size_type _N0, size_type _Count, _Elem _Ch)
		{	
		if (this->_Mysize < _Off)
			_Xran();	
		if (this->_Mysize - _Off < _N0)
			_N0 = this->_Mysize - _Off;	
		if (npos - _Count <= this->_Mysize - _N0)
			_Xlen();	
		size_type _Nm = this->_Mysize - _N0 - _Off;

		if (_Count < _N0)
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0,
				_Nm);	
		size_type _Num;
		if ((0 < _Count || 0 < _N0)
			&& _Grow(_Num = this->_Mysize + _Count - _N0))
			{	
			if (_N0 < _Count)
				_Traits::move(this->_Myptr() + _Off + _Count,
					this->_Myptr() + _Off + _N0, _Nm);	
			_Chassign(_Off, _Count, _Ch);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Myt& _Right)
		{	
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Elem *_Ptr, size_type _Count)
		{	
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Elem *_Ptr)
		{	
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		size_type _Count, _Elem _Ch)
		{	
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		replace(const_iterator _First, const_iterator _Last,
			_Iter _First2, _Iter _Last2)
		{	
		_Myt _Right(_First2, _Last2);
		replace(_First, _Last, _Right);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const_pointer _First2, const_pointer _Last2)
		{	
		if (_First2 == _Last2)
			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
		else
			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		pointer _First2, pointer _Last2)
		{	
		if (_First2 == _Last2)
			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
		else
			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const_iterator _First2, const_iterator _Last2)
		{	
		if (_First2 == _Last2)
			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
		else
			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		iterator _First2, iterator _Last2)
		{	
		if (_First2 == _Last2)
			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
		else
			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	iterator begin() throw ()
		{	
		return (iterator(this->_Myptr(), this));
		}

	const_iterator begin() const throw ()
		{	
		return (const_iterator(this->_Myptr(), this));
		}

	iterator end() throw ()
		{	
		return (iterator(this->_Myptr() + this->_Mysize, this));
		}

	const_iterator end() const throw ()
		{	
		return (const_iterator(this->_Myptr() + this->_Mysize, this));
		}

	reverse_iterator rbegin() throw ()
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const throw ()
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() throw ()
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const throw ()
		{	
		return (const_reverse_iterator(begin()));
		}

 
	const_iterator cbegin() const throw ()
		{	
		return (((const _Myt *)this)->begin());
		}

	const_iterator cend() const throw ()
		{	
		return (((const _Myt *)this)->end());
		}

	const_reverse_iterator crbegin() const throw ()
		{	
		return (((const _Myt *)this)->rbegin());
		}

	const_reverse_iterator crend() const throw ()
		{	
		return (((const _Myt *)this)->rend());
		}

	void shrink_to_fit()
		{	
		if ((size() | this->_ALLOC_MASK) < capacity())
			{	
			_Myt _Tmp(*this);
			swap(_Tmp);
			}
		}
 #line 1643 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

	reference at(size_type _Off)
		{	
		if (this->_Mysize <= _Off)
			_Xran();	
		return (this->_Myptr()[_Off]);
		}

	const_reference at(size_type _Off) const
		{	
		if (this->_Mysize <= _Off)
			_Xran();	
		return (this->_Myptr()[_Off]);
		}

	reference operator[](size_type _Off)
		{	
 



#line 1665 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

#line 1667 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		return (this->_Myptr()[_Off]);
		}

	const_reference operator[](size_type _Off) const
		{	
 



#line 1678 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

#line 1680 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		return (this->_Myptr()[_Off]);
		}

	void push_back(_Elem _Ch)
		{	
		insert(end(), _Ch);
		}

 
	void pop_back()
		{	
		erase(this->_Mysize - 1);	
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}
 #line 1715 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

	const _Elem *c_str() const throw ()
		{	
		return (this->_Myptr());
		}

	const _Elem *data() const throw ()
		{	
		return (c_str());
		}

	size_type length() const throw ()
		{	
		return (this->_Mysize);
		}

	size_type size() const throw ()
		{	
		return (this->_Mysize);
		}

	size_type max_size() const throw ()
		{	
		size_type _Num = this->_Getal().max_size();
		return (_Num <= 1 ? 1 : _Num - 1);
		}

	void resize(size_type _Newsize)
		{	
		resize(_Newsize, _Elem());
		}

	void resize(size_type _Newsize, _Elem _Ch)
		{	
		if (_Newsize <= this->_Mysize)
			_Eos(_Newsize);
		else
			append(_Newsize - this->_Mysize, _Ch);
		}

	size_type capacity() const throw ()
		{	
		return (this->_Myres);
		}

	void reserve(size_type _Newcap = 0)
		{	
		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
			{	
			size_type _Size = this->_Mysize;
			if (_Grow(_Newcap, true))
				_Eos(_Size);
			}
		}

	bool empty() const throw ()
		{	
		return (this->_Mysize == 0);
		}

	

	size_type copy(_Elem *_Ptr,
		size_type _Count, size_type _Off = 0) const
		{	
 


#line 1784 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		if (this->_Mysize < _Off)
			_Xran();	
		if (this->_Mysize - _Off < _Count)
			_Count = this->_Mysize - _Off;
		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
		return (_Count);
		}

	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
		size_type _Count, size_type _Off = 0) const
		{	
 


#line 1800 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		if (this->_Mysize < _Off)
			_Xran();	
		if (this->_Mysize - _Off < _Count)
			_Count = this->_Mysize - _Off;
		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
		return (_Count);
		}

	void _Swap_bx(_Myt& _Right)
		{	
		if (this->_BUF_SIZE <= this->_Myres)
			if (this->_BUF_SIZE <= _Right._Myres)
				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
			else
				{	
				pointer _Ptr = this->_Bx._Ptr;
				this->_Getal().destroy(&this->_Bx._Ptr);
				_Traits::copy(this->_Bx._Buf,
					_Right._Bx._Buf, _Right._Mysize + 1);
				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
				}
		else
			if (_Right._Myres < this->_BUF_SIZE)
				::std:: swap(this->_Bx._Buf, _Right._Bx._Buf);
			else
				{	
				pointer _Ptr = _Right._Bx._Ptr;
				this->_Getal().destroy(&_Right._Bx._Ptr);
				_Traits::copy(_Right._Bx._Buf,
					this->_Bx._Buf, this->_Mysize + 1);
				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
				}
		}

	void swap(_Myt& _Right)
		{	
		if (this == &_Right)
			;	
		else if (this->_Getal() == _Right._Getal())
			{	
			this->_Swap_all(_Right);
			_Swap_bx(_Right);
			::std:: swap(this->_Mysize, _Right._Mysize);
			::std:: swap(this->_Myres, _Right._Myres);
			}

 
		else if (_Alty::propagate_on_container_swap::value)
			{	
			this->_Swap_alloc(_Right);
			_Swap_bx(_Right);
			::std:: swap(this->_Bx, _Right._Bx);	
			::std:: swap(this->_Mysize, _Right._Mysize);
			::std:: swap(this->_Myres, _Right._Myres);
			}
 #line 1857 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		else
			{	
			_Myt _Tmp = *this;

			*this = _Right;
			_Right = _Tmp;
			}
		}

	size_type find(const _Myt& _Right, size_type _Off = 0) const throw ()
		{	
		return (find(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
 


#line 1879 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		if (_Count == 0 && _Off <= this->_Mysize)
			return (_Off);	

		size_type _Nm;
		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
			{	
			const _Elem *_Uptr, *_Vptr;
			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - this->_Myptr());	
			}

		return (npos);	
		}

	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
		{	
		;
		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find(_Elem _Ch, size_type _Off = 0) const
		{	
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type rfind(const _Myt& _Right, size_type _Off = npos) const throw ()
		{	
		return (rfind(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type rfind(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
 


#line 1920 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		if (_Count == 0)
			return (_Off < this->_Mysize ? _Off
				: this->_Mysize);	
		if (_Count <= this->_Mysize)
			{	
			const _Elem *_Uptr = this->_Myptr() +
				(_Off < this->_Mysize - _Count ? _Off
					: this->_Mysize - _Count);
			for (; ; --_Uptr)
				if (_Traits::eq(*_Uptr, *_Ptr)
					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - this->_Myptr());	
				else if (_Uptr == this->_Myptr())
					break;	
			}

		return (npos);	
		}

	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
		{	
		;
		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type rfind(_Elem _Ch, size_type _Off = npos) const
		{	
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_first_of(const _Myt& _Right,
		size_type _Off = 0) const throw ()
		{	
		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_first_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
 


#line 1964 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		if (0 < _Count && _Off < this->_Mysize)
			{	
			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
			for (const _Elem *_Uptr = this->_Myptr() + _Off;
				_Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - this->_Myptr());	
			}

		return (npos);	
		}

	size_type find_first_of(const _Elem *_Ptr,
		size_type _Off = 0) const
		{	
		;
		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_first_of(_Elem _Ch,
		size_type _Off = 0) const
		{	
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_last_of(const _Myt& _Right,
		size_type _Off = npos) const throw ()
		{	
		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_last_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
 


#line 2003 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		if (0 < _Count && 0 < this->_Mysize)
			{	
			const _Elem *_Uptr = this->_Myptr()
				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
			for (; ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - this->_Myptr());	
				else if (_Uptr == this->_Myptr())
					break;	
			}

		return (npos);	
		}

	size_type find_last_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{	
		;
		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_last_of(_Elem _Ch,
		size_type _Off = npos) const
		{	
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_first_not_of(const _Myt& _Right,
		size_type _Off = 0) const throw ()
		{	
		return (find_first_not_of(_Right._Myptr(), _Off,
			_Right.size()));
		}

	size_type find_first_not_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
 


#line 2045 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		if (_Off < this->_Mysize)
			{	
			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
			for (const _Elem *_Uptr = this->_Myptr() + _Off;
				_Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - this->_Myptr());
			}
		return (npos);
		}

	size_type find_first_not_of(const _Elem *_Ptr,
		size_type _Off = 0) const
		{	
		;
		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_first_not_of(_Elem _Ch,
		size_type _Off = 0) const
		{	
		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_last_not_of(const _Myt& _Right,
		size_type _Off = npos) const throw ()
		{	
		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_last_not_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
 


#line 2083 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		if (0 < this->_Mysize)
			{	
			const _Elem *_Uptr = this->_Myptr()
				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
			for (; ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - this->_Myptr());
				else if (_Uptr == this->_Myptr())
					break;
			}
		return (npos);
		}

	size_type find_last_not_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{	
		;
		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_last_not_of(_Elem _Ch,
		size_type _Off = npos) const
		{	
		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
		{	
		return (_Myt(*this, _Off, _Count, get_allocator()));
		}

	int compare(const _Myt& _Right) const throw ()
		{	
		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
		}

	int compare(size_type _Off, size_type _N0,
		const _Myt& _Right) const
		{	
		return (compare(_Off, _N0, _Right, 0, npos));
		}

	int compare(size_type _Off,
		size_type _N0, const _Myt& _Right,
		size_type _Roff, size_type _Count) const
		{	
		if (_Right.size() < _Roff)
			_Xran();	
		if (_Right._Mysize - _Roff < _Count)
			_Count = _Right._Mysize - _Roff;	
		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
		}

	int compare(const _Elem *_Ptr) const
		{	
		;
		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
		}

	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
		{	
		;
		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}

	int compare(size_type _Off,
		size_type _N0, const _Elem *_Ptr, size_type _Count) const
		{	
 


#line 2156 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"

		if (this->_Mysize < _Off)
			_Xran();	
		if (this->_Mysize - _Off < _N0)
			_N0 = this->_Mysize - _Off;	

		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
			_N0 < _Count ? _N0 : _Count);
		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
			: _N0 == _Count ? 0 : +1);
		}

	allocator_type get_allocator() const throw ()
		{	
		return (this->_Getal());
		}

	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
		{	
		if (_Count == 1)
			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
		else
			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
		}

	void _Copy(size_type _Newsize, size_type _Oldlen)
		{	
		size_type _Newres = _Newsize | this->_ALLOC_MASK;
		if (max_size() < _Newres)
			_Newres = _Newsize;	
		else if (this->_Myres / 2 <= _Newres / 3)
			;
		else if (this->_Myres <= max_size() - this->_Myres / 2)
			_Newres = this->_Myres
				+ this->_Myres / 2;	
		else
			_Newres = max_size();	

		_Elem *_Ptr;
		try {
			_Ptr = this->_Getal().allocate(_Newres + 1);
		} catch (...) {
			_Newres = _Newsize;	
			try {
				_Ptr = this->_Getal().allocate(_Newres + 1);
			} catch (...) {
			_Tidy(true);	
			throw;
			}
		}

		if (0 < _Oldlen)
			_Traits::copy(_Ptr, this->_Myptr(),
				_Oldlen);	
		_Tidy(true);
		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
		this->_Myres = _Newres;
		_Eos(_Oldlen);
		}

	void _Eos(size_type _Newsize)
		{	
		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
		}

	bool _Grow(size_type _Newsize,
		bool _Trim = false)
		{	
		if (max_size() < _Newsize)
			_Xlen();	
		if (this->_Myres < _Newsize)
			_Copy(_Newsize, this->_Mysize);	
		else if (_Trim && _Newsize < this->_BUF_SIZE)
			_Tidy(true,	
				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
		else if (_Newsize == 0)
			_Eos(0);	
		return (0 < _Newsize);	
		}

	bool _Inside(const _Elem *_Ptr)
		{	
		if (_Ptr == 0 || _Ptr < this->_Myptr()
			|| this->_Myptr() + this->_Mysize <= _Ptr)
			return (false);	
		else
			return (true);
		}

	static size_type _Pdif(const_iterator _P2,
		const_iterator _P1)
		{	
		return ((_P2)._Ptr == 0 ? 0 : _P2 - _P1);
		}

	void _Tidy(bool _Built = false,
		size_type _Newsize = 0)
		{	
		if (!_Built)
			;
		else if (this->_BUF_SIZE <= this->_Myres)
			{	
			pointer _Ptr = this->_Bx._Ptr;
			this->_Getal().destroy(&this->_Bx._Ptr);
			if (0 < _Newsize)
				_Traits::copy(this->_Bx._Buf,
					::std:: addressof(*_Ptr), _Newsize);
			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
			}
		this->_Myres = this->_BUF_SIZE - 1;
		_Eos(_Newsize);
		}

	__declspec(noreturn) void _Xlen() const
		{	
		_Xlength_error("string too long");
		}

	__declspec(noreturn) void _Xran() const
		{	
		_Xout_of_range("invalid string position");
		}
	};

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	 const typename basic_string<_Elem, _Traits, _Alloc>::size_type
		basic_string<_Elem, _Traits, _Alloc>::npos =
			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);

		

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

typedef basic_string<char, char_traits<char>, allocator<char> >
	string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
	wstring;

 
typedef basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >
	u16string;
typedef basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >
	u32string;
 #line 2310 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 2316 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"
#line 2317 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xstring"






#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdexcept"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {










		
class logic_error
	: public ::std:: exception
	{	
public:
	typedef ::std:: exception _Mybase;

	explicit logic_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit logic_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 50 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdexcept"
	};

		
class domain_error
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit domain_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit domain_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdexcept"
	};

		
class invalid_argument
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit invalid_argument(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit invalid_argument(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdexcept"
	};

		
class length_error
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit length_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit length_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 134 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdexcept"
	};

		
class out_of_range
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit out_of_range(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit out_of_range(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 162 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdexcept"
	};

		
class runtime_error
	: public ::std:: exception
	{	
public:
	typedef ::std:: exception _Mybase;

	explicit runtime_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit runtime_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 190 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdexcept"
	};

		
class overflow_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit overflow_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit overflow_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 218 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdexcept"
	};

		
class underflow_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit underflow_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit underflow_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 246 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdexcept"
	};

		
class range_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit range_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit range_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 274 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdexcept"
	};
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 280 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdexcept"
#line 281 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\stdexcept"





#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\typeinfo"














#pragma once






 
 
 #line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\typeinfo"

#pragma pack(push,8)
#pragma warning(push,3)


#pragma warning(disable: 4275)

 



 

#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\typeinfo"

struct __type_info_node {
    void *_MemPtr;
    __type_info_node* _Next;
};

extern __type_info_node __type_info_root_node;

class type_info {
public:
 
	size_t hash_code() const throw ()
		{	
		return (::std:: _Hash_seq((const unsigned char *) name(),
			:: strlen(name())));
		}
 #line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\typeinfo"

    


    virtual ~type_info() throw ();
    __declspec(dllimport) bool  operator==(const type_info& _Rhs) const;
    __declspec(dllimport) bool  operator!=(const type_info& _Rhs) const;
    __declspec(dllimport) bool  before(const type_info& _Rhs) const;
    __declspec(dllimport) const char*  name(__type_info_node* __ptype_info_node = &__type_info_root_node) const;
    __declspec(dllimport) const char*  raw_name() const;
private:
    void *_M_data;
    char _M_d_name[1];
     type_info(const type_info& _Rhs);
    type_info&  operator=(const type_info& _Rhs);
    __declspec(dllimport) static const char *__cdecl _Name_base(const type_info *,__type_info_node* __ptype_info_node);
    __declspec(dllimport) static void __cdecl _Type_info_dtor(type_info *);
};

 

 namespace std {

using ::type_info;

 }





 namespace std {

class __declspec(dllimport) bad_cast : public exception {
public:










     bad_cast(const char * _Message = "bad cast");
     bad_cast(const bad_cast &);
    virtual  ~bad_cast() throw ();
#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\typeinfo"
};

class __declspec(dllimport) bad_typeid : public exception {
public:










     bad_typeid(const char * _Message = "bad typeid");
     bad_typeid(const bad_typeid &);
    virtual  ~bad_typeid() throw ();
#line 123 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\typeinfo"

};

class __declspec(dllimport) __non_rtti_object : public bad_typeid {
public:










     __non_rtti_object(const char * _Message);
     __non_rtti_object(const __non_rtti_object &);
    virtual  ~__non_rtti_object() throw ();
#line 142 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\typeinfo"
};

 }

 























































#line 203 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\typeinfo"

#line 205 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\typeinfo"


#pragma pack(pop)
#pragma warning(pop)

#line 211 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\typeinfo"







#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocinfo"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocinfo.h"

#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\locale.h"













#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\locale.h"





#pragma pack(push,8)


extern "C" {
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\locale.h"

























struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        wchar_t *_W_decimal_point;
        wchar_t *_W_thousands_sep;
        wchar_t *_W_int_curr_symbol;
        wchar_t *_W_currency_symbol;
        wchar_t *_W_mon_decimal_point;
        wchar_t *_W_mon_thousands_sep;
        wchar_t *_W_positive_sign;
        wchar_t *_W_negative_sign;
        };

#line 85 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\locale.h"




















#line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\locale.h"

 __declspec(dllimport) int __cdecl _configthreadlocale(  int _Flag);
 __declspec(dllimport) char * __cdecl setlocale(  int _Category,   const char * _Locale);
 __declspec(dllimport) struct lconv * __cdecl localeconv(void);
 __declspec(dllimport) _locale_t __cdecl _get_current_locale(void);
 __declspec(dllimport) _locale_t __cdecl _create_locale(  int _Category,   const char * _Locale);
__declspec(dllimport) void __cdecl _free_locale(  _locale_t _Locale);



  __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "_get_current_locale" " instead. See online help for details.")) __declspec(dllimport) _locale_t __cdecl __get_current_locale(void);
  __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "_create_locale" " instead. See online help for details.")) __declspec(dllimport) _locale_t __cdecl __create_locale(  int _Category,   const char * _Locale);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "_free_locale" " instead. See online help for details.")) __declspec(dllimport) void __cdecl __free_locale(  _locale_t _Locale);
#line 120 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\locale.h"












}
#line 134 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\locale.h"

#pragma pack(pop)

#line 138 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\locale.h"
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocinfo.h"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 


  
extern "C" {
  #line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocinfo.h"

		












		










 
 
 
 
 
 
 
 

typedef struct _Collvec
	{	
	unsigned int _Page;		
	wchar_t *_LocaleName;
	} _Collvec;

typedef struct _Ctypevec
	{	
	unsigned int _Page;		
	const short *_Table;
	int _Delfl;
	wchar_t *_LocaleName;
	} _Ctypevec;

typedef struct _Cvtvec
	{	
	unsigned int _Page;		
	unsigned int _Mbcurmax;
	int _Isclocale;	
	unsigned char _Isleadbyte[32];	
	} _Cvtvec;

		
__declspec(dllimport) _Collvec __cdecl _Getcoll();
__declspec(dllimport) _Ctypevec __cdecl _Getctype();
__declspec(dllimport) _Cvtvec __cdecl _Getcvt();
__declspec(dllimport) int __cdecl _Getdateorder();

 








__declspec(dllimport) int __cdecl _Mbrtowc(  wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
 #line 94 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocinfo.h"

__declspec(dllimport) float __cdecl _Stof(const char *,
	    char **, long);
__declspec(dllimport) double __cdecl _Stod(const char *,
	    char **, long);
__declspec(dllimport) long double __cdecl _Stold(const char *,
	    char **, long);

__declspec(dllimport) int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
__declspec(dllimport) size_t __cdecl _Strxfrm(
	    char *_String1,
	  char *_End1, const char *, const char *, const _Collvec *);
__declspec(dllimport) int __cdecl _Tolower(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Toupper(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Wcrtomb(  char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
__declspec(dllimport) int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
__declspec(dllimport) size_t __cdecl _Wcsxfrm(
	    wchar_t *_String1,
	  wchar_t *_End1, const wchar_t *, const wchar_t *, const _Collvec *);

__declspec(dllimport) short __cdecl _Getwctype(wchar_t, const _Ctypevec *);
__declspec(dllimport) const wchar_t *__cdecl _Getwctypes(const wchar_t *,
	const wchar_t *, short *, const _Ctypevec *);
__declspec(dllimport) wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
__declspec(dllimport) wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);

  
}
  #line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocinfo.h"


extern "C" {
__declspec(dllimport) char *__cdecl _Getdays();
__declspec(dllimport) char *__cdecl _Getmonths();
__declspec(dllimport) void *__cdecl _Gettnames();
__declspec(dllimport) size_t __cdecl _Strftime(  char *,
	  size_t _Maxsize,     const char *,
	  const struct tm *, void *);

__declspec(dllimport) wchar_t *__cdecl _W_Getdays();
__declspec(dllimport) wchar_t *__cdecl _W_Getmonths();
__declspec(dllimport) void *__cdecl _W_Gettnames();
__declspec(dllimport) size_t __cdecl _Wcsftime(  wchar_t *,
	  size_t _Maxsize,     const wchar_t *,
	  const struct tm *, void *);
}

 







__declspec(dllimport) _locale_t __cdecl _GetLocaleForCP(unsigned int);
 #line 154 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocinfo.h"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 159 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocinfo.h"
#line 160 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocinfo.h"





#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocinfo"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412)

namespace std {
		
class __declspec(dllimport) _Timevec
	{	
public:
	 _Timevec(void *_Ptr = 0)
		: _Timeptr(_Ptr)
		{	
		}

	 _Timevec(const _Timevec& _Right)
		{	
		*this = _Right;
		}

	 ~_Timevec() throw ()
		{	
		free(_Timeptr);
		}

	_Timevec&  operator=(const _Timevec& _Right)
		{	
		_Timeptr = _Right._Timeptr;
		((_Timevec *)&_Right)->_Timeptr = 0;
		return (*this);
		}

	void * _Getptr() const
		{	
		return (_Timeptr);
		}

private:
	void *_Timeptr;	
	};

		
class __declspec(dllimport) _Locinfo
	{	
public:
	typedef ::_Collvec _Collvec;
	typedef ::_Ctypevec _Ctypevec;
	typedef ::_Cvtvec _Cvtvec;
	typedef ::std:: _Timevec _Timevec;

	static  void __cdecl _Locinfo_ctor(
		_Locinfo *, const char *);
	static  void __cdecl _Locinfo_ctor(
		_Locinfo *, int, const char *);
	static  void __cdecl _Locinfo_dtor(
		_Locinfo *);
	static  _Locinfo& __cdecl _Locinfo_Addcats(
		_Locinfo *, int, const char *);

	 _Locinfo(const char *_Pch = "C")
 
		: _Lock(0)
 #line 75 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocinfo"

		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		_Locinfo_ctor(this, _Pch);
		}

	 _Locinfo(int _Cat, const char *_Pch)
 
		: _Lock(0)
 #line 86 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocinfo"

		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		_Locinfo_ctor(this, _Cat, _Pch);
		}

	 ~_Locinfo() throw ()
		{	
		_Locinfo_dtor(this);
		}

	_Locinfo&  _Addcats(int _Cat, const char *_Pch)
		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		return (_Locinfo_Addcats(this, _Cat, _Pch));
		}

	const char * _Getname() const
		{	
		return (_Newlocname._C_str());
		}

	_Collvec  _Getcoll() const
		{	
		return (::_Getcoll());
		}

	_Ctypevec  _Getctype() const
		{	
		return (::_Getctype());
		}

	_Cvtvec  _Getcvt() const
		{	
		return (::_Getcvt());
		}

	const lconv * _Getlconv() const
		{	
		return (localeconv());
		}

	_Timevec  _Gettnames() const
		{	
		return (_Timevec(::_Gettnames()));
		}

	const char * _Getdays() const
		{	
		const char *_Ptr = ::_Getdays();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_Days = _Ptr;
			free((void *)_Ptr);
			}
		return (!_Days._Empty() ? _Days._C_str()
			: ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				":Thu:Thursday:Fri:Friday:Sat:Saturday");
		}

	const char * _Getmonths() const
		{	
		const char *_Ptr = ::_Getmonths();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_Months = _Ptr;
			free((void *)_Ptr);
			}
		return (!_Months._Empty() ? _Months._C_str()
			: ":Jan:January:Feb:February:Mar:March"
				":Apr:April:May:May:Jun:June"
				":Jul:July:Aug:August:Sep:September"
				":Oct:October:Nov:November:Dec:December");
		}

	const char * _Getfalse() const
		{	
		return ("false");
		}

	const char * _Gettrue() const
		{	
		return ("true");
		}

	int  _Getdateorder() const
		{	
		return (::_Getdateorder());
		}

	_Timevec  _W_Gettnames() const
		{	
		return (_Timevec(::_W_Gettnames()));
		}

	const unsigned short * _W_Getdays() const
		{	
		const wchar_t *_Ptr = ::_W_Getdays();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_W_Days = _Ptr;
			free((void *)_Ptr);
			}
		return ((const unsigned short *)(!_W_Days._Empty()
			? _W_Days._C_str()
			: L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				L":Thu:Thursday:Fri:Friday:Sat:Saturday"));
		}

	const unsigned short * _W_Getmonths() const
		{	
		const wchar_t *_Ptr = ::_W_Getmonths();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_W_Months = _Ptr;
			free((void *)_Ptr);
			}
		return ((const unsigned short *)(!_W_Months._Empty()
			? _W_Months._C_str()
			: L":Jan:January:Feb:February:Mar:March"
				L":Apr:April:May:May:Jun:June"
				L":Jul:July:Aug:August:Sep:September"
				L":Oct:October:Nov:November:Dec:December"));
		}

private:



 



	_Lockit _Lock;	
 #line 227 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocinfo"

	_Yarn<char> _Days;	
	_Yarn<char> _Months;	
	_Yarn<wchar_t> _W_Days;	
	_Yarn<wchar_t> _W_Months;	
	_Yarn<char> _Oldlocname;	
	_Yarn<char> _Newlocname;	
	};

		
template<class _Elem> inline
	int __cdecl _LStrcoll(const _Elem *_First1, const _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (*_First1 < *_First2)
			return (-1);	
		else if (*_First2 < *_First1)
			return (+1);	
	return (_First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0);
	}

template<> inline
	int __cdecl _LStrcoll(const char *_First1, const char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Strcoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	int __cdecl _LStrcoll(const wchar_t *_First1, const wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

		
template<class _Elem> inline
	size_t __cdecl _LStrxfrm(_Elem *_First1, _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	
	size_t _Count = _Last2 - _First2;
	if (_Count <= (size_t)(_Last1 - _First1))
		::memcpy_s((_First1), ((_Last1 - _First1) * sizeof (_Elem)), (_First2), (_Count * sizeof (_Elem)));
#line 276 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocinfo"
	return (_Count);
	}

template<> inline
	size_t __cdecl _LStrxfrm( 
		  char *_First1,   char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Strxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	size_t __cdecl _LStrxfrm( 
		  wchar_t *_First1,   wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 301 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocinfo"
#line 302 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocinfo"





#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xdebug"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)

 
  
 
  

namespace std {
struct _DebugHeapTag_t
	{	
	int _Type;
	};
}

		

 










































#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xdebug"
   
   
   
  #line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xdebug"

 
 

 #pragma warning(pop)
 #pragma pack(pop)


#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xdebug"
#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xdebug"





#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xfacet"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 






namespace std {
	
class __declspec(dllimport) _Facet_base
	{	
public:
	virtual  ~_Facet_base() throw ()
		{	
		}

	
	virtual void  _Incref() = 0;

	
	virtual _Facet_base *  _Decref() = 0;
	};

 


#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xfacet"
void __cdecl _Facet_Register(_Facet_base *);
 #line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xfacet"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xfacet"
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xfacet"

 



#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412 28197)

namespace std {
		
template<class _Dummy>
	class _Locbase
	{	
public:
	 static const int collate = ((1 << (1)) >> 1);
	 static const int ctype = ((1 << (2)) >> 1);
	 static const int monetary = ((1 << (3)) >> 1);
	 static const int numeric = ((1 << (4)) >> 1);
	 static const int time = ((1 << (5)) >> 1);
	 static const int messages = ((1 << (6)) >> 1);
	 static const int all = (((1 << ((6 + 1))) >> 1) - 1);
	 static const int none = 0;
	};

template<class _Dummy>
	const int _Locbase<_Dummy>::collate;
template<class _Dummy>
	const int _Locbase<_Dummy>::ctype;
template<class _Dummy>
	const int _Locbase<_Dummy>::monetary;
template<class _Dummy>
	const int _Locbase<_Dummy>::numeric;
template<class _Dummy>
	const int _Locbase<_Dummy>::time;
template<class _Dummy>
	const int _Locbase<_Dummy>::messages;
template<class _Dummy>
	const int _Locbase<_Dummy>::all;
template<class _Dummy>
	const int _Locbase<_Dummy>::none;

		
class locale;
template<class _Facet>
	const _Facet& __cdecl use_facet(const locale&);
template<class _Elem>
	class collate;

class  locale
	: public _Locbase<int>
	{	
public:
	typedef int category;

			
	class __declspec(dllimport) id
		{	
	public:
		 id(size_t _Val = 0)
			: _Id(_Val)
			{	
			}

		 operator size_t()
			{	
			if (_Id == 0)
				{	
				{ ::std:: _Lockit _Lock(0);
					if (_Id == 0)
						_Id = ++_Id_cnt;
				}
				}
			return (_Id);
			}

	private:
		size_t _Id;	

		 static int _Id_cnt;

		 id(const id&);	
		id&  operator=(const id&);	
		};

	class _Locimp;

			
	class __declspec(dllimport) facet
		: public _Facet_base
		{	
		friend class locale;
		friend class _Locimp;

		template<class _Ty>
			friend void __cdecl _DebugHeapDelete(_Ty *_Ptr);

	public:
		static size_t __cdecl _Getcat(const facet ** = 0,
			const locale * = 0)
			{	
			return ((size_t)(-1));
			}

  






















#line 141 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

		virtual void  _Incref()
			{   
			_InterlockedIncrement(reinterpret_cast<volatile long *>(&_Refs));
			}

		virtual _Facet_base * _Decref()
			{   
			if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&_Refs)) == 0)
				return (this);
			else
				return (0);
			}

private:
	_Atomic_counter_t _Refs;	

	protected:
		explicit  facet(size_t _Initrefs = 0)
			{	
			_Init_atomic_counter(_Refs, (_Atomic_integral_t)_Initrefs);
			}

		virtual  ~facet() throw ()
			{	
			}

		private:
			 facet(const facet&);	

		facet&  operator=(const facet&);	
		};

			
 #pragma warning(push)
 #pragma warning(disable: 4275)

	class __declspec(dllimport) _Locimp
		: public facet
		{	
	protected:
		 ~_Locimp() throw ()
		{	
		_Locimp_dtor(this);
		}

	private:
		static  _Locimp *__cdecl
			_New_Locimp(bool _Transparent = false);
		static  _Locimp *__cdecl
			_New_Locimp(const _Locimp& _Right);

		static  void __cdecl
			_Locimp_dtor(_Locimp *);
		static  void __cdecl
			_Locimp_Addfac(_Locimp *, facet *, size_t);	
		static void __cdecl
			_Locimp_ctor(_Locimp *, const _Locimp&);

		friend class locale;

		 _Locimp(bool _Transparent)
			: locale::facet(1), _Facetvec(0), _Facetcount(0),
				_Catmask(none), _Xparent(_Transparent),
					_Name("*")
			{	
			}

		 _Locimp(const _Locimp& _Right)
			: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
					_Name(_Right._Name.c_str())
			{	
			_Locimp_ctor(this, _Right);
			}

		void  _Addfac(facet *_Pfacet, size_t _Id)
			{	
			_Locimp_Addfac(this, _Pfacet, _Id);
			}

		static _Locimp *__cdecl _Makeloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

		static void __cdecl _Makewloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

 
		static void __cdecl _Makeushloc(const _Locinfo&,
			category, _Locimp *, const locale *);	
 #line 232 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

		static void __cdecl _Makexloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

		facet **_Facetvec;	
		size_t _Facetcount;	
		category _Catmask;	
		bool _Xparent;	
		_Yarn<char> _Name;	

		 static _Locimp *_Clocptr;

private:
		_Locimp&  operator=(const _Locimp&);	
		};

 #pragma warning(pop)

	template<class _Elem,
		class _Traits,
		class _Alloc>
		bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
		{	
		const ::std:: collate<_Elem>& _Coll_fac =
			use_facet<::std:: collate<_Elem> >(*this);

		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
		}

	template<class _Facet>
		locale combine(const locale& _Loc) const
		{	
		_Facet *_Facptr;

		try {
			_Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
		} catch (...) {
			_Xruntime_error("locale::combine facet missing");
		}

		_Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
		_Newimp->_Addfac(_Facptr, _Facet::id);
		_Newimp->_Catmask = 0;
		_Newimp->_Name = "*";
		return (locale(_Newimp));
		}

	template<class _Facet>
		locale(const locale& _Loc, const _Facet *_Facptr)
			: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		if (_Facptr != 0)
			{	
			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
			if (_Facet::_Getcat() != (size_t)(-1))
				{	
				_Ptr->_Catmask = 0;
				_Ptr->_Name = "*";
				}
			}
		}

	locale(_Uninitialized)
		{	
		}

 



















#line 321 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"
	locale(const locale& _Right) throw ()
		: _Ptr(_Right._Ptr)
		{	
		_Ptr->_Incref();
		}

	locale() throw ()
		: _Ptr(_Init(true))
		{	
		}

	locale(const locale& _Loc, const locale& _Other,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		try {
		{ _Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str());
			_Locimp::_Makeloc(_Lobj._Addcats(_Cat & _Other._Ptr->_Catmask,
				_Other._Ptr->_Name.c_str()), _Cat, _Ptr, &_Other);
		}
		} catch (...) {
		delete (_Ptr->_Decref());
		throw;
		}
		}

	explicit locale(const char *_Locname,
		category _Cat = all) 	
		: _Ptr(_Locimp::_New_Locimp())
		{	
		try {
		_Init();
		{ _Locinfo _Lobj(_Cat, _Locname);
			if (_Badname(_Lobj))
				_Xruntime_error("bad locale name");
			_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
		}
		} catch (...) {
		delete (_Ptr->_Decref());
		throw;
		}
		}

	locale(const locale& _Loc, const char *_Locname,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		try {
		{ _Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str());
			bool _Hadname = !_Badname(_Lobj);
			_Lobj._Addcats(_Cat, _Locname);

			if (_Hadname && _Badname(_Lobj))
				_Xruntime_error("bad locale name");
			_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
		}
		} catch (...) {
		delete (_Ptr->_Decref());
		throw;
		}
		}

 
	explicit locale(const string& _Str,
		category _Cat = all)
		: _Ptr(_Locimp::_New_Locimp())
		{	
		try {
		_Init();
		_Locinfo _Lobj(_Cat, _Str.c_str());

		if (_Badname(_Lobj))
			_Xruntime_error("bad locale name");
		_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
		} catch (...) {
		delete (_Ptr->_Decref());
		throw;
		}
		}

	locale(const locale& _Loc, const string& _Str,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		try {
		_Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str());
		bool _Hadname = !_Badname(_Lobj);
		_Lobj._Addcats(_Cat, _Str.c_str());

		if (_Hadname && _Badname(_Lobj))
			_Xruntime_error("bad locale name");
		_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
		} catch (...) {
		delete (_Ptr->_Decref());
		throw;
		}
		}
 #line 419 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

	~locale() throw ()
		{	
		if (_Ptr != 0)
			delete (_Ptr->_Decref());
		}

	locale& operator=(const locale& _Right) throw ()
		{	
		if (_Ptr != _Right._Ptr)
			{	
			delete (_Ptr->_Decref());
			_Ptr = _Right._Ptr;
			_Ptr->_Incref();
			}
		return (*this);
		}
 #line 437 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

	string name() const
		{	
		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
		}

	const char *c_str() const
		{	
		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
		}

	const facet *_Getfacet(size_t _Id) const
		{	
		const facet *_Facptr = _Id < _Ptr->_Facetcount
			? _Ptr->_Facetvec[_Id] : 0;	
		if (_Facptr != 0 || !_Ptr->_Xparent)
			return (_Facptr);	
		else
			{	
			locale::_Locimp *_Ptr = _Getgloballocale();
			return (_Id < _Ptr->_Facetcount
				? _Ptr->_Facetvec[_Id]	
				: 0);	
			}
		}

	bool operator==(const locale& _Loc) const
		{	
		return (_Ptr == _Loc._Ptr
			|| name().compare("*") != 0 && name().compare(_Loc.name()) == 0);
		}

	bool operator!=(const locale& _Right) const
		{	
		return (!(*this == _Right));
		}

	static __declspec(dllimport) const locale& __cdecl
		classic();	

	static __declspec(dllimport) locale __cdecl
		global(const locale&);	

	static __declspec(dllimport) locale __cdecl
		empty();	

private:
	locale(_Locimp *_Ptrimp)
		: _Ptr(_Ptrimp)
		{	
		}

    static __declspec(dllimport) _Locimp *__cdecl
		_Init(bool _Do_incref = false);	
	static __declspec(dllimport) _Locimp *__cdecl
		_Getgloballocale();
	static __declspec(dllimport) void __cdecl
		_Setgloballocale(void *);

	bool _Badname(const _Locinfo& _Lobj)
		{	
		return (:: strcmp(_Lobj._Getname(), "*") == 0);
		}

	_Locimp *_Ptr;	
	};

		

 
















#line 524 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

template<class _Facet>
	struct _Facetptr
	{	
	 static const locale::facet *_Psave;
	};

template<class _Facet>
	 const locale::facet *_Facetptr<_Facet>::
		_Psave = 0;

  

  


template<class _Facet> inline
	const _Facet& __cdecl use_facet(const locale& _Loc)

	{	
 



#line 549 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"
	{ ::std:: _Lockit _Lock(0);	
		const locale::facet *_Psave =
			_Facetptr<_Facet>::_Psave;	

		size_t _Id = _Facet::id;
		const locale::facet *_Pf = _Loc._Getfacet(_Id);

		if (_Pf != 0)
			;	
		else if (_Psave != 0)
			_Pf = _Psave;	
		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

 

			throw ::std:: bad_cast();	

 

#line 569 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

		else
			{	
			_Pf = _Psave;
			_Facetptr<_Facet>::_Psave = _Psave;

			locale::facet *_Pfmod = (_Facet *)_Psave;
			_Pfmod->_Incref();

 


#line 582 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"
			_Facet_Register(_Pfmod);
 #line 584 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"
			}

		return ((const _Facet&)(*_Pf));	
	}
 #line 589 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"
	}	

		
template<class _Elem,
	class _InIt> inline
	int __cdecl _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
		const _Elem *_Ptr)
	{	
	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
		if (_Ptr[_Off] == _Ptr[0])
			++_Numfields;	
	string _Str(_Numfields, '\0');	

	int _Ans = -2;	
	for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)
		{	
		bool _Prefix = false;	
		size_t _Off = 0;	
		size_t _Field = 0;	

		for (; _Field < _Numfields; ++_Field)
			{	
			for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
				;	

			if (_Str[_Field] != '\0')
				_Off += _Str[_Field];	
			else if (_Ptr[_Off += _Column] == _Ptr[0]
				|| _Ptr[_Off] == (_Elem)0)
				{	
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	
				_Ans = (int)_Field;	
				}
			else if (_First == _Last || _Ptr[_Off] != *_First)
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	
			else
				_Prefix = true;	
			}

		if (!_Prefix || _First == _Last)
			break;	
		}
	return (_Ans);	
	}

		



template<class _Elem> inline
	char __cdecl _Maklocbyte(_Elem _Char,
		const _Locinfo::_Cvtvec&)
	{	
	return ((char)(unsigned char)_Char);
	}

template<> inline
	char __cdecl _Maklocbyte(wchar_t _Char,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	char _Byte = '\0';
	mbstate_t _Mbst1 = {0};
	_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}

 
template<> inline
	char __cdecl _Maklocbyte(unsigned short _Char,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	char _Byte = '\0';
	mbstate_t _Mbst1 = {0};
	_Wcrtomb(&_Byte, (wchar_t)_Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}
 #line 668 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

		



template<class _Elem> inline
	_Elem __cdecl _Maklocchr(char _Byte, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	
	return ((_Elem)(unsigned char)_Byte);
	}

template<> inline
	wchar_t __cdecl _Maklocchr(char _Byte, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	wchar_t _Wc = L'\0';
	mbstate_t _Mbst1 = {0};
	_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}

 
template<> inline
	unsigned short __cdecl _Maklocchr(char _Byte, unsigned short *,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	unsigned short _Wc = (unsigned short)0;
	mbstate_t _Mbst1 = {0};
	_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}
 #line 701 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

		



template<class _Elem> inline
	_Elem *__cdecl _Maklocstr(const char *_Ptr, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	
	size_t _Count = :: strlen(_Ptr) + 1;
	_Elem *_Ptrdest = new _Elem[_Count];

 #pragma warning(push)
 #pragma warning(disable: 6011)	
	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;
 #pragma warning(pop)

	return (_Ptrdest);
	}

template<> inline
	wchar_t *__cdecl _Maklocstr(const char *_Ptr, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	wchar_t _Wc;
	mbstate_t _Mbst1 = {0};

	_Count1 = :: strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	

	wchar_t *_Ptrdest = new wchar_t[_Wchars];
	wchar_t *_Ptrnext = _Ptrdest;
	mbstate_t _Mbst2 = {0};

 #pragma warning(push)
 #pragma warning(disable: 6011)	
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';
 #pragma warning(pop)

	return (_Ptrdest);
	}

 
template<> inline
	unsigned short *__cdecl _Maklocstr(const char *_Ptr, unsigned short *,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	unsigned short _Wc;
	mbstate_t _Mbst1 = {0};

	_Count1 = :: strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes =
			_Mbrtowc((wchar_t *)&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	

	wchar_t *_Ptrdest = new wchar_t[_Wchars];
	wchar_t *_Ptrnext = _Ptrdest;
	mbstate_t _Mbst2 = {0};
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';
	return ((unsigned short *)_Ptrdest);
	}
 #line 787 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

		
 #pragma warning(push)
 #pragma warning(disable: 4275)

class __declspec(dllimport) codecvt_base
	: public locale::facet
	{	
public:
	enum
		{	
		ok, partial, error, noconv};
	typedef int result;

	 codecvt_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		}

	bool  always_noconv() const throw ()
		{	
		return (do_always_noconv());
		}

	int  max_length() const throw ()
		{	
		return (do_max_length());
		}

	int  encoding() const throw ()
		{	
		return (do_encoding());
		}

	 ~codecvt_base() throw ()
		{	
		}

protected:
	virtual bool  do_always_noconv() const throw ()
		{	
		return (false);
		}

	virtual int  do_max_length() const throw ()
		{	
		return (1);
		}

	virtual int  do_encoding() const throw ()
		{	
		return (1);	
		}
	};

 #pragma warning(pop)

		
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt
		: public codecvt_base
	{	
public:
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State, _First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;	

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Locinfo());
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() throw ()
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

	virtual bool  do_always_noconv() const throw ()
		{	
		return (is_same<_Byte, _Elem>::value);
		}

	virtual result  do_in(_Statype&,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		_Mid1 = _First1, _Mid2 = _First2;
		if (is_same<_Byte, _Elem>::value)
			return (noconv);	
		else
			{	
			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
				*_Mid2 = (_Elem)*_Mid1;
			return (ok);
			}
		}

	virtual result  do_out(_Statype&,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Mid1 = _First1, _Mid2 = _First2;
		if (is_same<_Byte, _Elem>::value)
			return (noconv);	
		else
			{	
			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
				*_Mid2 = (_Byte)*_Mid1;
			return (ok);
			}
		}

	virtual result  do_unshift(_Statype&,
		_Byte *_First2, _Byte *, _Byte *&_Mid2) const
		{	
		_Mid2 = _First2;
		return (ok);	
		}

	virtual int  do_length(_Statype&, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return ((int)(_Count < (size_t)(_Last1 - _First1)
			? _Count : _Last1 - _First1));	
		}
	};

		
template<class _Elem,
	class _Byte,
	class _Statype>
	 locale::id codecvt<_Elem, _Byte, _Statype>::id;

 




















































































































































































































































































































































































































































































































































































































#line 1570 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

		
template<>
	class __declspec(dllimport) codecvt<wchar_t, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef wchar_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() throw ()
		{	
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Cvt = _Lobj._Getcvt();
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		;
		;
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	
			case -2:	
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	
				return (error);

			case 0:	
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		;
		;
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			if ((int)___mb_cur_max_func() <= _Last2 - _Mid2)
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
			else
				{	
				_Byte _Buf[5];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else if (_Last2 - _Mid2 < _Bytes)
					{	
					_State = _Stsave;
					return (_Ans);
					}
				else
					{	
					:: memcpy(_Mid2, _Buf, _Bytes);
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
					}
				}
		return (_Ans);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		;
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[5];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	
		else if (_Last2 - _Mid2 < --_Bytes)
			{	
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	
			:: memcpy(_Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		;
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	
			case -2:	
				return (_Wchars);

			case -1:	
				return (_Wchars);

			case 0:	
				if (_Ch == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool  do_always_noconv() const throw ()
		{	
		return (false);
		}

	virtual int  do_max_length() const throw ()
		{	
		return (5);
		}

	virtual int  do_encoding() const throw ()
		{	
		return (0);	
		}

private:
	_Locinfo::_Cvtvec _Cvt;	
	};

 
		
template<>
	class __declspec(dllimport) codecvt<unsigned short, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef unsigned short _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() throw ()
		{	
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Cvt = _Lobj._Getcvt();
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		;
		;
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc((wchar_t *)_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	
			case -2:	
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	
				return (error);

			case 0:	
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		;
		;
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			if ((int)___mb_cur_max_func() <= _Last2 - _Mid2)
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
			else
				{	
				_Byte _Buf[5];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else if (_Last2 - _Mid2 < _Bytes)
					{	
					_State = _Stsave;
					return (_Ans);
					}
				else
					{	
					:: memcpy(_Mid2, _Buf, _Bytes);
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
					}
				}
		return (_Ans);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		;
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[5];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	
		else if (_Last2 - _Mid2 < --_Bytes)
			{	
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	
			:: memcpy(_Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		;
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc((wchar_t *)&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	
			case -2:	
				return (_Wchars);

			case -1:	
				return (_Wchars);

			case 0:	
				if (_Ch == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool  do_always_noconv() const throw ()
		{	
		return (false);
		}

	virtual int  do_max_length() const throw ()
		{	
		return (5);
		}

	virtual int  do_encoding() const throw ()
		{	
		return (0);	
		}

private:
	_Locinfo::_Cvtvec _Cvt;	
	};
 #line 2040 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

		
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt_byname
		: public codecvt<_Elem, _Byte, _Statype>
	{	
public:
	explicit  codecvt_byname(const char *_Locname, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
		{	
		}

 
	explicit  codecvt_byname(const string& _Str, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}
 #line 2060 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

protected:
	virtual  ~codecvt_byname() throw ()
		{	
		}
	};

		
 #pragma warning(push)
 #pragma warning(disable: 4275)

struct __declspec(dllimport) ctype_base
	: public locale::facet
	{	
	enum
		{	
		alnum = 0x4 | 0x2 | 0x1 | 0x100, alpha = 0x2 | 0x1 | 0x100,
		cntrl = 0x20, digit = 0x4, graph = 0x4 | 0x2 | 0x10 | 0x1 | 0x100,
		lower = 0x2, print = 0x4 | 0x2 | 0x10 | 0x40 | 0x1 | 0x100 | 0x80,
		punct = 0x10, space = 0x8 | 0x40 | 0x000, upper = 0x1,
		xdigit = 0x80, blank = 0x8 | 0x40 | 0x000 | 0x000};
	typedef short mask;	

	 ctype_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		}

	 ~ctype_base() throw ()
		{	
		}
	};

 #pragma warning(pop)

		
template<class _Elem>
	class ctype
		: public ctype_base
	{	
public:
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() throw ()
		{	
		if (_Ctype._Delfl)
			free((void *)_Ctype._Table);

		free((void *)_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
			& _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		;
		;
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
		return (_First);
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		;
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		;
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Tolower(_Byte, &_Ctype)));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		;
		for (; _First != _Last; ++_First)
			{	
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Tolower(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Toupper(_Byte, &_Ctype)));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		;
		for (; _First != _Last; ++_First)
			{	
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Toupper(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Maklocchr(_Byte, (_Elem *)0, _Cvt));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		;
		;
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Maklocchr(*_First, (_Elem *)0, _Cvt);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Byte;
		if (_Ch == (_Elem)0)
			return ('\0');
		else if ((_Byte = _Maklocbyte((_Elem)_Ch, _Cvt)) == '\0')
			return (_Dflt);
		else
			return (_Byte);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		;
		;
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};

		
template<class _Elem>
	locale::id ctype<_Elem>::id;

		
template<>
	class __declspec(dllimport) ctype<char>
	: public ctype_base
	{	
	typedef ctype<char> _Myt;

public:
	typedef char _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
		}

	const _Elem * is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		;
		;
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)*_First];
		return (_First);
		}

	const _Elem * scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		;
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	const _Elem * scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		;
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const _Elem * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	_Elem  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(const mask *_Table = 0,
		bool _Deletetable = false,
		size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}

		_Tidy();	
		if (_Table != 0)
			{	
			_Ctype._Table = _Table;
			_Ctype._Delfl = _Deletetable ? -1 : 0;
			}
		else
			{	
			_Ctype._Table = classic_table();
			_Ctype._Delfl = 0;
			}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

	const mask * table() const throw ()
		{	
		return (_Ctype._Table);
		}

	static const mask *__cdecl classic_table() throw ()
		{	
		const _Myt& _Ctype_fac = use_facet< _Myt >(locale::classic());
		return (_Ctype_fac.table());
		}

	 static const size_t table_size =
		1 << 8;	

protected:
	virtual  ~ctype() throw ()
		{	
		_Tidy();
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		}

	void  _Tidy()
		{	
		if (0 < _Ctype._Delfl)
			free((void *)_Ctype._Table);
		else if (_Ctype._Delfl < 0)
			delete[] (void *)_Ctype._Table;

		free((void *)_Ctype._LocaleName);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		;
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		;
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Byte);
		}

	virtual const _Elem * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		;
		;
		:: memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

	virtual _Elem  do_narrow(_Elem _Ch, char) const
		{	
		return (_Ch);
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char, char *_Dest) const
		{	
		;
		;
		:: memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	};

		
template<>
	class __declspec(dllimport) ctype<wchar_t>
	: public ctype_base
	{	
	typedef ctype<wchar_t> _Myt;

public:
	typedef wchar_t _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() throw ()
		{	
		if (_Ctype._Delfl)
			free((void *)_Ctype._Table);

		free((void *)_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		;
		;
		return (:: _Getwctypes(_First, _Last, _Dest, &_Ctype));
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		;
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		;
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		;
		for (; _First != _Last; ++_First)
			*_First = _Towlower(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		;
		for (; _First != _Last; ++_First)
			*_First = _Towupper(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	_Elem  _Dowiden(char _Byte) const
		{	
		mbstate_t _Mbst = {0};
		wchar_t _Wc;
		return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (wchar_t)(wint_t)(0xFFFF) : _Wc);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Dowiden(_Byte));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		;
		;
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Buf[5];
		mbstate_t _Mbst = {0};
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		;
		;
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};

 
		
template<>
	class __declspec(dllimport) ctype<unsigned short>
	: public ctype_base
	{	
	typedef ctype<unsigned short> _Myt;

public:
	typedef unsigned short _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() throw ()
		{	
		if (_Ctype._Delfl)
			free((void *)_Ctype._Table);

		free((void *)_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		;
		;
		return ((const _Elem *):: _Getwctypes((const wchar_t *)_First,
			(const wchar_t *)_Last, _Dest, &_Ctype));
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		;
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		;
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		;
		for (; _First != _Last; ++_First)
			*_First = _Towlower(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		;
		for (; _First != _Last; ++_First)
			*_First = _Towupper(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	_Elem  _Dowiden(char _Byte) const
		{	
		mbstate_t _Mbst = {0};
		unsigned short _Wc;
		return (_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (unsigned short)(wint_t)(0xFFFF) : _Wc);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Dowiden(_Byte));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		;
		;
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Buf[5];
		mbstate_t _Mbst = {0};
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		;
		;
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};
 #line 3010 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

		
template<class _Elem>
	class ctype_byname
	: public ctype<_Elem>
	{	
public:
	explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Locname), _Refs)
		{	
		}

 
	explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}
 #line 3028 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

protected:
	virtual  ~ctype_byname() throw ()
		{	
		}
	};

		
template<>
	class ctype_byname<char>
	: public ctype<char>
	{	
public:
	explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<char>(_Locinfo(_Locname), _Refs)
		{	
		}

 
	explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
		: ctype<char>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}
 #line 3052 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"

protected:
	virtual  ~ctype_byname() throw ()
		{	
		}
	};

 

template class __declspec(dllimport) codecvt<char, char, _Mbstatet>;

 #line 3064 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 3069 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"
#line 3070 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocale"






#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xiosbase"

 
 #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\system_error"

#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cerrno"

#pragma once











 #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\errno.h"















#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\errno.h"


extern "C" {
#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\errno.h"



























































#line 86 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\errno.h"
#line 87 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\errno.h"
















































}
#line 137 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\errno.h"

#line 139 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\errno.h"
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cerrno"
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cerrno"




#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cerrno"
#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\cerrno"





#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\system_error"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 

 

#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\system_error"

namespace std {
		

	namespace errc {
enum errc {	
	address_family_not_supported = 102,
	address_in_use = 100,
	address_not_available = 101,
	already_connected = 113,
	argument_list_too_long = 7,
	argument_out_of_domain = 33,
	bad_address = 14,
	bad_file_descriptor = 9,
	bad_message = 104,
	broken_pipe = 32,
	connection_aborted = 106,
	connection_already_in_progress = 103,
	connection_refused = 107,
	connection_reset = 108,
	cross_device_link = 18,
	destination_address_required = 109,
	device_or_resource_busy = 16,
	directory_not_empty = 41,
	executable_format_error = 8,
	file_exists = 17,
	file_too_large = 27,
	filename_too_long = 38,
	function_not_supported = 40,
	host_unreachable = 110,
	identifier_removed = 111,
	illegal_byte_sequence = 42,
	inappropriate_io_control_operation = 25,
	interrupted = 4,
	invalid_argument = 22,
	invalid_seek = 29,
	io_error = 5,
	is_a_directory = 21,
	message_size = 115,
	network_down = 116,
	network_reset = 117,
	network_unreachable = 118,
	no_buffer_space = 119,
	no_child_process = 10,
	no_link = 121,
	no_lock_available = 39,
	no_message_available = 120,
	no_message = 122,
	no_protocol_option = 123,
	no_space_on_device = 28,
	no_stream_resources = 124,
	no_such_device_or_address = 6,
	no_such_device = 19,
	no_such_file_or_directory = 2,
	no_such_process = 3,
	not_a_directory = 20,
	not_a_socket = 128,
	not_a_stream = 125,
	not_connected = 126,
	not_enough_memory = 12,
	not_supported = 129,
	operation_canceled = 105,
	operation_in_progress = 112,
	operation_not_permitted = 1,
	operation_not_supported = 130,
	operation_would_block = 140,
	owner_dead = 133,
	permission_denied = 13,
	protocol_error = 134,
	protocol_not_supported = 135,
	read_only_file_system = 30,
	resource_deadlock_would_occur = 36,
	resource_unavailable_try_again = 11,
	result_out_of_range = 34,
	state_not_recoverable = 127,
	stream_timeout = 137,
	text_file_busy = 139,
	timed_out = 138,
	too_many_files_open_in_system = 23,
	too_many_files_open = 24,
	too_many_links = 31,
	too_many_symbolic_link_levels = 114,
	value_too_large = 132,
	wrong_protocol_type = 136
	};
	}	

typedef errc::errc generic_errno;

		

	namespace io_errc {
enum io_errc {	
	stream = 1
	};
	}	

typedef io_errc::io_errc _Io_errc;

		
template<class _Enum>
	struct is_error_code_enum
		: public false_type
	{	
	};

template<>
	struct is_error_code_enum<_Io_errc>
		: public true_type
	{	
	};

		
template<class _Enum>
	struct is_error_condition_enum
		: public false_type
	{	
	};

template<>
	struct is_error_condition_enum<generic_errno>
		: public true_type
	{	
	};

class error_code;
class error_condition;
error_code make_error_code(generic_errno) throw ();
error_code make_error_code(_Io_errc) throw ();
error_condition make_error_condition(generic_errno) throw ();
error_condition make_error_condition(_Io_errc) throw ();

		
class error_category;

const error_category& generic_category() throw ();
const error_category& iostream_category() throw ();
const error_category& system_category() throw ();

class error_category
	{	
public:
	error_category()
		{	
		}

	virtual ~error_category() throw ()
		{	
		}

	virtual const char *name() const throw () = 0;

	virtual string message(int _Errval) const = 0;

	virtual error_condition
		default_error_condition(int _Errval) const throw ();

	virtual bool equivalent(int _Errval,
		const error_condition& _Cond) const throw ();

	virtual bool equivalent(const error_code& _Code,
		int _Errval) const throw ();

	bool operator==(const error_category& _Right) const throw ()
		{	
		return (this == &_Right);
		}

	bool operator!=(const error_category& _Right) const throw ()
		{	
		return (!(*this == _Right));
		}

	bool operator<(const error_category& _Right) const throw ()
		{	
		return (this < &_Right);
		}

private:
	error_category(const error_category&);	

	error_category& operator=(const error_category&);	
	};

		
class error_code
	{	
public:
	typedef error_code _Myt;

	error_code()
		: _Myval(0),
			_Mycat(&system_category())
		{	
		}

	error_code(int _Val, const error_category& _Cat)
		: _Myval(_Val), _Mycat(&_Cat)
		{	
		}

	template<class _Enum>
		error_code(_Enum _Errcode,
			typename enable_if<is_error_code_enum<_Enum>::value,
				void>::type ** = 0)
		: _Myval(0), _Mycat(0)
		{	
		*this = make_error_code(_Errcode);	
		}

	void assign(int _Val, const error_category& _Cat)
		{	
		_Myval = _Val;
		_Mycat = &_Cat;
		}

	template<class _Enum>
		typename enable_if<is_error_code_enum<_Enum>::value,
			error_code>::type& operator=(_Enum _Errcode)
		{	
		*this = make_error_code(_Errcode);	
		return (*this);
		}

	void clear() throw ()
		{	
		_Myval = 0;
		_Mycat = &system_category();
		}

	int value() const
		{	
		return (_Myval);
		}

	const error_category& category() const
		{	
		return (*_Mycat);
		}

	error_condition default_error_condition() const;

	string message() const
		{	
		return (category().message(value()));
		}

	typedef int ::std:: _Bool_struct<_Myt>::* _Bool_type;

	operator _Bool_type() const throw ()
		{	
		return (value() != 0 ? (&::std:: _Bool_struct<_Myt>::_Member) : 0);
		}

	bool operator!() const throw ()
		{	
		return (value() == 0);
		}

	bool operator==(const error_code& _Right) const throw ()
		{	
		return (category() == _Right.category()
			&& value() == _Right.value());
		}

	bool operator!=(const error_code& _Right) const throw ()
		{	
		return (!(*this == _Right));
		}

	bool operator<(const error_code& _Right) const throw ()
		{	
		return (category() < _Right.category()
			|| category() == _Right.category()
				&& value() < _Right.value());
		}

private:
	int _Myval;	
	const error_category *_Mycat;	
	};

		
class error_condition
	{	
public:
	typedef error_condition _Myt;

	error_condition() throw ()
		: _Myval(0),
			_Mycat(&generic_category())
		{	
		}

	error_condition(int _Val, const error_category& _Cat) throw ()
		: _Myval(_Val), _Mycat(&_Cat)
		{	
		}

	template<class _Enum>
		error_condition(_Enum _Errcode,
			typename enable_if<is_error_condition_enum<_Enum>::value,
				void>::type ** = 0) throw ()
		: _Myval(0), _Mycat(0)
		{	
		*this = make_error_condition(_Errcode);	
		}

	void assign(int _Val, const error_category& _Cat) throw ()
		{	
		_Myval = _Val;
		_Mycat = &_Cat;
		}

	template<class _Enum>
		typename enable_if<is_error_condition_enum<_Enum>::value,
			error_condition>::type& operator=(_Enum _Errcode) throw ()
		{	
		*this = make_error_condition(_Errcode);	
		return (*this);
		}

	void clear() throw ()
		{	
		_Myval = 0;
		_Mycat = &generic_category();
		}

	int value() const throw ()
		{	
		return (_Myval);
		}

	const error_category& category() const throw ()
		{	
		return (*_Mycat);
		}

	string message() const
		{	
		return (category().message(value()));
		}

	typedef int ::std:: _Bool_struct<_Myt>::* _Bool_type;

	operator _Bool_type() const throw ()
		{	
		return (value() != 0 ? (&::std:: _Bool_struct<_Myt>::_Member) : 0);
		}

	bool operator!() const throw ()
		{	
		return (value() == 0);
		}

	bool operator==(const error_condition& _Right) const throw ()
		{	
		return (category() == _Right.category()
			&& value() == _Right.value());
		}

	bool operator!=(const error_condition& _Right) const throw ()
		{	
		return (!(*this == _Right));
		}

	bool operator<(const error_condition& _Right) const throw ()
		{	
		return (category() < _Right.category()
			|| category() == _Right.category()
				&& value() < _Right.value());
		}

private:
	int _Myval;	
	const error_category *_Mycat;	
	};

		
inline error_condition
	error_category::default_error_condition(int _Errval) const throw ()
	{	
	return (error_condition(_Errval, *this));
	}

inline bool
	error_category::equivalent(int _Errval,
		const error_condition& _Cond) const throw ()
	{	
	return (default_error_condition(_Errval) == _Cond);
	}

inline bool
	error_category::equivalent(const error_code& _Code,
		int _Errval) const throw ()
	{	
	return (*this == _Code.category() && _Code.value() == _Errval);
	}

		
inline error_condition error_code::default_error_condition() const
	{	
	return (category().default_error_condition(value()));
	}

		
inline bool operator==(
	const error_code& _Left,
	const error_condition& _Right) throw ()
	{	
	return (_Left.category().equivalent(_Left.value(), _Right)
		|| _Right.category().equivalent(_Left, _Right.value()));
	}

inline bool operator==(
	const error_condition& _Left,
	const error_code& _Right) throw ()
	{	
	return (_Right.category().equivalent(_Right.value(), _Left)
		|| _Left.category().equivalent(_Right, _Left.value()));
	}

		
inline bool operator!=(
	const error_code& _Left,
	const error_condition& _Right) throw ()
	{	
	return (!(_Left == _Right));
	}

inline bool operator!=(
	const error_condition& _Left,
	const error_code& _Right) throw ()
	{	
	return (!(_Left == _Right));
	}

		
inline error_code make_error_code(generic_errno _Errno) throw ()
	{	
	return (error_code((int)_Errno, generic_category()));
	}

inline error_code make_error_code(_Io_errc _Errno) throw ()
	{	
	return (error_code((int)_Errno, iostream_category()));
	}

		
inline error_condition make_error_condition(generic_errno _Errno) throw ()
	{	
	return (error_condition((int)_Errno, generic_category()));
	}

inline error_condition make_error_condition(_Io_errc _Errno) throw ()
	{	
	return (error_condition((int)_Errno, iostream_category()));
	}

		
template<>
	struct hash<error_code>
		: public unary_function<error_code, size_t>
	{	
	typedef error_code _Kty;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (hash<int>()(_Keyval.value()));
		}
	};

		
class system_error
	: public runtime_error
	{	
public:
	explicit system_error(error_code _Errcode)
		: runtime_error(_Errcode.message()),
			_Mycode(_Errcode)
		{	
		_Makestr();
		}

	system_error(error_code _Errcode,
		const string& _Message)
		: runtime_error(_Message), _Mycode(_Errcode)
		{	
		_Makestr();
		}

	system_error(int _Errval,
		const error_category& _Errcat)
		: runtime_error(error_code(_Errval, _Errcat).message()),
			_Mycode(_Errval, _Errcat)
		{	
		_Makestr();
		}

	system_error(int _Errval,
		const error_category& _Errcat,
		const string& _Message)
		: runtime_error(_Message), _Mycode(_Errval, _Errcat)
		{	
		_Makestr();
		}

	system_error(int _Errval,
		const error_category& _Errcat,
		const char *_Message)
		: runtime_error(_Message), _Mycode(_Errval, _Errcat)
		{	
		_Makestr();
		}










	const error_code& code() const throw ()
		{	
		return (_Mycode);
		}

 

 





#line 558 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\system_error"

private:
	void _Makestr()
		{	




		}

	error_code _Mycode;	

	};

__declspec(dllimport) const char *__cdecl _Syserror_map(int);
__declspec(dllimport) const char *__cdecl _Winerror_map(int);

		
class _Generic_error_category
	: public error_category
	{	
public:
	_Generic_error_category()
		{	
		}

	virtual const char *name() const throw ()
		{	
		return ("generic");
		}

	virtual string message(int _Errcode) const
		{	
		const char *_Name = _Syserror_map(_Errcode);
		return (string(_Name != 0 ? _Name : "unknown error"));
		}
	};

		
class _Iostream_error_category
	: public _Generic_error_category
	{	
public:
	_Iostream_error_category()
		{	
		}

	virtual const char *name() const throw ()
		{	
		return ("iostream");
		}

	virtual string message(int _Errcode) const
		{	
		if (_Errcode == (int)io_errc::stream)
			return ("iostream stream error");
		else
			return (_Generic_error_category::message(_Errcode));
		}
	};

		
class _System_error_category
	: public _Generic_error_category
	{	
public:
	_System_error_category()
		{	
		}

	virtual const char *name() const throw ()
		{	
		return ("system");
		}

	virtual string message(int _Errcode) const
		{	
		const char *_Name = _Winerror_map(_Errcode);
		return (string(_Name != 0 ? _Name : "unknown error"));
		}

	virtual error_condition
		default_error_condition(int _Errval) const throw ()
		{	
		if (_Syserror_map(_Errval))
			return (error_condition(_Errval, generic_category()));
		else
			return (error_condition(_Errval, system_category()));
		}
	};

template<class _Cat>
	struct _Error_objects
	{	
	_Error_objects()
		{	
		}

	static _Generic_error_category _Generic_object;
	static _Iostream_error_category _Iostream_object;
	static _System_error_category _System_object;
	};

template<class _Cat>
	_Generic_error_category _Error_objects<_Cat>::_Generic_object;
template<class _Cat>
	_Iostream_error_category _Error_objects<_Cat>::_Iostream_object;
template<class _Cat>
	_System_error_category _Error_objects<_Cat>::_System_object;

inline const error_category& generic_category() throw ()
	{	
	return (_Error_objects<int>::_Generic_object);
	}

inline const error_category& iostream_category() throw ()
	{	
	return (_Error_objects<int>::_Iostream_object);
	}

inline const error_category& system_category() throw ()
	{	
	return (_Error_objects<int>::_System_object);
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 687 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\system_error"
#line 688 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\system_error"





#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xiosbase"
 #line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xiosbase"

 #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\share.h"












#pragma once






#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\share.h"














#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\share.h"

#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\share.h"
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xiosbase"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412)

 

namespace std {
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 
 

 
 
 

		
template<class _Dummy>
	class _Iosb
	{	
public:
	enum _Dummy_enum {_Dummy_enum_val = 1};	
	enum _Fmtflags
		{	
		_Fmtmask = 0xffff, _Fmtzero = 0};

	static const _Fmtflags skipws = (_Fmtflags)0x0001;
	static const _Fmtflags unitbuf = (_Fmtflags)0x0002;
	static const _Fmtflags uppercase = (_Fmtflags)0x0004;
	static const _Fmtflags showbase = (_Fmtflags)0x0008;
	static const _Fmtflags showpoint = (_Fmtflags)0x0010;
	static const _Fmtflags showpos = (_Fmtflags)0x0020;
	static const _Fmtflags left = (_Fmtflags)0x0040;
	static const _Fmtflags right = (_Fmtflags)0x0080;
	static const _Fmtflags internal = (_Fmtflags)0x0100;
	static const _Fmtflags dec = (_Fmtflags)0x0200;
	static const _Fmtflags oct = (_Fmtflags)0x0400;
	static const _Fmtflags hex = (_Fmtflags)0x0800;
	static const _Fmtflags scientific = (_Fmtflags)0x1000;
	static const _Fmtflags fixed = (_Fmtflags)0x2000;

	static const _Fmtflags hexfloat =
		(_Fmtflags)0x3000;	

	static const _Fmtflags boolalpha = (_Fmtflags)0x4000;
	static const _Fmtflags _Stdio = (_Fmtflags)0x8000;
	static const _Fmtflags adjustfield = (_Fmtflags)(0x0040
		| 0x0080 | 0x0100);
	static const _Fmtflags basefield = (_Fmtflags)(0x0200
		| 0x0400 | 0x0800);
	static const _Fmtflags floatfield = (_Fmtflags)(0x1000
		| 0x2000);

	enum _Iostate
		{	
		_Statmask = 0x17};

	static const _Iostate goodbit = (_Iostate)0x0;
	static const _Iostate eofbit = (_Iostate)0x1;
	static const _Iostate failbit = (_Iostate)0x2;
	static const _Iostate badbit = (_Iostate)0x4;
	static const _Iostate _Hardfail = (_Iostate)0x10;

	enum _Openmode
		{	
		_Openmask = 0xff};

	static const _Openmode in = (_Openmode)0x01;
	static const _Openmode out = (_Openmode)0x02;
	static const _Openmode ate = (_Openmode)0x04;
	static const _Openmode app = (_Openmode)0x08;
	static const _Openmode trunc = (_Openmode)0x10;
	static const _Openmode _Nocreate = (_Openmode)0x40;
	static const _Openmode _Noreplace = (_Openmode)0x80;
	static const _Openmode binary = (_Openmode)0x20;

	enum _Seekdir
		{	
		_Seekmask = 0x3};

	static const _Seekdir beg = (_Seekdir)0;
	static const _Seekdir cur = (_Seekdir)1;
	static const _Seekdir end = (_Seekdir)2;

	enum
		{	
		_Openprot = 0x40};
	};

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags
		_Iosb<_Dummy>::hexfloat;	

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::_Hardfail;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;

		
class __declspec(dllimport) ios_base
	: public _Iosb<int>
	{	
public:
	typedef int fmtflags;
	typedef int iostate;
	typedef int openmode;
	typedef int seekdir;

	typedef ::std:: streamoff streamoff;
	typedef ::std:: streampos streampos;

	enum event
		{	
		erase_event, imbue_event, copyfmt_event};

	typedef void (__cdecl *event_callback)(event, ios_base&, int);
	typedef unsigned int io_state, open_mode, seek_dir;

			
	class failure

 
		: public system_error
		{	
		static const _Io_errc _Stream_err = io_errc::stream;	

	public:
		explicit failure(const string &_Message,
			const error_code& _Errcode = make_error_code(_Stream_err))
			: system_error(_Errcode, _Message)
			{	
			}

		explicit failure(const char *_Message,
			const error_code& _Errcode = make_error_code(_Stream_err))
			: system_error(_Errcode, _Message)
			{	
			}

 












#line 255 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xiosbase"

 

 





#line 265 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xiosbase"
		};

			
	class __declspec(dllimport) Init
		{	
	public:
		 Init()
			{	
			_Init_ctor(this);
			}

		 ~Init() throw ()
			{	
			_Init_dtor(this);
			}

	private:
		static  void __cdecl _Init_ctor(Init *);
		static  void __cdecl _Init_dtor(Init *);

		 static int _Init_cnt;	

		static  int& __cdecl _Init_cnt_func();
		};

	 operator void *() const
		{	
		return (fail() ? 0 : (void *)this);
		}

	bool  operator!() const
		{	
		return (fail());
		}

	void  clear(iostate _State, bool _Reraise)
		{	
		_Mystate = (iostate)(_State & _Statmask);
		if ((_Mystate & _Except) == 0)
			;
		else if (_Reraise)
			throw;
		else if (_Mystate & _Except & badbit)
			throw failure("ios_base::badbit set");
		else if (_Mystate & _Except & failbit)
			throw failure("ios_base::failbit set");
		else
			throw failure("ios_base::eofbit set");
		}

	void  clear(iostate _State = goodbit)
		{	
		clear(_State, false);
		}

	void  clear(io_state _State)
		{	
		clear((iostate)_State);
		}

	iostate  rdstate() const
		{	
		return (_Mystate);
		}

	void  setstate(iostate _State, bool _Exreraise)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
		}

	void  setstate(iostate _State)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), false);
		}

	void  setstate(io_state _State)
		{	
		setstate((iostate)_State);
		}

	bool  good() const
		{	
		return (rdstate() == goodbit);
		}

	bool  eof() const
		{	
		return ((int)rdstate() & (int)eofbit);
		}

	bool  fail() const
		{	
		return (((int)rdstate()
			& ((int)badbit | (int)failbit)) != 0);
		}

	bool  bad() const
		{	
		return (((int)rdstate() & (int)badbit) != 0);
		}

	iostate  exceptions() const
		{	
		return (_Except);
		}

	void  exceptions(iostate _Newexcept)
		{	
		_Except = (iostate)((int)_Newexcept & (int)_Statmask);
		clear(_Mystate);
		}

	void  exceptions(io_state _State)
		{	
		exceptions((iostate)_State);
		}

	fmtflags  flags() const
		{	
		return (_Fmtfl);
		}

	fmtflags  flags(fmtflags _Newfmtflags)
		{	
		fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Newfmtflags & (int)_Fmtmask);
		return (_Oldfmtflags);
		}

	fmtflags  setf(fmtflags _Newfmtflags)
		{	
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Fmtfl
			| (int)_Newfmtflags & (int)_Fmtmask);
		return (_Oldfmtflags);
		}

	fmtflags  setf(fmtflags _Newfmtflags, fmtflags _Mask)
		{	
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)
			| ((int)_Newfmtflags & (int)_Mask & (int)_Fmtmask));
		return (_Oldfmtflags);
		}

	void  unsetf(fmtflags _Mask)
		{	
		_Fmtfl = (fmtflags)((int)_Fmtfl & (int)~_Mask);
		}

	streamsize  precision() const
		{	
		return (_Prec);
		}

	streamsize  precision(streamsize _Newprecision)
		{	
		streamsize _Oldprecision = _Prec;
		_Prec = _Newprecision;
		return (_Oldprecision);
		}

	streamsize  width() const
		{	
		return (_Wide);
		}

	streamsize  width(streamsize _Newwidth)
		{	
		streamsize _Oldwidth = _Wide;
		_Wide = _Newwidth;
		return (_Oldwidth);
		}

	locale  getloc() const
		{	
		return (*_Ploc);
		}

	locale  imbue(const locale& _Loc)
		{	
		locale _Oldlocale = *_Ploc;
		*_Ploc = _Loc;
		_Callfns(imbue_event);
		return (_Oldlocale);
		}

	static int __cdecl xalloc()
		{	
		{ ::std:: _Lockit _Lock(2);	
			return (_Index++);
		}
		}

	long&  iword(int _Idx)
		{	
		return (_Findarr(_Idx)._Lo);
		}

	void *&  pword(int _Idx)
		{	
		return (_Findarr(_Idx)._Vp);
		}

	void  register_callback(event_callback _Pfn,
		int _Idx)
		{	
		_Calls = new _Fnarray(_Idx, _Pfn, _Calls);
		}

	ios_base&  copyfmt(const ios_base& _Other)
		{	
		if (this != &_Other)
			{	
			_Tidy();
			*_Ploc = *_Other._Ploc;
			_Fmtfl = _Other._Fmtfl;
			_Prec = _Other._Prec;
			_Wide = _Other._Wide;
			_Iosarray *_Ptr = _Other._Arr;

			for (_Arr = 0; _Ptr != 0; _Ptr = _Ptr->_Next)
				if (_Ptr->_Lo != 0 || _Ptr->_Vp != 0)
					{	
					iword(_Ptr->_Index) = _Ptr->_Lo;
					pword(_Ptr->_Index) = _Ptr->_Vp;
					}

			for (_Fnarray *_Pfa = _Other._Calls; _Pfa != 0;
				_Pfa = _Pfa->_Next)
				register_callback(_Pfa->_Pfn, _Pfa->_Index);

			_Callfns(copyfmt_event);	
			exceptions(_Other._Except);	
			}
		return (*this);
		}

	static bool __cdecl sync_with_stdio(bool _Newsync = true)
		{	
		{ ::std:: _Lockit _Lock(2);	
			const bool _Oldsync = _Sync;
			_Sync = _Newsync;
			return (_Oldsync);
		}
		}

	void  swap(ios_base& _Right)
		{	
		if (this != &_Right)
			{	
			::std:: swap(_Mystate, _Right._Mystate);
			::std:: swap(_Except, _Right._Except);
			::std:: swap(_Fmtfl, _Right._Fmtfl);
			::std:: swap(_Prec, _Right._Prec);
			::std:: swap(_Wide, _Right._Wide);

			::std:: swap(_Arr, _Right._Arr);
			::std:: swap(_Calls, _Right._Calls);
			::std:: swap(_Ploc, _Right._Ploc);
			}
		}

	virtual  ~ios_base() throw ()	
		{	
		_Ios_base_dtor(this);
		}

	static  void __cdecl
		_Addstd(ios_base *);	

	size_t _Stdstr;	

protected:
	 ios_base()
		{	
		}

	void  _Init()
		{	
		_Ploc = 0;
		_Stdstr = 0;
		_Except = goodbit;
		_Fmtfl = (fmtflags)(skipws | dec);
		_Prec = 6;
		_Wide = 0;
		_Arr = 0;
		_Calls = 0;
		clear(goodbit);
		_Ploc = new locale;
		}

private:
			
	struct _Iosarray
		{	
	public:
		 _Iosarray(int _Idx, _Iosarray *_Link)
			: _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0)
			{	
			}

		_Iosarray *_Next;	
		int _Index;	
		long _Lo;	
		void *_Vp;	
		};

			
	struct _Fnarray
		{	
		 _Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link)
			: _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
			{	
			}

		_Fnarray *_Next;	
		int _Index;	
		event_callback _Pfn;	
		};

	void  _Callfns(event _Ev)
		{	
		for (_Fnarray *_Pfa = _Calls; _Pfa != 0; _Pfa = _Pfa->_Next)
			(*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
		}

	_Iosarray&  _Findarr(int _Idx)
		{	
		_Iosarray *_Ptr1, *_Ptr2;

		for (_Ptr1 = _Arr, _Ptr2 = 0; _Ptr1 != 0; _Ptr1 = _Ptr1->_Next)
			if (_Ptr1->_Index == _Idx)
				return (*_Ptr1);	
			else if (_Ptr2 == 0 && _Ptr1->_Lo == 0 && _Ptr1->_Vp == 0)
				_Ptr2 = _Ptr1;	

		if (_Ptr2 != 0)
			{	
			_Ptr2->_Index = _Idx;
			return (*_Ptr2);
			}

		_Arr = new _Iosarray(_Idx, _Arr);	
		return (*_Arr);
		}

	void  _Tidy()
		{	
		_Callfns(erase_event);
		_Iosarray *_Ptr1, *_Ptr2;

		for (_Ptr1 = _Arr; _Ptr1 != 0; _Ptr1 = _Ptr2)
			{	
			_Ptr2 = _Ptr1->_Next;
			delete (_Ptr1);
			}
		_Arr = 0;

		_Fnarray *_Pfa1, *_Pfa2;
		for (_Pfa1 = _Calls; _Pfa1 != 0; _Pfa1 = _Pfa2)
			{	
			_Pfa2 = _Pfa1->_Next;
			delete (_Pfa1);
			}
		_Calls = 0;
		}

	iostate _Mystate;	
	iostate _Except;	
	fmtflags _Fmtfl;	
	streamsize _Prec;	
	streamsize _Wide;	
	_Iosarray *_Arr;	
	_Fnarray *_Calls;	
	locale *_Ploc;	

	 static int _Index;
	 static bool _Sync;

	static  void __cdecl
		_Ios_base_dtor(ios_base *);

	ios_base(const ios_base&);	
	ios_base& operator=(const ios_base&);	
	};





}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 663 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xiosbase"
#line 664 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xiosbase"





#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\streambuf"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4251)

namespace std {
		
template<class _Elem,
	class _Traits>
	class basic_streambuf
	{	
	typedef basic_streambuf<_Elem, _Traits> _Myt;

protected:
	 basic_streambuf()
		: _Plocale(new locale)
		{	
		_Init();
		}

	 basic_streambuf(_Uninitialized)
		{	
		}

	 basic_streambuf(const _Myt& _Right)
		: _Plocale(new locale(_Right.getloc()))
		{	
		_Init();
		setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
		setg(_Right.eback(), _Right.gptr(), _Right.egptr());
		}

	_Myt&  operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			pubimbue(_Right.getloc());
			}
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Elem *_Pfirst = pbase();
			_Elem *_Pnext = pptr();
			_Elem *_Pend = epptr();
			_Elem *_Gfirst = eback();
			_Elem *_Gnext = gptr();
			_Elem *_Gend = egptr();

			setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			_Right.setp(_Pfirst, _Pnext, _Pend);

			setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			_Right.setg(_Gfirst, _Gnext, _Gend);

			::std:: swap(_Plocale, _Right._Plocale);
			}
		}

public:
	typedef _Elem char_type;
	typedef _Traits traits_type;

	virtual  ~basic_streambuf() throw ()
		{	
		delete (_Plocale);
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	pos_type  pubseekoff(off_type _Off,
		ios_base::seekdir _Way,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		return (seekoff(_Off, _Way, _Mode));
		}

	pos_type  pubseekoff(off_type _Off,
		ios_base::seek_dir _Way,
		ios_base::open_mode _Mode)
		{	
		return (pubseekoff(_Off, (ios_base::seekdir)_Way,
			(ios_base::openmode)_Mode));
		}

	pos_type  pubseekpos(pos_type _Pos,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		return (seekpos(_Pos, _Mode));
		}

	pos_type  pubseekpos(pos_type _Pos,
		ios_base::open_mode _Mode)
		{	
		return (seekpos(_Pos, (ios_base::openmode)_Mode));
		}

	_Myt * pubsetbuf(_Elem *_Buffer,
		streamsize _Count)
		{	
		return (setbuf(_Buffer, _Count));
		}

	locale  pubimbue(const locale &_Newlocale)
		{	
		locale _Oldlocale = *_Plocale;
		imbue(_Newlocale);
		*_Plocale = _Newlocale;
		return (_Oldlocale);
		}

	locale  getloc() const
		{	
		return (*_Plocale);
		}

	streamsize  in_avail()
		{	
		streamsize _Res = _Gnavail();
		return (0 < _Res ? _Res : showmanyc());
		}

	int  pubsync()
		{	
		return (sync());
		}

	int_type  sbumpc()
		{	
		return (0 < _Gnavail()
			? _Traits::to_int_type(*_Gninc()) : uflow());
		}

	int_type  sgetc()
		{	
		return (0 < _Gnavail()
			? _Traits::to_int_type(*gptr()) : underflow());
		}

	streamsize  sgetn(_Elem *_Ptr,
		streamsize _Count)
		{	
		return (xsgetn(_Ptr, _Count));
		}

	int_type  snextc()
		{	
		return (1 < _Gnavail()
			? _Traits::to_int_type(*_Gnpreinc())
			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
				? _Traits::eof() : sgetc());
		}

	int_type  sputbackc(_Elem _Ch)
		{	
		return (gptr() != 0 && eback() < gptr()
			&& _Traits::eq(_Ch, gptr()[-1])
			? _Traits::to_int_type(*_Gndec())
			: pbackfail(_Traits::to_int_type(_Ch)));
		}

	void  stossc()
		{	
		if (0 < _Gnavail())
			_Gninc();
		else
			uflow();
		}

	int_type  sungetc()
		{	
		return (gptr() != 0 && eback() < gptr()
			? _Traits::to_int_type(*_Gndec()) : pbackfail());
		}

	int_type  sputc(_Elem _Ch)
		{	
		return (0 < _Pnavail()
			? _Traits::to_int_type(*_Pninc() = _Ch)
			: overflow(_Traits::to_int_type(_Ch)));
		}

	streamsize  sputn(const _Elem *_Ptr,
		streamsize _Count)
		{	
		return (xsputn(_Ptr, _Count));
		}

	virtual void  _Lock()
		{	
		}

	virtual void  _Unlock()
		{	
		}

protected:
	_Elem * eback() const
		{	
		return (*_IGfirst);
		}

	_Elem * gptr() const
		{	
		return (*_IGnext);
		}

	_Elem * pbase() const
		{	
		return (*_IPfirst);
		}

	_Elem * pptr() const
		{	
		return (*_IPnext);
		}

	_Elem * egptr() const
		{	
		return (*_IGnext + *_IGcount);
		}

	void  gbump(int _Off)
		{	
		*_IGcount -= _Off;
		*_IGnext += _Off;
		}

	void  setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	
		*_IGfirst = _First;
		*_IGnext = _Next;
		*_IGcount = (int)(_Last - _Next);
		}

	_Elem * epptr() const
		{	
		return (*_IPnext + *_IPcount);
		}

	_Elem * _Gndec()
		{	
		++*_IGcount;
		return (--*_IGnext);
		}

	_Elem * _Gninc()
		{	
		--*_IGcount;
		return ((*_IGnext)++);
		}

	_Elem * _Gnpreinc()
		{	
		--*_IGcount;
		return (++(*_IGnext));
		}

	streamsize  _Gnavail() const
		{	
		return (*_IGnext != 0 ? *_IGcount : 0);
		}

	void  pbump(int _Off)
		{	
		*_IPcount -= _Off;
		*_IPnext += _Off;
		}

	void  setp(_Elem *_First, _Elem *_Last)
		{	
		*_IPfirst = _First;
		*_IPnext = _First;
		*_IPcount = (int)(_Last - _First);
		}

	void  setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	
		*_IPfirst = _First;
		*_IPnext = _Next;
		*_IPcount = (int)(_Last - _Next);
		}

	_Elem * _Pninc()
		{	
		--*_IPcount;
		return ((*_IPnext)++);
		}

	streamsize  _Pnavail() const
		{	
		return (*_IPnext != 0 ? *_IPcount : 0);
		}

	void  _Init()
		{	
		_IGfirst = &_Gfirst;
		_IPfirst = &_Pfirst;
		_IGnext = &_Gnext;
		_IPnext = &_Pnext;
		_IGcount = &_Gcount;
		_IPcount = &_Pcount;
		setp(0, 0);
		setg(0, 0, 0);
		}

	void  _Init(_Elem **_Gf, _Elem **_Gn, int *_Gc,
		_Elem **_Pf, _Elem **_Pn, int *_Pc)
		{	
		_IGfirst = _Gf;
		_IPfirst = _Pf;
		_IGnext = _Gn;
		_IPnext = _Pn;
		_IGcount = _Gc;
		_IPcount = _Pc;
		}

	virtual int_type  overflow(int_type = _Traits::eof())
		{	
		return (_Traits::eof());
		}

	virtual int_type  pbackfail(int_type = _Traits::eof())
		{	
		return (_Traits::eof());
		}

	virtual streamsize  showmanyc()
		{	
		return (0);
		}

	virtual int_type  underflow()
		{	
		return (_Traits::eof());
		}

	virtual int_type  uflow()
		{	
		return (_Traits::eq_int_type(_Traits::eof(), underflow())
			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
		}

	virtual streamsize  xsgetn(_Elem * _Ptr,
		streamsize _Count)
		{	
		int_type _Meta;
		streamsize _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (0 < (_Size = _Gnavail()))
				{	
				if (_Count < _Size)
					_Size = _Count;
				_Traits::copy(_Ptr, gptr(), (size_t)_Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				gbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
				break;	
			else
				{	
				*_Ptr++ = _Traits::to_char_type(_Meta);
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual streamsize  xsputn(const _Elem *_Ptr,
		streamsize _Count)
		{	
		streamsize _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (0 < (_Size = _Pnavail()))
				{	
				if (_Count < _Size)
					_Size = _Count;
				_Traits::copy(pptr(), _Ptr, (size_t)_Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				pbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(),
				overflow(_Traits::to_int_type(*_Ptr))))
				break;	
			else
				{	
				++_Ptr;
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual pos_type  seekoff(off_type,
		ios_base::seekdir,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	
		return (streampos(_BADOFF));
		}

	virtual pos_type  seekpos(pos_type,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	
		return (streampos(_BADOFF));
		}

	virtual _Myt * setbuf(_Elem *, streamsize)
		{	
		return (this);
		}

	virtual int  sync()
		{	
		return (0);
		}

	virtual void  imbue(const locale&)
		{	
		}

private:
	_Elem *_Gfirst;	
	_Elem *_Pfirst;	
	_Elem **_IGfirst;	
	_Elem **_IPfirst;	
	_Elem *_Gnext;	
	_Elem *_Pnext;	
	_Elem **_IGnext;	
	_Elem **_IPnext;	

	int _Gcount;	
	int _Pcount;	
	int *_IGcount;	
	int *_IPcount;	

protected:
	locale *_Plocale;	
	};

 

template class __declspec(dllimport) basic_streambuf<char, char_traits<char> >;
template class __declspec(dllimport) basic_streambuf<wchar_t, char_traits<wchar_t> >;

 #line 470 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\streambuf"

		
template<class _Elem,
	class _Traits>
	class istreambuf_iterator
		: public iterator<input_iterator_tag,
			_Elem, typename _Traits::off_type, const _Elem *, _Elem>
	{	
	typedef istreambuf_iterator<_Elem, _Traits> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_istream<_Elem, _Traits> istream_type;

	typedef typename traits_type::int_type int_type;
	typedef const _Elem *pointer;

	istreambuf_iterator(streambuf_type *_Sb = 0) throw ()
		: _Strbuf(_Sb), _Got(_Sb == 0)
		{	
		}

	istreambuf_iterator(istream_type& _Istr) throw ()
		: _Strbuf(_Istr.rdbuf()), _Got(_Istr.rdbuf() == 0)
		{	
		}

	const _Elem& operator*() const
		{	
		if (!_Got)
			_Peek();

 


#line 507 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\streambuf"

		return (_Val);
		}

	const _Elem *operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
 


#line 522 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\streambuf"

		_Inc();
		return (*this);
		}

	_Myt operator++(int)
		{	
		if (!_Got)
			_Peek();
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	bool equal(const _Myt& _Right) const
		{	
		if (!_Got)
			_Peek();
		if (!_Right._Got)
			_Right._Peek();
		return (_Strbuf == 0 && _Right._Strbuf == 0
			|| _Strbuf != 0 && _Right._Strbuf != 0);
		}

private:
	void _Inc()
		{	
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Strbuf->sbumpc()))
			_Strbuf = 0, _Got = true;
		else
			_Got = false;
		}

	_Elem _Peek() const
		{	
		int_type _Meta;
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Meta = _Strbuf->sgetc()))
			_Strbuf = 0;
		else
			_Val = traits_type::to_char_type(_Meta);
		_Got = true;
		return (_Val);
		}

	mutable streambuf_type *_Strbuf;	
	mutable bool _Got;	
	mutable _Elem _Val;	
	};

template<class _Elem,
	class _Traits>
	struct _Is_checked_helper<istreambuf_iterator<_Elem, _Traits> >
		: public true_type
	{	
	};

		
template<class _Elem,
	class _Traits> inline
	bool  operator==(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	
	return (_Left.equal(_Right));
	}

template<class _Elem,
	class _Traits> inline
	bool  operator!=(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	
	return (!(_Left == _Right));
	}

		
template<class _Elem,
	class _Traits>
	class ostreambuf_iterator
		: public _Outit
	{	
	typedef ostreambuf_iterator<_Elem, _Traits> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_ostream<_Elem, _Traits> ostream_type;

	ostreambuf_iterator(streambuf_type *_Sb) throw ()
		: _Failed(false), _Strbuf(_Sb)
		{	
		}

	ostreambuf_iterator(ostream_type& _Ostr) throw ()
		: _Failed(false), _Strbuf(_Ostr.rdbuf())
		{	
		}

	_Myt& operator=(_Elem _Right)
		{	
		if (_Strbuf == 0
			|| traits_type::eq_int_type(_Traits::eof(),
				_Strbuf->sputc(_Right)))
			_Failed = true;
		return (*this);
		}

	_Myt& operator*()
		{	
		return (*this);
		}

	_Myt& operator++()
		{	
		return (*this);
		}

	_Myt& operator++(int)
		{	
		return (*this);
		}

	bool failed() const throw ()
		{	
		return (_Failed);
		}

private:
	bool _Failed;	
	streambuf_type *_Strbuf;	
	};

template<class _Elem,
	class _Traits>
	struct _Is_checked_helper<ostreambuf_iterator<_Elem, _Traits> >
		: public true_type
	{	
	};
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 670 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\streambuf"
#line 671 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\streambuf"





#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocnum"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189 4275)

		

 
extern "C" {
 #line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocnum"

extern __declspec(dllimport) float __cdecl _Stofx(const char *,
	    char **,
	long, int *);
extern __declspec(dllimport) double __cdecl _Stodx(const char *,
	    char **,
	long, int *);
extern __declspec(dllimport) long double __cdecl _Stoldx(const char *,
	    char **,
	long, int *);
extern __declspec(dllimport) long __cdecl _Stolx(const char *,
	    char **,
	int, int *);
extern __declspec(dllimport) unsigned long __cdecl _Stoulx(const char *,
	    char **,
	int, int *);
extern __declspec(dllimport) __int64 __cdecl _Stollx(const char *,
	    char **,
	int, int *);
extern __declspec(dllimport) unsigned __int64 __cdecl _Stoullx(const char *,
	    char **,
	int, int *);

 
}
 #line 50 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocnum"

namespace std {

template<class _Elem> inline
	size_t _Find_elem(_Elem *_Base, _Elem _Ch)
	{	
	_Elem *_Ptr = _Base;
	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)
		;
	return ((size_t)(_Ptr - _Base));
	}

inline wchar_t *_Maklocwcs(const wchar_t *_Ptr)
	{	
	size_t _Count = :: wcslen(_Ptr) + 1;
	wchar_t *_Ptrdest = new wchar_t[_Count];
	:: wmemcpy(_Ptrdest, _Ptr, _Count);
	return (_Ptrdest);
	}

		
template<class _Elem>
	class numpunct
		: public locale::facet
	{	
public:
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		string_type;
	typedef _Elem char_type;

	 __declspec(dllimport) static locale::id id;	

	_Elem decimal_point() const
		{	
		return (do_decimal_point());
		}

	_Elem thousands_sep() const
		{	
		return (do_thousands_sep());
		}

	string grouping() const
		{	
		return (do_grouping());
		}

	string_type falsename() const
		{	
		return (do_falsename());
		}

	string_type truename() const
		{	
		return (do_truename());
		}

	explicit numpunct(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
			if (_Kseparator == 0)
				_Kseparator =	
					_Maklocchr(',', (_Elem *)0, _Lobj._Getcvt());
		}
		}

	numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj, _Isdef);
		}

	static size_t _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new numpunct<_Elem>(
				_Locinfo(_Ploc->c_str()), 0, true);
		return (4);
		}

protected:
	virtual  ~numpunct() throw ()
		{	
		_Tidy();
		}

	numpunct(const char *_Locname, size_t _Refs = 0, bool _Isdef = false)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj(_Locname);
			_Init(_Lobj, _Isdef);
		}
		}

	template<class _Elem2>
		void _Getvals(_Elem2, const lconv *_Ptr, _Locinfo::_Cvtvec _Cvt)
		{	
		_Dp = _Maklocchr(_Ptr->decimal_point[0], (_Elem2 *)0, _Cvt);
		_Kseparator = _Maklocchr(_Ptr->thousands_sep[0], (_Elem2 *)0, _Cvt);
		}

	template<>
		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)
		{	
		_Dp = (_Elem)_Ptr->_W_decimal_point[0];
		_Kseparator = (_Elem)_Ptr->_W_thousands_sep[0];
		}

	void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
		{	
		const lconv *_Ptr = _Lobj._Getlconv();
		_Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();	

		_Grouping = 0;
		_Falsename = 0;
		_Truename = 0;

		try {
		_Grouping = _Maklocstr(_Isdef ? "" : _Ptr->grouping, (char *)0, _Lobj._Getcvt());
#line 173 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocnum"
		_Falsename = _Maklocstr(_Lobj._Getfalse(), (_Elem *)0, _Cvt);
		_Truename = _Maklocstr(_Lobj._Gettrue(), (_Elem *)0, _Cvt);
		} catch (...) {
		_Tidy();
		throw;
		}

		if (_Isdef)
			{	

			_Dp = _Maklocchr('.', (_Elem *)0, _Cvt);
			_Kseparator = _Maklocchr(',', (_Elem *)0, _Cvt);
			}
		else
			_Getvals((_Elem)0, _Ptr, _Cvt);
		}

	virtual _Elem  do_decimal_point() const
		{	
		return (_Dp);
		}

	virtual _Elem  do_thousands_sep() const
		{	
		return (_Kseparator);
		}

	virtual string  do_grouping() const
		{	
		return (string(_Grouping));
		}

	virtual string_type  do_falsename() const
		{	
		return (string_type(_Falsename));
		}

	virtual string_type  do_truename() const
		{	
		return (string_type(_Truename));
		}

private:
	void _Tidy()
		{	
		delete[] ((void *)_Grouping);
		delete[] ((void *)_Falsename);
		delete[] ((void *)_Truename);
		}

	const char *_Grouping;	
	_Elem _Dp;	
	_Elem _Kseparator;	
	const _Elem *_Falsename;	
	const _Elem *_Truename;	
	};

		
template<class _Elem>
	class numpunct_byname
		: public numpunct<_Elem>
	{	
public:
	explicit numpunct_byname(const char *_Locname, size_t _Refs = 0)
		: numpunct<_Elem>(_Locname, _Refs)
		{	
		}

 
	explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
		: numpunct<_Elem>(_Str.c_str(), _Refs)
		{	
		}
 #line 247 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocnum"

protected:
	virtual  ~numpunct_byname() throw ()
		{	
		}
	};

		
template<class _Elem>
	 locale::id numpunct<_Elem>::id;

		
template<class _Elem,
	class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_get
		: public locale::facet
	{	
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new num_get<_Elem, _InIt>(
				_Locinfo(_Ploc->c_str()));
		return (4);
		}

	 static locale::id id;	

protected:
	virtual  ~num_get() throw ()
		{	
		}

	void _Init(const _Locinfo&)
		{	
		}

public:
	explicit  num_get(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 num_get(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _InIt iter_type;

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			_Bool& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			unsigned short& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			unsigned int& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

 
	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			__int64& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned __int64& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
 #line 357 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocnum"

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

protected:
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			_Bool& _Val) const
		{	
		;
		int _Ans = -1;	

		if (_Iosbase.flags() & ios_base::boolalpha)
			{	
			typedef typename _Mystr::size_type _Mystrsize;
			const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
			_Mystr _Str((_Mystrsize)1, (char_type)0);
			_Str += _Punct_fac.falsename();
			_Str += (char_type)0;
			_Str += _Punct_fac.truename();	
			_Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());
			}
		else
			{	
			char _Ac[32], *_Ep;
			int _Errno = 0;
			const unsigned long _Ulo = :: _Stoulx(_Ac, &_Ep,
				_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
					_Iosbase.getloc()), &_Errno);
			if (_Ep != _Ac && _Errno == 0 && _Ulo <= 1)
				_Ans = _Ulo;
			}

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ans < 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans != 0;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned short& _Val) const
		{	
		;
		char _Ac[32], *_Ep;
		int _Errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());	
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	
		const unsigned long _Ans =
			:: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || _Errno != 0 || 0xffff < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = (unsigned short)(_Ac[0] == '-'
				? 0 -_Ans : _Ans);	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned int& _Val) const
		{	
		;
		char _Ac[32], *_Ep;
		int _Errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());	
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	
		const unsigned long _Ans =
			:: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || _Errno != 0 || 0xffffffff < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = _Ac[0] == '-' ? 0 -_Ans : _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	
		;
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const long _Ans = :: _Stolx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	
		;
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const unsigned long _Ans = :: _Stoulx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

 
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			__int64& _Val) const
		{	
		;
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const __int64 _Ans = :: _Stollx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned __int64& _Val) const
		{	
		;
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const unsigned __int64 _Ans = :: _Stoullx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}
 #line 550 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocnum"

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	
		;
		char _Ac[8 + 36 + 16], *_Ep;
		int _Errno = 0;
		int _Hexexp = 0;
		float _Ans = :: _Stofx(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 0)
			_Ans = :: ldexpf(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	
		;
		char _Ac[8 + 36 + 16], *_Ep;
		int _Errno = 0;
		int _Hexexp = 0;
		double _Ans = :: _Stodx(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 0)
			_Ans = :: ldexp(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	
		;
		char _Ac[8 + 36 + 16], *_Ep;
		int _Errno = 0;
		int _Hexexp = 0;
		long double _Ans = :: _Stoldx(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 0)
			_Ans = :: ldexpl(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	
		;
		char _Ac[32], *_Ep;
		int _Errno = 0;

 
		int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex,
			_Iosbase.getloc());	
		const unsigned __int64 _Ans =
			(sizeof (void *) == sizeof (unsigned long))
				? (unsigned __int64):: _Stoulx(_Ac, &_Ep, _Base, &_Errno)
				: :: _Stoullx(_Ac, &_Ep, _Base, &_Errno);

 



#line 644 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocnum"

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = (void *)((char *)0 + _Ans);	
		return (_First);
		}

private:
	int __cdecl _Getifld(char *_Ac,
		_InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
			const locale& _Loc) const
		{	
		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Loc);
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Grouping.size() == 0
			? (_Elem)0 : _Punct_fac.thousands_sep();

		enum {
			_NUMGET_SIGNOFF = 22,
			_NUMGET_XOFF = 24};
		static const char _Src[] = {"0123456789ABCDEFabcdef-+Xx"};
		_Elem _Atoms[sizeof (_Src) - 1];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Loc);
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src) - 1], _Atoms);

		char *_Ptr = _Ac;

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		_Basefield &= ios_base::basefield;
		int _Base = _Basefield == ios_base::oct ? 8
			: _Basefield == ios_base::hex ? 16
			: _Basefield == ios_base::_Fmtzero ? 0 : 10;

		bool _Seendigit = false;	
		bool _Nonzero = false;	

		if (_First != _Last && *_First == _Atoms[0])
			{	
			_Seendigit = true, ++_First;
			if (_First != _Last && (*_First == _Atoms[_NUMGET_XOFF + 1]
					|| *_First == _Atoms[_NUMGET_XOFF])
				&& (_Base == 0 || _Base == 16))
				_Base = 16, _Seendigit = false, ++_First;
			else if (_Base == 0)
				_Base = 8;
			}

		size_t _Dlen = _Base == 0 || _Base == 10 ? 10
			: _Base == 8 ? 8 : 16 + 6;
		string _Groups((size_t)1, (char)_Seendigit);
		size_t _Group = 0;

		for (char *const _Pe = &_Ac[32 - 1];
			_First != _Last; ++_First)
			{	
			size_t _Idx = _Find_elem(_Atoms, *_First);
			if (_Idx < _Dlen)
				{	
				*_Ptr = _Src[_Idx];
				if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)
					++_Ptr, _Nonzero = true;
				_Seendigit = true;
				if (_Groups[_Group] != 127)
					++_Groups[_Group];
				}
			else if (_Groups[_Group] == '\0'
				|| _Kseparator == (_Elem)0
				|| *_First != _Kseparator)
				break;	
			else
				{	
				_Groups.append((string::size_type)1, '\0');
				++_Group;
				}
			}

		if (_Group == 0)
			;	
		else if ('\0' < _Groups[_Group])
			++_Group;	
		else
			_Seendigit = false;	

		for (const char *_Pg = &_Grouping[0]; _Seendigit && 0 < _Group; )
			if (*_Pg == 127)
				break;	
			else if (0 < --_Group && *_Pg != _Groups[_Group]
				|| 0 == _Group && *_Pg < _Groups[_Group])
				_Seendigit = false;	
			else if ('\0' < _Pg[1])
				++_Pg;	

		if (_Seendigit && !_Nonzero)
			*_Ptr++ = '0';	
		else if (!_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		return (_Base);
		}

	int __cdecl _Getffld(char *_Ac,
		_InIt& _First, _InIt &_Last,
		ios_base& _Iosbase, int *_Phexexp) const
		{	
		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat)
			return (_Getffldx(_Ac, _First, _Last,
				_Iosbase, _Phexexp));	

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		char *_Ptr = _Ac;
		bool _Bad = false;

		enum {
			_NUMGET_SIGNOFF = 10,
			_NUMGET_EOFF = 12};
		static const char _Src[] = {"0123456789-+Ee"};
		_Elem _Atoms[sizeof (_Src) - 1];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src) - 1], _Atoms);

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		bool _Seendigit = false;	
		int _Significant = 0;	
		int _Pten = 0;	
		size_t _Idx;

		const char *_Pg = &_Grouping[0];
		if (*_Pg == 127 || *_Pg <= '\0')
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
					_Seendigit = true, ++_First)
				if (36 <= _Significant)
					++_Pten;	
				else if (_Idx == 0 && _Significant == 0)
					;	
				else
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
		else
			{	
			const _Elem _Kseparator = _Grouping.size() == 0
				? (_Elem)0 : _Punct_fac.thousands_sep();
			string _Groups((size_t)1, '\0');
			size_t _Group = 0;

			for (; _First != _Last; ++_First)
				if ((_Idx = _Find_elem(_Atoms, *_First)) < 10)
					{	
					_Seendigit = true;
					if (36 <= _Significant)
						++_Pten;	
					else if (_Idx == 0 && _Significant == 0)
						;	
					else
						{	
						*_Ptr++ = _Src[_Idx];
						++_Significant;
						}
					if (_Groups[_Group] != 127)
						++_Groups[_Group];
					}
				else if (_Groups[_Group] == '\0'
					|| _Kseparator == (_Elem)0
					|| *_First != _Kseparator)
					break;	
				else
					{	
					_Groups.append((size_t)1, '\0');
					++_Group;
					}
			if (_Group == 0)
				;	
			else if ('\0' < _Groups[_Group])
				++_Group;	
			else
				_Bad = true;	

			while (!_Bad && 0 < _Group)
				if (*_Pg == 127)
					break;	
				else if (0 < --_Group && *_Pg != _Groups[_Group]
					|| 0 == _Group && *_Pg < _Groups[_Group])
					_Bad = true;	
				else if ('\0' < _Pg[1])
					++_Pg;	
			}

		if (_Seendigit && _Significant == 0)
			*_Ptr++ = '0';	

		if (_First != _Last && *_First == _Punct_fac.decimal_point())
			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	

		if (_Significant == 0)
			{	
			for (; _First != _Last && *_First == _Atoms[0];
				_Seendigit = true, ++_First)
				--_Pten;	
			if (_Pten < 0)
				*_Ptr++ = '0', ++_Pten;	
			}

		for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
				_Seendigit = true, ++_First)
			if (_Significant < 36)
				{	
				*_Ptr++ = _Src[_Idx];
				++_Significant;
				}

		if (_Seendigit && _First != _Last
			&& (*_First == _Atoms[_NUMGET_EOFF + 1]
				|| *_First == _Atoms[_NUMGET_EOFF]))
			{	
			*_Ptr++ = 'e', ++_First;
			_Seendigit = false, _Significant = 0;

			if (_First == _Last)
				;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
				*_Ptr++ = '+', ++_First;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF])
				*_Ptr++ = '-', ++_First;	
			for (; _First != _Last && *_First == _Atoms[0]; )
				_Seendigit = true, ++_First;	
			if (_Seendigit)
				*_Ptr++ = '0';	
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
				_Seendigit = true, ++_First)
				if (_Significant < 8)
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
			}

		if (_Bad || !_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		return (_Pten);
		}

	int __cdecl _Getffldx(char *_Ac,
		_InIt& _First, _InIt &_Last,
		ios_base& _Iosbase, int *_Phexexp) const
		{	
		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();

		enum {
			_NUMGET_SIGNOFF = 22,
			_NUMGET_XOFF = 24,
			_NUMGET_POFF = 26};
		static const char _Src[] = {"0123456789ABCDEFabcdef-+XxPp"};
		_Elem _Atoms[sizeof (_Src) - 1];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src) - 1], _Atoms);

		char *_Ptr = _Ac;
		bool _Bad = false;
		size_t _Idx;

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		*_Ptr++ = '0';
		*_Ptr++ = 'x';

		bool _Seendigit = false;	
		int _Significant = 0;	
		int _Phex = 0;	

		if (_First == _Last || *_First != _Atoms[0])
			;
		else if (++_First != _Last
			&& (*_First == _Atoms[_NUMGET_XOFF + 1]
				 || *_First == _Atoms[_NUMGET_XOFF]))
			++_First;	
		else
			_Seendigit = true;	

		const char *_Pg = &_Grouping[0];
		if (*_Pg == 127 || *_Pg <= '\0')
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
					_Seendigit = true, ++_First)
				if (36 <= _Significant)
					++_Phex;	
				else if (_Idx == 0 && _Significant == 0)
					;	
				else
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
		else
			{	
			const _Elem _Kseparator = _Grouping.size() == 0
				? (_Elem)0 : _Punct_fac.thousands_sep();
			string _Groups((size_t)1, '\0');
			size_t _Group = 0;

			for (; _First != _Last; ++_First)
				if ((_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF)
					{	
					_Seendigit = true;
					if (36 <= _Significant)
						++_Phex;	
					else if (_Idx == 0 && _Significant == 0)
						;	
					else
						{	
						*_Ptr++ = _Src[_Idx];
						++_Significant;
						}
					if (_Groups[_Group] != 127)
						++_Groups[_Group];
					}
				else if (_Groups[_Group] == '\0'
					|| _Kseparator == (_Elem)0
					|| *_First != _Kseparator)
					break;	
				else
					{	
					_Groups.append((size_t)1, '\0');
					++_Group;
					}
			if (_Group == 0)
				;	
			else if ('\0' < _Groups[_Group])
				++_Group;	
			else
				_Bad = true;	

			while (!_Bad && 0 < _Group)
				if (*_Pg == 127)
					break;	
				else if (0 < --_Group && *_Pg != _Groups[_Group]
					|| 0 == _Group && *_Pg < _Groups[_Group])
					_Bad = true;	
				else if ('\0' < _Pg[1])
					++_Pg;	
			}

		if (_Seendigit && _Significant == 0)
			*_Ptr++ = '0';	

		if (_First != _Last && *_First == _Punct_fac.decimal_point())
			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	

		if (_Significant == 0)
			{	
			for (; _First != _Last && *_First == _Atoms[0];
				_Seendigit = true, ++_First)
				--_Phex;	
			if (_Phex < 0)
				*_Ptr++ = '0', ++_Phex;	
			}

		for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
				_Seendigit = true, ++_First)
			if (_Significant < 36)
				{	
				*_Ptr++ = _Src[_Idx];
				++_Significant;
				}

		if (_Seendigit && _First != _Last
			&& (*_First == _Atoms[_NUMGET_POFF + 1]
				|| *_First == _Atoms[_NUMGET_POFF]))
			{	
			*_Ptr++ = 'p', ++_First;
			_Seendigit = false, _Significant = 0;

			if (_First == _Last)
				;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
				*_Ptr++ = '+', ++_First;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF])
				*_Ptr++ = '-', ++_First;	
			for (; _First != _Last && *_First == _Atoms[0]; )
				_Seendigit = true, ++_First;	
			if (_Seendigit)
				*_Ptr++ = '0';	
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
				_Seendigit = true, ++_First)
				if (_Significant < 8)
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
			}

		if (_Bad || !_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		*_Phexexp = _Phex;	
		return (0);	
		}
	};

		
template<class _Elem,
	class _InIt>
	 locale::id num_get<_Elem, _InIt>::id;

		
template<class _Elem,
	class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_put
		: public locale::facet
	{	
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new num_put<_Elem, _OutIt>(
				_Locinfo(_Ploc->c_str()));
		return (4);
		}

	 static locale::id id;	

protected:
	virtual  ~num_put() throw ()
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

public:
	explicit  num_put(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 num_put(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _OutIt iter_type;

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, _Bool _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

 
	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, __int64 _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned __int64 _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
 #line 1159 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocnum"

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

protected:
	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, _Bool _Val) const
		{	
		;
		if (!(_Iosbase.flags() & ios_base::boolalpha))
			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
		else
			{	
			const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
			_Mystr _Str;
			if (_Val)
				_Str.assign(_Punct_fac.truename());
			else
				_Str.assign(_Punct_fac.falsename());

			size_t _Fillcount = _Iosbase.width() <= 0
				|| (size_t)_Iosbase.width() <= _Str.size()
					? 0 : (size_t)_Iosbase.width() - _Str.size();

			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)
				{	
				_Dest = _Rep(_Dest, _Fill, _Fillcount);
				_Fillcount = 0;
				}
			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	
			_Iosbase.width(0);
			return (_Rep(_Dest, _Fill, _Fillcount));	
			}
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	
		char _Buf[2 * 32], _Fmt[6];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	
		char _Buf[2 * 32], _Fmt[6];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "lu",
				_Iosbase.flags()), _Val)));
		}

 
	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, __int64 _Val) const
		{	
		char _Buf[2 * 32], _Fmt[8];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned __int64 _Val) const
		{	
		char _Buf[2 * 32], _Fmt[8];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Lu",
				_Iosbase.flags()), _Val)));
		}
 #line 1250 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocnum"

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	
		char _Buf[8 + 36 + 64], _Fmt[8];
		streamsize _Precision = _Iosbase.precision() <= 0
			&& !(_Iosbase.flags() & ios_base::fixed)
				? 6 : _Iosbase.precision();	
		int _Significance = 36 < _Precision
			? 36 : (int)_Precision;	
		_Precision -= _Significance;
		size_t _Beforepoint = 0;	
		size_t _Afterpoint = 0;	

		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed
			&& _Val * 0.5 != _Val)	
			{	
			bool _Signed = _Val < 0;
			if (_Signed)
				_Val = -_Val;

			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)
				_Val /= 1e10;	

			if (0 < _Val)
				for (; 10 <= _Precision && _Val <= 1e-35
					&& _Afterpoint < 5000; _Afterpoint += 10)
					{	
					_Val *= 1e10;
					_Precision -= 10;
					}

			if (_Signed)
				_Val = -_Val;
			}

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
			_Beforepoint, _Afterpoint, (size_t)_Precision,
				:: sprintf_s(_Buf, sizeof (_Buf),
					_Ffmt(_Fmt, 0, _Iosbase.flags()),
					_Significance, _Val)));	
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	
		char _Buf[8 + 36 + 64], _Fmt[8];
		streamsize _Precision = _Iosbase.precision() <= 0
			&& !(_Iosbase.flags() & ios_base::fixed)
				? 6 : _Iosbase.precision();	
		int _Significance = 36 < _Precision
			? 36 : (int)_Precision;	
		_Precision -= _Significance;
		size_t _Beforepoint = 0;	
		size_t _Afterpoint = 0;	

		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed)
			{	
			bool _Signed = _Val < 0;
			if (_Signed)
				_Val = -_Val;

			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)
				_Val /= 1e10;	

			if (0 < _Val)
				for (; 10 <= _Precision && _Val <= 1e-35
					&& _Afterpoint < 5000; _Afterpoint += 10)
					{	
					_Val *= 1e10;
					_Precision -= 10;
					}

			if (_Signed)
				_Val = -_Val;
			}

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
			_Beforepoint, _Afterpoint, (size_t)_Precision,
				:: sprintf_s(_Buf, sizeof (_Buf),
					_Ffmt(_Fmt, 'L', _Iosbase.flags()),
					_Significance, _Val)));	
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	
		char _Buf[2 * 32];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), "%p", _Val)));
		}

private:
	char *__cdecl _Ffmt(char *_Fmt,
		char _Spec, ios_base::fmtflags _Flags) const
		{	
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showpoint)
			*_Ptr++ = '#';
		*_Ptr++ = '.';
		*_Ptr++ = '*';	
		if (_Spec != '\0')
			*_Ptr++ = _Spec;	

		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
		if (_Flags & ios_base::uppercase)
			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
				: _Ffl == ios_base::hexfloat ? 'A'	
				: _Ffl == ios_base::scientific ? 'E' : 'G';	
		else
			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
				: _Ffl == ios_base::hexfloat ? 'a'	
				: _Ffl == ios_base::scientific ? 'e' : 'g';	

		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __cdecl _Fput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const char *_Buf,
			size_t _Beforepoint, size_t _Afterpoint,
				size_t _Trailing, size_t _Count) const
		{	
		;
		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
			? 1 : 0;

		const char *_Exps;
		if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)
			_Exps = "eE";
		else
			{	
			_Exps = "pP";
			if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
				&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
				_Prefix += 2;
			}
		const size_t _Eoff =
			:: strcspn(&_Buf[0], _Exps);	
		char _Dp[2] = {"."};
		_Dp[0] = :: localeconv()->decimal_point[0];
		const size_t _Poff =
			:: strcspn(&_Buf[0], &_Dp[0]);	

		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		const _Elem _E0 = _Ctype_fac.widen('0');
		_Mystr _Groupstring(_Count, _Elem(0));	
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Punct_fac.thousands_sep();

		size_t _Off = _Beforepoint;	
		if (_Poff == _Count)
			{	
			_Off += _Eoff;
			_Groupstring.insert(_Eoff, _Beforepoint, _E0);
			}
		else
			{	
			_Off += _Poff;
			_Groupstring.insert(_Eoff, _Trailing, _E0);
			_Groupstring.insert(_Poff + 1, _Afterpoint, _E0);
			_Groupstring[_Poff] = _Punct_fac.decimal_point();
			_Groupstring.insert(_Poff, _Beforepoint, _E0);
			}

		const char *_Pg = &_Grouping[0];
		while (*_Pg != 127 && '\0' < *_Pg
			&& (size_t)*_Pg < _Off - _Prefix)
			{	
			_Groupstring.insert(_Off -= *_Pg, (size_t)1, _Kseparator);
			if ('\0' < _Pg[1])
				++_Pg;	
			}

		_Count = _Groupstring.size();
		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			}
		else if (_Adjustfield == ios_base::internal)
			{	
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	
		}

	char *__cdecl _Ifmt(char *_Fmt,
		const char *_Spec, ios_base::fmtflags _Flags) const
		{	
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showbase)
			*_Ptr++ = '#';
		if (_Spec[0] != 'L')
			*_Ptr++ = _Spec[0];	
		else

			{	
			*_Ptr++ = 'I';
			*_Ptr++ = '6';
			*_Ptr++ = '4';
			}

		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
			: _Basefield != ios_base::hex ? _Spec[1]	
			: _Flags & ios_base::uppercase ? 'X' : 'x';
		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __cdecl _Iput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, char *_Buf, size_t _Count) const
		{	
		;
		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
			? 1 : 0;
		if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex
			&& _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
			&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
			_Prefix += 2;

		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Mystr _Groupstring(_Count, _Elem(0));	
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		const char *_Pg = &_Grouping[0];
		if (*_Pg != 127 && '\0' < *_Pg)
			{	
			const _Elem _Kseparator = _Punct_fac.thousands_sep();
			while (*_Pg != 127 && '\0' < *_Pg
				&& (size_t)*_Pg < _Count - _Prefix)
				{	
				_Count -= *_Pg;
				_Groupstring.insert(_Count, 1, _Kseparator);
				if ('\0' < _Pg[1])
					++_Pg;	
				}
			}

		_Count = _Groupstring.size();
		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			}
		else if (_Adjustfield == ios_base::internal)
			{	
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	
		}

	_OutIt __cdecl _Put(_OutIt _Dest,
		const _Elem *_Ptr, size_t _Count) const
		{	
		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)
			*_Dest = *_Ptr;
		return (_Dest);
		}

	_OutIt __cdecl _Rep(_OutIt _Dest,
		_Elem _Ch, size_t _Count) const
		{	
		for (; 0 < _Count; --_Count, ++_Dest)
			*_Dest = _Ch;
		return (_Dest);
		}
	};

		
template<class _Elem,
	class _OutIt>
	 locale::id num_put<_Elem, _OutIt>::id;

 


template  locale::id numpunct<char>::id;

template class __declspec(dllimport) num_get<char,
	istreambuf_iterator<char, char_traits<char> > >;
template class __declspec(dllimport) num_put<char,
	ostreambuf_iterator<char, char_traits<char> > >;

template  locale::id numpunct<wchar_t>::id;

template class __declspec(dllimport) num_get<wchar_t,
	istreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
template class __declspec(dllimport) num_put<wchar_t,
	ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >;


 #line 1590 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocnum"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1595 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocnum"
#line 1596 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xlocnum"






#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ios"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189)

namespace std {
		
template<class _Elem,
	class _Traits>
	class basic_ios
		: public ios_base
	{	
public:
	typedef basic_ios<_Elem, _Traits> _Myt;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ctype<_Elem> _Ctype;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit  basic_ios(_Mysb *_Strbuf)
		{	
		init(_Strbuf);
		}

	virtual  ~basic_ios() throw ()
		{	
		}

	virtual void  _Add_vtordisp1()
		{	
		}

	virtual void  _Add_vtordisp2()
		{	
		}

	void  clear(iostate _State = goodbit,
		bool _Reraise = false)
		{	
		ios_base::clear((iostate)(_Mystrbuf == 0
			? (int)_State | (int)badbit : (int)_State), _Reraise);
		}

	void  clear(io_state _State)
		{	
		clear((iostate)_State);
		}

	void  setstate(iostate _State,
		bool _Reraise = false)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Reraise);
		}

	void  setstate(io_state _State)
		{	
		setstate((iostate)_State);
		}

	_Myt&  copyfmt(const _Myt& _Right)
		{	
		_Tiestr = _Right.tie();
		_Fillch = _Right.fill();
		ios_base::copyfmt(_Right);
		return (*this);
		}

	_Myos * tie() const
		{	
		return (_Tiestr);
		}

	_Myos * tie(_Myos *_Newtie)
		{	
		_Myos *_Oldtie = _Tiestr;
		_Tiestr = _Newtie;
		return (_Oldtie);
		}

	_Mysb * rdbuf() const
		{	
		return (_Mystrbuf);
		}

	_Mysb * rdbuf(_Mysb *_Strbuf)
		{	
		_Mysb *_Oldstrbuf = _Mystrbuf;
		_Mystrbuf = _Strbuf;
		clear();
		return (_Oldstrbuf);
		}

	locale  imbue(const locale& _Loc)
		{	
		locale _Oldlocale = ios_base::imbue(_Loc);
		if (rdbuf() != 0)
			rdbuf()->pubimbue(_Loc);
		return (_Oldlocale);
		}

	_Elem  fill() const
		{	
		return (_Fillch);
		}

	_Elem  fill(_Elem _Newfill)
		{	
		_Elem _Oldfill = _Fillch;
		_Fillch = _Newfill;
		return (_Oldfill);
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
		return (_Ctype_fac.narrow(_Ch, _Dflt));
		}

	_Elem  widen(char _Byte) const
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
		return (_Ctype_fac.widen(_Byte));
		}

	void  move(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mystrbuf = 0;
			_Tiestr = 0;
			this->swap(_Right);
			}
		}

	void  move(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Mystrbuf = 0;
			_Tiestr = 0;
			this->swap(_Right);
			}
		}

	void  swap(_Myt& _Right) throw ()
		{	
		ios_base::swap(_Right);
		::std:: swap(_Fillch, _Right._Fillch);
		::std:: swap(_Tiestr, _Right._Tiestr);
		}

	void  set_rdbuf(_Mysb *_Strbuf)
		{	
		_Mystrbuf = _Strbuf;
		}

protected:
	void  init(_Mysb *_Strbuf = 0,
		bool _Isstd = false)
		{	
		_Init();	
		_Mystrbuf = _Strbuf;
		_Tiestr = 0;
		_Fillch = widen(' ');

		if (_Mystrbuf == 0)
			setstate(badbit);

		if (_Isstd)
			_Addstd(this);	
		}

	 basic_ios()
		{	
		}

private:
	_Mysb *_Mystrbuf;	
	_Myos *_Tiestr;	
	_Elem _Fillch;	

	 basic_ios(const _Myt&);	
	_Myt&  operator=(const _Myt&);	
	};

 

template class __declspec(dllimport) basic_ios<char,
	char_traits<char> >;
template class __declspec(dllimport) basic_ios<wchar_t,
	char_traits<wchar_t> >;

 #line 208 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ios"

		
inline ios_base& __cdecl boolalpha(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl dec(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::dec, ios_base::basefield);
	return (_Iosbase);
	}

 
inline ios_base& __cdecl defaultfloat(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::floatfield);
	return (_Iosbase);
	}
 #line 229 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ios"

inline ios_base& __cdecl fixed(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::fixed, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl hex(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::hex, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl hexfloat(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
	return (_Iosbase);
	}

namespace tr1 {	
using ::std:: hexfloat;
}	

inline ios_base& __cdecl internal(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::internal, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl left(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::left, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowbase(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpos(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl noskipws(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl nouppercase(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::uppercase);
	return (_Iosbase);
	}

inline ios_base& __cdecl oct(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::oct, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl right(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::right, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl scientific(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::scientific, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl showbase(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpoint(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpos(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl skipws(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl unitbuf(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl uppercase(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::uppercase);
	return (_Iosbase);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 365 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ios"
#line 366 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ios"





#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ostream"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189 4390)

namespace std {
		

 
 

 



 



 



#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ostream"

		
template<class _Elem,
	class _Traits>
	class basic_ostream
		: virtual public basic_ios<_Elem, _Traits>
	{	
public:
	typedef basic_ostream<_Elem, _Traits> _Myt;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ostreambuf_iterator<_Elem, _Traits> _Iter;
	typedef num_put<_Elem, _Iter> _Nput;

	explicit  basic_ostream(
		basic_streambuf<_Elem, _Traits> *_Strbuf,

		bool _Isstd = false)
		{	
		_Myios::init(_Strbuf, _Isstd);
		}

	 basic_ostream(_Uninitialized, bool _Addit = true)
		{	
		if (_Addit)
			this->_Addstd(this);	
		}

protected:
	 basic_ostream(_Myt&& _Right)
		{	
		_Myios::init();
		_Myios::move(::std:: move(_Right));
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			_Myios::swap(_Right);
		}

private:
		 basic_ostream(const _Myt& _Right);	
		_Myt&  operator=(const _Myt&);	

public:
	virtual  ~basic_ostream() throw ()
		{	
		}

	virtual void  _Add_vtordisp2()
		{	
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	class _Sentry_base
		{	
	public:
		 _Sentry_base(_Myt& _Ostr)
			: _Myostr(_Ostr)
			{	
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Lock();
			}

		 ~_Sentry_base() throw ()
			{	
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Unlock();
			}

		_Myt& _Myostr;	

	private:
		_Sentry_base& operator=(const _Sentry_base&);
		};

	class sentry
		: public _Sentry_base
		{	
	public:
		explicit  sentry(_Myt& _Ostr)
			: _Sentry_base(_Ostr)
			{	
			if (_Ostr.good() && _Ostr.tie() != 0)
				_Ostr.tie()->flush();
			_Ok = _Ostr.good();	
			}

		 ~sentry() throw ()
			{	
 
			if (!::std:: uncaught_exception())
				this->_Myostr._Osfx();

 

#line 141 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ostream"
			}

		typedef int ::std:: _Bool_struct<_Myt>::* _Bool_type;

		 operator _Bool_type() const
			{	
			return (_Ok ? (&::std:: _Bool_struct<_Myt>::_Member) : 0);
			}

	private:
		bool _Ok;	

		 sentry(const sentry&);	
		sentry&  operator=(const sentry&);	
		};

	bool  opfx()
		{	
		if (this->good() && _Myios::tie() != 0)
			_Myios::tie()->flush();
		return (this->good());
		}

	void  osfx()
		{	
		_Osfx();
		}

	void  _Osfx()
		{	
		try {
		if (this->good() && this->flags() & ios_base::unitbuf)
			if (_Myios::rdbuf()->pubsync() == -1)	
				_Myios::setstate(ios_base::badbit);
		} catch (...) {
		}
		}

  





















	_Myt&  operator<<(_Myt& (__cdecl *_Pfn)(_Myt&))
		{	
		;
		return ((*_Pfn)(*this));
		}

	_Myt&  operator<<(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	
		;
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	_Myt&  operator<<(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	
		;
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	_Myt&  operator<<(_Bool _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(short _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
			ios_base::fmtflags _Bfl =
				this->flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned short)_Val : (long)_Val;

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}










	_Myt&  operator<<(unsigned short _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(int _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
			ios_base::fmtflags _Bfl =
				this->flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned int)_Val : (long)_Val;

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned int _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(long _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned long _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

 
	_Myt&  operator<<(__int64 _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned __int64 _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}
 #line 421 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ostream"

	_Myt&  operator<<(float _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (double)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(double _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(long double _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(const void *_Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(_Mysb *_Strbuf)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			for (int_type _Meta = _Traits::eof(); ; _Copied = true)
				{	
				try {
				_Meta = _Traits::eq_int_type(_Traits::eof(), _Meta)
					? _Strbuf->sgetc() : _Strbuf->snextc();
				} catch (...) {
					_Myios::setstate(ios_base::failbit);
					throw;
				}

				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					break;	

				try {
					if (_Traits::eq_int_type(_Traits::eof(),
						_Myios::rdbuf()->sputc(
							_Traits::to_char_type(_Meta))))
						{	
						_State |= ios_base::badbit;
						break;
						}
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

		this->width(0);
		_Myios::setstate(_Strbuf == 0 ? ios_base::badbit
			: !_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	_Myt&  put(_Elem _Ch)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputc(_Ch)))
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  write(const _Elem *_Str,
		streamsize _Count)
		{	
 


#line 566 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ostream"

		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else
			{	
			try {
			if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count)
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  flush()
		{	
		if (_Myios::rdbuf() != 0)
			{	
			const sentry _Ok(*this);

			if (_Ok && _Myios::rdbuf()->pubsync() == -1)
				_Myios::setstate(ios_base::badbit);	
			}
		return (*this);
		}

	_Myt&  seekp(pos_type _Pos)
		{	
		const sentry _Ok(*this);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	_Myt&  seekp(off_type _Off, ios_base::seekdir _Way)
		{	
		const sentry _Ok(*this);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	pos_type  tellp()
		{	
		const sentry _Ok(*this);

		if (!this->fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::out));
		else
			return (pos_type(_BADOFF));
		}
	};

	

  

















































 

template class __declspec(dllimport) basic_ostream<char,
	char_traits<char> >;
template class __declspec(dllimport) basic_ostream<wchar_t,
	char_traits<wchar_t> >;

 #line 690 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ostream"

		

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const char *_Val)
	{	
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize):: strlen(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, char _Ch)
	{	
	ios_base::iostate _State = ios_base::goodbit;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr,
		const char *_Val)
	{	
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, char _Ch)
	{	
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const _Elem *_Val)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, const signed char *_Val)
	{	
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, signed char _Ch)
	{	
	return (_Ostr << (char)_Ch);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, const unsigned char *_Val)
	{	
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch)
	{	
	return (_Ostr << (char)_Ch);
	}

template<class _Elem,
	class _Traits,
	class _Ty> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>&& _Ostr, const _Ty& _Val)
	{	
	return (_Ostr << _Val);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl endl(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.put(_Ostr.widen('\n'));
	_Ostr.flush();
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl ends(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.put(_Elem());
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.flush();
	return (_Ostr);
	}

__declspec(dllimport) inline basic_ostream<char, char_traits<char> >&
	__cdecl endl(basic_ostream<char, char_traits<char> >& _Ostr)
	{	
	_Ostr.put('\n');
	_Ostr.flush();
	return (_Ostr);
	}

__declspec(dllimport) inline basic_ostream<wchar_t, char_traits<wchar_t> >&
	__cdecl endl(basic_ostream<wchar_t,
		char_traits<wchar_t> >& _Ostr)
	{	
	_Ostr.put('\n');
	_Ostr.flush();
	return (_Ostr);
	}

 
__declspec(dllimport) inline basic_ostream<unsigned short, char_traits<unsigned short> >&
	__cdecl endl(basic_ostream<unsigned short,
		char_traits<unsigned short> >& _Ostr)
	{	
	_Ostr.put('\n');
	_Ostr.flush();
	return (_Ostr);
	}
 #line 1045 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ostream"

__declspec(dllimport) inline basic_ostream<char, char_traits<char> >&
	__cdecl ends(basic_ostream<char, char_traits<char> >& _Ostr)
	{	
	_Ostr.put('\0');
	return (_Ostr);
	}

__declspec(dllimport) inline basic_ostream<wchar_t, char_traits<wchar_t> >&
	__cdecl ends(basic_ostream<wchar_t,
		char_traits<wchar_t> >& _Ostr)
	{	
	_Ostr.put('\0');
	return (_Ostr);
	}

 
__declspec(dllimport) inline basic_ostream<unsigned short, char_traits<unsigned short> >&
	__cdecl ends(basic_ostream<unsigned short,
		char_traits<unsigned short> >& _Ostr)
	{	
	_Ostr.put('\0');
	return (_Ostr);
	}
 #line 1070 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ostream"

__declspec(dllimport) inline basic_ostream<char, char_traits<char> >&
	__cdecl flush(basic_ostream<char, char_traits<char> >& _Ostr)
	{	
	_Ostr.flush();
	return (_Ostr);
	}

__declspec(dllimport) inline basic_ostream<wchar_t, char_traits<wchar_t> >&
	__cdecl flush(basic_ostream<wchar_t,
		char_traits<wchar_t> >& _Ostr)
	{	
	_Ostr.flush();
	return (_Ostr);
	}

 
__declspec(dllimport) inline basic_ostream<unsigned short, char_traits<unsigned short> >&
	__cdecl flush(basic_ostream<unsigned short,
		char_traits<unsigned short> >& _Ostr)
	{	
	_Ostr.flush();
	return (_Ostr);
	}
 #line 1095 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ostream"

 
		
template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
			const error_code& _Errcode)
	{	
	return (_Ostr << _Errcode.category().name() << ':' << _Errcode.value());
	}
 #line 1107 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ostream"
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1113 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ostream"
#line 1114 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ostream"






#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\istream"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189 4250)

namespace std {
		
template<class _Elem,
	class _Traits>
	class basic_istream
		: virtual public basic_ios<_Elem, _Traits>
	{	
public:
	typedef basic_istream<_Elem, _Traits> _Myt;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef istreambuf_iterator<_Elem, _Traits> _Iter;
	typedef ctype<_Elem> _Ctype;
	typedef num_get<_Elem, _Iter> _Nget;


	explicit  basic_istream(_Mysb *_Strbuf,
		bool _Isstd = false)

		: _Chcount(0)
		{	
		_Myios::init(_Strbuf, _Isstd);
		}

	 basic_istream(_Uninitialized)
		{	
		this->_Addstd(this);
		}

protected:
	 basic_istream(_Myt&& _Right)
		: _Chcount(_Right._Chcount)
		{	
		_Myios::init();
		_Myios::move(::std:: move(_Right));
		_Right._Chcount = 0;
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		_Myios::swap(_Right);
		::std:: swap(_Chcount, _Right._Chcount);
		}

private:
		 basic_istream(const _Myt& _Right);	
		_Myt&  operator=(const _Myt&);	

public:
	virtual  ~basic_istream() throw ()
		{	
		}

	virtual void  _Add_vtordisp1()
		{	
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

		
	class _Sentry_base
		{	
	public:
		 _Sentry_base(_Myt& _Istr)
			: _Myistr(_Istr)
			{	
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Lock();
			}

		 ~_Sentry_base() throw ()
			{	
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Unlock();
			}

		_Myt& _Myistr;	

	private:
		_Sentry_base& operator=(const _Sentry_base&);
		};

	class sentry
		: public _Sentry_base
		{	
	public:
		explicit  sentry(_Myt& _Istr, bool _Noskip = false)
			: _Sentry_base(_Istr)
			{	
			_Ok = this->_Myistr._Ipfx(_Noskip);
			}

		typedef int ::std:: _Bool_struct<_Myt>::* _Bool_type;

		 operator _Bool_type() const
			{	
			return (_Ok ? (&::std:: _Bool_struct<_Myt>::_Member) : 0);
			}

	private:
		bool _Ok;	

		 sentry(const sentry&);	
		sentry&  operator=(const sentry&);	
		};

	bool  _Ipfx(bool _Noskip = false)
		{	
		if (this->good())
			{	
			if (_Myios::tie() != 0)
				_Myios::tie()->flush();

			if (!_Noskip && this->flags() & ios_base::skipws)
				{	
				const _Ctype& _Ctype_fac = use_facet< _Ctype >(this->getloc());

				try {
				int_type _Meta = _Myios::rdbuf()->sgetc();

				for (; ; _Meta = _Myios::rdbuf()->snextc())
					if (_Traits::eq_int_type(_Traits::eof(), _Meta))
						{	
						_Myios::setstate(ios_base::eofbit);
						break;
						}
					else if (!_Ctype_fac.is(_Ctype::space,
						_Traits::to_char_type(_Meta)))
						break;	
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

			if (this->good())
				return (true);
			}
		_Myios::setstate(ios_base::failbit);
		return (false);
		}

	bool  ipfx(bool _Noskip = false)
		{	
		return (_Ipfx(_Noskip));
		}

	void  isfx()
		{	
		}

  





















	_Myt&  operator>>(_Myt& (__cdecl *_Pfn)(_Myt&))
		{	
		;
		return ((*_Pfn)(*this));
		}

	_Myt&  operator>>(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	
		;
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	_Myt&  operator>>(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	
		;
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	_Myt&  operator>>(_Bool& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(short& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			long _Tmp = 0;
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }

			if (_State & ios_base::failbit
				|| _Tmp < (-32768) || 32767 < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = (short)_Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}










	_Myt&  operator>>(unsigned short& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(int& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			long _Tmp = 0;
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }

			if (_State & ios_base::failbit
				|| _Tmp < (-2147483647 - 1) || 2147483647 < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = _Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned int& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(long& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned long& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

 
	_Myt&  operator>>(__int64& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned __int64& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}
 #line 405 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\istream"

	_Myt&  operator>>(float& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(double& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(long double& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(void *& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(_Mysb *_Strbuf)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					try {
						if (_Traits::eq_int_type(_Traits::eof(),
							_Strbuf->sputc(_Traits::to_char_type(_Meta))))
							break;
					} catch (...) {
						break;
					}
					_Copied = true;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(!_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	int_type  get()
		{	
		int_type _Meta = 0;
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	
		else
			{	
			try {
			_Meta = _Myios::rdbuf()->sgetc();

			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				_State |= ios_base::eofbit | ios_base::failbit;	
			else
				{	
				_Myios::rdbuf()->sbumpc();
				++_Chcount;
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	_Myt&  get(_Elem *_Str, streamsize _Count)
		{	
		return (get(_Str, _Count, _Myios::widen('\n')));
		}

	_Myt&  get(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	
		;
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Traits::to_char_type(_Meta) == _Delim)
					break;	
				else
					{	
					*_Str++ = _Traits::to_char_type(_Meta);
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_Chcount == 0
			? _State | ios_base::failbit : _State);
		*_Str = _Elem();	
		return (*this);
		}

	_Myt&  get(_Elem& _Ch)
		{	
		int_type _Meta = get();
		if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
			_Ch = _Traits::to_char_type(_Meta);
		return (*this);
		}

	_Myt&  get(_Mysb& _Strbuf)
		{	
		return (get(_Strbuf, _Myios::widen('\n')));
		}

	_Myt&  get(_Mysb& _Strbuf, _Elem _Delim)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					try {
						_Elem _Ch = _Traits::to_char_type(_Meta);
						if (_Ch == _Delim
							|| _Traits::eq_int_type(_Traits::eof(),
								_Strbuf.sputc(_Ch)))
							break;
					} catch (...) {
						break;
					}
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		if (_Chcount == 0)
			_State |= ios_base::failbit;
		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  getline(_Elem *_Str, streamsize _Count)
		{	
		return (getline(_Str, _Count, _Myios::widen('\n')));
		}

	_Myt&  getline(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	
		;
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			int_type _Metadelim = _Traits::to_int_type(_Delim);

			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Meta == _Metadelim)
					{	
					++_Chcount;
					_Myios::rdbuf()->sbumpc();
					break;
					}
				else if (--_Count <= 0)
					{	
					_State |= ios_base::failbit;
					break;
					}
				else
					{	
					++_Chcount;
					*_Str++ = _Traits::to_char_type(_Meta);
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		*_Str = _Elem();	
		_Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
		return (*this);
		}

	_Myt&  ignore(streamsize _Count = 1,
		int_type _Metadelim = _Traits::eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			for (; ; )
				{	
				int_type _Meta;
				if (_Count != 2147483647 && --_Count < 0)
					break;	
				else if (_Traits::eq_int_type(_Traits::eof(),
					_Meta = _Myios::rdbuf()->sbumpc()))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					++_Chcount;
					if (_Meta == _Metadelim)
						break;	
					}
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  read(_Elem *_Str, streamsize _Count)
		{	
		;
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
			_Chcount += _Num;
			if (_Num != _Count)
				_State |= ios_base::eofbit | ios_base::failbit;	
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	streamsize  readsome(_Elem *_Str,
		streamsize _Count)
		{	
		;
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		streamsize _Num;

		if (!_Ok)
			_State |= ios_base::failbit;	
		else if ((_Num = _Myios::rdbuf()->in_avail()) < 0)
			_State |= ios_base::eofbit;	
		else if (0 < _Num)
			read(_Str, _Num < _Count ? _Num : _Count);	

		_Myios::setstate(_State);
		return (gcount());
		}

	int_type  peek()
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		int_type _Meta = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	
		else
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Meta = _Myios::rdbuf()->sgetc()))
				_State |= ios_base::eofbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	_Myt&  putback(_Elem _Ch)
		{	
		_Chcount = 0;
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputbackc(_Ch)))
				_State |= ios_base::badbit | _Oldstate;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  unget()
		{	
		_Chcount = 0;
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sungetc()))
				_State |= ios_base::badbit | _Oldstate;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	streamsize  gcount() const
		{	
		return (_Chcount);
		}

	int  sync()
		{	
		const sentry _Ok(*this, true);

		if (_Myios::rdbuf() == 0)
			return (-1);
		else if (_Myios::rdbuf()->pubsync() == -1)
			{	
			_Myios::setstate(ios_base::badbit);
			return (-1);
			}
		else
			return (0);
		}

	_Myt&  seekg(pos_type _Pos)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::in) == _BADOFF)
			_Myios::setstate(_State | ios_base::failbit);
		return (*this);
		}

	_Myt&  seekg(off_type _Off, ios_base::seekdir _Way)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::in) == _BADOFF)
			_Myios::setstate(_State | ios_base::failbit);
		return (*this);
		}

	pos_type  tellg()
		{	
		const sentry _Ok(*this, true);

		if (!this->fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::in));
		else
			return (pos_type(_BADOFF));
		}

private:
	streamsize _Chcount;	
	};

	

  






















 

template class __declspec(dllimport) basic_istream<char, char_traits<char> >;
template class __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t> >;

 #line 919 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\istream"

		
template<class _Elem,
	class _Traits>
	class basic_iostream
	: public basic_istream<_Elem, _Traits>,
		public basic_ostream<_Elem, _Traits>
	{	
public:
	typedef basic_iostream<_Elem, _Traits> _Myt;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit  basic_iostream(basic_streambuf<_Elem, _Traits> *_Strbuf)
		: _Myis(_Strbuf, false),
			_Myos(_Noinit, false)
		{	
		}

protected:
	 basic_iostream(_Myt&& _Right)
		: _Myis(_Right.rdbuf(), false),
			_Myos(_Noinit, false)
		{	
		_Myios::init();
		_Myios::move(::std:: forward<_Myt>(_Right));
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			_Myios::swap(_Right);
		}

private:
		 basic_iostream(const _Myt& _Right);	
		_Myt&  operator=(const _Myt&);	
public:
	virtual  ~basic_iostream() throw ()
		{	
		}
	};

	

 

template class __declspec(dllimport) basic_iostream<char, char_traits<char> >;
template class __declspec(dllimport) basic_iostream<wchar_t, char_traits<wchar_t> >;

 #line 982 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\istream"

		

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem *_Str)
	{	
	;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;
	ios_base::iostate _State = ios_base::goodbit;
	_Elem *_Str0 = _Str;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

		try {
		streamsize _Count = 0 < _Istr.width() ? _Istr.width() : 2147483647;
		typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
		_Elem _Ch;
		for (; 0 < --_Count; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Ch = _Traits::to_char_type(_Meta))
					|| _Ch == _Elem())
				break;	
			else
				*_Str++ = _Traits::to_char_type(_Meta);	
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	*_Str = _Elem();	
	_Istr.width(0);
	_Istr.setstate(_Str == _Str0 ? _State | ios_base::failbit : _State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;

	typename _Myis::int_type _Meta;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		try {
		_Meta = _Istr.rdbuf()->sbumpc();
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			_State |= ios_base::eofbit | ios_base::failbit;	
		else
			_Ch = _Traits::to_char_type(_Meta);	
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, signed char *_Str)
	{	
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, signed char& _Ch)
	{	
	return (_Istr >> (char&)_Ch);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char *_Str)
	{	
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char& _Ch)
	{	
	return (_Istr >> (char&)_Ch);
	}

template<class _Elem,
	class _Traits,
	class _Ty> inline
	basic_istream<_Elem, _Traits>&
		operator>>(basic_istream<_Elem, _Traits>&& _Istr, _Ty& _Val)
	{	
	return (_Istr >> _Val);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>&
		__cdecl ws(basic_istream<_Elem, _Traits>& _Istr)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;

	if (!_Istr.eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const typename _Myis::sentry _Ok(_Istr, true);

		if (_Ok)
			{	
			const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

			try {
			for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
				_Meta = _Istr.rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (!_Ctype_fac.is(_Ctype::space,
					_Traits::to_char_type(_Meta)))
					break;	
			} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
			}

		_Istr.setstate(_State);
		}
	return (_Istr);
	}

__declspec(dllimport) inline basic_istream<char, char_traits<char> >&
	__cdecl ws(basic_istream<char, char_traits<char> >& _Istr)
	{	
	typedef char _Elem;
	typedef char_traits<_Elem> _Traits;

	if (!_Istr.eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

		if (_Ok)
			{	
			const ctype<_Elem>& _Ctype_fac =
				use_facet< ctype<_Elem> >(_Istr.getloc());

			try {
			for (_Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
				_Meta = _Istr.rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (!_Ctype_fac.is(ctype<_Elem>::space,
					_Traits::to_char_type(_Meta)))
					break;	
			} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
			}

		_Istr.setstate(_State);
		}
	return (_Istr);
	}

__declspec(dllimport) inline basic_istream<wchar_t, char_traits<wchar_t> >&
	__cdecl ws(basic_istream<wchar_t, char_traits<wchar_t> >& _Istr)
	{	
	typedef wchar_t _Elem;
	typedef char_traits<_Elem> _Traits;

	if (!_Istr.eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

		if (_Ok)
			{	
			const ctype<_Elem>& _Ctype_fac =
				use_facet< ctype<_Elem> >(_Istr.getloc());

			try {
			for (_Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
				_Meta = _Istr.rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (!_Ctype_fac.is(ctype<_Elem>::space,
					_Traits::to_char_type(_Meta)))
					break;	
			} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
			}

		_Istr.setstate(_State);
		}
	return (_Istr);
	}

 
__declspec(dllimport) inline basic_istream<unsigned short, char_traits<unsigned short> >&
	__cdecl ws(basic_istream<unsigned short, char_traits<unsigned short> >& _Istr)
	{	
	typedef unsigned short _Elem;
	typedef char_traits<_Elem> _Traits;

	if (!_Istr.eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

		if (_Ok)
			{	
			const ctype<_Elem>& _Ctype_fac =
				use_facet< ctype<_Elem> >(_Istr.getloc());

			try {
			for (_Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
				_Meta = _Istr.rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (!_Ctype_fac.is(ctype<_Elem>::space,
					_Traits::to_char_type(_Meta)))
					break;	
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
			}

		_Istr.setstate(_State);
		}
	return (_Istr);
	}
 #line 1232 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\istream"
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1238 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\istream"
#line 1239 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\istream"






#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iterator"


 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		
template<class _Container>
	class back_insert_iterator
		: public _Outit
	{	
public:
	typedef back_insert_iterator<_Container> _Myt;
	typedef _Container container_type;
	typedef typename _Container::const_reference const_reference;
	typedef typename _Container::value_type _Valty;

	explicit back_insert_iterator(_Container& _Cont)
		: container(&_Cont)
		{	
		}

	_Myt& operator=(const _Valty& _Val)
		{	
		container->push_back(_Val);
		return (*this);
		}

	_Myt& operator=(_Valty&& _Val)
		{	
		container->push_back(::std:: forward<_Valty>(_Val));
		return (*this);
		}

	_Myt& operator*()
		{	
		return (*this);
		}

	_Myt& operator++()
		{	
		return (*this);
		}

	_Myt operator++(int)
		{	
		return (*this);
		}

protected:
	_Container *container;	
	};

template<class _Container>
	struct _Is_checked_helper<back_insert_iterator<_Container> >
		: public true_type
	{	
	};

		
template<class _Container> inline
	back_insert_iterator<_Container> back_inserter(_Container& _Cont)
	{	
	return (::std:: back_insert_iterator<_Container>(_Cont));
	}

		
template<class _Container>
	class front_insert_iterator
		: public _Outit
	{	
public:
	typedef front_insert_iterator<_Container> _Myt;
	typedef _Container container_type;
	typedef typename _Container::const_reference const_reference;
	typedef typename _Container::value_type _Valty;

	explicit front_insert_iterator(_Container& _Cont)
		: container(&_Cont)
		{	
		}

	_Myt& operator=(const _Valty& _Val)
		{	
		container->push_front(_Val);
		return (*this);
		}

	_Myt& operator=(_Valty&& _Val)
		{	
		container->push_front(::std:: forward<_Valty>(_Val));
		return (*this);
		}

	_Myt& operator*()
		{	
		return (*this);
		}

	_Myt& operator++()
		{	
		return (*this);
		}

	_Myt operator++(int)
		{	
		return (*this);
		}

protected:
	_Container *container;	
	};

template<class _Container>
	struct _Is_checked_helper<front_insert_iterator<_Container> >
		: public true_type
	{	
	};

		
template<class _Container> inline
	front_insert_iterator<_Container> front_inserter(_Container& _Cont)
	{	
	return (::std:: front_insert_iterator<_Container>(_Cont));
	}

		
template<class _Container>
	class insert_iterator
		: public _Outit
	{	
public:
	typedef insert_iterator<_Container> _Myt;
	typedef _Container container_type;
	typedef typename _Container::const_reference const_reference;
	typedef typename _Container::value_type _Valty;

	insert_iterator(_Container& _Cont, typename _Container::iterator _Where)
		: container(&_Cont), iter(_Where)
		{	
		}

	_Myt& operator=(const _Valty& _Val)
		{	
		iter = container->insert(iter, _Val);
		++iter;
		return (*this);
		}

	_Myt& operator=(_Valty&& _Val)
		{	
		iter = container->insert(iter, ::std:: forward<_Valty>(_Val));
		++iter;
		return (*this);
		}

	_Myt& operator*()
		{	
		return (*this);
		}

	_Myt& operator++()
		{	
		return (*this);
		}

	_Myt& operator++(int)
		{	
		return (*this);
		}

protected:
	_Container *container;	
	typename _Container::iterator iter;	
	};

template<class _Container>
	struct _Is_checked_helper<insert_iterator<_Container> >
		: public true_type
	{	
	};

		
template<class _Container> inline
	insert_iterator<_Container> inserter(_Container& _Cont,
		typename _Container::iterator _Where)
	{	
	return (::std:: insert_iterator<_Container>(_Cont, _Where));
	}

		

template<class _Ty,
	class _Elem = char,
	class _Traits = char_traits<_Elem>,
	class _Diff = ptrdiff_t>
	class istream_iterator
		: public iterator<input_iterator_tag, _Ty, _Diff,
			const _Ty *, const _Ty&>
	{	
	typedef istream_iterator<_Ty, _Elem, _Traits, _Diff> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_istream<_Elem, _Traits> istream_type;

	typedef const _Ty *pointer;

	istream_iterator()
		: _Myistr(0)
		{	
		}

	istream_iterator(istream_type& _Istr)
		: _Myistr(&_Istr)
		{	
		_Getval();
		}

	const _Ty& operator*() const
		{	
		return (_Myval);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
		_Getval();
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	bool _Equal(const _Myt& _Right) const
		{	
		return (_Myistr == _Right._Myistr);
		}

protected:
	void _Getval()
		{	
		if (_Myistr != 0 && !(*_Myistr >> _Myval))
			_Myistr = 0;
		}

	istream_type *_Myistr;	
	_Ty _Myval;	
	};

template<class _Ty,
	class _Elem,
	class _Traits,
	class _Diff>
	struct _Is_checked_helper<istream_iterator<_Ty, _Elem, _Traits, _Diff> >
		: public true_type
	{	
	};

		
template<class _Ty,
	class _Elem,
	class _Traits,
	class _Diff> inline
	bool operator==(
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
	{	
	return (_Left._Equal(_Right));
	}

template<class _Ty,
	class _Elem,
	class _Traits,
	class _Diff> inline
	bool operator!=(
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
	{	
	return (!(_Left == _Right));
	}

		

template<class _Ty,
	class _Elem = char,
	class _Traits = char_traits<_Elem> >
	class ostream_iterator
		: public _Outit
	{	
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_ostream<_Elem, _Traits> ostream_type;

	ostream_iterator(ostream_type& _Ostr,
		const _Elem *_Delim = 0)
		: _Myostr(&_Ostr), _Mydelim(_Delim)
		{	
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator=(const _Ty& _Val)
		{	
		*_Myostr << _Val;
		if (_Mydelim != 0)
			*_Myostr << _Mydelim;
		return (*this);
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator*()
		{	
		return (*this);
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator++()
		{	
		return (*this);
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator++(int)
		{	
		return (*this);
		}

protected:
	const _Elem *_Mydelim;	
	ostream_type *_Myostr;	
	};

template<class _Ty,
	class _Elem,
	class _Traits>
	struct _Is_checked_helper<ostream_iterator<_Ty, _Elem, _Traits> >
		: public true_type
	{	
	};
}

namespace stdext {
using ::std:: iterator_traits;
using ::std:: size_t;

		
template<class _Iterator>
	class checked_array_iterator
	{	
public:
	typedef checked_array_iterator<_Iterator> _Myt;

	typedef typename iterator_traits<_Iterator>::iterator_category
		iterator_category;
	typedef typename iterator_traits<_Iterator>::value_type
		value_type;
	typedef typename iterator_traits<_Iterator>::difference_type
		difference_type;
	typedef typename iterator_traits<_Iterator>::difference_type
		distance_type;	
	typedef typename iterator_traits<_Iterator>::pointer
		pointer;
	typedef typename iterator_traits<_Iterator>::reference
		reference;

	checked_array_iterator()
		: _Myarray(), _Mysize(0), _Myindex(0)
		{	
		}

	checked_array_iterator(_Iterator _Array, size_t _Size,
		size_t _Index = 0)
		: _Myarray(_Array), _Mysize(_Size), _Myindex(_Index)
		{	
		{ if (!(_Index <= _Size)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
		}

	_Iterator base() const
		{	
		return (_Myarray + _Myindex);
		}

	typedef _Iterator _Unchecked_type;

	_Myt& _Rechecked(_Unchecked_type _Right)
		{	
		_Myindex = _Right - _Myarray;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (base());
		}

	reference operator*() const
		{	
		{ if (!(_Myarray != 0 && _Myindex < _Mysize)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
#line 413 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iterator"
		return (_Myarray[_Myindex]);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
		{ if (!(_Myarray != 0 && _Myindex < _Mysize)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
#line 425 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iterator"
		++_Myindex;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		{ if (!(_Myarray != 0 && 0 < _Myindex)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
#line 440 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iterator"
		--_Myindex;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myt& operator+=(difference_type _Off)
		{	
		{ if (!(_Myarray != 0 && _Myindex + _Off <= _Mysize)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
#line 455 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iterator"
		_Myindex += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myt operator-(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myt& _Right) const
		{	
		{ if (!(_Myarray == _Right._Myarray)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
		return (_Myindex - _Right._Myindex);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myt& _Right) const
		{	
		{ if (!(_Myarray == _Right._Myarray)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
		return (_Myindex == _Right._Myindex);
		}

	bool operator!=(const _Myt& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myt& _Right) const
		{	
		{ if (!(_Myarray == _Right._Myarray)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
		return (_Myindex < _Right._Myindex);
		}

	bool operator>(const _Myt& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myt& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myt& _Right) const
		{	
		return (!(*this < _Right));
		}

private:
	_Iterator _Myarray;	
	size_t _Mysize;	
	size_t _Myindex;	
	};

template<class _Iterator> inline
	typename checked_array_iterator<_Iterator>::_Unchecked_type
		_Unchecked(checked_array_iterator<_Iterator> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Iterator> inline
	checked_array_iterator<_Iterator>&
		_Rechecked(checked_array_iterator<_Iterator>& _Iter,
			typename checked_array_iterator<_Iterator>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Iterator> inline
	checked_array_iterator<_Iterator> operator+(
		typename checked_array_iterator<_Iterator>::difference_type _Off,
		checked_array_iterator<_Iterator> _Next)
	{	
	return (_Next += _Off);
	}

template<class _Iterator> inline
	checked_array_iterator<_Iterator> make_checked_array_iterator(
		_Iterator _Array, size_t _Size, size_t _Index = 0)
	{	
	return (checked_array_iterator<_Iterator>(_Array, _Size, _Index));
	}

		
template<class _Iterator>
	class unchecked_array_iterator
	{	
public:
	typedef unchecked_array_iterator<_Iterator> _Myt;

	typedef typename iterator_traits<_Iterator>::iterator_category
		iterator_category;
	typedef typename iterator_traits<_Iterator>::value_type
		value_type;
	typedef typename iterator_traits<_Iterator>::difference_type
		difference_type;
	typedef typename iterator_traits<_Iterator>::difference_type
		distance_type;	
	typedef typename iterator_traits<_Iterator>::pointer
		pointer;
	typedef typename iterator_traits<_Iterator>::reference
		reference;

	unchecked_array_iterator()
		: _Myptr()
		{	
		}

	explicit unchecked_array_iterator(_Iterator _Ptr)
		: _Myptr(_Ptr)
		{	
		}

	_Iterator base() const
		{	
		return (_Myptr);
		}

	typedef _Iterator _Unchecked_type;

	_Myt& _Rechecked(_Unchecked_type _Right)
		{	
		_Myptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (base());
		}

	reference operator*() const
		{	
		return (*_Myptr);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
		++_Myptr;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		--_Myptr;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myt& operator+=(difference_type _Off)
		{	
		_Myptr += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myt operator-(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myt& _Right) const
		{	
		return (_Myptr - _Right._Myptr);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myt& _Right) const
		{	
		return (_Myptr == _Right._Myptr);
		}

	bool operator!=(const _Myt& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myt& _Right) const
		{	
		return (_Myptr < _Right._Myptr);
		}

	bool operator>(const _Myt& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myt& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myt& _Right) const
		{	
		return (!(*this < _Right));
		}

private:
	_Iterator _Myptr;	
	};

template<class _Iterator> inline
	typename unchecked_array_iterator<_Iterator>::_Unchecked_type
		_Unchecked(unchecked_array_iterator<_Iterator> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Iterator> inline
	unchecked_array_iterator<_Iterator>&
		_Rechecked(unchecked_array_iterator<_Iterator>& _Iter,
			typename unchecked_array_iterator<_Iterator>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Iterator> inline
	unchecked_array_iterator<_Iterator> operator+(
		typename unchecked_array_iterator<_Iterator>::difference_type _Off,
		unchecked_array_iterator<_Iterator> _Next)
	{	
	return (_Next += _Off);
	}

template<class _Iterator> inline
	unchecked_array_iterator<_Iterator> make_unchecked_array_iterator(
		_Iterator _Ptr)
	{	
	return (unchecked_array_iterator<_Iterator>(_Ptr));
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 743 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iterator"
#line 744 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iterator"






















#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189)
 #pragma warning(disable: 4172)

namespace std {
		
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem *_Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Traits::length(_Left) + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(1 + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + _Traits::length(_Right));
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + 1);
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (::std:: move(_Left.append(_Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	if (_Right.size() <= _Left.capacity() - _Left.size()
		|| _Right.capacity() - _Right.size() < _Left.size())
		return (::std:: move(_Left.append(_Right)));
	else
		return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem *_Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	return (::std:: move(_Right.insert(0, 1, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const _Elem *_Right)
	{	
	return (::std:: move(_Left.append(_Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const _Elem _Right)
	{	
	return (::std:: move(_Left.append(1, _Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Left.compare(_Right) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right.compare(_Left) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Left.compare(_Right) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const _Elem *_Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right.compare(_Left) > 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Left < _Right));
	}

		
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	typedef ctype<_Elem> _Ctype;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());
		_Str.erase();

		try {
		_Mysizt _Size = 0 < _Istr.width()
			&& (_Mysizt)_Istr.width() < _Str.max_size()
				? (_Mysizt)_Istr.width() : _Str.max_size();
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())
			if(_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Traits::to_char_type(_Meta)))
				break;	
			else
				{	
				_Str.append(1, _Traits::to_char_type(_Meta));
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.width(0);
	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str,
		const _Elem _Delim)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr, true);

	if (_Ok)
		{	
		try {
		_Str.erase();
		const typename _Traits::int_type _Metadelim =
			_Traits::to_int_type(_Delim);
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; ; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Traits::eq_int_type(_Meta, _Metadelim))
				{	
				_Changed = true;
				_Istr.rdbuf()->sbumpc();
				break;
				}
			else if (_Str.max_size() <= _Str.size())
				{	
				_State |= ios_base::failbit;
				break;
				}
			else
				{	
				_Str += _Traits::to_char_type(_Meta);
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (getline(_Istr, _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (::std:: move(_Istr) >> _Str);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str,
		const _Elem _Delim)
	{	
	return (getline(::std:: move(_Istr), _Str, _Delim));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (getline(::std:: move(_Istr), _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr,
		const basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	_Mysizt _Size = _Str.size();
	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
		? 0 : (_Mysizt)_Ostr.width() - _Size;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
	try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Str.c_str(), (streamsize)_Size)
				!= (streamsize)_Size)
				_State |= ios_base::badbit;
		else
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

 
		











inline int stoi(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoi argument");
	if ((*_errno()) == 34 || _Ans < (-2147483647 - 1) != 2147483647 < _Ans)
		_Xout_of_range("stoi argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return ((int)_Ans);
	}

inline long stol(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stol argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stol argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long stoul(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	unsigned long _Ans = :: strtoul(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoul argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoul argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline _Longlong stoll(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	_Longlong _Ans = :: _strtoi64(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoll argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoll argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline _ULonglong stoull(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	(*_errno()) = 0;
	char *_Eptr;
	_ULonglong _Ans = :: _strtoui64(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoull argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoull argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline float stof(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	(*_errno()) = 0;
	char *_Eptr;
	float _Ans = (float):: strtod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stof argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stof argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline double stod(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	(*_errno()) = 0;
	char *_Eptr;
	double _Ans = :: strtod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stod argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stod argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long double stold(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	(*_errno()) = 0;
	char *_Eptr;
	long double _Ans = :: strtod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stold argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stold argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

		
inline int stoi(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoi argument");
	if ((*_errno()) == 34 || _Ans < (-2147483647 - 1) != 2147483647 < _Ans)
		_Xout_of_range("stoi argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return ((int)_Ans);
	}

inline long stol(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stol argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stol argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long stoul(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	unsigned long _Ans = :: wcstoul(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoul argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoul argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline _Longlong stoll(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	_Longlong _Ans = :: _wcstoi64(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoll argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoll argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline _ULonglong stoull(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	(*_errno()) = 0;
	wchar_t *_Eptr;
	_ULonglong _Ans = :: _wcstoui64(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoull argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoull argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline float stof(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	(*_errno()) = 0;
	wchar_t *_Eptr;
	float _Ans = (float):: wcstod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stof argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stof argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline double stod(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	(*_errno()) = 0;
	wchar_t *_Eptr;
	double _Ans = :: wcstod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stod argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stod argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long double stold(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	(*_errno()) = 0;
	wchar_t *_Eptr;
	long double _Ans = :: wcstod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stold argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stold argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

		

 

 


inline string to_string(int _Val)
	{	
	char _Buf[2 * 32];

	:: sprintf_s(_Buf, sizeof (_Buf), "%d", _Val);
	return (string(_Buf));
	}

inline string to_string(unsigned int _Val)
	{	
	char _Buf[2 * 32];

	:: sprintf_s(_Buf, sizeof (_Buf), "%u", _Val);
	return (string(_Buf));
	}

inline string to_string(long _Val)
	{	
	char _Buf[2 * 32];

	:: sprintf_s(_Buf, sizeof (_Buf), "%ld", _Val);
	return (string(_Buf));
	}

inline string to_string(unsigned long _Val)
	{	
	char _Buf[2 * 32];

	:: sprintf_s(_Buf, sizeof (_Buf), "%lu", _Val);
	return (string(_Buf));
	}

inline string to_string(_Longlong _Val)
	{	
	char _Buf[2 * 32];

	:: sprintf_s(_Buf, sizeof (_Buf), "%I64" "d", _Val);
	return (string(_Buf));
	}

inline string to_string(_ULonglong _Val)
	{	
	char _Buf[2 * 32];

	:: sprintf_s(_Buf, sizeof (_Buf), "%I64" "u", _Val);
	return (string(_Buf));
	}

inline string to_string(long double _Val)
	{	
	typedef back_insert_iterator<string> _Iter;
	typedef num_put<char, _Iter> _Nput;
	const _Nput& _Nput_fac = use_facet<_Nput>(locale());
	ostream _Ios((streambuf *)0);
	string _Str;

	_Ios.setf(ios_base::fixed);
	_Nput_fac.put(_Iter(_Str), _Ios, ' ', _Val);
	return (_Str);
	}

inline string to_string(double _Val)
	{	
	return (to_string((long double)_Val));
	}

inline string to_string(float _Val)
	{	
	return (to_string((long double)_Val));
	}

		

 

 


inline wstring to_wstring(int _Val)
	{	
	wchar_t _Buf[2 * 32];

	:: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%d", _Val);
	return (wstring(_Buf));
	}

inline wstring to_wstring(unsigned int _Val)
	{	
	wchar_t _Buf[2 * 32];

	:: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%u", _Val);
	return (wstring(_Buf));
	}

inline wstring to_wstring(long _Val)
	{	
	wchar_t _Buf[2 * 32];

	:: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%ld", _Val);
	return (wstring(_Buf));
	}

inline wstring to_wstring(unsigned long _Val)
	{	
	wchar_t _Buf[2 * 32];

	:: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%lu", _Val);
	return (wstring(_Buf));
	}

inline wstring to_wstring(_Longlong _Val)
	{	
	wchar_t _Buf[2 * 32];

	:: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%I64" L"d", _Val);
	return (wstring(_Buf));
	}

inline wstring to_wstring(_ULonglong _Val)
	{	
	wchar_t _Buf[2 * 32];

	:: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%I64" L"u", _Val);
	return (wstring(_Buf));
	}

inline wstring to_wstring(long double _Val)
	{	
	typedef back_insert_iterator<wstring> _Iter;
	typedef num_put<wchar_t, _Iter> _Nput;
	const _Nput& _Nput_fac = use_facet<_Nput>(locale());
	ostream _Ios((streambuf *)0);
	wstring _Str;

	_Ios.setf(ios_base::fixed);
	_Nput_fac.put(_Iter(_Str), _Ios, L' ', _Val);
	return (_Str);
	}

inline wstring to_wstring(double _Val)
	{	
	return (to_wstring((long double)_Val));
	}

inline wstring to_wstring(float _Val)
	{	
	return (to_wstring((long double)_Val));
	}

	
template<class _Elem,
	class _Traits,
	class _Alloc>
	struct hash<basic_string<_Elem, _Traits, _Alloc> >
		: public unary_function<basic_string<_Elem, _Traits, _Alloc>, size_t>
	{	
	typedef basic_string<_Elem, _Traits, _Alloc> _Kty;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Hash_seq((const unsigned char *)_Keyval.c_str(),
			_Keyval.size() * sizeof (_Elem)));
		}
	};
 #line 991 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string"
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 997 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string"
#line 998 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\string"





#line 57 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvstd.hpp"







namespace cv
{
    static inline uchar abs(uchar a) { return a; }
    static inline ushort abs(ushort a) { return a; }
    static inline unsigned abs(unsigned a) { return a; }
    static inline uint64 abs(uint64 a) { return a; }

    using std::min;
    using std::max;
    using std::abs;
    using std::swap;
    using std::sqrt;
    using std::exp;
    using std::pow;
    using std::log;
}

namespace cv {












 void* fastMalloc(size_t bufSize);








 void fastFree(void* ptr);




template<typename _Tp> class Allocator
{
public:
    typedef _Tp value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    template<typename U> class rebind { typedef Allocator<U> other; };

    explicit Allocator() {}
    ~Allocator() {}
    explicit Allocator(Allocator const&) {}
    template<typename U>
    explicit Allocator(Allocator<U> const&) {}

    
    pointer address(reference r) { return &r; }
    const_pointer address(const_reference r) { return &r; }

    pointer allocate(size_type count, const void* =0) { return reinterpret_cast<pointer>(fastMalloc(count * sizeof (_Tp))); }
    void deallocate(pointer p, size_type) { fastFree(p); }

    void construct(pointer p, const _Tp& v) { new(static_cast<void*>(p)) _Tp(v); }
    void destroy(pointer p) { p->~_Tp(); }

    size_type max_size() const { return cv::max(static_cast<_Tp>(-1)/sizeof(_Tp), 1); }
};





namespace detail
{


template<typename T>
struct RefOrVoid { typedef T& type; };

template<>
struct RefOrVoid<void>{ typedef void type; };

template<>
struct RefOrVoid<const void>{ typedef const void type; };

template<>
struct RefOrVoid<volatile void>{ typedef volatile void type; };

template<>
struct RefOrVoid<const volatile void>{ typedef const volatile void type; };


struct PtrOwner;

}

template<typename Y>
struct DefaultDeleter
{
    void operator () (Y* p) const;
};
























































































template<typename T>
struct Ptr
{
    
    typedef T element_type;

    

    Ptr();

    












    template<typename Y>



    Ptr(Y* p);

    



    template<typename Y, typename D>
    Ptr(Y* p, D d);

    












    Ptr(const Ptr& o);

    


    template<typename Y>
    Ptr(const Ptr<Y>& o);

    



    template<typename Y>
    Ptr(const Ptr<Y>& o, T* p);

    
    ~Ptr();

    




    Ptr& operator = (const Ptr& o);

    
    template<typename Y>
    Ptr& operator = (const Ptr<Y>& o);

    


    void release();

    



    template<typename Y>
    void reset(Y* p);

    



    template<typename Y, typename D>
    void reset(Y* p, D d);

    



    void swap(Ptr& o);

    
    T* get() const;

    
    typename detail::RefOrVoid<T>::type operator * () const;

    
    T* operator -> () const;

    
    operator T* () const;

    
    bool empty() const;

    


    template<typename Y>
    Ptr<Y> staticCast() const;

    
    template<typename Y>
    Ptr<Y> constCast() const;

    
    template<typename Y>
    Ptr<Y> dynamicCast() const;


    Ptr(Ptr&& o);
    Ptr& operator = (Ptr&& o);
#line 396 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvstd.hpp"

private:
    detail::PtrOwner* owner;
    T* stored;

    template<typename Y>
    friend struct Ptr; 
};


template<typename T>
void swap(Ptr<T>& ptr1, Ptr<T>& ptr2);


template<typename T>
bool operator == (const Ptr<T>& ptr1, const Ptr<T>& ptr2);
template<typename T>
bool operator != (const Ptr<T>& ptr1, const Ptr<T>& ptr2);







template<typename T>
Ptr<T> makePtr();

template<typename T, typename A1>
Ptr<T> makePtr(const A1& a1);

template<typename T, typename A1, typename A2>
Ptr<T> makePtr(const A1& a1, const A2& a2);

template<typename T, typename A1, typename A2, typename A3>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3);

template<typename T, typename A1, typename A2, typename A3, typename A4>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3, const A4& a4);

template<typename T, typename A1, typename A2, typename A3, typename A4, typename A5>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5);

template<typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6);

template<typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7);

template<typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8);

template<typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9);

template<typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10);



class  FileNode; 

class  String
{
public:
    typedef char value_type;
    typedef char& reference;
    typedef const char& const_reference;
    typedef char* pointer;
    typedef const char* const_pointer;
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef char* iterator;
    typedef const char* const_iterator;

    static const size_t npos = size_t(-1);

    String();
    String(const String& str);
    String(const String& str, size_t pos, size_t len = npos);
    String(const char* s);
    String(const char* s, size_t n);
    String(size_t n, char c);
    String(const char* first, const char* last);
    template<typename Iterator> String(Iterator first, Iterator last);
    explicit String(const FileNode& fn);
    ~String();

    String& operator=(const String& str);
    String& operator=(const char* s);
    String& operator=(char c);

    String& operator+=(const String& str);
    String& operator+=(const char* s);
    String& operator+=(char c);

    size_t size() const;
    size_t length() const;

    char operator[](size_t idx) const;
    char operator[](int idx) const;

    const char* begin() const;
    const char* end() const;

    const char* c_str() const;

    bool empty() const;
    void clear();

    int compare(const char* s) const;
    int compare(const String& str) const;

    void swap(String& str);
    String substr(size_t pos = 0, size_t len = npos) const;

    size_t find(const char* s, size_t pos, size_t n) const;
    size_t find(char c, size_t pos = 0) const;
    size_t find(const String& str, size_t pos = 0) const;
    size_t find(const char* s, size_t pos = 0) const;

    size_t rfind(const char* s, size_t pos, size_t n) const;
    size_t rfind(char c, size_t pos = npos) const;
    size_t rfind(const String& str, size_t pos = npos) const;
    size_t rfind(const char* s, size_t pos = npos) const;

    size_t find_first_of(const char* s, size_t pos, size_t n) const;
    size_t find_first_of(char c, size_t pos = 0) const;
    size_t find_first_of(const String& str, size_t pos = 0) const;
    size_t find_first_of(const char* s, size_t pos = 0) const;

    size_t find_last_of(const char* s, size_t pos, size_t n) const;
    size_t find_last_of(char c, size_t pos = npos) const;
    size_t find_last_of(const String& str, size_t pos = npos) const;
    size_t find_last_of(const char* s, size_t pos = npos) const;

    friend String operator+ (const String& lhs, const String& rhs);
    friend String operator+ (const String& lhs, const char*   rhs);
    friend String operator+ (const char*   lhs, const String& rhs);
    friend String operator+ (const String& lhs, char          rhs);
    friend String operator+ (char          lhs, const String& rhs);

    String toLowerCase() const;

    String(const std::string& str);
    String(const std::string& str, size_t pos, size_t len = npos);
    String& operator=(const std::string& str);
    String& operator+=(const std::string& str);
    operator std::string() const;

    friend String operator+ (const String& lhs, const std::string& rhs);
    friend String operator+ (const std::string& lhs, const String& rhs);

private:
    char*  cstr_;
    size_t len_;

    char* allocate(size_t len); 
    void deallocate();

    String(int); 
};







inline
String::String()
    : cstr_(0), len_(0)
{}

inline
String::String(const String& str)
    : cstr_(str.cstr_), len_(str.len_)
{
    if (cstr_)
        (int)_InterlockedExchangeAdd((long volatile*)((int*)cstr_)-1, 1);
}

inline
String::String(const String& str, size_t pos, size_t len)
    : cstr_(0), len_(0)
{
    pos = min(pos, str.len_);
    len = min(str.len_ - pos, len);
    if (!len) return;
    if (len == str.len_)
    {
        (int)_InterlockedExchangeAdd((long volatile*)((int*)str.cstr_)-1, 1);
        cstr_ = str.cstr_;
        len_ = str.len_;
        return;
    }
    memcpy(allocate(len), str.cstr_ + pos, len);
}

inline
String::String(const char* s)
    : cstr_(0), len_(0)
{
    if (!s) return;
    size_t len = strlen(s);
    memcpy(allocate(len), s, len);
}

inline
String::String(const char* s, size_t n)
    : cstr_(0), len_(0)
{
    if (!n) return;
    if (!s) return;
    memcpy(allocate(n), s, n);
}

inline
String::String(size_t n, char c)
    : cstr_(0), len_(0)
{
    if (!n) return;
    memset(allocate(n), c, n);
}

inline
String::String(const char* first, const char* last)
    : cstr_(0), len_(0)
{
    size_t len = (size_t)(last - first);
    if (!len) return;
    memcpy(allocate(len), first, len);
}

template<typename Iterator> inline
String::String(Iterator first, Iterator last)
    : cstr_(0), len_(0)
{
    size_t len = (size_t)(last - first);
    if (!len) return;
    char* str = allocate(len);
    while (first != last)
    {
        *str++ = *first;
        ++first;
    }
}

inline
String::~String()
{
    deallocate();
}

inline
String& String::operator=(const String& str)
{
    if (&str == this) return *this;

    deallocate();
    if (str.cstr_) (int)_InterlockedExchangeAdd((long volatile*)((int*)str.cstr_)-1, 1);
    cstr_ = str.cstr_;
    len_ = str.len_;
    return *this;
}

inline
String& String::operator=(const char* s)
{
    deallocate();
    if (!s) return *this;
    size_t len = strlen(s);
    memcpy(allocate(len), s, len);
    return *this;
}

inline
String& String::operator=(char c)
{
    deallocate();
    allocate(1)[0] = c;
    return *this;
}

inline
String& String::operator+=(const String& str)
{
    *this = *this + str;
    return *this;
}

inline
String& String::operator+=(const char* s)
{
    *this = *this + s;
    return *this;
}

inline
String& String::operator+=(char c)
{
    *this = *this + c;
    return *this;
}

inline
size_t String::size() const
{
    return len_;
}

inline
size_t String::length() const
{
    return len_;
}

inline
char String::operator[](size_t idx) const
{
    return cstr_[idx];
}

inline
char String::operator[](int idx) const
{
    return cstr_[idx];
}

inline
const char* String::begin() const
{
    return cstr_;
}

inline
const char* String::end() const
{
    return len_ ? cstr_ + len_ : 0;
}

inline
bool String::empty() const
{
    return len_ == 0;
}

inline
const char* String::c_str() const
{
    return cstr_ ? cstr_ : "";
}

inline
void String::swap(String& str)
{
    cv::swap(cstr_, str.cstr_);
    cv::swap(len_, str.len_);
}

inline
void String::clear()
{
    deallocate();
}

inline
int String::compare(const char* s) const
{
    if (cstr_ == s) return 0;
    return strcmp(c_str(), s);
}

inline
int String::compare(const String& str) const
{
    if (cstr_ == str.cstr_) return 0;
    return strcmp(c_str(), str.c_str());
}

inline
String String::substr(size_t pos, size_t len) const
{
    return String(*this, pos, len);
}

inline
size_t String::find(const char* s, size_t pos, size_t n) const
{
    if (n == 0 || pos + n > len_) return npos;
    const char* lmax = cstr_ + len_ - n;
    for (const char* i = cstr_ + pos; i <= lmax; ++i)
    {
        size_t j = 0;
        while (j < n && s[j] == i[j]) ++j;
        if (j == n) return (size_t)(i - cstr_);
    }
    return npos;
}

inline
size_t String::find(char c, size_t pos) const
{
    return find(&c, pos, 1);
}

inline
size_t String::find(const String& str, size_t pos) const
{
    return find(str.c_str(), pos, str.len_);
}

inline
size_t String::find(const char* s, size_t pos) const
{
    if (pos >= len_ || !s[0]) return npos;
    const char* lmax = cstr_ + len_;
    for (const char* i = cstr_ + pos; i < lmax; ++i)
    {
        size_t j = 0;
        while (s[j] && s[j] == i[j])
        {   if(i + j >= lmax) return npos;
            ++j;
        }
        if (!s[j]) return (size_t)(i - cstr_);
    }
    return npos;
}

inline
size_t String::rfind(const char* s, size_t pos, size_t n) const
{
    if (n > len_) return npos;
    if (pos > len_ - n) pos = len_ - n;
    for (const char* i = cstr_ + pos; i >= cstr_; --i)
    {
        size_t j = 0;
        while (j < n && s[j] == i[j]) ++j;
        if (j == n) return (size_t)(i - cstr_);
    }
    return npos;
}

inline
size_t String::rfind(char c, size_t pos) const
{
    return rfind(&c, pos, 1);
}

inline
size_t String::rfind(const String& str, size_t pos) const
{
    return rfind(str.c_str(), pos, str.len_);
}

inline
size_t String::rfind(const char* s, size_t pos) const
{
    return rfind(s, pos, strlen(s));
}

inline
size_t String::find_first_of(const char* s, size_t pos, size_t n) const
{
    if (n == 0 || pos + n > len_) return npos;
    const char* lmax = cstr_ + len_;
    for (const char* i = cstr_ + pos; i < lmax; ++i)
    {
        for (size_t j = 0; j < n; ++j)
            if (s[j] == *i)
                return (size_t)(i - cstr_);
    }
    return npos;
}

inline
size_t String::find_first_of(char c, size_t pos) const
{
    return find_first_of(&c, pos, 1);
}

inline
size_t String::find_first_of(const String& str, size_t pos) const
{
    return find_first_of(str.c_str(), pos, str.len_);
}

inline
size_t String::find_first_of(const char* s, size_t pos) const
{
    if (len_ == 0) return npos;
    if (pos >= len_ || !s[0]) return npos;
    const char* lmax = cstr_ + len_;
    for (const char* i = cstr_ + pos; i < lmax; ++i)
    {
        for (size_t j = 0; s[j]; ++j)
            if (s[j] == *i)
                return (size_t)(i - cstr_);
    }
    return npos;
}

inline
size_t String::find_last_of(const char* s, size_t pos, size_t n) const
{
    if (len_ == 0) return npos;
    if (pos >= len_) pos = len_ - 1;
    for (const char* i = cstr_ + pos; i >= cstr_; --i)
    {
        for (size_t j = 0; j < n; ++j)
            if (s[j] == *i)
                return (size_t)(i - cstr_);
    }
    return npos;
}

inline
size_t String::find_last_of(char c, size_t pos) const
{
    return find_last_of(&c, pos, 1);
}

inline
size_t String::find_last_of(const String& str, size_t pos) const
{
    return find_last_of(str.c_str(), pos, str.len_);
}

inline
size_t String::find_last_of(const char* s, size_t pos) const
{
    if (len_ == 0) return npos;
    if (pos >= len_) pos = len_ - 1;
    for (const char* i = cstr_ + pos; i >= cstr_; --i)
    {
        for (size_t j = 0; s[j]; ++j)
            if (s[j] == *i)
                return (size_t)(i - cstr_);
    }
    return npos;
}

inline
String String::toLowerCase() const
{
    if (!cstr_)
        return String();
    String res(cstr_, len_);
    for (size_t i = 0; i < len_; ++i)
        res.cstr_[i] = (char) ::tolower(cstr_[i]);

    return res;
}








inline
String operator + (const String& lhs, const String& rhs)
{
    String s;
    s.allocate(lhs.len_ + rhs.len_);
    memcpy(s.cstr_, lhs.cstr_, lhs.len_);
    memcpy(s.cstr_ + lhs.len_, rhs.cstr_, rhs.len_);
    return s;
}

inline
String operator + (const String& lhs, const char* rhs)
{
    String s;
    size_t rhslen = strlen(rhs);
    s.allocate(lhs.len_ + rhslen);
    memcpy(s.cstr_, lhs.cstr_, lhs.len_);
    memcpy(s.cstr_ + lhs.len_, rhs, rhslen);
    return s;
}

inline
String operator + (const char* lhs, const String& rhs)
{
    String s;
    size_t lhslen = strlen(lhs);
    s.allocate(lhslen + rhs.len_);
    memcpy(s.cstr_, lhs, lhslen);
    memcpy(s.cstr_ + lhslen, rhs.cstr_, rhs.len_);
    return s;
}

inline
String operator + (const String& lhs, char rhs)
{
    String s;
    s.allocate(lhs.len_ + 1);
    memcpy(s.cstr_, lhs.cstr_, lhs.len_);
    s.cstr_[lhs.len_] = rhs;
    return s;
}

inline
String operator + (char lhs, const String& rhs)
{
    String s;
    s.allocate(rhs.len_ + 1);
    s.cstr_[0] = lhs;
    memcpy(s.cstr_ + 1, rhs.cstr_, rhs.len_);
    return s;
}

static inline bool operator== (const String& lhs, const String& rhs) { return 0 == lhs.compare(rhs); }
static inline bool operator== (const char*   lhs, const String& rhs) { return 0 == rhs.compare(lhs); }
static inline bool operator== (const String& lhs, const char*   rhs) { return 0 == lhs.compare(rhs); }
static inline bool operator!= (const String& lhs, const String& rhs) { return 0 != lhs.compare(rhs); }
static inline bool operator!= (const char*   lhs, const String& rhs) { return 0 != rhs.compare(lhs); }
static inline bool operator!= (const String& lhs, const char*   rhs) { return 0 != lhs.compare(rhs); }
static inline bool operator<  (const String& lhs, const String& rhs) { return lhs.compare(rhs) <  0; }
static inline bool operator<  (const char*   lhs, const String& rhs) { return rhs.compare(lhs) >  0; }
static inline bool operator<  (const String& lhs, const char*   rhs) { return lhs.compare(rhs) <  0; }
static inline bool operator<= (const String& lhs, const String& rhs) { return lhs.compare(rhs) <= 0; }
static inline bool operator<= (const char*   lhs, const String& rhs) { return rhs.compare(lhs) >= 0; }
static inline bool operator<= (const String& lhs, const char*   rhs) { return lhs.compare(rhs) <= 0; }
static inline bool operator>  (const String& lhs, const String& rhs) { return lhs.compare(rhs) >  0; }
static inline bool operator>  (const char*   lhs, const String& rhs) { return rhs.compare(lhs) <  0; }
static inline bool operator>  (const String& lhs, const char*   rhs) { return lhs.compare(rhs) >  0; }
static inline bool operator>= (const String& lhs, const String& rhs) { return lhs.compare(rhs) >= 0; }
static inline bool operator>= (const char*   lhs, const String& rhs) { return rhs.compare(lhs) <= 0; }
static inline bool operator>= (const String& lhs, const char*   rhs) { return lhs.compare(rhs) >= 0; }



} 

namespace std
{
    static inline void swap(cv::String& a, cv::String& b) { a.swap(b); }
}

#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/ptr.inl.hpp"
















































namespace cv {

template<typename Y>
void DefaultDeleter<Y>::operator () (Y* p) const
{
    delete p;
}

namespace detail
{

struct PtrOwner
{
    PtrOwner() : refCount(1)
    {}

    void incRef()
    {
        (int)_InterlockedExchangeAdd((long volatile*)&refCount, 1);
    }

    void decRef()
    {
        if ((int)_InterlockedExchangeAdd((long volatile*)&refCount, -1) == 1) deleteSelf();
    }

protected:
    

    virtual ~PtrOwner()
    {}

    virtual void deleteSelf() = 0;

private:
    unsigned int refCount;

    
    PtrOwner(const PtrOwner&);
    PtrOwner& operator = (const PtrOwner&);
};

template<typename Y, typename D>
struct PtrOwnerImpl : PtrOwner
{
    PtrOwnerImpl(Y* p, D d) : owned(p), deleter(d)
    {}

    void deleteSelf()
    {
        deleter(owned);
        delete this;
    }

private:
    Y* owned;
    D deleter;
};


}

template<typename T>
Ptr<T>::Ptr() : owner(0), stored(0)
{}

template<typename T>
template<typename Y>
Ptr<T>::Ptr(Y* p)
  : owner(p
      ? new detail::PtrOwnerImpl<Y, DefaultDeleter<Y> >(p, DefaultDeleter<Y>())
      : 0),
    stored(p)
{}

template<typename T>
template<typename Y, typename D>
Ptr<T>::Ptr(Y* p, D d)
  : owner(p
      ? new detail::PtrOwnerImpl<Y, D>(p, d)
      : 0),
    stored(p)
{}

template<typename T>
Ptr<T>::Ptr(const Ptr& o) : owner(o.owner), stored(o.stored)
{
    if (owner) owner->incRef();
}

template<typename T>
template<typename Y>
Ptr<T>::Ptr(const Ptr<Y>& o) : owner(o.owner), stored(o.stored)
{
    if (owner) owner->incRef();
}

template<typename T>
template<typename Y>
Ptr<T>::Ptr(const Ptr<Y>& o, T* p) : owner(o.owner), stored(p)
{
    if (owner) owner->incRef();
}

template<typename T>
Ptr<T>::~Ptr()
{
    release();
}

template<typename T>
Ptr<T>& Ptr<T>::operator = (const Ptr<T>& o)
{
    Ptr(o).swap(*this);
    return *this;
}

template<typename T>
template<typename Y>
Ptr<T>& Ptr<T>::operator = (const Ptr<Y>& o)
{
    Ptr(o).swap(*this);
    return *this;
}

template<typename T>
void Ptr<T>::release()
{
    if (owner) owner->decRef();
    owner = 0;
    stored = 0;
}

template<typename T>
template<typename Y>
void Ptr<T>::reset(Y* p)
{
    Ptr(p).swap(*this);
}

template<typename T>
template<typename Y, typename D>
void Ptr<T>::reset(Y* p, D d)
{
    Ptr(p, d).swap(*this);
}

template<typename T>
void Ptr<T>::swap(Ptr<T>& o)
{
    std::swap(owner, o.owner);
    std::swap(stored, o.stored);
}

template<typename T>
T* Ptr<T>::get() const
{
    return stored;
}

template<typename T>
typename detail::RefOrVoid<T>::type Ptr<T>::operator * () const
{
    return *stored;
}

template<typename T>
T* Ptr<T>::operator -> () const
{
    return stored;
}

template<typename T>
Ptr<T>::operator T* () const
{
    return stored;
}


template<typename T>
bool Ptr<T>::empty() const
{
    return !stored;
}

template<typename T>
template<typename Y>
Ptr<Y> Ptr<T>::staticCast() const
{
    return Ptr<Y>(*this, static_cast<Y*>(stored));
}

template<typename T>
template<typename Y>
Ptr<Y> Ptr<T>::constCast() const
{
    return Ptr<Y>(*this, const_cast<Y*>(stored));
}

template<typename T>
template<typename Y>
Ptr<Y> Ptr<T>::dynamicCast() const
{
    return Ptr<Y>(*this, dynamic_cast<Y*>(stored));
}



template<typename T>
Ptr<T>::Ptr(Ptr&& o) : owner(o.owner), stored(o.stored)
{
    o.owner = 0;
    o.stored = 0;
}

template<typename T>
Ptr<T>& Ptr<T>::operator = (Ptr<T>&& o)
{
    if (this == &o)
        return *this;

    release();
    owner = o.owner;
    stored = o.stored;
    o.owner = 0;
    o.stored = 0;
    return *this;
}

#line 279 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/ptr.inl.hpp"


template<typename T>
void swap(Ptr<T>& ptr1, Ptr<T>& ptr2){
    ptr1.swap(ptr2);
}

template<typename T>
bool operator == (const Ptr<T>& ptr1, const Ptr<T>& ptr2)
{
    return ptr1.get() == ptr2.get();
}

template<typename T>
bool operator != (const Ptr<T>& ptr1, const Ptr<T>& ptr2)
{
    return ptr1.get() != ptr2.get();
}

template<typename T>
Ptr<T> makePtr()
{
    return Ptr<T>(new T());
}

template<typename T, typename A1>
Ptr<T> makePtr(const A1& a1)
{
    return Ptr<T>(new T(a1));
}

template<typename T, typename A1, typename A2>
Ptr<T> makePtr(const A1& a1, const A2& a2)
{
    return Ptr<T>(new T(a1, a2));
}

template<typename T, typename A1, typename A2, typename A3>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3)
{
    return Ptr<T>(new T(a1, a2, a3));
}

template<typename T, typename A1, typename A2, typename A3, typename A4>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3, const A4& a4)
{
    return Ptr<T>(new T(a1, a2, a3, a4));
}

template<typename T, typename A1, typename A2, typename A3, typename A4, typename A5>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5)
{
    return Ptr<T>(new T(a1, a2, a3, a4, a5));
}

template<typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6)
{
    return Ptr<T>(new T(a1, a2, a3, a4, a5, a6));
}

template<typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7)
{
    return Ptr<T>(new T(a1, a2, a3, a4, a5, a6, a7));
}

template<typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8)
{
    return Ptr<T>(new T(a1, a2, a3, a4, a5, a6, a7, a8));
}

template<typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9)
{
    return Ptr<T>(new T(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}

template<typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10)
{
    return Ptr<T>(new T(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10));
}

template<typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10, const A11& a11)
{
    return Ptr<T>(new T(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11));
}

template<typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3, const A4& a4, const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9, const A10& a10, const A11& a11, const A12& a12)
{
    return Ptr<T>(new T(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12));
}
} 



#line 380 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/ptr.inl.hpp"
#line 1038 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvstd.hpp"

#line 1040 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvstd.hpp"

#line 59 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"

namespace cv
{




namespace Error {

enum Code {
    StsOk=                       0,  
    StsBackTrace=               -1,  
    StsError=                   -2,  
    StsInternal=                -3,  
    StsNoMem=                   -4,  
    StsBadArg=                  -5,  
    StsBadFunc=                 -6,  
    StsNoConv=                  -7,  
    StsAutoTrace=               -8,  
    HeaderIsNull=               -9,  
    BadImageSize=              -10,  
    BadOffset=                 -11,  
    BadDataPtr=                -12,  
    BadStep=                   -13,  
    BadModelOrChSeq=           -14,  
    BadNumChannels=            -15,  
    BadNumChannel1U=           -16,  
    BadDepth=                  -17,  
    BadAlphaChannel=           -18,  
    BadOrder=                  -19,  
    BadOrigin=                 -20,  
    BadAlign=                  -21,  
    BadCallBack=               -22,  
    BadTileSize=               -23,  
    BadCOI=                    -24,  
    BadROISize=                -25,  
    MaskIsTiled=               -26,  
    StsNullPtr=                -27,  
    StsVecLengthErr=           -28,  
    StsFilterStructContentErr= -29,  
    StsKernelStructContentErr= -30,  
    StsFilterOffsetErr=        -31,  
    StsBadSize=                -201, 
    StsDivByZero=              -202, 
    StsInplaceNotSupported=    -203, 
    StsObjectNotFound=         -204, 
    StsUnmatchedFormats=       -205, 
    StsBadFlag=                -206, 
    StsBadPoint=               -207, 
    StsBadMask=                -208, 
    StsUnmatchedSizes=         -209, 
    StsUnsupportedFormat=      -210, 
    StsOutOfRange=             -211, 
    StsParseError=             -212, 
    StsNotImplemented=         -213, 
    StsBadMemBlock=            -214, 
    StsAssert=                 -215, 
    GpuNotSupported=           -216, 
    GpuApiCallError=           -217, 
    OpenGlNotSupported=        -218, 
    OpenGlApiCallError=        -219, 
    OpenCLApiCallError=        -220, 
    OpenCLDoubleNotSupported=  -221,
    OpenCLInitError=           -222, 
    OpenCLNoAMDBlasFft=        -223
};
} 







enum DecompTypes {
    
    DECOMP_LU       = 0,
    

    DECOMP_SVD      = 1,
    
    DECOMP_EIG      = 2,
    

    DECOMP_CHOLESKY = 3,
    
    DECOMP_QR       = 4,
    




    DECOMP_NORMAL   = 16
};



































enum NormTypes { NORM_INF       = 1,
                 NORM_L1        = 2,
                 NORM_L2        = 4,
                 NORM_L2SQR     = 5,
                 NORM_HAMMING   = 6,
                 NORM_HAMMING2  = 7,
                 NORM_TYPE_MASK = 7,
                 NORM_RELATIVE  = 8, 
                 NORM_MINMAX    = 32 
               };


enum CmpTypes { CMP_EQ = 0, 
                CMP_GT = 1, 
                CMP_GE = 2, 
                CMP_LT = 3, 
                CMP_LE = 4, 
                CMP_NE = 5  
              };


enum GemmFlags { GEMM_1_T = 1, 
                 GEMM_2_T = 2, 
                 GEMM_3_T = 4 
               };

enum DftFlags {
    

    DFT_INVERSE        = 1,
    

    DFT_SCALE          = 2,
    



    DFT_ROWS           = 4,
    





    DFT_COMPLEX_OUTPUT = 16,
    







    DFT_REAL_OUTPUT    = 32,
    


    DFT_COMPLEX_INPUT  = 64,
    
    DCT_INVERSE        = DFT_INVERSE,
    



    DCT_ROWS           = DFT_ROWS
};



enum BorderTypes {
    BORDER_CONSTANT    = 0, 
    BORDER_REPLICATE   = 1, 
    BORDER_REFLECT     = 2, 
    BORDER_WRAP        = 3, 
    BORDER_REFLECT_101 = 4, 
    BORDER_TRANSPARENT = 5, 

    BORDER_REFLECT101  = BORDER_REFLECT_101, 
    BORDER_DEFAULT     = BORDER_REFLECT_101, 
    BORDER_ISOLATED    = 16 
};





















#line 291 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"



#line 295 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"


#line 298 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"
#line 299 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"














    




#line 319 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"














#line 334 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"















 void error(int _code, const String& _err, const char* _func, const char* _file, int _line);









static inline __declspec(noreturn) void errorNoReturn(int _code, const String& _err, const char* _func, const char* _file, int _line)
{
    error(_code, _err, _func, _file, _line);







}








#line 379 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"



#line 383 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"




















































#line 436 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"






#line 443 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"





struct  Hamming
{
    enum { normType = NORM_HAMMING };
    typedef unsigned char ValueType;
    typedef int ResultType;

    

    ResultType operator()( const unsigned char* a, const unsigned char* b, int size ) const;
};

typedef Hamming HammingLUT;



template<typename _Tp> inline _Tp cv_abs(_Tp x) { return std::abs(x); }
inline int cv_abs(uchar x) { return x; }
inline int cv_abs(schar x) { return std::abs(x); }
inline int cv_abs(ushort x) { return x; }
inline int cv_abs(short x) { return std::abs(x); }

template<typename _Tp, typename _AccTp> static inline
_AccTp normL2Sqr(const _Tp* a, int n)
{
    _AccTp s = 0;
    int i=0;

    for( ; i <= n - 4; i += 4 )
    {
        _AccTp v0 = a[i], v1 = a[i+1], v2 = a[i+2], v3 = a[i+3];
        s += v0*v0 + v1*v1 + v2*v2 + v3*v3;
    }
#line 481 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"
    for( ; i < n; i++ )
    {
        _AccTp v = a[i];
        s += v*v;
    }
    return s;
}

template<typename _Tp, typename _AccTp> static inline
_AccTp normL1(const _Tp* a, int n)
{
    _AccTp s = 0;
    int i = 0;

    for(; i <= n - 4; i += 4 )
    {
        s += (_AccTp)cv_abs(a[i]) + (_AccTp)cv_abs(a[i+1]) +
            (_AccTp)cv_abs(a[i+2]) + (_AccTp)cv_abs(a[i+3]);
    }
#line 501 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"
    for( ; i < n; i++ )
        s += cv_abs(a[i]);
    return s;
}

template<typename _Tp, typename _AccTp> static inline
_AccTp normInf(const _Tp* a, int n)
{
    _AccTp s = 0;
    for( int i = 0; i < n; i++ )
        s = std::max(s, (_AccTp)cv_abs(a[i]));
    return s;
}

template<typename _Tp, typename _AccTp> static inline
_AccTp normL2Sqr(const _Tp* a, const _Tp* b, int n)
{
    _AccTp s = 0;
    int i= 0;

    for(; i <= n - 4; i += 4 )
    {
        _AccTp v0 = _AccTp(a[i] - b[i]), v1 = _AccTp(a[i+1] - b[i+1]), v2 = _AccTp(a[i+2] - b[i+2]), v3 = _AccTp(a[i+3] - b[i+3]);
        s += v0*v0 + v1*v1 + v2*v2 + v3*v3;
    }
#line 527 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"
    for( ; i < n; i++ )
    {
        _AccTp v = _AccTp(a[i] - b[i]);
        s += v*v;
    }
    return s;
}

static inline float normL2Sqr(const float* a, const float* b, int n)
{
    float s = 0.f;
    for( int i = 0; i < n; i++ )
    {
        float v = a[i] - b[i];
        s += v*v;
    }
    return s;
}

template<typename _Tp, typename _AccTp> static inline
_AccTp normL1(const _Tp* a, const _Tp* b, int n)
{
    _AccTp s = 0;
    int i= 0;

    for(; i <= n - 4; i += 4 )
    {
        _AccTp v0 = _AccTp(a[i] - b[i]), v1 = _AccTp(a[i+1] - b[i+1]), v2 = _AccTp(a[i+2] - b[i+2]), v3 = _AccTp(a[i+3] - b[i+3]);
        s += std::abs(v0) + std::abs(v1) + std::abs(v2) + std::abs(v3);
    }
#line 558 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"
    for( ; i < n; i++ )
    {
        _AccTp v = _AccTp(a[i] - b[i]);
        s += std::abs(v);
    }
    return s;
}

inline float normL1(const float* a, const float* b, int n)
{
    float s = 0.f;
    for( int i = 0; i < n; i++ )
    {
        s += std::abs(a[i] - b[i]);
    }
    return s;
}

inline int normL1(const uchar* a, const uchar* b, int n)
{
    int s = 0;
    for( int i = 0; i < n; i++ )
    {
        s += std::abs(a[i] - b[i]);
    }
    return s;
}

template<typename _Tp, typename _AccTp> static inline
_AccTp normInf(const _Tp* a, const _Tp* b, int n)
{
    _AccTp s = 0;
    for( int i = 0; i < n; i++ )
    {
        _AccTp v0 = a[i] - b[i];
        s = std::max(s, std::abs(v0));
    }
    return s;
}








 float cubeRoot(float val);








 float fastAtan2(float y, float x);


 int LU(float* A, size_t astep, int m, float* b, size_t bstep, int n);

 int LU(double* A, size_t astep, int m, double* b, size_t bstep, int n);

 bool Cholesky(float* A, size_t astep, int m, float* b, size_t bstep, int n);

 bool Cholesky(double* A, size_t astep, int m, double* b, size_t bstep, int n);





template<typename _Tp, int cn> class Vec;
template<typename _Tp, int m, int n> class Matx;

template<typename _Tp> class Complex;
template<typename _Tp> class Point_;
template<typename _Tp> class Point3_;
template<typename _Tp> class Size_;
template<typename _Tp> class Rect_;
template<typename _Tp> class Scalar_;

class  RotatedRect;
class  Range;
class  TermCriteria;
class  KeyPoint;
class  DMatch;
class  RNG;

class  Mat;
class  MatExpr;

class  UMat;

class  SparseMat;
typedef Mat MatND;

template<typename _Tp> class Mat_;
template<typename _Tp> class SparseMat_;

class  MatConstIterator;
class  SparseMatIterator;
class  SparseMatConstIterator;
template<typename _Tp> class MatIterator_;
template<typename _Tp> class MatConstIterator_;
template<typename _Tp> class SparseMatIterator_;
template<typename _Tp> class SparseMatConstIterator_;

namespace ogl
{
    class  Buffer;
    class  Texture2D;
    class  Arrays;
}

namespace cuda
{
    class  GpuMat;
    class  HostMem;
    class  Stream;
    class  Event;
}

namespace cudev
{
    template <typename _Tp> class GpuMat_;
}

namespace ipp
{


#line 690 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"
   int getIppFeatures();
#line 692 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"
   void setIppStatus(int status, const char * const funcname = 0, const char * const filename = 0,
                             int line = 0);
   int getIppStatus();
   String getIppErrorLocation();
 bool useIPP();
 void setUseIPP(bool flag);

} 








} 

#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/neon_utils.hpp"












































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"


















































































































































































































































































































































































































































#line 46 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/neon_utils.hpp"














































































#line 125 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/neon_utils.hpp"



#line 129 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/neon_utils.hpp"
#line 711 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"

#line 713 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"

#line 55 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvstd.hpp"
















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 56 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/traits.hpp"














































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"


















































































































































































































































































































































































































































#line 48 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/traits.hpp"

namespace cv
{























































template<typename _Tp> class DataType
{
public:
    typedef _Tp         value_type;
    typedef value_type  work_type;
    typedef value_type  channel_type;
    typedef value_type  vec_type;
    enum { generic_type = 1,
           depth        = -1,
           channels     = 1,
           fmt          = 0,
           type = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };
};

template<> class DataType<bool>
{
public:
    typedef bool        value_type;
    typedef int         work_type;
    typedef value_type  channel_type;
    typedef value_type  vec_type;
    enum { generic_type = 0,
           depth        = 0,
           channels     = 1,
           fmt          = (int)'u',
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };
};

template<> class DataType<uchar>
{
public:
    typedef uchar       value_type;
    typedef int         work_type;
    typedef value_type  channel_type;
    typedef value_type  vec_type;
    enum { generic_type = 0,
           depth        = 0,
           channels     = 1,
           fmt          = (int)'u',
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };
};

template<> class DataType<schar>
{
public:
    typedef schar       value_type;
    typedef int         work_type;
    typedef value_type  channel_type;
    typedef value_type  vec_type;
    enum { generic_type = 0,
           depth        = 1,
           channels     = 1,
           fmt          = (int)'c',
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };
};

template<> class DataType<char>
{
public:
    typedef schar       value_type;
    typedef int         work_type;
    typedef value_type  channel_type;
    typedef value_type  vec_type;
    enum { generic_type = 0,
           depth        = 1,
           channels     = 1,
           fmt          = (int)'c',
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };
};

template<> class DataType<ushort>
{
public:
    typedef ushort      value_type;
    typedef int         work_type;
    typedef value_type  channel_type;
    typedef value_type  vec_type;
    enum { generic_type = 0,
           depth        = 2,
           channels     = 1,
           fmt          = (int)'w',
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };
};

template<> class DataType<short>
{
public:
    typedef short       value_type;
    typedef int         work_type;
    typedef value_type  channel_type;
    typedef value_type  vec_type;
    enum { generic_type = 0,
           depth        = 3,
           channels     = 1,
           fmt          = (int)'s',
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };
};

template<> class DataType<int>
{
public:
    typedef int         value_type;
    typedef value_type  work_type;
    typedef value_type  channel_type;
    typedef value_type  vec_type;
    enum { generic_type = 0,
           depth        = 4,
           channels     = 1,
           fmt          = (int)'i',
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };
};

template<> class DataType<float>
{
public:
    typedef float       value_type;
    typedef value_type  work_type;
    typedef value_type  channel_type;
    typedef value_type  vec_type;
    enum { generic_type = 0,
           depth        = 5,
           channels     = 1,
           fmt          = (int)'f',
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };
};

template<> class DataType<double>
{
public:
    typedef double      value_type;
    typedef value_type  work_type;
    typedef value_type  channel_type;
    typedef value_type  vec_type;
    enum { generic_type = 0,
           depth        = 6,
           channels     = 1,
           fmt          = (int)'d',
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };
};







template<typename _Tp> class DataDepth
{
public:
    enum
    {
        value = DataType<_Tp>::depth,
        fmt   = DataType<_Tp>::fmt
    };
};



template<int _depth> class TypeDepth
{
    enum { depth = 7 };
    typedef void value_type;
};

template<> class TypeDepth<0>
{
    enum { depth = 0 };
    typedef uchar value_type;
};

template<> class TypeDepth<1>
{
    enum { depth = 1 };
    typedef schar value_type;
};

template<> class TypeDepth<2>
{
    enum { depth = 2 };
    typedef ushort value_type;
};

template<> class TypeDepth<3>
{
    enum { depth = 3 };
    typedef short value_type;
};

template<> class TypeDepth<4>
{
    enum { depth = 4 };
    typedef int value_type;
};

template<> class TypeDepth<5>
{
    enum { depth = 5 };
    typedef float value_type;
};

template<> class TypeDepth<6>
{
    enum { depth = 6 };
    typedef double value_type;
};



} 

#line 327 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/traits.hpp"
#line 57 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/matx.hpp"


















































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"


















































































































































































































































































































































































































































#line 52 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/matx.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/base.hpp"









































































































































































































































































































































































































































































































































































































































































































































#line 53 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/matx.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/traits.hpp"






































































































































































































































































































































#line 54 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/matx.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/saturate.hpp"















































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"


















































































































































































































































































































































































































































#line 49 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/saturate.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/fast_math.hpp"















































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"


















































































































































































































































































































































































































































#line 49 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/fast_math.hpp"



#line 54 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/fast_math.hpp"

















#line 72 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/fast_math.hpp"





















#line 94 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/fast_math.hpp"






static inline int
cvRound( double value )
{

    __m128d t = _mm_set_sd( value );
    return _mm_cvtsd_si32(t);





















#line 129 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/fast_math.hpp"
}









static inline int cvFloor( double value )
{
    int i = (int)value;
    return i - (i > value);
}








static inline int cvCeil( double value )
{
    int i = (int)value;
    return i + (i < value);
}







static inline int cvIsNaN( double value )
{
    Cv64suf ieee754;
    ieee754.f = value;
    return ((unsigned)(ieee754.u >> 32) & 0x7fffffff) +
           ((unsigned)ieee754.u != 0) > 0x7ff00000;
}







static inline int cvIsInf( double value )
{
    Cv64suf ieee754;
    ieee754.f = value;
    return ((unsigned)(ieee754.u >> 32) & 0x7fffffff) == 0x7ff00000 &&
            (unsigned)ieee754.u == 0;
}




static inline int cvRound(float value)
{

    __m128 t = _mm_set_ss( value );
    return _mm_cvt_ss2si(t);





















#line 217 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/fast_math.hpp"
}


static inline int cvRound( int value )
{
    return value;
}


static inline int cvFloor( float value )
{
    int i = (int)value;
    return i - (i > value);
}


static inline int cvFloor( int value )
{
    return value;
}


static inline int cvCeil( float value )
{
    int i = (int)value;
    return i + (i < value);
}


static inline int cvCeil( int value )
{
    return value;
}


static inline int cvIsNaN( float value )
{
    Cv32suf ieee754;
    ieee754.f = value;
    return (ieee754.u & 0x7fffffff) > 0x7f800000;
}


static inline int cvIsInf( float value )
{
    Cv32suf ieee754;
    ieee754.f = value;
    return (ieee754.u & 0x7fffffff) == 0x7f800000;
}

#line 268 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/fast_math.hpp"



#line 272 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/fast_math.hpp"
#line 50 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/saturate.hpp"

namespace cv
{





























template<typename _Tp> static inline _Tp saturate_cast(uchar v)    { return _Tp(v); }

template<typename _Tp> static inline _Tp saturate_cast(schar v)    { return _Tp(v); }

template<typename _Tp> static inline _Tp saturate_cast(ushort v)   { return _Tp(v); }

template<typename _Tp> static inline _Tp saturate_cast(short v)    { return _Tp(v); }

template<typename _Tp> static inline _Tp saturate_cast(unsigned v) { return _Tp(v); }

template<typename _Tp> static inline _Tp saturate_cast(int v)      { return _Tp(v); }

template<typename _Tp> static inline _Tp saturate_cast(float v)    { return _Tp(v); }

template<typename _Tp> static inline _Tp saturate_cast(double v)   { return _Tp(v); }

template<typename _Tp> static inline _Tp saturate_cast(int64 v)    { return _Tp(v); }

template<typename _Tp> static inline _Tp saturate_cast(uint64 v)   { return _Tp(v); }

template<> inline uchar saturate_cast<uchar>(schar v)        { return (uchar)std::max((int)v, 0); }
template<> inline uchar saturate_cast<uchar>(ushort v)       { return (uchar)std::min((unsigned)v, (unsigned)0xff); }
template<> inline uchar saturate_cast<uchar>(int v)          { return (uchar)((unsigned)v <= 0xff ? v : v > 0 ? 0xff : 0); }
template<> inline uchar saturate_cast<uchar>(short v)        { return saturate_cast<uchar>((int)v); }
template<> inline uchar saturate_cast<uchar>(unsigned v)     { return (uchar)std::min(v, (unsigned)0xff); }
template<> inline uchar saturate_cast<uchar>(float v)        { int iv = cvRound(v); return saturate_cast<uchar>(iv); }
template<> inline uchar saturate_cast<uchar>(double v)       { int iv = cvRound(v); return saturate_cast<uchar>(iv); }
template<> inline uchar saturate_cast<uchar>(int64 v)        { return (uchar)((uint64)v <= (uint64)0xff ? v : v > 0 ? 0xff : 0); }
template<> inline uchar saturate_cast<uchar>(uint64 v)       { return (uchar)std::min(v, (uint64)0xff); }

template<> inline schar saturate_cast<schar>(uchar v)        { return (schar)std::min((int)v, 127); }
template<> inline schar saturate_cast<schar>(ushort v)       { return (schar)std::min((unsigned)v, (unsigned)127); }
template<> inline schar saturate_cast<schar>(int v)          { return (schar)((unsigned)(v-(-128)) <= (unsigned)0xff ? v : v > 0 ? 127 : (-128)); }
template<> inline schar saturate_cast<schar>(short v)        { return saturate_cast<schar>((int)v); }
template<> inline schar saturate_cast<schar>(unsigned v)     { return (schar)std::min(v, (unsigned)127); }
template<> inline schar saturate_cast<schar>(float v)        { int iv = cvRound(v); return saturate_cast<schar>(iv); }
template<> inline schar saturate_cast<schar>(double v)       { int iv = cvRound(v); return saturate_cast<schar>(iv); }
template<> inline schar saturate_cast<schar>(int64 v)        { return (schar)((uint64)((int64)v-(-128)) <= (uint64)0xff ? v : v > 0 ? 127 : (-128)); }
template<> inline schar saturate_cast<schar>(uint64 v)       { return (schar)std::min(v, (uint64)127); }

template<> inline ushort saturate_cast<ushort>(schar v)      { return (ushort)std::max((int)v, 0); }
template<> inline ushort saturate_cast<ushort>(short v)      { return (ushort)std::max((int)v, 0); }
template<> inline ushort saturate_cast<ushort>(int v)        { return (ushort)((unsigned)v <= (unsigned)0xffff ? v : v > 0 ? 0xffff : 0); }
template<> inline ushort saturate_cast<ushort>(unsigned v)   { return (ushort)std::min(v, (unsigned)0xffff); }
template<> inline ushort saturate_cast<ushort>(float v)      { int iv = cvRound(v); return saturate_cast<ushort>(iv); }
template<> inline ushort saturate_cast<ushort>(double v)     { int iv = cvRound(v); return saturate_cast<ushort>(iv); }
template<> inline ushort saturate_cast<ushort>(int64 v)      { return (ushort)((uint64)v <= (uint64)0xffff ? v : v > 0 ? 0xffff : 0); }
template<> inline ushort saturate_cast<ushort>(uint64 v)     { return (ushort)std::min(v, (uint64)0xffff); }

template<> inline short saturate_cast<short>(ushort v)       { return (short)std::min((int)v, 32767); }
template<> inline short saturate_cast<short>(int v)          { return (short)((unsigned)(v - (-32768)) <= (unsigned)0xffff ? v : v > 0 ? 32767 : (-32768)); }
template<> inline short saturate_cast<short>(unsigned v)     { return (short)std::min(v, (unsigned)32767); }
template<> inline short saturate_cast<short>(float v)        { int iv = cvRound(v); return saturate_cast<short>(iv); }
template<> inline short saturate_cast<short>(double v)       { int iv = cvRound(v); return saturate_cast<short>(iv); }
template<> inline short saturate_cast<short>(int64 v)        { return (short)((uint64)((int64)v - (-32768)) <= (uint64)0xffff ? v : v > 0 ? 32767 : (-32768)); }
template<> inline short saturate_cast<short>(uint64 v)       { return (short)std::min(v, (uint64)32767); }

template<> inline int saturate_cast<int>(float v)            { return cvRound(v); }
template<> inline int saturate_cast<int>(double v)           { return cvRound(v); }


template<> inline unsigned saturate_cast<unsigned>(float v)  { return cvRound(v); }
template<> inline unsigned saturate_cast<unsigned>(double v) { return cvRound(v); }



} 

#line 151 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/saturate.hpp"
#line 55 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/matx.hpp"





namespace cv
{







struct  Matx_AddOp {};
struct  Matx_SubOp {};
struct  Matx_ScaleOp {};
struct  Matx_MulOp {};
struct  Matx_DivOp {};
struct  Matx_MatMulOp {};
struct  Matx_TOp {};
























template<typename _Tp, int m, int n> class Matx
{
public:
    enum { depth    = DataType<_Tp>::depth,
           rows     = m,
           cols     = n,
           channels = rows*cols,
           type     = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)),
           shortdim = (m < n ? m : n)
         };

    typedef _Tp                           value_type;
    typedef Matx<_Tp, m, n>               mat_type;
    typedef Matx<_Tp, shortdim, 1> diag_type;

    
    Matx();

    Matx(_Tp v0); 
    Matx(_Tp v0, _Tp v1); 
    Matx(_Tp v0, _Tp v1, _Tp v2); 
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3); 
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4); 
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5); 
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6); 
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7); 
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8); 
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9); 
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
         _Tp v4, _Tp v5, _Tp v6, _Tp v7,
         _Tp v8, _Tp v9, _Tp v10, _Tp v11); 
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
         _Tp v4, _Tp v5, _Tp v6, _Tp v7,
         _Tp v8, _Tp v9, _Tp v10, _Tp v11,
         _Tp v12, _Tp v13); 
    Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3,
         _Tp v4, _Tp v5, _Tp v6, _Tp v7,
         _Tp v8, _Tp v9, _Tp v10, _Tp v11,
         _Tp v12, _Tp v13, _Tp v14, _Tp v15); 
    explicit Matx(const _Tp* vals); 





    static Matx all(_Tp alpha);
    static Matx zeros();
    static Matx ones();
    static Matx eye();
    static Matx diag(const diag_type& d);
    static Matx randu(_Tp a, _Tp b);
    static Matx randn(_Tp a, _Tp b);

    
    _Tp dot(const Matx<_Tp, m, n>& v) const;

    
    double ddot(const Matx<_Tp, m, n>& v) const;

    
    template<typename T2> operator Matx<T2, m, n>() const;

    
    template<int m1, int n1> Matx<_Tp, m1, n1> reshape() const;

    
    template<int m1, int n1> Matx<_Tp, m1, n1> get_minor(int i, int j) const;

    
    Matx<_Tp, 1, n> row(int i) const;

    
    Matx<_Tp, m, 1> col(int i) const;

    
    diag_type diag() const;

    
    Matx<_Tp, n, m> t() const;

    
    Matx<_Tp, n, m> inv(int method=DECOMP_LU, bool *p_is_ok = 0) const;

    
    template<int l> Matx<_Tp, n, l> solve(const Matx<_Tp, m, l>& rhs, int flags=DECOMP_LU) const;
    Vec<_Tp, n> solve(const Vec<_Tp, m>& rhs, int method) const;

    
    Matx<_Tp, m, n> mul(const Matx<_Tp, m, n>& a) const;

    
    Matx<_Tp, m, n> div(const Matx<_Tp, m, n>& a) const;

    
    const _Tp& operator ()(int i, int j) const;
    _Tp& operator ()(int i, int j);

    
    const _Tp& operator ()(int i) const;
    _Tp& operator ()(int i);

    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp);
    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp);
    template<typename _T2> Matx(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp);
    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp);
    Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_DivOp);
    template<int l> Matx(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp);
    Matx(const Matx<_Tp, n, m>& a, Matx_TOp);

    _Tp val[m*n]; 
};

typedef Matx<float, 1, 2> Matx12f;
typedef Matx<double, 1, 2> Matx12d;
typedef Matx<float, 1, 3> Matx13f;
typedef Matx<double, 1, 3> Matx13d;
typedef Matx<float, 1, 4> Matx14f;
typedef Matx<double, 1, 4> Matx14d;
typedef Matx<float, 1, 6> Matx16f;
typedef Matx<double, 1, 6> Matx16d;

typedef Matx<float, 2, 1> Matx21f;
typedef Matx<double, 2, 1> Matx21d;
typedef Matx<float, 3, 1> Matx31f;
typedef Matx<double, 3, 1> Matx31d;
typedef Matx<float, 4, 1> Matx41f;
typedef Matx<double, 4, 1> Matx41d;
typedef Matx<float, 6, 1> Matx61f;
typedef Matx<double, 6, 1> Matx61d;

typedef Matx<float, 2, 2> Matx22f;
typedef Matx<double, 2, 2> Matx22d;
typedef Matx<float, 2, 3> Matx23f;
typedef Matx<double, 2, 3> Matx23d;
typedef Matx<float, 3, 2> Matx32f;
typedef Matx<double, 3, 2> Matx32d;

typedef Matx<float, 3, 3> Matx33f;
typedef Matx<double, 3, 3> Matx33d;

typedef Matx<float, 3, 4> Matx34f;
typedef Matx<double, 3, 4> Matx34d;
typedef Matx<float, 4, 3> Matx43f;
typedef Matx<double, 4, 3> Matx43d;

typedef Matx<float, 4, 4> Matx44f;
typedef Matx<double, 4, 4> Matx44d;
typedef Matx<float, 6, 6> Matx66f;
typedef Matx<double, 6, 6> Matx66d;




template<typename _Tp, int m, int n> class DataType< Matx<_Tp, m, n> >
{
public:
    typedef Matx<_Tp, m, n>                               value_type;
    typedef Matx<typename DataType<_Tp>::work_type, m, n> work_type;
    typedef _Tp                                           channel_type;
    typedef value_type                                    vec_type;

    enum { generic_type = 0,
           depth        = DataType<channel_type>::depth,
           channels     = m * n,
           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };
};



template<typename _Tp, int m, int n> class MatxCommaInitializer
{
public:
    MatxCommaInitializer(Matx<_Tp, m, n>* _mtx);
    template<typename T2> MatxCommaInitializer<_Tp, m, n>& operator , (T2 val);
    Matx<_Tp, m, n> operator *() const;

    Matx<_Tp, m, n>* dst;
    int idx;
};




template<typename _Tp, int m> static double determinant(const Matx<_Tp, m, m>& a);
template<typename _Tp, int m, int n> static double trace(const Matx<_Tp, m, n>& a);
template<typename _Tp, int m, int n> static double norm(const Matx<_Tp, m, n>& M);
template<typename _Tp, int m, int n> static double norm(const Matx<_Tp, m, n>& M, int normType);

































template<typename _Tp, int cn> class Vec : public Matx<_Tp, cn, 1>
{
public:
    typedef _Tp value_type;
    enum { depth    = Matx<_Tp, cn, 1>::depth,
           channels = cn,
           type     = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };

    
    Vec();

    Vec(_Tp v0); 
    Vec(_Tp v0, _Tp v1); 
    Vec(_Tp v0, _Tp v1, _Tp v2); 
    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3); 
    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4); 
    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5); 
    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6); 
    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7); 
    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8); 
    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9); 
    Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13); 
    explicit Vec(const _Tp* values);





    Vec(const Vec<_Tp, cn>& v);

    static Vec all(_Tp alpha);

    
    Vec mul(const Vec<_Tp, cn>& v) const;

    
    Vec conj() const;

    




    Vec cross(const Vec& v) const;
    
    template<typename T2> operator Vec<T2, cn>() const;

    
    const _Tp& operator [](int i) const;
    _Tp& operator[](int i);
    const _Tp& operator ()(int i) const;
    _Tp& operator ()(int i);

    Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_AddOp);
    Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_SubOp);
    template<typename _T2> Vec(const Matx<_Tp, cn, 1>& a, _T2 alpha, Matx_ScaleOp);
};




typedef Vec<uchar, 2> Vec2b;
typedef Vec<uchar, 3> Vec3b;
typedef Vec<uchar, 4> Vec4b;

typedef Vec<short, 2> Vec2s;
typedef Vec<short, 3> Vec3s;
typedef Vec<short, 4> Vec4s;

typedef Vec<ushort, 2> Vec2w;
typedef Vec<ushort, 3> Vec3w;
typedef Vec<ushort, 4> Vec4w;

typedef Vec<int, 2> Vec2i;
typedef Vec<int, 3> Vec3i;
typedef Vec<int, 4> Vec4i;
typedef Vec<int, 6> Vec6i;
typedef Vec<int, 8> Vec8i;

typedef Vec<float, 2> Vec2f;
typedef Vec<float, 3> Vec3f;
typedef Vec<float, 4> Vec4f;
typedef Vec<float, 6> Vec6f;

typedef Vec<double, 2> Vec2d;
typedef Vec<double, 3> Vec3d;
typedef Vec<double, 4> Vec4d;
typedef Vec<double, 6> Vec6d;





template<typename _Tp, int cn> class DataType< Vec<_Tp, cn> >
{
public:
    typedef Vec<_Tp, cn>                               value_type;
    typedef Vec<typename DataType<_Tp>::work_type, cn> work_type;
    typedef _Tp                                        channel_type;
    typedef value_type                                 vec_type;

    enum { generic_type = 0,
           depth        = DataType<channel_type>::depth,
           channels     = cn,
           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };
};



template<typename _Tp, int m> class VecCommaInitializer : public MatxCommaInitializer<_Tp, m, 1>
{
public:
    VecCommaInitializer(Vec<_Tp, m>* _vec);
    template<typename T2> VecCommaInitializer<_Tp, m>& operator , (T2 val);
    Vec<_Tp, m> operator *() const;
};

template<typename _Tp, int cn> static Vec<_Tp, cn> normalize(const Vec<_Tp, cn>& v);






namespace internal
{

template<typename _Tp, int m> struct Matx_DetOp
{
    double operator ()(const Matx<_Tp, m, m>& a) const
    {
        Matx<_Tp, m, m> temp = a;
        double p = LU(temp.val, m*sizeof(_Tp), m, 0, 0, 0);
        if( p == 0 )
            return p;
        for( int i = 0; i < m; i++ )
            p *= temp(i, i);
        return p;
    }
};

template<typename _Tp> struct Matx_DetOp<_Tp, 1>
{
    double operator ()(const Matx<_Tp, 1, 1>& a) const
    {
        return a(0,0);
    }
};

template<typename _Tp> struct Matx_DetOp<_Tp, 2>
{
    double operator ()(const Matx<_Tp, 2, 2>& a) const
    {
        return a(0,0)*a(1,1) - a(0,1)*a(1,0);
    }
};

template<typename _Tp> struct Matx_DetOp<_Tp, 3>
{
    double operator ()(const Matx<_Tp, 3, 3>& a) const
    {
        return a(0,0)*(a(1,1)*a(2,2) - a(2,1)*a(1,2)) -
            a(0,1)*(a(1,0)*a(2,2) - a(2,0)*a(1,2)) +
            a(0,2)*(a(1,0)*a(2,1) - a(2,0)*a(1,1));
    }
};

template<typename _Tp> Vec<_Tp, 2> inline conjugate(const Vec<_Tp, 2>& v)
{
    return Vec<_Tp, 2>(v[0], -v[1]);
}

template<typename _Tp> Vec<_Tp, 4> inline conjugate(const Vec<_Tp, 4>& v)
{
    return Vec<_Tp, 4>(v[0], -v[1], -v[2], -v[3]);
}

} 





template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n>::Matx()
{
    for(int i = 0; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n>::Matx(_Tp v0)
{
    val[0] = v0;
    for(int i = 1; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1)
{
    static_assert((channels >= 2), "Matx should have at least 2 elements." " " "channels >= 2");
    val[0] = v0; val[1] = v1;
    for(int i = 2; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2)
{
    static_assert((channels >= 3), "Matx should have at least 3 elements." " " "channels >= 3");
    val[0] = v0; val[1] = v1; val[2] = v2;
    for(int i = 3; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
{
    static_assert((channels >= 4), "Matx should have at least 4 elements." " " "channels >= 4");
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    for(int i = 4; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
{
    static_assert((channels >= 5), "Matx should have at least 5 elements." " " "channels >= 5");
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3; val[4] = v4;
    for(int i = 5; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
{
    static_assert((channels >= 6), "Matx should have at least 6 elements." " " "channels >= 6");
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    val[4] = v4; val[5] = v5;
    for(int i = 6; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
{
    static_assert((channels >= 7), "Matx should have at least 7 elements." " " "channels >= 7");
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    val[4] = v4; val[5] = v5; val[6] = v6;
    for(int i = 7; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
{
    static_assert((channels >= 8), "Matx should have at least 8 elements." " " "channels >= 8");
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    val[4] = v4; val[5] = v5; val[6] = v6; val[7] = v7;
    for(int i = 8; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
{
    static_assert((channels >= 9), "Matx should have at least 9 elements." " " "channels >= 9");
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    val[4] = v4; val[5] = v5; val[6] = v6; val[7] = v7;
    val[8] = v8;
    for(int i = 9; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
{
    static_assert((channels >= 10), "Matx should have at least 10 elements." " " "channels >= 10");
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    val[4] = v4; val[5] = v5; val[6] = v6; val[7] = v7;
    val[8] = v8; val[9] = v9;
    for(int i = 10; i < channels; i++) val[i] = _Tp(0);
}


template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11)
{
    static_assert((channels >= 12), "Matx should have at least 12 elements." " " "channels >= 12");
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    val[4] = v4; val[5] = v5; val[6] = v6; val[7] = v7;
    val[8] = v8; val[9] = v9; val[10] = v10; val[11] = v11;
    for(int i = 12; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13)
{
    static_assert((channels >= 14), "Matx should have at least 14 elements." " " "channels >= 14");
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    val[4] = v4; val[5] = v5; val[6] = v6; val[7] = v7;
    val[8] = v8; val[9] = v9; val[10] = v10; val[11] = v11;
    val[12] = v12; val[13] = v13;
    for (int i = 14; i < channels; i++) val[i] = _Tp(0);
}


template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n>::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13, _Tp v14, _Tp v15)
{
    static_assert((channels >= 16), "Matx should have at least 16 elements." " " "channels >= 16");
    val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    val[4] = v4; val[5] = v5; val[6] = v6; val[7] = v7;
    val[8] = v8; val[9] = v9; val[10] = v10; val[11] = v11;
    val[12] = v12; val[13] = v13; val[14] = v14; val[15] = v15;
    for(int i = 16; i < channels; i++) val[i] = _Tp(0);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n>::Matx(const _Tp* values)
{
    for( int i = 0; i < channels; i++ ) val[i] = values[i];
}














template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n> Matx<_Tp, m, n>::all(_Tp alpha)
{
    Matx<_Tp, m, n> M;
    for( int i = 0; i < m*n; i++ ) M.val[i] = alpha;
    return M;
}

template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n> Matx<_Tp,m,n>::zeros()
{
    return all(0);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n> Matx<_Tp,m,n>::ones()
{
    return all(1);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n> Matx<_Tp,m,n>::eye()
{
    Matx<_Tp,m,n> M;
    for(int i = 0; i < shortdim; i++)
        M(i,i) = 1;
    return M;
}

template<typename _Tp, int m, int n> inline
_Tp Matx<_Tp, m, n>::dot(const Matx<_Tp, m, n>& M) const
{
    _Tp s = 0;
    for( int i = 0; i < channels; i++ ) s += val[i]*M.val[i];
    return s;
}

template<typename _Tp, int m, int n> inline
double Matx<_Tp, m, n>::ddot(const Matx<_Tp, m, n>& M) const
{
    double s = 0;
    for( int i = 0; i < channels; i++ ) s += (double)val[i]*M.val[i];
    return s;
}

template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n> Matx<_Tp,m,n>::diag(const typename Matx<_Tp,m,n>::diag_type& d)
{
    Matx<_Tp,m,n> M;
    for(int i = 0; i < shortdim; i++)
        M(i,i) = d(i, 0);
    return M;
}

template<typename _Tp, int m, int n> template<typename T2>
inline Matx<_Tp, m, n>::operator Matx<T2, m, n>() const
{
    Matx<T2, m, n> M;
    for( int i = 0; i < m*n; i++ ) M.val[i] = saturate_cast<T2>(val[i]);
    return M;
}

template<typename _Tp, int m, int n> template<int m1, int n1> inline
Matx<_Tp, m1, n1> Matx<_Tp, m, n>::reshape() const
{
    static_assert((m1*n1 == m*n), "Input and destnarion matrices must have the same number of elements" " " "m1*n1 == m*n");
    return (const Matx<_Tp, m1, n1>&)*this;
}

template<typename _Tp, int m, int n>
template<int m1, int n1> inline
Matx<_Tp, m1, n1> Matx<_Tp, m, n>::get_minor(int i, int j) const
{
    ;
    Matx<_Tp, m1, n1> s;
    for( int di = 0; di < m1; di++ )
        for( int dj = 0; dj < n1; dj++ )
            s(di, dj) = (*this)(i+di, j+dj);
    return s;
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, 1, n> Matx<_Tp, m, n>::row(int i) const
{
    ;
    return Matx<_Tp, 1, n>(&val[i*n]);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, m, 1> Matx<_Tp, m, n>::col(int j) const
{
    ;
    Matx<_Tp, m, 1> v;
    for( int i = 0; i < m; i++ )
        v.val[i] = val[i*n + j];
    return v;
}

template<typename _Tp, int m, int n> inline
typename Matx<_Tp, m, n>::diag_type Matx<_Tp, m, n>::diag() const
{
    diag_type d;
    for( int i = 0; i < shortdim; i++ )
        d.val[i] = val[i*n + i];
    return d;
}

template<typename _Tp, int m, int n> inline
const _Tp& Matx<_Tp, m, n>::operator()(int i, int j) const
{
    ;
    return this->val[i*n + j];
}

template<typename _Tp, int m, int n> inline
_Tp& Matx<_Tp, m, n>::operator ()(int i, int j)
{
    ;
    return val[i*n + j];
}

template<typename _Tp, int m, int n> inline
const _Tp& Matx<_Tp, m, n>::operator ()(int i) const
{
    static_assert((m == 1 || n == 1), "Single index indexation requires matrix to be a column or a row" " " "m == 1 || n == 1");
    ;
    return val[i];
}

template<typename _Tp, int m, int n> inline
_Tp& Matx<_Tp, m, n>::operator ()(int i)
{
    static_assert((m == 1 || n == 1), "Single index indexation requires matrix to be a column or a row" " " "m == 1 || n == 1");
    ;
    return val[i];
}

template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp)
{
    for( int i = 0; i < channels; i++ )
        val[i] = saturate_cast<_Tp>(a.val[i] + b.val[i]);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp)
{
    for( int i = 0; i < channels; i++ )
        val[i] = saturate_cast<_Tp>(a.val[i] - b.val[i]);
}

template<typename _Tp, int m, int n> template<typename _T2> inline
Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp)
{
    for( int i = 0; i < channels; i++ )
        val[i] = saturate_cast<_Tp>(a.val[i] * alpha);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp)
{
    for( int i = 0; i < channels; i++ )
        val[i] = saturate_cast<_Tp>(a.val[i] * b.val[i]);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_DivOp)
{
    for( int i = 0; i < channels; i++ )
        val[i] = saturate_cast<_Tp>(a.val[i] / b.val[i]);
}

template<typename _Tp, int m, int n> template<int l> inline
Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b, Matx_MatMulOp)
{
    for( int i = 0; i < m; i++ )
        for( int j = 0; j < n; j++ )
        {
            _Tp s = 0;
            for( int k = 0; k < l; k++ )
                s += a(i, k) * b(k, j);
            val[i*n + j] = s;
        }
}

template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n>::Matx(const Matx<_Tp, n, m>& a, Matx_TOp)
{
    for( int i = 0; i < m; i++ )
        for( int j = 0; j < n; j++ )
            val[i*n + j] = a(j, i);
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n> Matx<_Tp, m, n>::mul(const Matx<_Tp, m, n>& a) const
{
    return Matx<_Tp, m, n>(*this, a, Matx_MulOp());
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n> Matx<_Tp, m, n>::div(const Matx<_Tp, m, n>& a) const
{
    return Matx<_Tp, m, n>(*this, a, Matx_DivOp());
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, n, m> Matx<_Tp, m, n>::t() const
{
    return Matx<_Tp, n, m>(*this, Matx_TOp());
}

template<typename _Tp, int m, int n> inline
Vec<_Tp, n> Matx<_Tp, m, n>::solve(const Vec<_Tp, m>& rhs, int method) const
{
    Matx<_Tp, n, 1> x = solve((const Matx<_Tp, m, 1>&)(rhs), method);
    return (Vec<_Tp, n>&)(x);
}

template<typename _Tp, int m> static inline
double determinant(const Matx<_Tp, m, m>& a)
{
    return cv::internal::Matx_DetOp<_Tp, m>()(a);
}

template<typename _Tp, int m, int n> static inline
double trace(const Matx<_Tp, m, n>& a)
{
    _Tp s = 0;
    for( int i = 0; i < std::min(m, n); i++ )
        s += a(i,i);
    return s;
}

template<typename _Tp, int m, int n> static inline
double norm(const Matx<_Tp, m, n>& M)
{
    return std::sqrt(normL2Sqr<_Tp, double>(M.val, m*n));
}

template<typename _Tp, int m, int n> static inline
double norm(const Matx<_Tp, m, n>& M, int normType)
{
    switch(normType) {
    case NORM_INF:
        return (double)normInf<_Tp, typename DataType<_Tp>::work_type>(M.val, m*n);
    case NORM_L1:
        return (double)normL1<_Tp, typename DataType<_Tp>::work_type>(M.val, m*n);
    case NORM_L2SQR:
        return (double)normL2Sqr<_Tp, typename DataType<_Tp>::work_type>(M.val, m*n);
    default:
    case NORM_L2:
        return std::sqrt((double)normL2Sqr<_Tp, typename DataType<_Tp>::work_type>(M.val, m*n));
    }
}





template<typename _Tp, typename _T2, int m, int n> static inline
MatxCommaInitializer<_Tp, m, n> operator << (const Matx<_Tp, m, n>& mtx, _T2 val)
{
    MatxCommaInitializer<_Tp, m, n> commaInitializer((Matx<_Tp, m, n>*)&mtx);
    return (commaInitializer, val);
}

template<typename _Tp, int m, int n> inline
MatxCommaInitializer<_Tp, m, n>::MatxCommaInitializer(Matx<_Tp, m, n>* _mtx)
    : dst(_mtx), idx(0)
{}

template<typename _Tp, int m, int n> template<typename _T2> inline
MatxCommaInitializer<_Tp, m, n>& MatxCommaInitializer<_Tp, m, n>::operator , (_T2 value)
{
    ;
    dst->val[idx++] = saturate_cast<_Tp>(value);
    return *this;
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, m, n> MatxCommaInitializer<_Tp, m, n>::operator *() const
{
    ;
    return *dst;
}





template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec() {}

template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec(_Tp v0)
    : Matx<_Tp, cn, 1>(v0) {}

template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1)
    : Matx<_Tp, cn, 1>(v0, v1) {}

template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2)
    : Matx<_Tp, cn, 1>(v0, v1, v2) {}

template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
    : Matx<_Tp, cn, 1>(v0, v1, v2, v3) {}

template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4)
    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4) {}

template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5)
    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4, v5) {}

template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6)
    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4, v5, v6) {}

template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7)
    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4, v5, v6, v7) {}

template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8)
    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4, v5, v6, v7, v8) {}

template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9)
    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {}

template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13)
    : Matx<_Tp, cn, 1>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) {}

template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec(const _Tp* values)
    : Matx<_Tp, cn, 1>(values) {}







template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec(const Vec<_Tp, cn>& m)
    : Matx<_Tp, cn, 1>(m.val) {}

template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_AddOp op)
    : Matx<_Tp, cn, 1>(a, b, op) {}

template<typename _Tp, int cn> inline
Vec<_Tp, cn>::Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_SubOp op)
    : Matx<_Tp, cn, 1>(a, b, op) {}

template<typename _Tp, int cn> template<typename _T2> inline
Vec<_Tp, cn>::Vec(const Matx<_Tp, cn, 1>& a, _T2 alpha, Matx_ScaleOp op)
    : Matx<_Tp, cn, 1>(a, alpha, op) {}

template<typename _Tp, int cn> inline
Vec<_Tp, cn> Vec<_Tp, cn>::all(_Tp alpha)
{
    Vec v;
    for( int i = 0; i < cn; i++ ) v.val[i] = alpha;
    return v;
}

template<typename _Tp, int cn> inline
Vec<_Tp, cn> Vec<_Tp, cn>::mul(const Vec<_Tp, cn>& v) const
{
    Vec<_Tp, cn> w;
    for( int i = 0; i < cn; i++ ) w.val[i] = saturate_cast<_Tp>(this->val[i]*v.val[i]);
    return w;
}

template<> inline
Vec<float, 2> Vec<float, 2>::conj() const
{
    return cv::internal::conjugate(*this);
}

template<> inline
Vec<double, 2> Vec<double, 2>::conj() const
{
    return cv::internal::conjugate(*this);
}

template<> inline
Vec<float, 4> Vec<float, 4>::conj() const
{
    return cv::internal::conjugate(*this);
}

template<> inline
Vec<double, 4> Vec<double, 4>::conj() const
{
    return cv::internal::conjugate(*this);
}

template<typename _Tp, int cn> inline
Vec<_Tp, cn> Vec<_Tp, cn>::cross(const Vec<_Tp, cn>&) const
{
    static_assert((cn == 3), "for arbitrary-size vector there is no cross-product defined" " " "cn == 3");
    return Vec<_Tp, cn>();
}

template<> inline
Vec<float, 3> Vec<float, 3>::cross(const Vec<float, 3>& v) const
{
    return Vec<float,3>(this->val[1]*v.val[2] - this->val[2]*v.val[1],
                     this->val[2]*v.val[0] - this->val[0]*v.val[2],
                     this->val[0]*v.val[1] - this->val[1]*v.val[0]);
}

template<> inline
Vec<double, 3> Vec<double, 3>::cross(const Vec<double, 3>& v) const
{
    return Vec<double,3>(this->val[1]*v.val[2] - this->val[2]*v.val[1],
                     this->val[2]*v.val[0] - this->val[0]*v.val[2],
                     this->val[0]*v.val[1] - this->val[1]*v.val[0]);
}

template<typename _Tp, int cn> template<typename T2> inline
Vec<_Tp, cn>::operator Vec<T2, cn>() const
{
    Vec<T2, cn> v;
    for( int i = 0; i < cn; i++ ) v.val[i] = saturate_cast<T2>(this->val[i]);
    return v;
}

template<typename _Tp, int cn> inline
const _Tp& Vec<_Tp, cn>::operator [](int i) const
{
    ;
    return this->val[i];
}

template<typename _Tp, int cn> inline
_Tp& Vec<_Tp, cn>::operator [](int i)
{
    ;
    return this->val[i];
}

template<typename _Tp, int cn> inline
const _Tp& Vec<_Tp, cn>::operator ()(int i) const
{
    ;
    return this->val[i];
}

template<typename _Tp, int cn> inline
_Tp& Vec<_Tp, cn>::operator ()(int i)
{
    ;
    return this->val[i];
}

template<typename _Tp, int cn> inline
Vec<_Tp, cn> normalize(const Vec<_Tp, cn>& v)
{
    double nv = norm(v);
    return v * (nv ? 1./nv : 0.);
}






template<typename _Tp, typename _T2, int cn> static inline
VecCommaInitializer<_Tp, cn> operator << (const Vec<_Tp, cn>& vec, _T2 val)
{
    VecCommaInitializer<_Tp, cn> commaInitializer((Vec<_Tp, cn>*)&vec);
    return (commaInitializer, val);
}

template<typename _Tp, int cn> inline
VecCommaInitializer<_Tp, cn>::VecCommaInitializer(Vec<_Tp, cn>* _vec)
    : MatxCommaInitializer<_Tp, cn, 1>(_vec)
{}

template<typename _Tp, int cn> template<typename _T2> inline
VecCommaInitializer<_Tp, cn>& VecCommaInitializer<_Tp, cn>::operator , (_T2 value)
{
    ;
    this->dst->val[this->idx++] = saturate_cast<_Tp>(value);
    return *this;
}

template<typename _Tp, int cn> inline
Vec<_Tp, cn> VecCommaInitializer<_Tp, cn>::operator *() const
{
    ;
    return *this->dst;
}








template<typename _Tp1, typename _Tp2, int m, int n> static inline
Matx<_Tp1, m, n>& operator += (Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)
{
    for( int i = 0; i < m*n; i++ )
        a.val[i] = saturate_cast<_Tp1>(a.val[i] + b.val[i]);
    return a;
}

template<typename _Tp1, typename _Tp2, int m, int n> static inline
Matx<_Tp1, m, n>& operator -= (Matx<_Tp1, m, n>& a, const Matx<_Tp2, m, n>& b)
{
    for( int i = 0; i < m*n; i++ )
        a.val[i] = saturate_cast<_Tp1>(a.val[i] - b.val[i]);
    return a;
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator + (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
{
    return Matx<_Tp, m, n>(a, b, Matx_AddOp());
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator - (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
{
    return Matx<_Tp, m, n>(a, b, Matx_SubOp());
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, int alpha)
{
    for( int i = 0; i < m*n; i++ )
        a.val[i] = saturate_cast<_Tp>(a.val[i] * alpha);
    return a;
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, float alpha)
{
    for( int i = 0; i < m*n; i++ )
        a.val[i] = saturate_cast<_Tp>(a.val[i] * alpha);
    return a;
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n>& operator *= (Matx<_Tp, m, n>& a, double alpha)
{
    for( int i = 0; i < m*n; i++ )
        a.val[i] = saturate_cast<_Tp>(a.val[i] * alpha);
    return a;
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, int alpha)
{
    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, float alpha)
{
    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, double alpha)
{
    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator * (int alpha, const Matx<_Tp, m, n>& a)
{
    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator * (float alpha, const Matx<_Tp, m, n>& a)
{
    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator * (double alpha, const Matx<_Tp, m, n>& a)
{
    return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int m, int n> static inline
Matx<_Tp, m, n> operator - (const Matx<_Tp, m, n>& a)
{
    return Matx<_Tp, m, n>(a, -1, Matx_ScaleOp());
}

template<typename _Tp, int m, int n, int l> static inline
Matx<_Tp, m, n> operator * (const Matx<_Tp, m, l>& a, const Matx<_Tp, l, n>& b)
{
    return Matx<_Tp, m, n>(a, b, Matx_MatMulOp());
}

template<typename _Tp, int m, int n> static inline
Vec<_Tp, m> operator * (const Matx<_Tp, m, n>& a, const Vec<_Tp, n>& b)
{
    Matx<_Tp, m, 1> c(a, b, Matx_MatMulOp());
    return (const Vec<_Tp, m>&)(c);
}

template<typename _Tp, int m, int n> static inline
bool operator == (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
{
    for( int i = 0; i < m*n; i++ )
        if( a.val[i] != b.val[i] ) return false;
    return true;
}

template<typename _Tp, int m, int n> static inline
bool operator != (const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b)
{
    return !(a == b);
}








template<typename _Tp1, typename _Tp2, int cn> static inline
Vec<_Tp1, cn>& operator += (Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)
{
    for( int i = 0; i < cn; i++ )
        a.val[i] = saturate_cast<_Tp1>(a.val[i] + b.val[i]);
    return a;
}

template<typename _Tp1, typename _Tp2, int cn> static inline
Vec<_Tp1, cn>& operator -= (Vec<_Tp1, cn>& a, const Vec<_Tp2, cn>& b)
{
    for( int i = 0; i < cn; i++ )
        a.val[i] = saturate_cast<_Tp1>(a.val[i] - b.val[i]);
    return a;
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn> operator + (const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)
{
    return Vec<_Tp, cn>(a, b, Matx_AddOp());
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn> operator - (const Vec<_Tp, cn>& a, const Vec<_Tp, cn>& b)
{
    return Vec<_Tp, cn>(a, b, Matx_SubOp());
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn>& operator *= (Vec<_Tp, cn>& a, int alpha)
{
    for( int i = 0; i < cn; i++ )
        a[i] = saturate_cast<_Tp>(a[i]*alpha);
    return a;
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn>& operator *= (Vec<_Tp, cn>& a, float alpha)
{
    for( int i = 0; i < cn; i++ )
        a[i] = saturate_cast<_Tp>(a[i]*alpha);
    return a;
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn>& operator *= (Vec<_Tp, cn>& a, double alpha)
{
    for( int i = 0; i < cn; i++ )
        a[i] = saturate_cast<_Tp>(a[i]*alpha);
    return a;
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn>& operator /= (Vec<_Tp, cn>& a, int alpha)
{
    double ialpha = 1./alpha;
    for( int i = 0; i < cn; i++ )
        a[i] = saturate_cast<_Tp>(a[i]*ialpha);
    return a;
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn>& operator /= (Vec<_Tp, cn>& a, float alpha)
{
    float ialpha = 1.f/alpha;
    for( int i = 0; i < cn; i++ )
        a[i] = saturate_cast<_Tp>(a[i]*ialpha);
    return a;
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn>& operator /= (Vec<_Tp, cn>& a, double alpha)
{
    double ialpha = 1./alpha;
    for( int i = 0; i < cn; i++ )
        a[i] = saturate_cast<_Tp>(a[i]*ialpha);
    return a;
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn> operator * (const Vec<_Tp, cn>& a, int alpha)
{
    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn> operator * (int alpha, const Vec<_Tp, cn>& a)
{
    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn> operator * (const Vec<_Tp, cn>& a, float alpha)
{
    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn> operator * (float alpha, const Vec<_Tp, cn>& a)
{
    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn> operator * (const Vec<_Tp, cn>& a, double alpha)
{
    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn> operator * (double alpha, const Vec<_Tp, cn>& a)
{
    return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn> operator / (const Vec<_Tp, cn>& a, int alpha)
{
    return Vec<_Tp, cn>(a, 1./alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn> operator / (const Vec<_Tp, cn>& a, float alpha)
{
    return Vec<_Tp, cn>(a, 1.f/alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn> operator / (const Vec<_Tp, cn>& a, double alpha)
{
    return Vec<_Tp, cn>(a, 1./alpha, Matx_ScaleOp());
}

template<typename _Tp, int cn> static inline
Vec<_Tp, cn> operator - (const Vec<_Tp, cn>& a)
{
    Vec<_Tp,cn> t;
    for( int i = 0; i < cn; i++ ) t.val[i] = saturate_cast<_Tp>(-a.val[i]);
    return t;
}

template<typename _Tp> inline Vec<_Tp, 4> operator * (const Vec<_Tp, 4>& v1, const Vec<_Tp, 4>& v2)
{
    return Vec<_Tp, 4>(saturate_cast<_Tp>(v1[0]*v2[0] - v1[1]*v2[1] - v1[2]*v2[2] - v1[3]*v2[3]),
                       saturate_cast<_Tp>(v1[0]*v2[1] + v1[1]*v2[0] + v1[2]*v2[3] - v1[3]*v2[2]),
                       saturate_cast<_Tp>(v1[0]*v2[2] - v1[1]*v2[3] + v1[2]*v2[0] + v1[3]*v2[1]),
                       saturate_cast<_Tp>(v1[0]*v2[3] + v1[1]*v2[2] - v1[2]*v2[1] + v1[3]*v2[0]));
}

template<typename _Tp> inline Vec<_Tp, 4>& operator *= (Vec<_Tp, 4>& v1, const Vec<_Tp, 4>& v2)
{
    v1 = v1 * v2;
    return v1;
}



} 

#line 1449 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/matx.hpp"

#line 58 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types.hpp"




















































#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

#pragma once






 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4127)
 #pragma warning(disable: 4244)

namespace std {
 

		
template<class _Myvec>
	class _Vector_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			typename _Myvec::value_type,
			typename _Myvec::difference_type,
			typename _Myvec::const_pointer,
			typename _Myvec::const_reference,
			_Iterator_base>
	{	
public:
	typedef _Vector_const_iterator<_Myvec> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Myvec::value_type value_type;
	typedef typename _Myvec::difference_type difference_type;
	typedef typename _Myvec::const_pointer pointer;
	typedef typename _Myvec::const_reference reference;
	typedef typename _Myvec::pointer _Tptr;

	_Vector_const_iterator()
		: _Ptr()
		{	
		}

	_Vector_const_iterator(_Tptr _Parg, const _Container_base *_Pvector)
		: _Ptr(_Parg)
		{	
		this->_Adopt(_Pvector);
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = (_Tptr)_Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr));
		}

	reference operator*() const
		{	
 









#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"





#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

		;

		return (*this->_Ptr);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 








#line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"




#line 111 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

		++this->_Ptr;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 








#line 135 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"




#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

		--this->_Ptr;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
 








#line 164 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"




#line 169 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

		_Ptr += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr - _Right._Ptr);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr < _Right._Ptr);
		}

	bool operator>(const _Myiter& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	
		return (!(*this < _Right));
		}

 










#line 246 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"






#line 253 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"
	void _Compat(const _Myiter&) const
		{	
		}
 #line 257 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

	_Tptr _Ptr;	
	};

template<class _Myvec> inline
	typename _Vector_const_iterator<_Myvec>::_Unchecked_type
		_Unchecked(_Vector_const_iterator<_Myvec> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Myvec> inline
	_Vector_const_iterator<_Myvec>&
		_Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
			typename _Vector_const_iterator<_Myvec>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Myvec> inline
	_Vector_const_iterator<_Myvec> operator+(
		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
		_Vector_const_iterator<_Myvec> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Myvec>
	class _Vector_iterator
		: public _Vector_const_iterator<_Myvec>
	{	
public:
	typedef _Vector_iterator<_Myvec> _Myiter;
	typedef _Vector_const_iterator<_Myvec> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Myvec::value_type value_type;
	typedef typename _Myvec::difference_type difference_type;
	typedef typename _Myvec::pointer pointer;
	typedef typename _Myvec::reference reference;

	_Vector_iterator()
		{	
		}

	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
		: _Mybase(_Parg, _Pvector)
		{	
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr));
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Myvec> inline
	typename _Vector_iterator<_Myvec>::_Unchecked_type
		_Unchecked(_Vector_iterator<_Myvec> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Myvec> inline
	_Vector_iterator<_Myvec>&
		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
			typename _Vector_iterator<_Myvec>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Myvec> inline
	_Vector_iterator<_Myvec> operator+(
		typename _Vector_iterator<_Myvec>::difference_type _Off,
		_Vector_iterator<_Myvec> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference>
	struct _Vec_iter_types
	{	
	typedef _Value_type value_type;
	typedef _Size_type size_type;
	typedef _Difference_type difference_type;
	typedef _Pointer pointer;
	typedef _Const_pointer const_pointer;
	typedef _Reference reference;
	typedef _Const_reference const_reference;
	};

template<class _Ty,
	class _Alloc0>
	struct _Vec_base_types
	{	
	typedef _Alloc0 _Alloc;
	typedef _Vec_base_types<_Ty, _Alloc> _Myt;

 
	typedef _Wrap_alloc<_Alloc> _Alty0;
	typedef typename _Alty0::template rebind<_Ty>::other _Alty;

 

#line 449 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

	typedef typename _Alty::pointer _Tptr;
	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;

	typedef typename _If<_Is_simple_alloc<_Alty>::value,
		_Simple_types<typename _Alty::value_type>,
		_Vec_iter_types<typename _Alty::value_type,
			typename _Alty::size_type,
			typename _Alty::difference_type,
			typename _Alty::pointer,
			typename _Alty::const_pointer,
			typename _Alty::reference,
			typename _Alty::const_reference> >::type
		_Val_types;
	};

		
template<class _Val_types>
	class _Vector_val
		: public _Container_base
	{	
public:
	typedef _Vector_val<_Val_types> _Myt;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _Vector_iterator<_Myt> iterator;
	typedef _Vector_const_iterator<_Myt> const_iterator;

	_Vector_val()
		{	
		_Myfirst = pointer();
		_Mylast = pointer();
		_Myend = pointer();
		}

	pointer _Myfirst;	
	pointer _Mylast;	
	pointer _Myend;	
	};

		
template<bool _Al_has_storage,
	class _Alloc_types>
	class _Vector_alloc
		: public _Vector_val<typename _Alloc_types::_Val_types>
	{	
public:
	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
	typedef typename _Alloc_types::_Alloc _Alloc;

	typedef typename _Alloc_types::_Alty _Alty;

 
	_Vector_alloc(const _Alloc& _Al = _Alloc())
		: _Alval(_Al)
		{	
		}

	void _Change_alloc(const _Alty& _Al)
		{	
		_Alval = _Al;
		}

	void _Swap_alloc(_Myt& _Right)
		{	
		_Swap_adl(this->_Alval, _Right._Alval);
		}

 










































#line 568 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

	_Alty& _Getal()
		{	
		return (_Alval);
		}

	const _Alty& _Getal() const
		{	
		return (_Alval);
		}

	_Alty _Alval;	
	};

template<class _Alloc_types>
	class _Vector_alloc<false, _Alloc_types>
		: public _Vector_val<typename _Alloc_types::_Val_types>
	{	
public:
	typedef _Vector_alloc<false, _Alloc_types> _Myt;
	typedef typename _Alloc_types::_Alloc _Alloc;

	typedef typename _Alloc_types::_Alty _Alty;

 
	_Vector_alloc(const _Alloc& = _Alloc())
		{	
		}

	void _Change_alloc(const _Alty&)
		{	
		}

	void _Swap_alloc(_Myt&)
		{	
		}

 





































#line 644 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

	_Alty _Getal() const
		{	
		return (_Alty());
		}
	};

		
template<class _Ty,
	class _Alloc = allocator<_Ty> >
	class vector
		: public _Vector_alloc<!is_empty<_Alloc>::value,
			_Vec_base_types<_Ty, _Alloc> >
	{	
public:
	typedef vector<_Ty, _Alloc> _Myt;
	typedef _Vector_alloc<!is_empty<_Alloc>::value,
		_Vec_base_types<_Ty, _Alloc> > _Mybase;
	typedef _Alloc allocator_type;

	typedef typename _Mybase::_Alty _Alty;

	typedef typename _Mybase::value_type value_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;

 
 

	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;

	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	vector()
		: _Mybase()
		{	
		}

	explicit vector(const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		}

	explicit vector(size_type _Count)
		: _Mybase()
		{	
		resize(_Count);
		}

	vector(size_type _Count, const value_type& _Val)
		: _Mybase()
		{	
		_Construct_n(_Count, ::std:: addressof(_Val));
		}

	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Construct_n(_Count, ::std:: addressof(_Val));
		}

	vector(const _Myt& _Right)

 
		: _Mybase(_Right._Getal().select_on_container_copy_construction())

 

#line 719 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

		{	
		if (_Buy(_Right.size()))
			try {
			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
				this->_Myfirst);
			} catch (...) {
			_Tidy();
			throw;
			}
		}

	vector(const _Myt& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		if (_Buy(_Right.size()))
			try {
			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
				this->_Myfirst);
			} catch (...) {
			_Tidy();
			throw;
			}
		}

	template<class _Iter>
		vector(_Iter _First, _Iter _Last,
			typename enable_if<_Is_iterator<_Iter>::value,
				void>:: type ** = 0)
		: _Mybase()
		{	
		_Construct(_First, _Last);
		}

	template<class _Iter>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al,
			typename enable_if<_Is_iterator<_Iter>::value,
				void>:: type ** = 0)
		: _Mybase(_Al)
		{	
		_Construct(_First, _Last);
		}

	template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last)
		{	
		try {
		insert(begin(), _First, _Last);
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	void _Construct_n(size_type _Count, const value_type *_Pval)
		{	
		if (_Buy(_Count))
			{	
			try {
			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

	vector(_Myt&& _Right)
		: _Mybase(_Right._Getal())
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	vector(_Myt&& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		if (this->_Getal() != _Right._Getal())
			assign(::std:: make_move_iterator(_Right.begin()),
				::std:: make_move_iterator(_Right.end()));
		else
			_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Tidy();

 
			if (this->_Getal() != _Right._Getal()
				&& _Alty::propagate_on_container_move_assignment::value)
				this->_Change_alloc(_Right._Getal());
 #line 813 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

			if (this->_Getal() != _Right._Getal())
				assign(::std:: make_move_iterator(_Right.begin()),
					::std:: make_move_iterator(_Right.end()));
			else
				_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		this->_Swap_all((_Myt&)_Right);
		this->_Myfirst = _Right._Myfirst;
		this->_Mylast = _Right._Mylast;
		this->_Myend = _Right._Myend;

		_Right._Myfirst = pointer();
		_Right._Mylast = pointer();
		_Right._Myend = pointer();
		}

	void push_back(value_type&& _Val)
		{	
		if (_Inside(::std:: addressof(_Val)))
			{	
			size_type _Idx = ::std:: addressof(_Val) - this->_Myfirst;
			if (this->_Mylast == this->_Myend)
				_Reserve(1);
			_Orphan_range(this->_Mylast, this->_Mylast);
			this->_Getal().construct(this->_Mylast,
				::std:: forward<value_type>(this->_Myfirst[_Idx]));
			++this->_Mylast;
			}
		else
			{	
			if (this->_Mylast == this->_Myend)
				_Reserve(1);
			_Orphan_range(this->_Mylast, this->_Mylast);
			this->_Getal().construct(this->_Mylast,
				::std:: forward<value_type>(_Val));
			++this->_Mylast;
			}
		}

	iterator insert(const_iterator _Where, _Ty&& _Val)
		{	
		return (emplace(_Where, ::std:: move(_Val)));
		}























 




#line 891 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

 #line 893 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

 void emplace_back() { if (this->_Mylast == this->_Myend) _Reserve(1); _Orphan_range(this->_Mylast, this->_Mylast); this->_Getal().construct(this->_Mylast  ); ++this->_Mylast; }  iterator emplace(const_iterator _Where  ) { size_type _Off = (_Where)._Ptr - this->_Myfirst;  emplace_back(); ::std:: rotate(begin() + _Off, end() - 1, end()); return (begin() + _Off); } template<class _V0_t> void emplace_back(_V0_t&& _V0) { if (this->_Mylast == this->_Myend) _Reserve(1); _Orphan_range(this->_Mylast, this->_Mylast); this->_Getal().construct(this->_Mylast , ::std:: forward<_V0_t>(_V0)); ++this->_Mylast; } template<class _V0_t> iterator emplace(const_iterator _Where , _V0_t&& _V0) { size_type _Off = (_Where)._Ptr - this->_Myfirst;  emplace_back(::std:: forward<_V0_t>(_V0)); ::std:: rotate(begin() + _Off, end() - 1, end()); return (begin() + _Off); } template<class _V0_t , class _V1_t> void emplace_back(_V0_t&& _V0 , _V1_t&& _V1) { if (this->_Mylast == this->_Myend) _Reserve(1); _Orphan_range(this->_Mylast, this->_Mylast); this->_Getal().construct(this->_Mylast , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1)); ++this->_Mylast; } template<class _V0_t , class _V1_t> iterator emplace(const_iterator _Where , _V0_t&& _V0 , _V1_t&& _V1) { size_type _Off = (_Where)._Ptr - this->_Myfirst;  emplace_back(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1)); ::std:: rotate(begin() + _Off, end() - 1, end()); return (begin() + _Off); } template<class _V0_t , class _V1_t , class _V2_t> void emplace_back(_V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2) { if (this->_Mylast == this->_Myend) _Reserve(1); _Orphan_range(this->_Mylast, this->_Mylast); this->_Getal().construct(this->_Mylast , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2)); ++this->_Mylast; } template<class _V0_t , class _V1_t , class _V2_t> iterator emplace(const_iterator _Where , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2) { size_type _Off = (_Where)._Ptr - this->_Myfirst;  emplace_back(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2)); ::std:: rotate(begin() + _Off, end() - 1, end()); return (begin() + _Off); } template<class _V0_t , class _V1_t , class _V2_t , class _V3_t> void emplace_back(_V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3) { if (this->_Mylast == this->_Myend) _Reserve(1); _Orphan_range(this->_Mylast, this->_Mylast); this->_Getal().construct(this->_Mylast , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3)); ++this->_Mylast; } template<class _V0_t , class _V1_t , class _V2_t , class _V3_t> iterator emplace(const_iterator _Where , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3) { size_type _Off = (_Where)._Ptr - this->_Myfirst;  emplace_back(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3)); ::std:: rotate(begin() + _Off, end() - 1, end()); return (begin() + _Off); } template<class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> void emplace_back(_V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3 , _V4_t&& _V4) { if (this->_Mylast == this->_Myend) _Reserve(1); _Orphan_range(this->_Mylast, this->_Mylast); this->_Getal().construct(this->_Mylast , ::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3) , ::std:: forward<_V4_t>(_V4)); ++this->_Mylast; } template<class _V0_t , class _V1_t , class _V2_t , class _V3_t , class _V4_t> iterator emplace(const_iterator _Where , _V0_t&& _V0 , _V1_t&& _V1 , _V2_t&& _V2 , _V3_t&& _V3 , _V4_t&& _V4) { size_type _Off = (_Where)._Ptr - this->_Myfirst;  emplace_back(::std:: forward<_V0_t>(_V0) , ::std:: forward<_V1_t>(_V1) , ::std:: forward<_V2_t>(_V2) , ::std:: forward<_V3_t>(_V3) , ::std:: forward<_V4_t>(_V4)); ::std:: rotate(begin() + _Off, end() - 1, end()); return (begin() + _Off); }



	~vector() throw ()
		{	
		_Tidy();
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
 
			if (this->_Getal() != _Right._Getal()
				&& _Alty::propagate_on_container_copy_assignment::value)
				{	
				_Tidy();
				this->_Change_alloc(_Right._Getal());
				}
 #line 915 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

			this->_Orphan_all();

			if (_Right.empty())
				clear();	
			else if (_Right.size() <= size())
				{	
				pointer _Ptr = _Copy_impl(_Right._Myfirst,
					_Right._Mylast, this->_Myfirst);	
				_Destroy(_Ptr, this->_Mylast);	
				this->_Mylast = this->_Myfirst + _Right.size();
				}
			else if (_Right.size() <= capacity())
				{	
				pointer _Ptr = _Right._Myfirst + size();
				_Copy_impl(_Right._Myfirst,
					_Ptr, this->_Myfirst);
				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
				}
			else
				{	
				if (this->_Myfirst != pointer())
					{	
					_Destroy(this->_Myfirst, this->_Mylast);
					this->_Getal().deallocate(this->_Myfirst,
						this->_Myend - this->_Myfirst);
					}
				if (_Buy(_Right.size()))
					try {
					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
						this->_Myfirst);
					} catch (...) {
					_Tidy();
					throw;
					}
				}
			}
		return (*this);
		}

	void reserve(size_type _Count)
		{	
		if (capacity() < _Count)
			{	
			if (max_size() < _Count)
				_Xlen();
			_Reallocate(_Count);
			}
		}

	size_type capacity() const throw ()
		{	
		return (this->_Myend - this->_Myfirst);
		}

	size_type _Unused_capacity() const throw ()
		{	
		return (this->_Myend - this->_Mylast);
		}

	size_type _Has_unused_capacity() const throw ()
		{	
		return (this->_Myend != this->_Mylast);
		}

	iterator begin() throw ()
		{	
		return (iterator(this->_Myfirst, this));
		}

	const_iterator begin() const throw ()
		{	
		return (const_iterator(this->_Myfirst, this));
		}

	iterator end() throw ()
		{	
		return (iterator(this->_Mylast, this));
		}

	const_iterator end() const throw ()
		{	
		return (const_iterator(this->_Mylast, this));
		}

	iterator _Make_iter(const_iterator _Where) const
		{	
		return (iterator(_Where._Ptr, this));
		}

	reverse_iterator rbegin() throw ()
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const throw ()
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() throw ()
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const throw ()
		{	
		return (const_reverse_iterator(begin()));
		}

 
	const_iterator cbegin() const throw ()
		{	
		return (((const _Myt *)this)->begin());
		}

	const_iterator cend() const throw ()
		{	
		return (((const _Myt *)this)->end());
		}

	const_reverse_iterator crbegin() const throw ()
		{	
		return (((const _Myt *)this)->rbegin());
		}

	const_reverse_iterator crend() const throw ()
		{	
		return (((const _Myt *)this)->rend());
		}

	void shrink_to_fit()
		{	
		if (_Has_unused_capacity())
			{	
			if (empty())
				_Tidy();
			else
				_Reallocate(size());
			}
		}
 #line 1057 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

	void resize(size_type _Newsize)
		{	
		if (_Newsize < size())
			erase(begin() + _Newsize, end());
		else if (size() < _Newsize)
			{	
			_Alty _Alval(this->_Getal());
			_Reserve(_Newsize - size());
			try {
			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
				_Alval);
			} catch (...) {
			_Tidy();
			throw;
			}
			this->_Mylast += _Newsize - size();
			}
		}

	void resize(size_type _Newsize, const value_type& _Val)
		{	
		if (_Newsize < size())
			erase(begin() + _Newsize, end());
		else if (size() < _Newsize)
			_Insert_n(end(), _Newsize - size(), _Val);
		}

	size_type size() const throw ()
		{	
		return (this->_Mylast - this->_Myfirst);
		}

	size_type max_size() const throw ()
		{	
		return (this->_Getal().max_size());
		}

	bool empty() const throw ()
		{	
		return (this->_Myfirst == this->_Mylast);
		}

	_Alloc get_allocator() const throw ()
		{	
		return (this->_Getal());
		}

	const_reference at(size_type _Pos) const
		{	
		if (size() <= _Pos)
			_Xran();
		return (*(this->_Myfirst + _Pos));
		}

	reference at(size_type _Pos)
		{	
		if (size() <= _Pos)
			_Xran();
		return (*(this->_Myfirst + _Pos));
		}

	const_reference operator[](size_type _Pos) const
		{	
 






#line 1129 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

#line 1131 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

		return (*(this->_Myfirst + _Pos));
		}

	reference operator[](size_type _Pos)
		{	
 






#line 1145 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

#line 1147 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

		return (*(this->_Myfirst + _Pos));
		}

 
	pointer data() throw ()
		{	
		return (this->_Myfirst);
		}

	const_pointer data() const throw ()
		{	
		return (this->_Myfirst);
		}
 #line 1162 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}

	void push_back(const value_type& _Val)
		{	
		if (_Inside(::std:: addressof(_Val)))
			{	
			size_type _Idx = ::std:: addressof(_Val) - this->_Myfirst;
			if (this->_Mylast == this->_Myend)
				_Reserve(1);
			_Orphan_range(this->_Mylast, this->_Mylast);
			this->_Getal().construct(this->_Mylast,
				this->_Myfirst[_Idx]);
			++this->_Mylast;
			}
		else
			{	
			if (this->_Mylast == this->_Myend)
				_Reserve(1);
			_Orphan_range(this->_Mylast, this->_Mylast);
			this->_Getal().construct(this->_Mylast,
				_Val);
			++this->_Mylast;
			}
		}

 












#line 1220 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"
	void pop_back()
		{	
		if (!empty())
			{	
			this->_Getal().destroy(this->_Mylast - 1);
			--this->_Mylast;
			}
		}
 #line 1229 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			void>::type
		assign(_Iter _First, _Iter _Last)
		{	
		erase(begin(), end());
		insert(begin(), _First, _Last);
		}

	void assign(size_type _Count, const value_type& _Val)
		{	
		_Assign_n(_Count, _Val);
		}

	iterator insert(const_iterator _Where, const _Ty& _Val)
		{	
		return (_Insert_n(_Where, (size_type)1, _Val));
		}

	iterator insert(const_iterator _Where, size_type _Count,
		const _Ty& _Val)
		{	
		return (_Insert_n(_Where, _Count, _Val));
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			iterator>::type
		insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	
		size_type _Off = (_Where)._Ptr - this->_Myfirst;
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		return (begin() + _Off);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
			input_iterator_tag)
		{	
		size_type _Off = (_Where)._Ptr - this->_Myfirst;

 


#line 1275 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

		if (_First != _Last)
			{	
			size_type _Oldsize = size();

			try {
			for (; _First != _Last; ++_First)
				push_back(*_First);	

			} catch (...) {
			erase(begin() + _Oldsize, end());
			throw;
			}

			::std:: rotate(begin() + _Off, begin() + _Oldsize, end());
			}
		}

	template<class _Iter>
		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
			forward_iterator_tag)
		{	
 





#line 1304 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

		size_type _Count = 0;
		_Distance(_First, _Last, _Count);

		if (_Count == 0)
			;
		else if (_Unused_capacity() < _Count)
			{	
			if (max_size() - size() < _Count)
				_Xlen();	

			size_type _Capacity = _Grow_to(size() + _Count);
			pointer _Newvec = this->_Getal().allocate(_Capacity);
			pointer _Ptr = _Newvec;

			try {
			_Ptr = _Umove(this->_Myfirst, (_Where)._Ptr,
				_Newvec);	
			_Ptr = _Ucopy(_First, _Last, _Ptr);	
			_Umove((_Where)._Ptr, this->_Mylast,
				_Ptr);	
			} catch (...) {
			_Destroy(_Newvec, _Ptr);
			this->_Getal().deallocate(_Newvec, _Capacity);
			throw;
			}

			_Count += size();
			if (this->_Myfirst != pointer())
				{	
				_Destroy(this->_Myfirst, this->_Mylast);
				this->_Getal().deallocate(this->_Myfirst,
					this->_Myend - this->_Myfirst);
				}

			this->_Orphan_all();
			this->_Myend = _Newvec + _Capacity;
			this->_Mylast = _Newvec + _Count;
			this->_Myfirst = _Newvec;
			}
		else
			{	
			_Ucopy(_First, _Last, this->_Mylast);
			::std:: rotate((_Where)._Ptr, this->_Mylast,
				this->_Mylast + _Count);
			this->_Mylast += _Count;
			_Orphan_range((_Where)._Ptr, this->_Mylast);
			}
		}

 













#line 1369 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"
	iterator erase(const_iterator _Where)
		{	
		_Move((_Where)._Ptr + 1, this->_Mylast,
			(_Where)._Ptr);
		_Destroy(this->_Mylast - 1, this->_Mylast);
		--this->_Mylast;
		return (_Make_iter(_Where));
		}
 #line 1378 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

	iterator erase(const_iterator _First_arg,
		const_iterator _Last_arg)
		{	
		if (_First_arg == begin() && _Last_arg == end())
			clear();
		else if (_First_arg != _Last_arg)
			{	
			iterator _First = _Make_iter(_First_arg);
			iterator _Last = _Make_iter(_Last_arg);

			if (_First != _Last)
				{	
 








#line 1401 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"
				pointer _Ptr = _Move((_Last)._Ptr, this->_Mylast,
					(_First)._Ptr);
 #line 1404 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

				_Destroy(_Ptr, this->_Mylast);
				this->_Mylast = _Ptr;
				}
			}
		return (_Make_iter(_First_arg));
		}

	void clear() throw ()
		{	
		this->_Orphan_all();
		_Destroy(this->_Myfirst, this->_Mylast);
		this->_Mylast = this->_Myfirst;
		}

	void swap(_Myt& _Right)
		{	
		if (this == &_Right)
			;	
		else if (this->_Getal() == _Right._Getal())
			{	
			this->_Swap_all(_Right);
			_Swap_adl(this->_Myfirst, _Right._Myfirst);
			_Swap_adl(this->_Mylast, _Right._Mylast);
			_Swap_adl(this->_Myend, _Right._Myend);
			}

 
		else if (_Alty::propagate_on_container_swap::value)
			{	
			this->_Swap_alloc(_Right);
			_Swap_adl(this->_Myfirst, _Right._Myfirst);
			_Swap_adl(this->_Mylast, _Right._Mylast);
			_Swap_adl(this->_Myend, _Right._Myend);
			}
 #line 1440 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

		else
			{	
			_Myt _Ts = _Move(*this);

			*this = _Move(_Right);
			_Right = _Move(_Ts);
			}
		}

protected:
	void _Assign_n(size_type _Count, const value_type& _Val)
		{	
		value_type _Tmp = _Val;	
		erase(begin(), end());
		insert(begin(), _Count, _Tmp);
		}

	bool _Buy(size_type _Capacity)
		{	
		this->_Myfirst = pointer();
		this->_Mylast = pointer();
		this->_Myend = pointer();

		if (_Capacity == 0)
			return (false);
		else if (max_size() < _Capacity)
			_Xlen();	
		else
			{	
			this->_Myfirst = this->_Getal().allocate(_Capacity);
			this->_Mylast = this->_Myfirst;
			this->_Myend = this->_Myfirst + _Capacity;
			}
		return (true);
		}

	void _Destroy(pointer _First, pointer _Last)
		{	
		_Alty _Alval(this->_Getal());
		_Destroy_range(_First, _Last, _Alval);
		}

	size_type _Grow_to(size_type _Count) const
		{	
		size_type _Capacity = capacity();

		_Capacity = max_size() - _Capacity / 2 < _Capacity
			? 0 : _Capacity + _Capacity / 2;	
		if (_Capacity < _Count)
			_Capacity = _Count;
		return (_Capacity);
		}

	bool _Inside(const value_type *_Ptr) const
		{	
		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
		}

	void _Reallocate(size_type _Count)
		{	
		pointer _Ptr = this->_Getal().allocate(_Count);

		try {
		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
		} catch (...) {
		this->_Getal().deallocate(_Ptr, _Count);
		throw;
		}

		size_type _Size = size();
		if (this->_Myfirst != pointer())
			{	
			_Destroy(this->_Myfirst, this->_Mylast);
			this->_Getal().deallocate(this->_Myfirst,
				this->_Myend - this->_Myfirst);
			}

		this->_Orphan_all();
		this->_Myend = _Ptr + _Count;
		this->_Mylast = _Ptr + _Size;
		this->_Myfirst = _Ptr;
		}

	void _Reserve(size_type _Count)
		{	
		if (_Unused_capacity() < _Count)
			{	
			if (max_size() - size() < _Count)
				_Xlen();
			_Reallocate(_Grow_to(size() + _Count));
			}
		}

	void _Tidy()
		{	
		if (this->_Myfirst != pointer())
			{	
			this->_Orphan_all();
			_Destroy(this->_Myfirst, this->_Mylast);
			this->_Getal().deallocate(this->_Myfirst,
				this->_Myend - this->_Myfirst);
			this->_Myfirst = pointer();
			this->_Mylast = pointer();
			this->_Myend = pointer();
			}
		}

	template<class _Iter>
		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
		{	
		_Alty _Alval(this->_Getal());
		return (_Uninitialized_copy(_First, _Last,
			_Ptr, _Alval));
		}

	template<class _Iter>
		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
		{	
		_Alty _Alval(this->_Getal());
		return (_Uninitialized_move(_First, _Last,
			_Ptr, _Alval));
		}

	iterator _Insert_n(const_iterator _Where,
		size_type _Count, const value_type& _Val)
		{	
 




#line 1573 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

		size_type _Off = (_Where)._Ptr - this->_Myfirst;
		if (_Count == 0)
			;
		else if (_Unused_capacity() < _Count)
			{	
			if (max_size() - size() < _Count)
				_Xlen();	

			size_type _Capacity = _Grow_to(size() + _Count);
			pointer _Newvec = this->_Getal().allocate(_Capacity);
			size_type _Whereoff = (_Where)._Ptr - this->_Myfirst;
			int _Ncopied = 0;

			try {
			_Ufill(_Newvec + _Whereoff, _Count,
				::std:: addressof(_Val));	
			++_Ncopied;
			_Umove(this->_Myfirst, (_Where)._Ptr,
				_Newvec);	
			++_Ncopied;
			_Umove((_Where)._Ptr, this->_Mylast,
				_Newvec + (_Whereoff + _Count));	
			} catch (...) {
			if (1 < _Ncopied)
				_Destroy(_Newvec, _Newvec + _Whereoff);
			if (0 < _Ncopied)
				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
			this->_Getal().deallocate(_Newvec, _Capacity);
			throw;
			}

			_Count += size();
			if (this->_Myfirst != pointer())
				{	
				_Destroy(this->_Myfirst, this->_Mylast);
				this->_Getal().deallocate(this->_Myfirst,
					this->_Myend - this->_Myfirst);
				}

			this->_Orphan_all();
			this->_Myend = _Newvec + _Capacity;
			this->_Mylast = _Newvec + _Count;
			this->_Myfirst = _Newvec;
			}
		else if ((size_type)(this->_Mylast - (_Where)._Ptr)
			< _Count)
			{	
			value_type _Tmp = _Val;	

			_Umove((_Where)._Ptr, this->_Mylast,
				(_Where)._Ptr + _Count);	

			try {
			_Ufill(this->_Mylast,
				_Count - (this->_Mylast - (_Where)._Ptr),
				::std:: addressof(_Tmp));	
			} catch (...) {
			_Destroy((_Where)._Ptr + _Count,
				this->_Mylast + _Count);
			throw;
			}

			this->_Mylast += _Count;
			_Orphan_range((_Where)._Ptr, this->_Mylast);
			::std:: fill((_Where)._Ptr, this->_Mylast - _Count,
				_Tmp);	
			}
		else
			{	
			value_type _Tmp = _Val;	

			pointer _Oldend = this->_Mylast;
			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
				this->_Mylast);	

			_Orphan_range((_Where)._Ptr, this->_Mylast);
			_Copy_backward((_Where)._Ptr, _Oldend - _Count,
				_Oldend);	
			::std:: fill((_Where)._Ptr,
				(_Where)._Ptr + _Count, _Tmp);	
			}
		return (begin() + _Off);
		}

	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
		{	
		_Alty _Alval(this->_Getal());
		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
		return (_Ptr + _Count);
		}

	__declspec(noreturn) void _Xlen() const
		{	
		_Xlength_error("vector<T> too long");
		}

	__declspec(noreturn) void _Xran() const
		{	
		_Xout_of_range("invalid vector<T> subscript");
		}

 















#line 1692 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"
	void _Orphan_range(pointer, pointer) const
		{	
		}
 #line 1696 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"
	};

		

template<class _Ty,
	class _Alloc> inline
	void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator==(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (_Left.size() == _Right.size()
		&& equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator!=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}




typedef unsigned int _Vbase;	
const int _VBITS = 8 * sizeof (_Vbase);	

		
template<class _Alloc>
	class _Vb_iter_base
		: public _Iterator012<random_access_iterator_tag,
			_Bool,
			typename _Alloc::difference_type,
			bool *,
			bool,
			_Iterator_base>
	{	
public:
	typedef typename _Alloc::size_type _Sizet;
	typedef vector<_Bool, _Alloc> _Mycont;

	_Vb_iter_base()
		: _Myptr(0), _Myoff(0)
		{	
		}

	_Vb_iter_base(const _Vbase *_Ptr, _Sizet _Off,
		const _Container_base *_Mypvbool)
		: _Myptr(_Ptr), _Myoff(_Off)
		{	
		this->_Adopt(_Mypvbool);
		}

	int _Valid(_Sizet _Inc) const
		{	
 







#line 1800 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

		return (-1);
 #line 1803 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"
		}

	const _Vbase *_Myptr;
	_Sizet _Myoff;
	};

		
template<class _Alloc>
	class _Vb_reference
		: public _Vb_iter_base<_Alloc>
	{	
	typedef _Vb_iter_base<_Alloc> _Mybase;
	typedef _Vb_reference<_Alloc> _Mytype;

	_Vb_reference()
		{	
		}

public:
	_Vb_reference(const _Mybase& _Right)
		: _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont())
		{	
		}

	_Mytype& operator=(const _Mytype& _Right)
		{	
		return (*this = bool(_Right));
		}

	_Mytype& operator=(bool _Val)
		{	
		if (_Val)
			*(_Vbase *)_Getptr() |= _Mask();
		else
			*(_Vbase *)_Getptr() &= (~_Mask());	
		return (*this);
		}

	void flip()
		{	
		*(_Vbase *)_Getptr() ^= _Mask();
		}

	operator bool() const
		{	
		return ((*_Getptr() & _Mask()) != 0);
		}

	const _Vbase *_Getptr() const
		{	
 








#line 1863 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"


#line 1866 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

		return (this->_Myptr);
		}

protected:
	_Vbase _Mask() const
		{	
		return ((_Vbase)(1 << this->_Myoff));
		}
	};

template<class _Alloc> inline
	void swap(_Vb_reference<_Alloc> _Left,
		_Vb_reference<_Alloc> _Right)
	{	
	bool _Val = _Left;	
	_Left = _Right;
	_Right = _Val;
	}

		
template<class _Alloc>
	class _Vb_const_iterator
		: public _Vb_iter_base<_Alloc>
	{	
public:
	typedef _Vb_iter_base<_Alloc> _Mybase;
	typedef _Vb_const_iterator<_Alloc> _Mytype;

	typedef _Vb_reference<_Alloc> _Reft;
	typedef bool const_reference;

	typedef random_access_iterator_tag iterator_category;
	typedef _Bool value_type;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef const_reference *pointer;
	typedef const_reference reference;

	_Vb_const_iterator()
		{	
		}

	_Vb_const_iterator(const _Vbase *_Ptr, const _Container_base *_Mypvbool)
		: _Mybase(_Ptr, 0, _Mypvbool)
		{	
		}

	const_reference operator*() const
		{	
		return (_Reft(*this));
		}

	_Mytype& operator++()
		{	
		_Inc();
		return (*this);
		}

	_Mytype operator++(int)
		{	
		_Mytype _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Mytype& operator--()
		{	
		_Dec();
		return (*this);
		}

	_Mytype operator--(int)
		{	
		_Mytype _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Mytype& operator+=(difference_type _Off)
		{	
		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)
			{	
			this->_Myoff += _Off;
			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;
			this->_Myoff %= _VBITS;
			}
		else
			{	
			this->_Myoff += _Off;
			this->_Myptr += this->_Myoff / _VBITS;
			this->_Myoff %= _VBITS;
			}
		return (*this);
		}

	_Mytype operator+(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Mytype& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Mytype operator-(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(
		const _Mytype& _Right) const
		{	
		_Compat(_Right);
		return (_VBITS * (this->_Myptr - _Right._Myptr)
			+ (difference_type)this->_Myoff
			- (difference_type)_Right._Myoff);
		}

	const_reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Mytype& _Right) const
		{	
		_Compat(_Right);
		return (this->_Myptr == _Right._Myptr
			&& this->_Myoff == _Right._Myoff);
		}

	bool operator!=(const _Mytype& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Mytype& _Right) const
		{	
		_Compat(_Right);
		return (this->_Myptr < _Right._Myptr
			|| this->_Myptr == _Right._Myptr
				&& this->_Myoff < _Right._Myoff);
		}

	bool operator>(const _Mytype& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Mytype& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Mytype& _Right) const
		{	
		return (!(*this < _Right));
		}

 







#line 2037 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"






#line 2044 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"
	void _Compat(const _Mytype&) const
		{	
		}
 #line 2048 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

	void _Dec()
		{	
		if (this->_Myoff != 0)
			--this->_Myoff;
		else
			{	
 






#line 2063 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"


#line 2066 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

			this->_Myoff = _VBITS - 1;
			--this->_Myptr;
			}
		}

	void _Inc()
		{	
		if (this->_Myoff < _VBITS - 1)
			++this->_Myoff;
		else
			{	
 






#line 2086 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"


#line 2089 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

			this->_Myoff = 0;
			++this->_Myptr;
			}
		}
	};

template<class _Alloc> inline
	_Vb_const_iterator<_Alloc> operator+(
		typename _Alloc::difference_type _Off,
		_Vb_const_iterator<_Alloc> _Right)
		{	
		return (_Right += _Off);
		}

template<class _Alloc>
	struct _Is_checked_helper<_Vb_const_iterator<_Alloc> >
		: public true_type
	{	
	};

	
template<class _Alloc>
	class _Vb_iterator
		: public _Vb_const_iterator<_Alloc>
	{	
public:
	typedef _Vb_const_iterator<_Alloc> _Mybase;
	typedef _Vb_iterator<_Alloc> _Mytype;

	typedef _Vb_reference<_Alloc> _Reft;
	typedef bool const_reference;

	typedef random_access_iterator_tag iterator_category;
	typedef _Bool value_type;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef _Reft *pointer;
	typedef _Reft reference;

	_Vb_iterator()
		{	
		}

	_Vb_iterator(_Vbase *_Ptr, _Container_base *_Mypvbool)
		: _Mybase(_Ptr, _Mypvbool)
		{	
		}

	reference operator*() const
		{	
		return (_Reft(*this));
		}

	_Mytype& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Mytype operator++(int)
		{	
		_Mytype _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Mytype& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Mytype operator--(int)
		{	
		_Mytype _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Mytype& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Mytype operator+(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Mytype& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Mytype operator-(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Alloc> inline
	_Vb_iterator<_Alloc> operator+(typename _Alloc::difference_type _Off,
		_Vb_iterator<_Alloc> _Right)
		{	
		return (_Right += _Off);
		}

template<class _Alloc>
	struct _Is_checked_helper<_Vb_iterator<_Alloc> >
		: public true_type
	{	
	};

		
template<class _Alloc>
	class _Vb_val
		: public _Container_base
	{	
public:
	typedef ::std:: vector<_Vbase, _Alloc> _Vectype;
	typedef typename _Vectype::_Alty _Alty;
	typedef typename _Alty::size_type size_type;

	_Vb_val(size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
		: _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)
		{	
		_Alloc_proxy();
		_Mysize = 0;
		}

	_Vb_val(const _Vb_val& _Right)
		: _Myvec(_Right._Myvec),
			_Mysize(_Right._Mysize)
		{	
		_Alloc_proxy();
		}

	_Vb_val(const _Vb_val& _Right, const _Alloc& _Al)
		: _Myvec(_Right._Myvec, _Al),
			_Mysize(_Right._Mysize)
		{	
		_Alloc_proxy();
		}

	_Vb_val(_Vb_val&& _Right)
		: _Myvec(::std:: forward<_Vectype>(_Right._Myvec)),
			_Mysize(_Right._Mysize)
		{	
		_Right._Mysize = 0;
		_Alloc_proxy();
		}

	_Vb_val(_Vb_val&& _Right, const _Alloc& _Al)
		: _Myvec(::std:: forward<_Vectype>(_Right._Myvec), _Al),
			_Mysize(_Right._Mysize)
		{	
		_Right._Mysize = 0;
		_Alloc_proxy();
		}

	~_Vb_val() throw ()
		{	
		_Free_proxy();
		}

 
	void _Swap_alloc(_Vb_val&)
		{	
		}

	void _Alloc_proxy()
	 	{	
	 	}

	void _Free_proxy()
	 	{	
	 	}

 























#line 2306 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

	static size_type _Nw(size_type _Count)
		{	
		return ((_Count + _VBITS - 1) / _VBITS);
		}

	_Vectype _Myvec;	
	typename _Alty::size_type _Mysize;	
	};

		

template<class _Alloc>
	class vector<_Bool, _Alloc>
		: public _Vb_val<_Alloc>
	{	
public:
	typedef ::std:: vector<_Bool, _Alloc> _Myt;
	typedef _Vb_val<_Alloc> _Mybase;
	typedef typename _Mybase::_Alty _Alty;
	typedef typename _Mybase::_Vectype _Vectype;

	typedef typename _Alty::size_type size_type;
	typedef typename _Alty::difference_type _Dift;
	typedef _Dift difference_type;
	typedef _Bool _Ty;
	typedef _Alloc allocator_type;

	typedef _Vb_reference<_Alty> reference;
	typedef bool const_reference;
	typedef bool value_type;

	typedef reference _Reft;
	typedef _Vb_const_iterator<_Alty> const_iterator;
	typedef _Vb_iterator<_Alty> iterator;

	typedef iterator pointer;
	typedef const_iterator const_pointer;
	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	static const int _VBITS = ::std:: _VBITS;

	enum {_EEN_VBITS = _VBITS};	

	vector()
		: _Mybase(0, false)
		{	
		}

	explicit vector(const _Alloc& _Al)
		: _Mybase(0, false, _Al)
		{	
		}

	explicit vector(size_type _Count, const bool& _Val = false)
		: _Mybase(_Count, _Val)
		{	
		_Trim(_Count);
		}

	vector(size_type _Count, const bool& _Val, const _Alloc& _Al)
		: _Mybase(_Count, _Val, _Al)
		{	
		_Trim(_Count);
		}

	vector(const _Myt& _Right)
		: _Mybase(_Right)
		{	
		}

	vector(const _Myt& _Right, const _Alloc& _Al)
		: _Mybase(_Right, _Al)
		{	
		}

	template<class _Iter>
		vector(_Iter _First, _Iter _Last,
			typename enable_if<_Is_iterator<_Iter>::value,
				void>:: type ** = 0)
		: _Mybase(0, false)
		{	
		_BConstruct(_First, _Last);
		}

	template<class _Iter>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al,
			typename enable_if<_Is_iterator<_Iter>::value,
				void>:: type ** = 0)
		: _Mybase(0, false, _Al)
		{	
		_BConstruct(_First, _Last);
		}

	template<class _Iter>
		void _BConstruct(_Iter _First, _Iter _Last)
		{	
		insert(begin(), _First, _Last);
		}

	vector(_Myt&& _Right)
		: _Mybase(::std:: forward<_Myt>(_Right))
		{	
		}

	vector(_Myt&& _Right, const _Alloc& _Al)
		: _Mybase(::std:: forward<_Myt>(_Right), _Al)
		{	
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			clear();

 
			if (this->get_allocator() != _Right.get_allocator()
				&& _Alty::propagate_on_container_move_assignment::value)
				{	
				this->_Free_proxy();
				this->_Myvec = ::std:: move(_Right._Myvec);
				this->_Alloc_proxy();
				}
			else
				this->_Myvec = ::std:: move(_Right._Myvec);

 

#line 2437 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

			this->_Mysize = _Right._Mysize;
			_Right._Mysize = 0;
			}
		return (*this);
		}

	~vector() throw ()
		{	
		this->_Mysize = 0;
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		this->_Mysize = _Right._Mysize;
		this->_Myvec = _Right._Myvec;
		return (*this);
		}

	void reserve(size_type _Count)
		{	
		this->_Myvec.reserve(this->_Nw(_Count));
		}

	size_type capacity() const
		{	
		return (this->_Myvec.capacity() * _VBITS);
		}

	iterator begin()
		{	
		return (iterator((_Vbase *)this->_Myvec._Myfirst, this));
		}

	const_iterator begin() const
		{	
		return (const_iterator((_Vbase *)this->_Myvec._Myfirst, this));
		}

	iterator end()
		{	
		iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += this->_Mysize;
		return (_Tmp);
		}

	const_iterator end() const
		{	
		const_iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += this->_Mysize;
		return (_Tmp);
		}

 
	const_iterator cbegin() const
		{	
		return (((const _Myt *)this)->begin());
		}

	const_iterator cend() const
		{	
		return (((const _Myt *)this)->end());
		}

	const_reverse_iterator crbegin() const
		{	
		return (((const _Myt *)this)->rbegin());
		}

	const_reverse_iterator crend() const
		{	
		return (((const _Myt *)this)->rend());
		}

	void shrink_to_fit()
		{	
		if (this->_Myvec._Has_unused_capacity())
			{	
			_Myt _Tmp(*this);
			swap(_Tmp);
			}
		}
 #line 2522 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

	iterator _Make_iter(const_iterator _Where)
		{	
		iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += _Where - begin();
		return (_Tmp);
		}

	reverse_iterator rbegin()
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend()
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const
		{	
		return (const_reverse_iterator(begin()));
		}

	void resize(size_type _Newsize, bool _Val = false)
		{	
		if (size() < _Newsize)
			_Insert_n(end(), _Newsize - size(), _Val);
		else if (_Newsize < size())
			erase(begin() + _Newsize, end());
		}

	size_type size() const
		{	
		return (this->_Mysize);
		}

	size_type max_size() const
		{	
		const size_type _Maxsize = this->_Myvec.max_size();
		return (_Maxsize < (size_type)(-1) / _VBITS
			? _Maxsize * _VBITS : (size_type)(-1));
		}

	bool empty() const
		{	
		return (size() == 0);
		}

	_Alloc get_allocator() const
		{	
		return (this->_Myvec.get_allocator());
		}

	const_reference at(size_type _Off) const
		{	
		if (size() <= _Off)
			_Xran();
		return (*(begin() + _Off));
		}

	reference at(size_type _Off)
		{	
		if (size() <= _Off)
			_Xran();
		return (*(begin() + _Off));
		}

	const_reference operator[](size_type _Off) const
		{	
		return (*(begin() + _Off));
		}

	reference operator[](size_type _Off)
		{	
		return (*(begin() + _Off));
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}

	void push_back(const bool& _Val)
		{	
		insert(end(), _Val);
		}

	void pop_back()
		{	
		if (!empty())
			erase(end() - 1);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			void>::type
		assign(_Iter _First, _Iter _Last)
		{	
		erase(begin(), end());
		insert(begin(), _First, _Last);
		}

	void assign(size_type _Count, const bool& _Val)
		{	
		_Assign_n(_Count, _Val);
		}

	iterator insert(const_iterator _Where, const bool& _Val)
		{	
		return (_Insert_n(_Where, (size_type)1, _Val));
		}

	iterator insert(const_iterator _Where, size_type _Count,
		const bool& _Val)
		{	
		return (_Insert_n(_Where, _Count, _Val));
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			iterator>::type
		insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	
		size_type _Off = _Where - begin();
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		return (begin() + _Off);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
			input_iterator_tag)
		{	
		size_type _Off = _Where - begin();

		for (; _First != _Last; ++_First, ++_Off)
			insert(begin() + _Off, *_First);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
			forward_iterator_tag)
		{	
		;
		size_type _Count = 0;
		_Distance(_First, _Last, _Count);

		size_type _Off = _Insert_x(_Where, _Count);
		::std:: copy(_First, _Last, begin() + _Off);
		}

	iterator erase(const_iterator _Where_arg)
		{	
		iterator _Where = _Make_iter(_Where_arg);
		size_type _Off = _Where - begin();

 





#line 2706 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"
		::std:: copy(_Where + 1, end(), _Where);
 #line 2708 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

		_Trim(this->_Mysize - 1);
		return (begin() + _Off);
		}

	iterator erase(const_iterator _First_arg, const_iterator _Last_arg)
		{	
		iterator _First = _Make_iter(_First_arg);
		iterator _Last = _Make_iter(_Last_arg);
		size_type _Off = _First - begin();

		if (_First != _Last)
			{	
 







#line 2730 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"
			iterator _Next = ::std:: copy(_Last, end(), _First);
			_Trim(_Next - begin());
 #line 2733 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"
			}
		return (begin() + _Off);
		}

	void clear() throw ()
		{	
		erase(begin(), end());
		}

	void flip()
		{	
		for (typename _Vectype::iterator _Next = this->_Myvec.begin();
			_Next != this->_Myvec.end(); ++_Next)
			*_Next = (_Vbase)~*_Next;
		_Trim(this->_Mysize);
		}

	void swap(_Myt& _Right)
		{	
		if (this == &_Right)
			;	
		else if (this->get_allocator() == _Right.get_allocator())
			{	
			this->_Swap_all(_Right);
			this->_Myvec.swap(_Right._Myvec);
			::std:: swap(this->_Mysize, _Right._Mysize);
			}

 
		else if (_Alty::propagate_on_container_swap::value)
			{	
			this->_Swap_alloc(_Right);
			this->_Myvec.swap(_Right._Myvec);
			::std:: swap(this->_Mysize, _Right._Mysize);
			}
 #line 2769 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

		else
			{	
			this->_Swap_all(_Right);
			this->_Myvec.swap(_Right._Myvec);
			::std:: swap(this->_Mysize, _Right._Mysize);
			}
		}

	static void swap(reference _Left, reference _Right)
		{	
		bool _Val = _Left;	

		_Left = _Right;
		_Right = _Val;
		}

 
	size_t hash() const
		{	
		return (_Hash_seq((const unsigned char *)this->_Myvec.data(),
			this->_Myvec.size() * sizeof (_Vbase)));
		}
 #line 2793 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

	void _Assign_n(size_type _Count, const bool& _Val)
		{	
		erase(begin(), end());
		_Insert_n(begin(), _Count, _Val);
		}

	iterator _Insert_n(const_iterator _Where,
		size_type _Count, const bool& _Val)
		{	
		size_type _Off = _Insert_x(_Where, _Count);
		::std:: fill(begin() + _Off, begin() + (_Off + _Count), _Val);
		return (begin() + _Off);
		}

	size_type _Insert_x(const_iterator _Where, size_type _Count)
		{	
		size_type _Off = _Where - begin();

 



#line 2817 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

		if (_Count == 0)
			;
		else if (max_size() - size() < _Count)
			_Xlen();	
		else
			{	
			this->_Myvec.resize(this->_Nw(size() + _Count), 0);
			if (empty())
				this->_Mysize += _Count;
			else
				{	
				iterator _Oldend = end();
				this->_Mysize += _Count;
				::std:: copy_backward(begin() + _Off, _Oldend, end());
				}

 

#line 2837 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"
			}
		return (_Off);
		}

 























#line 2866 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"
	void _Orphan_range(size_type, size_type) const
		{	
		}
 #line 2870 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"

	void _Trim(size_type _Size)
		{	
		if (max_size() < _Size)
			_Xlen();	
		size_type _Words = this->_Nw(_Size);

		if (_Words < this->_Myvec.size())
			this->_Myvec.erase(this->_Myvec.begin() + _Words,
				this->_Myvec.end());
		this->_Mysize = _Size;
		_Size %= _VBITS;
		if (0 < _Size)
			this->_Myvec[_Words - 1] &= (_Vbase)((1 << _Size) - 1);
		}

	__declspec(noreturn) void _Xlen() const
		{	
		_Xlength_error("vector<bool> too long");
		}

	__declspec(noreturn) void _Xran() const
		{	
		_Xout_of_range("invalid vector<bool> subscript");
		}
	};

template<class _Alloc> inline
	bool operator==(const vector<bool, _Alloc>& _Left,
		const vector<bool, _Alloc>& _Right)
	{	
	return (_Left.size() == _Right.size()
		&& equal(_Left._Myvec.begin(), _Left._Myvec.end(),
			_Right._Myvec.begin()));
	}

template<class _Alloc> inline
	bool operator!=(const vector<bool, _Alloc>& _Left,
		const vector<bool, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

 
	
template<class _Alloc>
	struct hash<vector<_Bool, _Alloc> >
		: public unary_function<vector<_Bool, _Alloc>, size_t>
	{	
	typedef vector<_Bool, _Alloc> _Kty;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Keyval.hash());
		}
	};
 #line 2927 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 2933 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"
#line 2934 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\vector"























#line 54 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types.hpp"


#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"


















































































































































































































































































































































































































































#line 57 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvstd.hpp"
















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 58 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/matx.hpp"









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 59 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types.hpp"

namespace cv
{












template<typename _Tp> class Complex
{
public:

    
    Complex();
    Complex( _Tp _re, _Tp _im = 0 );

    
    template<typename T2> operator Complex<T2>() const;
    
    Complex conj() const;

    _Tp re, im; 
};

typedef Complex<float> Complexf;
typedef Complex<double> Complexd;

template<typename _Tp> class DataType< Complex<_Tp> >
{
public:
    typedef Complex<_Tp> value_type;
    typedef value_type   work_type;
    typedef _Tp          channel_type;

    enum { generic_type = 0,
           depth        = DataType<channel_type>::depth,
           channels     = 2,
           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };

    typedef Vec<channel_type, channels> vec_type;
};








































template<typename _Tp> class Point_
{
public:
    typedef _Tp value_type;

    
    Point_();
    Point_(_Tp _x, _Tp _y);
    Point_(const Point_& pt);
    Point_(const Size_<_Tp>& sz);
    Point_(const Vec<_Tp, 2>& v);

    Point_& operator = (const Point_& pt);
    
    template<typename _Tp2> operator Point_<_Tp2>() const;

    
    operator Vec<_Tp, 2>() const;

    
    _Tp dot(const Point_& pt) const;
    
    double ddot(const Point_& pt) const;
    
    double cross(const Point_& pt) const;
    
    bool inside(const Rect_<_Tp>& r) const;

    _Tp x, y; 
};

typedef Point_<int> Point2i;
typedef Point_<int64> Point2l;
typedef Point_<float> Point2f;
typedef Point_<double> Point2d;
typedef Point2i Point;

template<typename _Tp> class DataType< Point_<_Tp> >
{
public:
    typedef Point_<_Tp>                               value_type;
    typedef Point_<typename DataType<_Tp>::work_type> work_type;
    typedef _Tp                                       channel_type;

    enum { generic_type = 0,
           depth        = DataType<channel_type>::depth,
           channels     = 2,
           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };

    typedef Vec<channel_type, channels> vec_type;
};



















template<typename _Tp> class Point3_
{
public:
    typedef _Tp value_type;

    
    Point3_();
    Point3_(_Tp _x, _Tp _y, _Tp _z);
    Point3_(const Point3_& pt);
    explicit Point3_(const Point_<_Tp>& pt);
    Point3_(const Vec<_Tp, 3>& v);

    Point3_& operator = (const Point3_& pt);
    
    template<typename _Tp2> operator Point3_<_Tp2>() const;
    


#line 239 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types.hpp"
    operator Vec<_Tp, 3>() const;
#line 241 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types.hpp"

    
    _Tp dot(const Point3_& pt) const;
    
    double ddot(const Point3_& pt) const;
    
    Point3_ cross(const Point3_& pt) const;

    _Tp x, y, z; 
};

typedef Point3_<int> Point3i;
typedef Point3_<float> Point3f;
typedef Point3_<double> Point3d;

template<typename _Tp> class DataType< Point3_<_Tp> >
{
public:
    typedef Point3_<_Tp>                               value_type;
    typedef Point3_<typename DataType<_Tp>::work_type> work_type;
    typedef _Tp                                        channel_type;

    enum { generic_type = 0,
           depth        = DataType<channel_type>::depth,
           channels     = 3,
           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };

    typedef Vec<channel_type, channels> vec_type;
};


















template<typename _Tp> class Size_
{
public:
    typedef _Tp value_type;

    
    Size_();
    Size_(_Tp _width, _Tp _height);
    Size_(const Size_& sz);
    Size_(const Point_<_Tp>& pt);

    Size_& operator = (const Size_& sz);
    
    _Tp area() const;
    
    bool empty() const;

    
    template<typename _Tp2> operator Size_<_Tp2>() const;

    _Tp width, height; 
};

typedef Size_<int> Size2i;
typedef Size_<int64> Size2l;
typedef Size_<float> Size2f;
typedef Size_<double> Size2d;
typedef Size2i Size;

template<typename _Tp> class DataType< Size_<_Tp> >
{
public:
    typedef Size_<_Tp>                               value_type;
    typedef Size_<typename DataType<_Tp>::work_type> work_type;
    typedef _Tp                                      channel_type;

    enum { generic_type = 0,
           depth        = DataType<channel_type>::depth,
           channels     = 2,
           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };

    typedef Vec<channel_type, channels> vec_type;
};
















































template<typename _Tp> class Rect_
{
public:
    typedef _Tp value_type;

    
    Rect_();
    Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height);
    Rect_(const Rect_& r);
    Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz);
    Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2);

    Rect_& operator = ( const Rect_& r );
    
    Point_<_Tp> tl() const;
    
    Point_<_Tp> br() const;

    
    Size_<_Tp> size() const;
    
    _Tp area() const;
    
    bool empty() const;

    
    template<typename _Tp2> operator Rect_<_Tp2>() const;

    
    bool contains(const Point_<_Tp>& pt) const;

    _Tp x, y, width, height; 
};

typedef Rect_<int> Rect2i;
typedef Rect_<float> Rect2f;
typedef Rect_<double> Rect2d;
typedef Rect2i Rect;

template<typename _Tp> class DataType< Rect_<_Tp> >
{
public:
    typedef Rect_<_Tp>                               value_type;
    typedef Rect_<typename DataType<_Tp>::work_type> work_type;
    typedef _Tp                                      channel_type;

    enum { generic_type = 0,
           depth        = DataType<channel_type>::depth,
           channels     = 4,
           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };

    typedef Vec<channel_type, channels> vec_type;
};






























class  RotatedRect
{
public:
    
    RotatedRect();
    





    RotatedRect(const Point2f& center, const Size2f& size, float angle);
    



    RotatedRect(const Point2f& point1, const Point2f& point2, const Point2f& point3);

    


    void points(Point2f pts[]) const;
    
    Rect boundingRect() const;
    
    Rect_<float> boundingRect2f() const;

    Point2f center; 
    Size2f size;    
    float angle;    
};

template<> class DataType< RotatedRect >
{
public:
    typedef RotatedRect  value_type;
    typedef value_type   work_type;
    typedef float        channel_type;

    enum { generic_type = 0,
           depth        = DataType<channel_type>::depth,
           channels     = (int)sizeof(value_type)/sizeof(channel_type), 
           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };

    typedef Vec<channel_type, channels> vec_type;
};




























class  Range
{
public:
    Range();
    Range(int _start, int _end);
    int size() const;
    bool empty() const;
    static Range all();

    int start, end;
};

template<> class DataType<Range>
{
public:
    typedef Range      value_type;
    typedef value_type work_type;
    typedef int        channel_type;

    enum { generic_type = 0,
           depth        = DataType<channel_type>::depth,
           channels     = 2,
           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };

    typedef Vec<channel_type, channels> vec_type;
};











template<typename _Tp> class Scalar_ : public Vec<_Tp, 4>
{
public:
    
    Scalar_();
    Scalar_(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0);
    Scalar_(_Tp v0);

    template<typename _Tp2, int cn>
    Scalar_(const Vec<_Tp2, cn>& v);

    
    static Scalar_<_Tp> all(_Tp v0);

    
    template<typename T2> operator Scalar_<T2>() const;

    
    Scalar_<_Tp> mul(const Scalar_<_Tp>& a, double scale=1 ) const;

    
    Scalar_<_Tp> conj() const;

    
    bool isReal() const;
};

typedef Scalar_<double> Scalar;

template<typename _Tp> class DataType< Scalar_<_Tp> >
{
public:
    typedef Scalar_<_Tp>                               value_type;
    typedef Scalar_<typename DataType<_Tp>::work_type> work_type;
    typedef _Tp                                        channel_type;

    enum { generic_type = 0,
           depth        = DataType<channel_type>::depth,
           channels     = 4,
           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };

    typedef Vec<channel_type, channels> vec_type;
};

















class  KeyPoint
{
public:
    
     KeyPoint();
    







    KeyPoint(Point2f _pt, float _size, float _angle=-1, float _response=0, int _octave=0, int _class_id=-1);
    








     KeyPoint(float x, float y, float _size, float _angle=-1, float _response=0, int _octave=0, int _class_id=-1);

    size_t hash() const;

    








     static void convert(const std::vector<KeyPoint>& keypoints,
                                 std::vector<Point2f>& points2f,
                                const std::vector<int>& keypointIndexes=std::vector<int>());
    







     static void convert(const std::vector<Point2f>& points2f,
                                 std::vector<KeyPoint>& keypoints,
                                float size=1, float response=1, int octave=0, int class_id=-1);

    






     static float overlap(const KeyPoint& kp1, const KeyPoint& kp2);

     Point2f pt; 
     float size; 
     float angle; 
                            
                            
     float response; 
     int octave; 
     int class_id; 
};

template<> class DataType<KeyPoint>
{
public:
    typedef KeyPoint      value_type;
    typedef float         work_type;
    typedef float         channel_type;

    enum { generic_type = 0,
           depth        = DataType<channel_type>::depth,
           channels     = (int)(sizeof(value_type)/sizeof(channel_type)), 
           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };

    typedef Vec<channel_type, channels> vec_type;
};










class  DMatch
{
public:
     DMatch();
     DMatch(int _queryIdx, int _trainIdx, float _distance);
     DMatch(int _queryIdx, int _trainIdx, int _imgIdx, float _distance);

     int queryIdx; 
     int trainIdx; 
     int imgIdx;   

     float distance;

    
    bool operator<(const DMatch &m) const;
};

template<> class DataType<DMatch>
{
public:
    typedef DMatch      value_type;
    typedef int         work_type;
    typedef int         channel_type;

    enum { generic_type = 0,
           depth        = DataType<channel_type>::depth,
           channels     = (int)(sizeof(value_type)/sizeof(channel_type)), 
           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };

    typedef Vec<channel_type, channels> vec_type;
};










class  TermCriteria
{
public:
    


    enum Type
    {
        COUNT=1, 
        MAX_ITER=COUNT, 
        EPS=2 
    };

    
    TermCriteria();
    




    TermCriteria(int type, int maxCount, double epsilon);

    int type; 
    int maxCount; 
    double epsilon; 
};









































class  Moments
{
public:
    
    Moments();
    
    Moments(double m00, double m10, double m01, double m20, double m11,
            double m02, double m30, double m21, double m12, double m03 );
    
    
    
    

    
    
     double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;
    

    
    
     double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;
    

    
    
     double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;
    
};

template<> class DataType<Moments>
{
public:
    typedef Moments     value_type;
    typedef double      work_type;
    typedef double      channel_type;

    enum { generic_type = 0,
           depth        = DataType<channel_type>::depth,
           channels     = (int)(sizeof(value_type)/sizeof(channel_type)), 
           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3))
         };

    typedef Vec<channel_type, channels> vec_type;
};











template<typename _Tp> inline
Complex<_Tp>::Complex()
    : re(0), im(0) {}

template<typename _Tp> inline
Complex<_Tp>::Complex( _Tp _re, _Tp _im )
    : re(_re), im(_im) {}

template<typename _Tp> template<typename T2> inline
Complex<_Tp>::operator Complex<T2>() const
{
    return Complex<T2>(saturate_cast<T2>(re), saturate_cast<T2>(im));
}

template<typename _Tp> inline
Complex<_Tp> Complex<_Tp>::conj() const
{
    return Complex<_Tp>(re, -im);
}


template<typename _Tp> static inline
bool operator == (const Complex<_Tp>& a, const Complex<_Tp>& b)
{
    return a.re == b.re && a.im == b.im;
}

template<typename _Tp> static inline
bool operator != (const Complex<_Tp>& a, const Complex<_Tp>& b)
{
    return a.re != b.re || a.im != b.im;
}

template<typename _Tp> static inline
Complex<_Tp> operator + (const Complex<_Tp>& a, const Complex<_Tp>& b)
{
    return Complex<_Tp>( a.re + b.re, a.im + b.im );
}

template<typename _Tp> static inline
Complex<_Tp>& operator += (Complex<_Tp>& a, const Complex<_Tp>& b)
{
    a.re += b.re; a.im += b.im;
    return a;
}

template<typename _Tp> static inline
Complex<_Tp> operator - (const Complex<_Tp>& a, const Complex<_Tp>& b)
{
    return Complex<_Tp>( a.re - b.re, a.im - b.im );
}

template<typename _Tp> static inline
Complex<_Tp>& operator -= (Complex<_Tp>& a, const Complex<_Tp>& b)
{
    a.re -= b.re; a.im -= b.im;
    return a;
}

template<typename _Tp> static inline
Complex<_Tp> operator - (const Complex<_Tp>& a)
{
    return Complex<_Tp>(-a.re, -a.im);
}

template<typename _Tp> static inline
Complex<_Tp> operator * (const Complex<_Tp>& a, const Complex<_Tp>& b)
{
    return Complex<_Tp>( a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re );
}

template<typename _Tp> static inline
Complex<_Tp> operator * (const Complex<_Tp>& a, _Tp b)
{
    return Complex<_Tp>( a.re*b, a.im*b );
}

template<typename _Tp> static inline
Complex<_Tp> operator * (_Tp b, const Complex<_Tp>& a)
{
    return Complex<_Tp>( a.re*b, a.im*b );
}

template<typename _Tp> static inline
Complex<_Tp> operator + (const Complex<_Tp>& a, _Tp b)
{
    return Complex<_Tp>( a.re + b, a.im );
}

template<typename _Tp> static inline
Complex<_Tp> operator - (const Complex<_Tp>& a, _Tp b)
{ return Complex<_Tp>( a.re - b, a.im ); }

template<typename _Tp> static inline
Complex<_Tp> operator + (_Tp b, const Complex<_Tp>& a)
{
    return Complex<_Tp>( a.re + b, a.im );
}

template<typename _Tp> static inline
Complex<_Tp> operator - (_Tp b, const Complex<_Tp>& a)
{
    return Complex<_Tp>( b - a.re, -a.im );
}

template<typename _Tp> static inline
Complex<_Tp>& operator += (Complex<_Tp>& a, _Tp b)
{
    a.re += b; return a;
}

template<typename _Tp> static inline
Complex<_Tp>& operator -= (Complex<_Tp>& a, _Tp b)
{
    a.re -= b; return a;
}

template<typename _Tp> static inline
Complex<_Tp>& operator *= (Complex<_Tp>& a, _Tp b)
{
    a.re *= b; a.im *= b; return a;
}

template<typename _Tp> static inline
double abs(const Complex<_Tp>& a)
{
    return std::sqrt( (double)a.re*a.re + (double)a.im*a.im);
}

template<typename _Tp> static inline
Complex<_Tp> operator / (const Complex<_Tp>& a, const Complex<_Tp>& b)
{
    double t = 1./((double)b.re*b.re + (double)b.im*b.im);
    return Complex<_Tp>( (_Tp)((a.re*b.re + a.im*b.im)*t),
                        (_Tp)((-a.re*b.im + a.im*b.re)*t) );
}

template<typename _Tp> static inline
Complex<_Tp>& operator /= (Complex<_Tp>& a, const Complex<_Tp>& b)
{
    a = a / b;
    return a;
}

template<typename _Tp> static inline
Complex<_Tp> operator / (const Complex<_Tp>& a, _Tp b)
{
    _Tp t = (_Tp)1/b;
    return Complex<_Tp>( a.re*t, a.im*t );
}

template<typename _Tp> static inline
Complex<_Tp> operator / (_Tp b, const Complex<_Tp>& a)
{
    return Complex<_Tp>(b)/a;
}

template<typename _Tp> static inline
Complex<_Tp> operator /= (const Complex<_Tp>& a, _Tp b)
{
    _Tp t = (_Tp)1/b;
    a.re *= t; a.im *= t; return a;
}





template<typename _Tp> inline
Point_<_Tp>::Point_()
    : x(0), y(0) {}

template<typename _Tp> inline
Point_<_Tp>::Point_(_Tp _x, _Tp _y)
    : x(_x), y(_y) {}

template<typename _Tp> inline
Point_<_Tp>::Point_(const Point_& pt)
    : x(pt.x), y(pt.y) {}

template<typename _Tp> inline
Point_<_Tp>::Point_(const Size_<_Tp>& sz)
    : x(sz.width), y(sz.height) {}

template<typename _Tp> inline
Point_<_Tp>::Point_(const Vec<_Tp,2>& v)
    : x(v[0]), y(v[1]) {}

template<typename _Tp> inline
Point_<_Tp>& Point_<_Tp>::operator = (const Point_& pt)
{
    x = pt.x; y = pt.y;
    return *this;
}

template<typename _Tp> template<typename _Tp2> inline
Point_<_Tp>::operator Point_<_Tp2>() const
{
    return Point_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y));
}

template<typename _Tp> inline
Point_<_Tp>::operator Vec<_Tp, 2>() const
{
    return Vec<_Tp, 2>(x, y);
}

template<typename _Tp> inline
_Tp Point_<_Tp>::dot(const Point_& pt) const
{
    return saturate_cast<_Tp>(x*pt.x + y*pt.y);
}

template<typename _Tp> inline
double Point_<_Tp>::ddot(const Point_& pt) const
{
    return (double)x*pt.x + (double)y*pt.y;
}

template<typename _Tp> inline
double Point_<_Tp>::cross(const Point_& pt) const
{
    return (double)x*pt.y - (double)y*pt.x;
}

template<typename _Tp> inline bool
Point_<_Tp>::inside( const Rect_<_Tp>& r ) const
{
    return r.contains(*this);
}


template<typename _Tp> static inline
Point_<_Tp>& operator += (Point_<_Tp>& a, const Point_<_Tp>& b)
{
    a.x += b.x;
    a.y += b.y;
    return a;
}

template<typename _Tp> static inline
Point_<_Tp>& operator -= (Point_<_Tp>& a, const Point_<_Tp>& b)
{
    a.x -= b.x;
    a.y -= b.y;
    return a;
}

template<typename _Tp> static inline
Point_<_Tp>& operator *= (Point_<_Tp>& a, int b)
{
    a.x = saturate_cast<_Tp>(a.x * b);
    a.y = saturate_cast<_Tp>(a.y * b);
    return a;
}

template<typename _Tp> static inline
Point_<_Tp>& operator *= (Point_<_Tp>& a, float b)
{
    a.x = saturate_cast<_Tp>(a.x * b);
    a.y = saturate_cast<_Tp>(a.y * b);
    return a;
}

template<typename _Tp> static inline
Point_<_Tp>& operator *= (Point_<_Tp>& a, double b)
{
    a.x = saturate_cast<_Tp>(a.x * b);
    a.y = saturate_cast<_Tp>(a.y * b);
    return a;
}

template<typename _Tp> static inline
Point_<_Tp>& operator /= (Point_<_Tp>& a, int b)
{
    a.x = saturate_cast<_Tp>(a.x / b);
    a.y = saturate_cast<_Tp>(a.y / b);
    return a;
}

template<typename _Tp> static inline
Point_<_Tp>& operator /= (Point_<_Tp>& a, float b)
{
    a.x = saturate_cast<_Tp>(a.x / b);
    a.y = saturate_cast<_Tp>(a.y / b);
    return a;
}

template<typename _Tp> static inline
Point_<_Tp>& operator /= (Point_<_Tp>& a, double b)
{
    a.x = saturate_cast<_Tp>(a.x / b);
    a.y = saturate_cast<_Tp>(a.y / b);
    return a;
}

template<typename _Tp> static inline
double norm(const Point_<_Tp>& pt)
{
    return std::sqrt((double)pt.x*pt.x + (double)pt.y*pt.y);
}

template<typename _Tp> static inline
bool operator == (const Point_<_Tp>& a, const Point_<_Tp>& b)
{
    return a.x == b.x && a.y == b.y;
}

template<typename _Tp> static inline
bool operator != (const Point_<_Tp>& a, const Point_<_Tp>& b)
{
    return a.x != b.x || a.y != b.y;
}

template<typename _Tp> static inline
Point_<_Tp> operator + (const Point_<_Tp>& a, const Point_<_Tp>& b)
{
    return Point_<_Tp>( saturate_cast<_Tp>(a.x + b.x), saturate_cast<_Tp>(a.y + b.y) );
}

template<typename _Tp> static inline
Point_<_Tp> operator - (const Point_<_Tp>& a, const Point_<_Tp>& b)
{
    return Point_<_Tp>( saturate_cast<_Tp>(a.x - b.x), saturate_cast<_Tp>(a.y - b.y) );
}

template<typename _Tp> static inline
Point_<_Tp> operator - (const Point_<_Tp>& a)
{
    return Point_<_Tp>( saturate_cast<_Tp>(-a.x), saturate_cast<_Tp>(-a.y) );
}

template<typename _Tp> static inline
Point_<_Tp> operator * (const Point_<_Tp>& a, int b)
{
    return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) );
}

template<typename _Tp> static inline
Point_<_Tp> operator * (int a, const Point_<_Tp>& b)
{
    return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) );
}

template<typename _Tp> static inline
Point_<_Tp> operator * (const Point_<_Tp>& a, float b)
{
    return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) );
}

template<typename _Tp> static inline
Point_<_Tp> operator * (float a, const Point_<_Tp>& b)
{
    return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) );
}

template<typename _Tp> static inline
Point_<_Tp> operator * (const Point_<_Tp>& a, double b)
{
    return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) );
}

template<typename _Tp> static inline
Point_<_Tp> operator * (double a, const Point_<_Tp>& b)
{
    return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) );
}

template<typename _Tp> static inline
Point_<_Tp> operator * (const Matx<_Tp, 2, 2>& a, const Point_<_Tp>& b)
{
    Matx<_Tp, 2, 1> tmp = a * Vec<_Tp,2>(b.x, b.y);
    return Point_<_Tp>(tmp.val[0], tmp.val[1]);
}

template<typename _Tp> static inline
Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point_<_Tp>& b)
{
    Matx<_Tp, 3, 1> tmp = a * Vec<_Tp,3>(b.x, b.y, 1);
    return Point3_<_Tp>(tmp.val[0], tmp.val[1], tmp.val[2]);
}

template<typename _Tp> static inline
Point_<_Tp> operator / (const Point_<_Tp>& a, int b)
{
    Point_<_Tp> tmp(a);
    tmp /= b;
    return tmp;
}

template<typename _Tp> static inline
Point_<_Tp> operator / (const Point_<_Tp>& a, float b)
{
    Point_<_Tp> tmp(a);
    tmp /= b;
    return tmp;
}

template<typename _Tp> static inline
Point_<_Tp> operator / (const Point_<_Tp>& a, double b)
{
    Point_<_Tp> tmp(a);
    tmp /= b;
    return tmp;
}





template<typename _Tp> inline
Point3_<_Tp>::Point3_()
    : x(0), y(0), z(0) {}

template<typename _Tp> inline
Point3_<_Tp>::Point3_(_Tp _x, _Tp _y, _Tp _z)
    : x(_x), y(_y), z(_z) {}

template<typename _Tp> inline
Point3_<_Tp>::Point3_(const Point3_& pt)
    : x(pt.x), y(pt.y), z(pt.z) {}

template<typename _Tp> inline
Point3_<_Tp>::Point3_(const Point_<_Tp>& pt)
    : x(pt.x), y(pt.y), z(_Tp()) {}

template<typename _Tp> inline
Point3_<_Tp>::Point3_(const Vec<_Tp, 3>& v)
    : x(v[0]), y(v[1]), z(v[2]) {}

template<typename _Tp> template<typename _Tp2> inline
Point3_<_Tp>::operator Point3_<_Tp2>() const
{
    return Point3_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y), saturate_cast<_Tp2>(z));
}







#line 1350 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types.hpp"
template<typename _Tp> inline
Point3_<_Tp>::operator Vec<_Tp, 3>() const
{
    return Vec<_Tp, 3>(x, y, z);
}
#line 1356 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types.hpp"

template<typename _Tp> inline
Point3_<_Tp>& Point3_<_Tp>::operator = (const Point3_& pt)
{
    x = pt.x; y = pt.y; z = pt.z;
    return *this;
}

template<typename _Tp> inline
_Tp Point3_<_Tp>::dot(const Point3_& pt) const
{
    return saturate_cast<_Tp>(x*pt.x + y*pt.y + z*pt.z);
}

template<typename _Tp> inline
double Point3_<_Tp>::ddot(const Point3_& pt) const
{
    return (double)x*pt.x + (double)y*pt.y + (double)z*pt.z;
}

template<typename _Tp> inline
Point3_<_Tp> Point3_<_Tp>::cross(const Point3_<_Tp>& pt) const
{
    return Point3_<_Tp>(y*pt.z - z*pt.y, z*pt.x - x*pt.z, x*pt.y - y*pt.x);
}


template<typename _Tp> static inline
Point3_<_Tp>& operator += (Point3_<_Tp>& a, const Point3_<_Tp>& b)
{
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return a;
}

template<typename _Tp> static inline
Point3_<_Tp>& operator -= (Point3_<_Tp>& a, const Point3_<_Tp>& b)
{
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return a;
}

template<typename _Tp> static inline
Point3_<_Tp>& operator *= (Point3_<_Tp>& a, int b)
{
    a.x = saturate_cast<_Tp>(a.x * b);
    a.y = saturate_cast<_Tp>(a.y * b);
    a.z = saturate_cast<_Tp>(a.z * b);
    return a;
}

template<typename _Tp> static inline
Point3_<_Tp>& operator *= (Point3_<_Tp>& a, float b)
{
    a.x = saturate_cast<_Tp>(a.x * b);
    a.y = saturate_cast<_Tp>(a.y * b);
    a.z = saturate_cast<_Tp>(a.z * b);
    return a;
}

template<typename _Tp> static inline
Point3_<_Tp>& operator *= (Point3_<_Tp>& a, double b)
{
    a.x = saturate_cast<_Tp>(a.x * b);
    a.y = saturate_cast<_Tp>(a.y * b);
    a.z = saturate_cast<_Tp>(a.z * b);
    return a;
}

template<typename _Tp> static inline
Point3_<_Tp>& operator /= (Point3_<_Tp>& a, int b)
{
    a.x = saturate_cast<_Tp>(a.x / b);
    a.y = saturate_cast<_Tp>(a.y / b);
    a.z = saturate_cast<_Tp>(a.z / b);
    return a;
}

template<typename _Tp> static inline
Point3_<_Tp>& operator /= (Point3_<_Tp>& a, float b)
{
    a.x = saturate_cast<_Tp>(a.x / b);
    a.y = saturate_cast<_Tp>(a.y / b);
    a.z = saturate_cast<_Tp>(a.z / b);
    return a;
}

template<typename _Tp> static inline
Point3_<_Tp>& operator /= (Point3_<_Tp>& a, double b)
{
    a.x = saturate_cast<_Tp>(a.x / b);
    a.y = saturate_cast<_Tp>(a.y / b);
    a.z = saturate_cast<_Tp>(a.z / b);
    return a;
}

template<typename _Tp> static inline
double norm(const Point3_<_Tp>& pt)
{
    return std::sqrt((double)pt.x*pt.x + (double)pt.y*pt.y + (double)pt.z*pt.z);
}

template<typename _Tp> static inline
bool operator == (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
{
    return a.x == b.x && a.y == b.y && a.z == b.z;
}

template<typename _Tp> static inline
bool operator != (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
{
    return a.x != b.x || a.y != b.y || a.z != b.z;
}

template<typename _Tp> static inline
Point3_<_Tp> operator + (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
{
    return Point3_<_Tp>( saturate_cast<_Tp>(a.x + b.x), saturate_cast<_Tp>(a.y + b.y), saturate_cast<_Tp>(a.z + b.z));
}

template<typename _Tp> static inline
Point3_<_Tp> operator - (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
{
    return Point3_<_Tp>( saturate_cast<_Tp>(a.x - b.x), saturate_cast<_Tp>(a.y - b.y), saturate_cast<_Tp>(a.z - b.z));
}

template<typename _Tp> static inline
Point3_<_Tp> operator - (const Point3_<_Tp>& a)
{
    return Point3_<_Tp>( saturate_cast<_Tp>(-a.x), saturate_cast<_Tp>(-a.y), saturate_cast<_Tp>(-a.z) );
}

template<typename _Tp> static inline
Point3_<_Tp> operator * (const Point3_<_Tp>& a, int b)
{
    return Point3_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b), saturate_cast<_Tp>(a.z*b) );
}

template<typename _Tp> static inline
Point3_<_Tp> operator * (int a, const Point3_<_Tp>& b)
{
    return Point3_<_Tp>( saturate_cast<_Tp>(b.x * a), saturate_cast<_Tp>(b.y * a), saturate_cast<_Tp>(b.z * a) );
}

template<typename _Tp> static inline
Point3_<_Tp> operator * (const Point3_<_Tp>& a, float b)
{
    return Point3_<_Tp>( saturate_cast<_Tp>(a.x * b), saturate_cast<_Tp>(a.y * b), saturate_cast<_Tp>(a.z * b) );
}

template<typename _Tp> static inline
Point3_<_Tp> operator * (float a, const Point3_<_Tp>& b)
{
    return Point3_<_Tp>( saturate_cast<_Tp>(b.x * a), saturate_cast<_Tp>(b.y * a), saturate_cast<_Tp>(b.z * a) );
}

template<typename _Tp> static inline
Point3_<_Tp> operator * (const Point3_<_Tp>& a, double b)
{
    return Point3_<_Tp>( saturate_cast<_Tp>(a.x * b), saturate_cast<_Tp>(a.y * b), saturate_cast<_Tp>(a.z * b) );
}

template<typename _Tp> static inline
Point3_<_Tp> operator * (double a, const Point3_<_Tp>& b)
{
    return Point3_<_Tp>( saturate_cast<_Tp>(b.x * a), saturate_cast<_Tp>(b.y * a), saturate_cast<_Tp>(b.z * a) );
}

template<typename _Tp> static inline
Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point3_<_Tp>& b)
{
    Matx<_Tp, 3, 1> tmp = a * Vec<_Tp,3>(b.x, b.y, b.z);
    return Point3_<_Tp>(tmp.val[0], tmp.val[1], tmp.val[2]);
}

template<typename _Tp> static inline
Matx<_Tp, 4, 1> operator * (const Matx<_Tp, 4, 4>& a, const Point3_<_Tp>& b)
{
    return a * Matx<_Tp, 4, 1>(b.x, b.y, b.z, 1);
}

template<typename _Tp> static inline
Point3_<_Tp> operator / (const Point3_<_Tp>& a, int b)
{
    Point3_<_Tp> tmp(a);
    tmp /= b;
    return tmp;
}

template<typename _Tp> static inline
Point3_<_Tp> operator / (const Point3_<_Tp>& a, float b)
{
    Point3_<_Tp> tmp(a);
    tmp /= b;
    return tmp;
}

template<typename _Tp> static inline
Point3_<_Tp> operator / (const Point3_<_Tp>& a, double b)
{
    Point3_<_Tp> tmp(a);
    tmp /= b;
    return tmp;
}





template<typename _Tp> inline
Size_<_Tp>::Size_()
    : width(0), height(0) {}

template<typename _Tp> inline
Size_<_Tp>::Size_(_Tp _width, _Tp _height)
    : width(_width), height(_height) {}

template<typename _Tp> inline
Size_<_Tp>::Size_(const Size_& sz)
    : width(sz.width), height(sz.height) {}

template<typename _Tp> inline
Size_<_Tp>::Size_(const Point_<_Tp>& pt)
    : width(pt.x), height(pt.y) {}

template<typename _Tp> template<typename _Tp2> inline
Size_<_Tp>::operator Size_<_Tp2>() const
{
    return Size_<_Tp2>(saturate_cast<_Tp2>(width), saturate_cast<_Tp2>(height));
}

template<typename _Tp> inline
Size_<_Tp>& Size_<_Tp>::operator = (const Size_<_Tp>& sz)
{
    width = sz.width; height = sz.height;
    return *this;
}

template<typename _Tp> inline
_Tp Size_<_Tp>::area() const
{
    const _Tp result = width * height;
    ; 
#line 1603 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types.hpp"
    return result;
}

template<typename _Tp> inline
bool Size_<_Tp>::empty() const
{
    return width <= 0 || height <= 0;
}


template<typename _Tp> static inline
Size_<_Tp>& operator *= (Size_<_Tp>& a, _Tp b)
{
    a.width *= b;
    a.height *= b;
    return a;
}

template<typename _Tp> static inline
Size_<_Tp> operator * (const Size_<_Tp>& a, _Tp b)
{
    Size_<_Tp> tmp(a);
    tmp *= b;
    return tmp;
}

template<typename _Tp> static inline
Size_<_Tp>& operator /= (Size_<_Tp>& a, _Tp b)
{
    a.width /= b;
    a.height /= b;
    return a;
}

template<typename _Tp> static inline
Size_<_Tp> operator / (const Size_<_Tp>& a, _Tp b)
{
    Size_<_Tp> tmp(a);
    tmp /= b;
    return tmp;
}

template<typename _Tp> static inline
Size_<_Tp>& operator += (Size_<_Tp>& a, const Size_<_Tp>& b)
{
    a.width += b.width;
    a.height += b.height;
    return a;
}

template<typename _Tp> static inline
Size_<_Tp> operator + (const Size_<_Tp>& a, const Size_<_Tp>& b)
{
    Size_<_Tp> tmp(a);
    tmp += b;
    return tmp;
}

template<typename _Tp> static inline
Size_<_Tp>& operator -= (Size_<_Tp>& a, const Size_<_Tp>& b)
{
    a.width -= b.width;
    a.height -= b.height;
    return a;
}

template<typename _Tp> static inline
Size_<_Tp> operator - (const Size_<_Tp>& a, const Size_<_Tp>& b)
{
    Size_<_Tp> tmp(a);
    tmp -= b;
    return tmp;
}

template<typename _Tp> static inline
bool operator == (const Size_<_Tp>& a, const Size_<_Tp>& b)
{
    return a.width == b.width && a.height == b.height;
}

template<typename _Tp> static inline
bool operator != (const Size_<_Tp>& a, const Size_<_Tp>& b)
{
    return !(a == b);
}





template<typename _Tp> inline
Rect_<_Tp>::Rect_()
    : x(0), y(0), width(0), height(0) {}

template<typename _Tp> inline
Rect_<_Tp>::Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height)
    : x(_x), y(_y), width(_width), height(_height) {}

template<typename _Tp> inline
Rect_<_Tp>::Rect_(const Rect_<_Tp>& r)
    : x(r.x), y(r.y), width(r.width), height(r.height) {}

template<typename _Tp> inline
Rect_<_Tp>::Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz)
    : x(org.x), y(org.y), width(sz.width), height(sz.height) {}

template<typename _Tp> inline
Rect_<_Tp>::Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)
{
    x = std::min(pt1.x, pt2.x);
    y = std::min(pt1.y, pt2.y);
    width = std::max(pt1.x, pt2.x) - x;
    height = std::max(pt1.y, pt2.y) - y;
}

template<typename _Tp> inline
Rect_<_Tp>& Rect_<_Tp>::operator = ( const Rect_<_Tp>& r )
{
    x = r.x;
    y = r.y;
    width = r.width;
    height = r.height;
    return *this;
}

template<typename _Tp> inline
Point_<_Tp> Rect_<_Tp>::tl() const
{
    return Point_<_Tp>(x,y);
}

template<typename _Tp> inline
Point_<_Tp> Rect_<_Tp>::br() const
{
    return Point_<_Tp>(x + width, y + height);
}

template<typename _Tp> inline
Size_<_Tp> Rect_<_Tp>::size() const
{
    return Size_<_Tp>(width, height);
}

template<typename _Tp> inline
_Tp Rect_<_Tp>::area() const
{
    const _Tp result = width * height;
    ; 
#line 1752 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types.hpp"
    return result;
}

template<typename _Tp> inline
bool Rect_<_Tp>::empty() const
{
    return width <= 0 || height <= 0;
}

template<typename _Tp> template<typename _Tp2> inline
Rect_<_Tp>::operator Rect_<_Tp2>() const
{
    return Rect_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y), saturate_cast<_Tp2>(width), saturate_cast<_Tp2>(height));
}

template<typename _Tp> inline
bool Rect_<_Tp>::contains(const Point_<_Tp>& pt) const
{
    return x <= pt.x && pt.x < x + width && y <= pt.y && pt.y < y + height;
}


template<typename _Tp> static inline
Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Point_<_Tp>& b )
{
    a.x += b.x;
    a.y += b.y;
    return a;
}

template<typename _Tp> static inline
Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Point_<_Tp>& b )
{
    a.x -= b.x;
    a.y -= b.y;
    return a;
}

template<typename _Tp> static inline
Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Size_<_Tp>& b )
{
    a.width += b.width;
    a.height += b.height;
    return a;
}

template<typename _Tp> static inline
Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Size_<_Tp>& b )
{
    a.width -= b.width;
    a.height -= b.height;
    return a;
}

template<typename _Tp> static inline
Rect_<_Tp>& operator &= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )
{
    _Tp x1 = std::max(a.x, b.x);
    _Tp y1 = std::max(a.y, b.y);
    a.width = std::min(a.x + a.width, b.x + b.width) - x1;
    a.height = std::min(a.y + a.height, b.y + b.height) - y1;
    a.x = x1;
    a.y = y1;
    if( a.width <= 0 || a.height <= 0 )
        a = Rect();
    return a;
}

template<typename _Tp> static inline
Rect_<_Tp>& operator |= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )
{
    if (a.empty()) {
        a = b;
    }
    else if (!b.empty()) {
        _Tp x1 = std::min(a.x, b.x);
        _Tp y1 = std::min(a.y, b.y);
        a.width = std::max(a.x + a.width, b.x + b.width) - x1;
        a.height = std::max(a.y + a.height, b.y + b.height) - y1;
        a.x = x1;
        a.y = y1;
    }
    return a;
}

template<typename _Tp> static inline
bool operator == (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
{
    return a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height;
}

template<typename _Tp> static inline
bool operator != (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
{
    return a.x != b.x || a.y != b.y || a.width != b.width || a.height != b.height;
}

template<typename _Tp> static inline
Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Point_<_Tp>& b)
{
    return Rect_<_Tp>( a.x + b.x, a.y + b.y, a.width, a.height );
}

template<typename _Tp> static inline
Rect_<_Tp> operator - (const Rect_<_Tp>& a, const Point_<_Tp>& b)
{
    return Rect_<_Tp>( a.x - b.x, a.y - b.y, a.width, a.height );
}

template<typename _Tp> static inline
Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Size_<_Tp>& b)
{
    return Rect_<_Tp>( a.x, a.y, a.width + b.width, a.height + b.height );
}

template<typename _Tp> static inline
Rect_<_Tp> operator & (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
{
    Rect_<_Tp> c = a;
    return c &= b;
}

template<typename _Tp> static inline
Rect_<_Tp> operator | (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
{
    Rect_<_Tp> c = a;
    return c |= b;
}







template<typename _Tp> static inline
double jaccardDistance(const Rect_<_Tp>& a, const Rect_<_Tp>& b) {
    _Tp Aa = a.area();
    _Tp Ab = b.area();

    if ((Aa + Ab) <= std::numeric_limits<_Tp>::epsilon()) {
        
        return 0.0;
    }

    double Aab = (a & b).area();
    
    return 1.0 - Aab / (Aa + Ab - Aab);
}



inline
RotatedRect::RotatedRect()
    : center(), size(), angle(0) {}

inline
RotatedRect::RotatedRect(const Point2f& _center, const Size2f& _size, float _angle)
    : center(_center), size(_size), angle(_angle) {}





inline
Range::Range()
    : start(0), end(0) {}

inline
Range::Range(int _start, int _end)
    : start(_start), end(_end) {}

inline
int Range::size() const
{
    return end - start;
}

inline
bool Range::empty() const
{
    return start == end;
}

inline
Range Range::all()
{
    return Range((-2147483647 - 1), 2147483647);
}


static inline
bool operator == (const Range& r1, const Range& r2)
{
    return r1.start == r2.start && r1.end == r2.end;
}

static inline
bool operator != (const Range& r1, const Range& r2)
{
    return !(r1 == r2);
}

static inline
bool operator !(const Range& r)
{
    return r.start == r.end;
}

static inline
Range operator & (const Range& r1, const Range& r2)
{
    Range r(std::max(r1.start, r2.start), std::min(r1.end, r2.end));
    r.end = std::max(r.end, r.start);
    return r;
}

static inline
Range& operator &= (Range& r1, const Range& r2)
{
    r1 = r1 & r2;
    return r1;
}

static inline
Range operator + (const Range& r1, int delta)
{
    return Range(r1.start + delta, r1.end + delta);
}

static inline
Range operator + (int delta, const Range& r1)
{
    return Range(r1.start + delta, r1.end + delta);
}

static inline
Range operator - (const Range& r1, int delta)
{
    return r1 + (-delta);
}





template<typename _Tp> inline
Scalar_<_Tp>::Scalar_()
{
    this->val[0] = this->val[1] = this->val[2] = this->val[3] = 0;
}

template<typename _Tp> inline
Scalar_<_Tp>::Scalar_(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
{
    this->val[0] = v0;
    this->val[1] = v1;
    this->val[2] = v2;
    this->val[3] = v3;
}

template<typename _Tp> template<typename _Tp2, int cn> inline
Scalar_<_Tp>::Scalar_(const Vec<_Tp2, cn>& v)
{
    int i;
    for( i = 0; i < (cn < 4 ? cn : 4); i++ )
        this->val[i] = cv::saturate_cast<_Tp>(v.val[i]);
    for( ; i < 4; i++ )
        this->val[i] = 0;
}

template<typename _Tp> inline
Scalar_<_Tp>::Scalar_(_Tp v0)
{
    this->val[0] = v0;
    this->val[1] = this->val[2] = this->val[3] = 0;
}

template<typename _Tp> inline
Scalar_<_Tp> Scalar_<_Tp>::all(_Tp v0)
{
    return Scalar_<_Tp>(v0, v0, v0, v0);
}


template<typename _Tp> inline
Scalar_<_Tp> Scalar_<_Tp>::mul(const Scalar_<_Tp>& a, double scale ) const
{
    return Scalar_<_Tp>(saturate_cast<_Tp>(this->val[0] * a.val[0] * scale),
                        saturate_cast<_Tp>(this->val[1] * a.val[1] * scale),
                        saturate_cast<_Tp>(this->val[2] * a.val[2] * scale),
                        saturate_cast<_Tp>(this->val[3] * a.val[3] * scale));
}

template<typename _Tp> inline
Scalar_<_Tp> Scalar_<_Tp>::conj() const
{
    return Scalar_<_Tp>(saturate_cast<_Tp>( this->val[0]),
                        saturate_cast<_Tp>(-this->val[1]),
                        saturate_cast<_Tp>(-this->val[2]),
                        saturate_cast<_Tp>(-this->val[3]));
}

template<typename _Tp> inline
bool Scalar_<_Tp>::isReal() const
{
    return this->val[1] == 0 && this->val[2] == 0 && this->val[3] == 0;
}


template<typename _Tp> template<typename T2> inline
Scalar_<_Tp>::operator Scalar_<T2>() const
{
    return Scalar_<T2>(saturate_cast<T2>(this->val[0]),
                       saturate_cast<T2>(this->val[1]),
                       saturate_cast<T2>(this->val[2]),
                       saturate_cast<T2>(this->val[3]));
}


template<typename _Tp> static inline
Scalar_<_Tp>& operator += (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
{
    a.val[0] += b.val[0];
    a.val[1] += b.val[1];
    a.val[2] += b.val[2];
    a.val[3] += b.val[3];
    return a;
}

template<typename _Tp> static inline
Scalar_<_Tp>& operator -= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
{
    a.val[0] -= b.val[0];
    a.val[1] -= b.val[1];
    a.val[2] -= b.val[2];
    a.val[3] -= b.val[3];
    return a;
}

template<typename _Tp> static inline
Scalar_<_Tp>& operator *= ( Scalar_<_Tp>& a, _Tp v )
{
    a.val[0] *= v;
    a.val[1] *= v;
    a.val[2] *= v;
    a.val[3] *= v;
    return a;
}

template<typename _Tp> static inline
bool operator == ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
{
    return a.val[0] == b.val[0] && a.val[1] == b.val[1] &&
           a.val[2] == b.val[2] && a.val[3] == b.val[3];
}

template<typename _Tp> static inline
bool operator != ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
{
    return a.val[0] != b.val[0] || a.val[1] != b.val[1] ||
           a.val[2] != b.val[2] || a.val[3] != b.val[3];
}

template<typename _Tp> static inline
Scalar_<_Tp> operator + (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
{
    return Scalar_<_Tp>(a.val[0] + b.val[0],
                        a.val[1] + b.val[1],
                        a.val[2] + b.val[2],
                        a.val[3] + b.val[3]);
}

template<typename _Tp> static inline
Scalar_<_Tp> operator - (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
{
    return Scalar_<_Tp>(saturate_cast<_Tp>(a.val[0] - b.val[0]),
                        saturate_cast<_Tp>(a.val[1] - b.val[1]),
                        saturate_cast<_Tp>(a.val[2] - b.val[2]),
                        saturate_cast<_Tp>(a.val[3] - b.val[3]));
}

template<typename _Tp> static inline
Scalar_<_Tp> operator * (const Scalar_<_Tp>& a, _Tp alpha)
{
    return Scalar_<_Tp>(a.val[0] * alpha,
                        a.val[1] * alpha,
                        a.val[2] * alpha,
                        a.val[3] * alpha);
}

template<typename _Tp> static inline
Scalar_<_Tp> operator * (_Tp alpha, const Scalar_<_Tp>& a)
{
    return a*alpha;
}

template<typename _Tp> static inline
Scalar_<_Tp> operator - (const Scalar_<_Tp>& a)
{
    return Scalar_<_Tp>(saturate_cast<_Tp>(-a.val[0]),
                        saturate_cast<_Tp>(-a.val[1]),
                        saturate_cast<_Tp>(-a.val[2]),
                        saturate_cast<_Tp>(-a.val[3]));
}


template<typename _Tp> static inline
Scalar_<_Tp> operator * (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
{
    return Scalar_<_Tp>(saturate_cast<_Tp>(a[0]*b[0] - a[1]*b[1] - a[2]*b[2] - a[3]*b[3]),
                        saturate_cast<_Tp>(a[0]*b[1] + a[1]*b[0] + a[2]*b[3] - a[3]*b[2]),
                        saturate_cast<_Tp>(a[0]*b[2] - a[1]*b[3] + a[2]*b[0] + a[3]*b[1]),
                        saturate_cast<_Tp>(a[0]*b[3] + a[1]*b[2] - a[2]*b[1] + a[3]*b[0]));
}

template<typename _Tp> static inline
Scalar_<_Tp>& operator *= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
{
    a = a * b;
    return a;
}

template<typename _Tp> static inline
Scalar_<_Tp> operator / (const Scalar_<_Tp>& a, _Tp alpha)
{
    return Scalar_<_Tp>(a.val[0] / alpha,
                        a.val[1] / alpha,
                        a.val[2] / alpha,
                        a.val[3] / alpha);
}

template<typename _Tp> static inline
Scalar_<float> operator / (const Scalar_<float>& a, float alpha)
{
    float s = 1 / alpha;
    return Scalar_<float>(a.val[0] * s, a.val[1] * s, a.val[2] * s, a.val[3] * s);
}

template<typename _Tp> static inline
Scalar_<double> operator / (const Scalar_<double>& a, double alpha)
{
    double s = 1 / alpha;
    return Scalar_<double>(a.val[0] * s, a.val[1] * s, a.val[2] * s, a.val[3] * s);
}

template<typename _Tp> static inline
Scalar_<_Tp>& operator /= (Scalar_<_Tp>& a, _Tp alpha)
{
    a = a / alpha;
    return a;
}

template<typename _Tp> static inline
Scalar_<_Tp> operator / (_Tp a, const Scalar_<_Tp>& b)
{
    _Tp s = a / (b[0]*b[0] + b[1]*b[1] + b[2]*b[2] + b[3]*b[3]);
    return b.conj() * s;
}

template<typename _Tp> static inline
Scalar_<_Tp> operator / (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
{
    return a * ((_Tp)1 / b);
}

template<typename _Tp> static inline
Scalar_<_Tp>& operator /= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
{
    a = a / b;
    return a;
}

template<typename _Tp> static inline
Scalar operator * (const Matx<_Tp, 4, 4>& a, const Scalar& b)
{
    Matx<double, 4, 1> c((Matx<double, 4, 4>)a, b, Matx_MatMulOp());
    return reinterpret_cast<const Scalar&>(c);
}

template<> inline
Scalar operator * (const Matx<double, 4, 4>& a, const Scalar& b)
{
    Matx<double, 4, 1> c(a, b, Matx_MatMulOp());
    return reinterpret_cast<const Scalar&>(c);
}





inline
KeyPoint::KeyPoint()
    : pt(0,0), size(0), angle(-1), response(0), octave(0), class_id(-1) {}

inline
KeyPoint::KeyPoint(Point2f _pt, float _size, float _angle, float _response, int _octave, int _class_id)
    : pt(_pt), size(_size), angle(_angle), response(_response), octave(_octave), class_id(_class_id) {}

inline
KeyPoint::KeyPoint(float x, float y, float _size, float _angle, float _response, int _octave, int _class_id)
    : pt(x, y), size(_size), angle(_angle), response(_response), octave(_octave), class_id(_class_id) {}





inline
DMatch::DMatch()
    : queryIdx(-1), trainIdx(-1), imgIdx(-1), distance(3.402823466e+38F) {}

inline
DMatch::DMatch(int _queryIdx, int _trainIdx, float _distance)
    : queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx(-1), distance(_distance) {}

inline
DMatch::DMatch(int _queryIdx, int _trainIdx, int _imgIdx, float _distance)
    : queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx(_imgIdx), distance(_distance) {}

inline
bool DMatch::operator < (const DMatch &m) const
{
    return distance < m.distance;
}





inline
TermCriteria::TermCriteria()
    : type(0), maxCount(0), epsilon(0) {}

inline
TermCriteria::TermCriteria(int _type, int _maxCount, double _epsilon)
    : type(_type), maxCount(_maxCount), epsilon(_epsilon) {}



} 

#line 2294 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types.hpp"

#line 59 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.hpp"


















































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/matx.hpp"









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 52 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types.hpp"






















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 53 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.hpp"

#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/bufferpool.hpp"










#pragma warning(push)
#pragma warning(disable: 4265)
#line 14 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/bufferpool.hpp"

namespace cv
{




class BufferPoolController
{
protected:
    ~BufferPoolController() { }
public:
    virtual size_t getReservedSize() const = 0;
    virtual size_t getMaxReservedSize() const = 0;
    virtual void setMaxReservedSize(size_t size) = 0;
    virtual void freeAllReservedBuffers() = 0;
};



}


#pragma warning(pop)
#line 39 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/bufferpool.hpp"

#line 41 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/bufferpool.hpp"
#line 55 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.hpp"

namespace cv
{




enum { ACCESS_READ=1<<24, ACCESS_WRITE=1<<25,
    ACCESS_RW=3<<24, ACCESS_MASK=ACCESS_RW, ACCESS_FAST=1<<26 };



class  _OutputArray;
















































































class  _InputArray
{
public:
    enum {
        KIND_SHIFT = 16,
        FIXED_TYPE = 0x8000 << KIND_SHIFT,
        FIXED_SIZE = 0x4000 << KIND_SHIFT,
        KIND_MASK = 31 << KIND_SHIFT,

        NONE              = 0 << KIND_SHIFT,
        MAT               = 1 << KIND_SHIFT,
        MATX              = 2 << KIND_SHIFT,
        STD_VECTOR        = 3 << KIND_SHIFT,
        STD_VECTOR_VECTOR = 4 << KIND_SHIFT,
        STD_VECTOR_MAT    = 5 << KIND_SHIFT,
        EXPR              = 6 << KIND_SHIFT,
        OPENGL_BUFFER     = 7 << KIND_SHIFT,
        CUDA_HOST_MEM     = 8 << KIND_SHIFT,
        CUDA_GPU_MAT      = 9 << KIND_SHIFT,
        UMAT              =10 << KIND_SHIFT,
        STD_VECTOR_UMAT   =11 << KIND_SHIFT,
        STD_BOOL_VECTOR   =12 << KIND_SHIFT,
        STD_VECTOR_CUDA_GPU_MAT = 13 << KIND_SHIFT,
        STD_ARRAY         =14 << KIND_SHIFT,
        STD_ARRAY_MAT     =15 << KIND_SHIFT
    };

    _InputArray();
    _InputArray(int _flags, void* _obj);
    _InputArray(const Mat& m);
    _InputArray(const MatExpr& expr);
    _InputArray(const std::vector<Mat>& vec);
    template<typename _Tp> _InputArray(const Mat_<_Tp>& m);
    template<typename _Tp> _InputArray(const std::vector<_Tp>& vec);
    _InputArray(const std::vector<bool>& vec);
    template<typename _Tp> _InputArray(const std::vector<std::vector<_Tp> >& vec);
    _InputArray(const std::vector<std::vector<bool> >&);
    template<typename _Tp> _InputArray(const std::vector<Mat_<_Tp> >& vec);
    template<typename _Tp> _InputArray(const _Tp* vec, int n);
    template<typename _Tp, int m, int n> _InputArray(const Matx<_Tp, m, n>& matx);
    _InputArray(const double& val);
    _InputArray(const cuda::GpuMat& d_mat);
    _InputArray(const std::vector<cuda::GpuMat>& d_mat_array);
    _InputArray(const ogl::Buffer& buf);
    _InputArray(const cuda::HostMem& cuda_mem);
    template<typename _Tp> _InputArray(const cudev::GpuMat_<_Tp>& m);
    _InputArray(const UMat& um);
    _InputArray(const std::vector<UMat>& umv);






    Mat getMat(int idx=-1) const;
    Mat getMat_(int idx=-1) const;
    UMat getUMat(int idx=-1) const;
    void getMatVector(std::vector<Mat>& mv) const;
    void getUMatVector(std::vector<UMat>& umv) const;
    void getGpuMatVector(std::vector<cuda::GpuMat>& gpumv) const;
    cuda::GpuMat getGpuMat() const;
    ogl::Buffer getOGlBuffer() const;

    int getFlags() const;
    void* getObj() const;
    Size getSz() const;

    int kind() const;
    int dims(int i=-1) const;
    int cols(int i=-1) const;
    int rows(int i=-1) const;
    Size size(int i=-1) const;
    int sizend(int* sz, int i=-1) const;
    bool sameSize(const _InputArray& arr) const;
    size_t total(int i=-1) const;
    int type(int i=-1) const;
    int depth(int i=-1) const;
    int channels(int i=-1) const;
    bool isContinuous(int i=-1) const;
    bool isSubmatrix(int i=-1) const;
    bool empty() const;
    void copyTo(const _OutputArray& arr) const;
    void copyTo(const _OutputArray& arr, const _InputArray & mask) const;
    size_t offset(int i=-1) const;
    size_t step(int i=-1) const;
    bool isMat() const;
    bool isUMat() const;
    bool isMatVector() const;
    bool isUMatVector() const;
    bool isMatx() const;
    bool isVector() const;
    bool isGpuMatVector() const;
    ~_InputArray();

protected:
    int flags;
    void* obj;
    Size sz;

    void init(int _flags, const void* _obj);
    void init(int _flags, const void* _obj, Size _sz);
};



























class  _OutputArray : public _InputArray
{
public:
    enum
    {
        DEPTH_MASK_8U = 1 << 0,
        DEPTH_MASK_8S = 1 << 1,
        DEPTH_MASK_16U = 1 << 2,
        DEPTH_MASK_16S = 1 << 3,
        DEPTH_MASK_32S = 1 << 4,
        DEPTH_MASK_32F = 1 << 5,
        DEPTH_MASK_64F = 1 << 6,
        DEPTH_MASK_ALL = (DEPTH_MASK_64F<<1)-1,
        DEPTH_MASK_ALL_BUT_8S = DEPTH_MASK_ALL & ~DEPTH_MASK_8S,
        DEPTH_MASK_FLT = DEPTH_MASK_32F + DEPTH_MASK_64F
    };

    _OutputArray();
    _OutputArray(int _flags, void* _obj);
    _OutputArray(Mat& m);
    _OutputArray(std::vector<Mat>& vec);
    _OutputArray(cuda::GpuMat& d_mat);
    _OutputArray(std::vector<cuda::GpuMat>& d_mat);
    _OutputArray(ogl::Buffer& buf);
    _OutputArray(cuda::HostMem& cuda_mem);
    template<typename _Tp> _OutputArray(cudev::GpuMat_<_Tp>& m);
    template<typename _Tp> _OutputArray(std::vector<_Tp>& vec);
    _OutputArray(std::vector<bool>& vec);
    template<typename _Tp> _OutputArray(std::vector<std::vector<_Tp> >& vec);
    _OutputArray(std::vector<std::vector<bool> >&);
    template<typename _Tp> _OutputArray(std::vector<Mat_<_Tp> >& vec);
    template<typename _Tp> _OutputArray(Mat_<_Tp>& m);
    template<typename _Tp> _OutputArray(_Tp* vec, int n);
    template<typename _Tp, int m, int n> _OutputArray(Matx<_Tp, m, n>& matx);
    _OutputArray(UMat& m);
    _OutputArray(std::vector<UMat>& vec);

    _OutputArray(const Mat& m);
    _OutputArray(const std::vector<Mat>& vec);
    _OutputArray(const cuda::GpuMat& d_mat);
    _OutputArray(const std::vector<cuda::GpuMat>& d_mat);
    _OutputArray(const ogl::Buffer& buf);
    _OutputArray(const cuda::HostMem& cuda_mem);
    template<typename _Tp> _OutputArray(const cudev::GpuMat_<_Tp>& m);
    template<typename _Tp> _OutputArray(const std::vector<_Tp>& vec);
    template<typename _Tp> _OutputArray(const std::vector<std::vector<_Tp> >& vec);
    template<typename _Tp> _OutputArray(const std::vector<Mat_<_Tp> >& vec);
    template<typename _Tp> _OutputArray(const Mat_<_Tp>& m);
    template<typename _Tp> _OutputArray(const _Tp* vec, int n);
    template<typename _Tp, int m, int n> _OutputArray(const Matx<_Tp, m, n>& matx);
    _OutputArray(const UMat& m);
    _OutputArray(const std::vector<UMat>& vec);








    bool fixedSize() const;
    bool fixedType() const;
    bool needed() const;
    Mat& getMatRef(int i=-1) const;
    UMat& getUMatRef(int i=-1) const;
    cuda::GpuMat& getGpuMatRef() const;
    std::vector<cuda::GpuMat>& getGpuMatVecRef() const;
    ogl::Buffer& getOGlBufferRef() const;
    cuda::HostMem& getHostMemRef() const;
    void create(Size sz, int type, int i=-1, bool allowTransposed=false, int fixedDepthMask=0) const;
    void create(int rows, int cols, int type, int i=-1, bool allowTransposed=false, int fixedDepthMask=0) const;
    void create(int dims, const int* size, int type, int i=-1, bool allowTransposed=false, int fixedDepthMask=0) const;
    void createSameSize(const _InputArray& arr, int mtype) const;
    void release() const;
    void clear() const;
    void setTo(const _InputArray& value, const _InputArray & mask = _InputArray()) const;

    void assign(const UMat& u) const;
    void assign(const Mat& m) const;
};


class  _InputOutputArray : public _OutputArray
{
public:
    _InputOutputArray();
    _InputOutputArray(int _flags, void* _obj);
    _InputOutputArray(Mat& m);
    _InputOutputArray(std::vector<Mat>& vec);
    _InputOutputArray(cuda::GpuMat& d_mat);
    _InputOutputArray(ogl::Buffer& buf);
    _InputOutputArray(cuda::HostMem& cuda_mem);
    template<typename _Tp> _InputOutputArray(cudev::GpuMat_<_Tp>& m);
    template<typename _Tp> _InputOutputArray(std::vector<_Tp>& vec);
    _InputOutputArray(std::vector<bool>& vec);
    template<typename _Tp> _InputOutputArray(std::vector<std::vector<_Tp> >& vec);
    template<typename _Tp> _InputOutputArray(std::vector<Mat_<_Tp> >& vec);
    template<typename _Tp> _InputOutputArray(Mat_<_Tp>& m);
    template<typename _Tp> _InputOutputArray(_Tp* vec, int n);
    template<typename _Tp, int m, int n> _InputOutputArray(Matx<_Tp, m, n>& matx);
    _InputOutputArray(UMat& m);
    _InputOutputArray(std::vector<UMat>& vec);

    _InputOutputArray(const Mat& m);
    _InputOutputArray(const std::vector<Mat>& vec);
    _InputOutputArray(const cuda::GpuMat& d_mat);
    _InputOutputArray(const std::vector<cuda::GpuMat>& d_mat);
    _InputOutputArray(const ogl::Buffer& buf);
    _InputOutputArray(const cuda::HostMem& cuda_mem);
    template<typename _Tp> _InputOutputArray(const cudev::GpuMat_<_Tp>& m);
    template<typename _Tp> _InputOutputArray(const std::vector<_Tp>& vec);
    template<typename _Tp> _InputOutputArray(const std::vector<std::vector<_Tp> >& vec);
    template<typename _Tp> _InputOutputArray(const std::vector<Mat_<_Tp> >& vec);
    template<typename _Tp> _InputOutputArray(const Mat_<_Tp>& m);
    template<typename _Tp> _InputOutputArray(const _Tp* vec, int n);
    template<typename _Tp, int m, int n> _InputOutputArray(const Matx<_Tp, m, n>& matx);
    _InputOutputArray(const UMat& m);
    _InputOutputArray(const std::vector<UMat>& vec);








};



typedef const _InputArray& InputArray;
typedef InputArray InputArrayOfArrays;
typedef const _OutputArray& OutputArray;
typedef OutputArray OutputArrayOfArrays;
typedef const _InputOutputArray& InputOutputArray;
typedef InputOutputArray InputOutputArrayOfArrays;

 InputOutputArray noArray();




enum UMatUsageFlags
{
    USAGE_DEFAULT = 0,

    
    USAGE_ALLOCATE_HOST_MEMORY = 1 << 0,
    USAGE_ALLOCATE_DEVICE_MEMORY = 1 << 1,
    USAGE_ALLOCATE_SHARED_MEMORY = 1 << 2, 

    __UMAT_USAGE_FLAGS_32BIT = 0x7fffffff 
};

struct  UMatData;



class  MatAllocator
{
public:
    MatAllocator() {}
    virtual ~MatAllocator() {}

    
    
    
    
    virtual UMatData* allocate(int dims, const int* sizes, int type,
                               void* data, size_t* step, int flags, UMatUsageFlags usageFlags) const = 0;
    virtual bool allocate(UMatData* data, int accessflags, UMatUsageFlags usageFlags) const = 0;
    virtual void deallocate(UMatData* data) const = 0;
    virtual void map(UMatData* data, int accessflags) const;
    virtual void unmap(UMatData* data) const;
    virtual void download(UMatData* data, void* dst, int dims, const size_t sz[],
                          const size_t srcofs[], const size_t srcstep[],
                          const size_t dststep[]) const;
    virtual void upload(UMatData* data, const void* src, int dims, const size_t sz[],
                        const size_t dstofs[], const size_t dststep[],
                        const size_t srcstep[]) const;
    virtual void copy(UMatData* srcdata, UMatData* dstdata, int dims, const size_t sz[],
                      const size_t srcofs[], const size_t srcstep[],
                      const size_t dstofs[], const size_t dststep[], bool sync) const;

    
    virtual BufferPoolController* getBufferPoolController(const char* id = 0) const;
};
















template<typename _Tp> class MatCommaInitializer_
{
public:
    
    MatCommaInitializer_(Mat_<_Tp>* _m);
    
    template<typename T2> MatCommaInitializer_<_Tp>& operator , (T2 v);
    
    operator Mat_<_Tp>() const;
protected:
    MatIterator_<_Tp> it;
};








struct  UMatData
{
    enum { COPY_ON_MAP=1, HOST_COPY_OBSOLETE=2,
        DEVICE_COPY_OBSOLETE=4, TEMP_UMAT=8, TEMP_COPIED_UMAT=24,
        USER_ALLOCATED=32, DEVICE_MEM_MAPPED=64,
        ASYNC_CLEANUP=128
    };
    UMatData(const MatAllocator* allocator);
    ~UMatData();

    
    void lock();
    void unlock();

    bool hostCopyObsolete() const;
    bool deviceCopyObsolete() const;
    bool deviceMemMapped() const;
    bool copyOnMap() const;
    bool tempUMat() const;
    bool tempCopiedUMat() const;
    void markHostCopyObsolete(bool flag);
    void markDeviceCopyObsolete(bool flag);
    void markDeviceMemMapped(bool flag);

    const MatAllocator* prevAllocator;
    const MatAllocator* currAllocator;
    int urefcount;
    int refcount;
    uchar* data;
    uchar* origdata;
    size_t size;

    int flags;
    void* handle;
    void* userdata;
    int allocatorFlags_;
    int mapcount;
    UMatData* originalUMatData;
};


struct  UMatDataAutoLock
{
    explicit UMatDataAutoLock(UMatData* u);
    ~UMatDataAutoLock();
    UMatData* u;
};


struct  MatSize
{
    explicit MatSize(int* _p);
    Size operator()() const;
    const int& operator[](int i) const;
    int& operator[](int i);
    operator const int*() const;
    bool operator == (const MatSize& sz) const;
    bool operator != (const MatSize& sz) const;

    int* p;
};

struct  MatStep
{
    MatStep();
    explicit MatStep(size_t s);
    const size_t& operator[](int i) const;
    size_t& operator[](int i);
    operator size_t() const;
    MatStep& operator = (size_t s);

    size_t* p;
    size_t buf[2];
protected:
    MatStep& operator = (const MatStep&);
};





 






























































































































































































class  Mat
{
public:
    





    Mat();

    





    Mat(int rows, int cols, int type);

    





    Mat(Size size, int type);

    








    Mat(int rows, int cols, int type, const Scalar& s);

    








    Mat(Size size, int type, const Scalar& s);

    





    Mat(int ndims, const int* sizes, int type);

    




    Mat(const std::vector<int>& sizes, int type);

    








    Mat(int ndims, const int* sizes, int type, const Scalar& s);

    







    Mat(const std::vector<int>& sizes, int type, const Scalar& s);


    






    Mat(const Mat& m);

    













    Mat(int rows, int cols, int type, void* data, size_t step=AUTO_STEP);

    













    Mat(Size size, int type, void* data, size_t step=AUTO_STEP);

    












    Mat(int ndims, const int* sizes, int type, void* data, const size_t* steps=0);

    











    Mat(const std::vector<int>& sizes, int type, void* data, const size_t* steps=0);

    









    Mat(const Mat& m, const Range& rowRange, const Range& colRange=Range::all());

    







    Mat(const Mat& m, const Rect& roi);

    







    Mat(const Mat& m, const Range* ranges);

    







    Mat(const Mat& m, const std::vector<Range>& ranges);

    















    template<typename _Tp> explicit Mat(const std::vector<_Tp>& vec, bool copyData=false);













    

    template<typename _Tp, int n> explicit Mat(const Vec<_Tp, n>& vec, bool copyData=true);

    

    template<typename _Tp, int m, int n> explicit Mat(const Matx<_Tp, m, n>& mtx, bool copyData=true);

    

    template<typename _Tp> explicit Mat(const Point_<_Tp>& pt, bool copyData=true);

    

    template<typename _Tp> explicit Mat(const Point3_<_Tp>& pt, bool copyData=true);

    

    template<typename _Tp> explicit Mat(const MatCommaInitializer_<_Tp>& commaInitializer);

    
    explicit Mat(const cuda::GpuMat& m);

    
    ~Mat();

    







    Mat& operator = (const Mat& m);

    






    Mat& operator = (const MatExpr& expr);

    
    UMat getUMat(int accessFlags, UMatUsageFlags usageFlags = USAGE_DEFAULT) const;

    
































    Mat row(int y) const;

    






    Mat col(int x) const;

    






    Mat rowRange(int startrow, int endrow) const;

    


    Mat rowRange(const Range& r) const;

    






    Mat colRange(int startcol, int endcol) const;

    


    Mat colRange(const Range& r) const;

    

































    Mat diag(int d=0) const;

    




    static Mat diag(const Mat& d);

    




    Mat clone() const;

    














    void copyTo( OutputArray m ) const;

    





    void copyTo( OutputArray m, InputArray mask ) const;

    












    void convertTo( OutputArray m, int rtype, double alpha=1, double beta=0 ) const;

    





    void assignTo( Mat& m, int type=-1 ) const;

    


    Mat& operator = (const Scalar& s);

    





    Mat& setTo(InputArray value, InputArray mask=noArray());

    























    Mat reshape(int cn, int rows=0) const;

    
    Mat reshape(int cn, int newndims, const int* newsz) const;

    
    Mat reshape(int cn, const std::vector<int>& newshape) const;

    









    MatExpr t() const;

    






    MatExpr inv(int method=DECOMP_LU) const;

    











    MatExpr mul(InputArray m, double scale=1) const;

    






    Mat cross(InputArray m) const;

    







    double dot(InputArray m) const;

    













    static MatExpr zeros(int rows, int cols, int type);

    



    static MatExpr zeros(Size size, int type);

    




    static MatExpr zeros(int ndims, const int* sz, int type);

    













    static MatExpr ones(int rows, int cols, int type);

    



    static MatExpr ones(Size size, int type);

    




    static MatExpr ones(int ndims, const int* sz, int type);

    











    static MatExpr eye(int rows, int cols, int type);

    



    static MatExpr eye(Size size, int type);

    
































    void create(int rows, int cols, int type);

    



    void create(Size size, int type);

    




    void create(int ndims, const int* sizes, int type);

    



    void create(const std::vector<int>& sizes, int type);

    








    void addref();

    












    void release();

    
    void deallocate();
    
    void copySize(const Mat& m);

    






    void reserve(size_t sz);

    





    void reserveBuffer(size_t sz);

    






    void resize(size_t sz);

    



    void resize(size_t sz, const Scalar& s);

    
    void push_back_(const void* elem);

    






    template<typename _Tp> void push_back(const _Tp& elem);

    


    template<typename _Tp> void push_back(const Mat_<_Tp>& elem);

    


    void push_back(const Mat& m);

    





    void pop_back(size_t nelems=1);

    










    void locateROI( Size& wholeSize, Point& ofs ) const;

    


























    Mat& adjustROI( int dtop, int dbottom, int dleft, int dright );

    










    Mat operator()( Range rowRange, Range colRange ) const;

    


    Mat operator()( const Rect& roi ) const;

    


    Mat operator()( const Range* ranges ) const;

    


    Mat operator()(const std::vector<Range>& ranges) const;

    
    
    
    
    
    

    template<typename _Tp> operator std::vector<_Tp>() const;
    template<typename _Tp, int n> operator Vec<_Tp, n>() const;
    template<typename _Tp, int m, int n> operator Matx<_Tp, m, n>() const;





    









































































    bool isContinuous() const;

    
    bool isSubmatrix() const;

    




    size_t elemSize() const;

    




    size_t elemSize1() const;

    




    int type() const;

    












    int depth() const;

    



    int channels() const;

    




    size_t step1(int i=0) const;

    




    bool empty() const;

    




    size_t total() const;

    



    size_t total(int startDim, int endDim=2147483647) const;

    
    int checkVector(int elemChannels, int depth=-1, bool requireContinuous=true) const;

    





    uchar* ptr(int i0=0);
    
    const uchar* ptr(int i0=0) const;

    



    uchar* ptr(int row, int col);
    



    const uchar* ptr(int row, int col) const;

    
    uchar* ptr(int i0, int i1, int i2);
    
    const uchar* ptr(int i0, int i1, int i2) const;

    
    uchar* ptr(const int* idx);
    
    const uchar* ptr(const int* idx) const;
    
    template<int n> uchar* ptr(const Vec<int, n>& idx);
    
    template<int n> const uchar* ptr(const Vec<int, n>& idx) const;

    
    template<typename _Tp> _Tp* ptr(int i0=0);
    
    template<typename _Tp> const _Tp* ptr(int i0=0) const;
    



    template<typename _Tp> _Tp* ptr(int row, int col);
    



    template<typename _Tp> const _Tp* ptr(int row, int col) const;
    
    template<typename _Tp> _Tp* ptr(int i0, int i1, int i2);
    
    template<typename _Tp> const _Tp* ptr(int i0, int i1, int i2) const;
    
    template<typename _Tp> _Tp* ptr(const int* idx);
    
    template<typename _Tp> const _Tp* ptr(const int* idx) const;
    
    template<typename _Tp, int n> _Tp* ptr(const Vec<int, n>& idx);
    
    template<typename _Tp, int n> const _Tp* ptr(const Vec<int, n>& idx) const;

    





























    template<typename _Tp> _Tp& at(int i0=0);
    


    template<typename _Tp> const _Tp& at(int i0=0) const;
    



    template<typename _Tp> _Tp& at(int row, int col);
    



    template<typename _Tp> const _Tp& at(int row, int col) const;

    




    template<typename _Tp> _Tp& at(int i0, int i1, int i2);
    




    template<typename _Tp> const _Tp& at(int i0, int i1, int i2) const;

    


    template<typename _Tp> _Tp& at(const int* idx);
    


    template<typename _Tp> const _Tp& at(const int* idx) const;

    
    template<typename _Tp, int n> _Tp& at(const Vec<int, n>& idx);
    
    template<typename _Tp, int n> const _Tp& at(const Vec<int, n>& idx) const;

    



    template<typename _Tp> _Tp& at(Point pt);
    



    template<typename _Tp> const _Tp& at(Point pt) const;

    



































    template<typename _Tp> MatIterator_<_Tp> begin();
    template<typename _Tp> MatConstIterator_<_Tp> begin() const;

    




    template<typename _Tp> MatIterator_<_Tp> end();
    template<typename _Tp> MatConstIterator_<_Tp> end() const;

    





















































    template<typename _Tp, typename Functor> void forEach(const Functor& operation);
    
    template<typename _Tp, typename Functor> void forEach(const Functor& operation) const;


    Mat(Mat&& m);
    Mat& operator = (Mat&& m);
#line 2033 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.hpp"

    enum { MAGIC_VAL  = 0x42FF0000, AUTO_STEP = 0, CONTINUOUS_FLAG = (1 << 14), SUBMATRIX_FLAG = (1 << 15) };
    enum { MAGIC_MASK = 0xFFFF0000, TYPE_MASK = 0x00000FFF, DEPTH_MASK = 7 };

    





    int flags;
    
    int dims;
    
    int rows, cols;
    
    uchar* data;

    
    const uchar* datastart;
    const uchar* dataend;
    const uchar* datalimit;

    
    MatAllocator* allocator;
    
    static MatAllocator* getStdAllocator();
    static MatAllocator* getDefaultAllocator();
    static void setDefaultAllocator(MatAllocator* allocator);

    
    UMatData* u;

    MatSize size;
    MatStep step;

protected:
    template<typename _Tp, typename Functor> void forEach_impl(const Functor& operation);
};































































template<typename _Tp> class Mat_ : public Mat
{
public:
    typedef _Tp value_type;
    typedef typename DataType<_Tp>::channel_type channel_type;
    typedef MatIterator_<_Tp> iterator;
    typedef MatConstIterator_<_Tp> const_iterator;

    
    Mat_();
    
    Mat_(int _rows, int _cols);
    
    Mat_(int _rows, int _cols, const _Tp& value);
    
    explicit Mat_(Size _size);
    
    Mat_(Size _size, const _Tp& value);
    
    Mat_(int _ndims, const int* _sizes);
    
    Mat_(int _ndims, const int* _sizes, const _Tp& value);
    
    Mat_(const Mat& m);
    
    Mat_(const Mat_& m);
    
    Mat_(int _rows, int _cols, _Tp* _data, size_t _step=AUTO_STEP);
    
    Mat_(int _ndims, const int* _sizes, _Tp* _data, const size_t* _steps=0);
    
    Mat_(const Mat_& m, const Range& rowRange, const Range& colRange=Range::all());
    
    Mat_(const Mat_& m, const Rect& roi);
    
    Mat_(const Mat_& m, const Range* ranges);
    
    Mat_(const Mat_& m, const std::vector<Range>& ranges);
    
    explicit Mat_(const MatExpr& e);
    
    explicit Mat_(const std::vector<_Tp>& vec, bool copyData=false);
    template<int n> explicit Mat_(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData=true);
    template<int m, int n> explicit Mat_(const Matx<typename DataType<_Tp>::channel_type, m, n>& mtx, bool copyData=true);
    explicit Mat_(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true);
    explicit Mat_(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData=true);
    explicit Mat_(const MatCommaInitializer_<_Tp>& commaInitializer);









    Mat_& operator = (const Mat& m);
    Mat_& operator = (const Mat_& m);
    
    Mat_& operator = (const _Tp& s);
    
    Mat_& operator = (const MatExpr& e);

    
    iterator begin();
    iterator end();
    const_iterator begin() const;
    const_iterator end() const;

    
    
    template<typename Functor> void forEach(const Functor& operation);
    template<typename Functor> void forEach(const Functor& operation) const;

    
    void create(int _rows, int _cols);
    
    void create(Size _size);
    
    void create(int _ndims, const int* _sizes);
    
    void release();
    
    Mat_ cross(const Mat_& m) const;
    
    template<typename T2> operator Mat_<T2>() const;
    
    Mat_ row(int y) const;
    Mat_ col(int x) const;
    Mat_ diag(int d=0) const;
    Mat_ clone() const;

    
    size_t elemSize() const;
    size_t elemSize1() const;
    int type() const;
    int depth() const;
    int channels() const;
    size_t step1(int i=0) const;
    
    size_t stepT(int i=0) const;

    
    static MatExpr zeros(int rows, int cols);
    static MatExpr zeros(Size size);
    static MatExpr zeros(int _ndims, const int* _sizes);
    static MatExpr ones(int rows, int cols);
    static MatExpr ones(Size size);
    static MatExpr ones(int _ndims, const int* _sizes);
    static MatExpr eye(int rows, int cols);
    static MatExpr eye(Size size);

    
    Mat_& adjustROI( int dtop, int dbottom, int dleft, int dright );
    Mat_ operator()( const Range& rowRange, const Range& colRange ) const;
    Mat_ operator()( const Rect& roi ) const;
    Mat_ operator()( const Range* ranges ) const;
    Mat_ operator()(const std::vector<Range>& ranges) const;

    
    _Tp* operator [](int y);
    const _Tp* operator [](int y) const;

    
    _Tp& operator ()(const int* idx);
    
    const _Tp& operator ()(const int* idx) const;

    
    template<int n> _Tp& operator ()(const Vec<int, n>& idx);
    
    template<int n> const _Tp& operator ()(const Vec<int, n>& idx) const;

    
    _Tp& operator ()(int idx0);
    
    const _Tp& operator ()(int idx0) const;
    
    _Tp& operator ()(int row, int col);
    
    const _Tp& operator ()(int row, int col) const;
    
    _Tp& operator ()(int idx0, int idx1, int idx2);
    
    const _Tp& operator ()(int idx0, int idx1, int idx2) const;

    _Tp& operator ()(Point pt);
    const _Tp& operator ()(Point pt) const;

    
    operator std::vector<_Tp>() const;






    
    template<int n> operator Vec<typename DataType<_Tp>::channel_type, n>() const;
    
    template<int m, int n> operator Matx<typename DataType<_Tp>::channel_type, m, n>() const;


    Mat_(Mat_&& m);
    Mat_& operator = (Mat_&& m);

    Mat_(Mat&& m);
    Mat_& operator = (Mat&& m);

    Mat_(MatExpr&& e);
#line 2306 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.hpp"
};

typedef Mat_<uchar> Mat1b;
typedef Mat_<Vec2b> Mat2b;
typedef Mat_<Vec3b> Mat3b;
typedef Mat_<Vec4b> Mat4b;

typedef Mat_<short> Mat1s;
typedef Mat_<Vec2s> Mat2s;
typedef Mat_<Vec3s> Mat3s;
typedef Mat_<Vec4s> Mat4s;

typedef Mat_<ushort> Mat1w;
typedef Mat_<Vec2w> Mat2w;
typedef Mat_<Vec3w> Mat3w;
typedef Mat_<Vec4w> Mat4w;

typedef Mat_<int>   Mat1i;
typedef Mat_<Vec2i> Mat2i;
typedef Mat_<Vec3i> Mat3i;
typedef Mat_<Vec4i> Mat4i;

typedef Mat_<float> Mat1f;
typedef Mat_<Vec2f> Mat2f;
typedef Mat_<Vec3f> Mat3f;
typedef Mat_<Vec4f> Mat4f;

typedef Mat_<double> Mat1d;
typedef Mat_<Vec2d> Mat2d;
typedef Mat_<Vec3d> Mat3d;
typedef Mat_<Vec4d> Mat4d;


class  UMat
{
public:
    
    UMat(UMatUsageFlags usageFlags = USAGE_DEFAULT);
    
    
    UMat(int rows, int cols, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
    UMat(Size size, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
    
    UMat(int rows, int cols, int type, const Scalar& s, UMatUsageFlags usageFlags = USAGE_DEFAULT);
    UMat(Size size, int type, const Scalar& s, UMatUsageFlags usageFlags = USAGE_DEFAULT);

    
    UMat(int ndims, const int* sizes, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
    UMat(int ndims, const int* sizes, int type, const Scalar& s, UMatUsageFlags usageFlags = USAGE_DEFAULT);

    
    UMat(const UMat& m);

    
    UMat(const UMat& m, const Range& rowRange, const Range& colRange=Range::all());
    UMat(const UMat& m, const Rect& roi);
    UMat(const UMat& m, const Range* ranges);
    UMat(const UMat& m, const std::vector<Range>& ranges);
    
    template<typename _Tp> explicit UMat(const std::vector<_Tp>& vec, bool copyData=false);

    
    template<typename _Tp, int n> explicit UMat(const Vec<_Tp, n>& vec, bool copyData=true);
    
    template<typename _Tp, int m, int n> explicit UMat(const Matx<_Tp, m, n>& mtx, bool copyData=true);
    
    template<typename _Tp> explicit UMat(const Point_<_Tp>& pt, bool copyData=true);
    
    template<typename _Tp> explicit UMat(const Point3_<_Tp>& pt, bool copyData=true);
    
    template<typename _Tp> explicit UMat(const MatCommaInitializer_<_Tp>& commaInitializer);

    
    ~UMat();
    
    UMat& operator = (const UMat& m);

    Mat getMat(int flags) const;

    
    UMat row(int y) const;
    
    UMat col(int x) const;
    
    UMat rowRange(int startrow, int endrow) const;
    UMat rowRange(const Range& r) const;
    
    UMat colRange(int startcol, int endcol) const;
    UMat colRange(const Range& r) const;
    
    
    
    
    UMat diag(int d=0) const;
    
    static UMat diag(const UMat& d);

    
    UMat clone() const;
    
    
    void copyTo( OutputArray m ) const;
    
    void copyTo( OutputArray m, InputArray mask ) const;
    
    void convertTo( OutputArray m, int rtype, double alpha=1, double beta=0 ) const;

    void assignTo( UMat& m, int type=-1 ) const;

    
    UMat& operator = (const Scalar& s);
    
    UMat& setTo(InputArray value, InputArray mask=noArray());
    
    
    UMat reshape(int cn, int rows=0) const;
    UMat reshape(int cn, int newndims, const int* newsz) const;

    
    UMat t() const;
    
    UMat inv(int method=DECOMP_LU) const;
    
    UMat mul(InputArray m, double scale=1) const;

    
    double dot(InputArray m) const;

    
    static UMat zeros(int rows, int cols, int type);
    static UMat zeros(Size size, int type);
    static UMat zeros(int ndims, const int* sz, int type);
    static UMat ones(int rows, int cols, int type);
    static UMat ones(Size size, int type);
    static UMat ones(int ndims, const int* sz, int type);
    static UMat eye(int rows, int cols, int type);
    static UMat eye(Size size, int type);

    
    
    void create(int rows, int cols, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
    void create(Size size, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
    void create(int ndims, const int* sizes, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
    void create(const std::vector<int>& sizes, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);

    
    void addref();
    
    
    void release();

    
    void deallocate();
    
    void copySize(const UMat& m);

    
    void locateROI( Size& wholeSize, Point& ofs ) const;
    
    UMat& adjustROI( int dtop, int dbottom, int dleft, int dright );
    
    
    UMat operator()( Range rowRange, Range colRange ) const;
    UMat operator()( const Rect& roi ) const;
    UMat operator()( const Range* ranges ) const;
    UMat operator()(const std::vector<Range>& ranges) const;

    
    
    
    bool isContinuous() const;

    
    bool isSubmatrix() const;

    
    
    size_t elemSize() const;
    
    size_t elemSize1() const;
    
    int type() const;
    
    int depth() const;
    
    int channels() const;
    
    size_t step1(int i=0) const;
    
    bool empty() const;
    
    size_t total() const;

    
    int checkVector(int elemChannels, int depth=-1, bool requireContinuous=true) const;


    UMat(UMat&& m);
    UMat& operator = (UMat&& m);
#line 2506 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.hpp"

    



    void* handle(int accessFlags) const;
    void ndoffset(size_t* ofs) const;

    enum { MAGIC_VAL  = 0x42FF0000, AUTO_STEP = 0, CONTINUOUS_FLAG = (1 << 14), SUBMATRIX_FLAG = (1 << 15) };
    enum { MAGIC_MASK = 0xFFFF0000, TYPE_MASK = 0x00000FFF, DEPTH_MASK = 7 };

    





    int flags;
    
    int dims;
    
    int rows, cols;

    
    MatAllocator* allocator;
    UMatUsageFlags usageFlags; 
    
    static MatAllocator* getStdAllocator();

    
    UMatData* u;

    
    size_t offset;

    MatSize size;
    MatStep step;

protected:
};



















































































class  SparseMat
{
public:
    typedef SparseMatIterator iterator;
    typedef SparseMatConstIterator const_iterator;

    enum { MAGIC_VAL=0x42FD0000, MAX_DIM=32, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };

    
    struct  Hdr
    {
        Hdr(int _dims, const int* _sizes, int _type);
        void clear();
        int refcount;
        int dims;
        int valueOffset;
        size_t nodeSize;
        size_t nodeCount;
        size_t freeList;
        std::vector<uchar> pool;
        std::vector<size_t> hashtab;
        int size[MAX_DIM];
    };

    
    struct  Node
    {
        
        size_t hashval;
        
        size_t next;
        
        int idx[MAX_DIM];
    };

    

    SparseMat();

    




    SparseMat(int dims, const int* _sizes, int _type);

    



    SparseMat(const SparseMat& m);

    



    explicit SparseMat(const Mat& m);

    
    ~SparseMat();

    
    SparseMat& operator = (const SparseMat& m);
    
    SparseMat& operator = (const Mat& m);

    
    SparseMat clone() const;

    
    void copyTo( SparseMat& m ) const;
    
    void copyTo( Mat& m ) const;
    
    void convertTo( SparseMat& m, int rtype, double alpha=1 ) const;
    
    








    void convertTo( Mat& m, int rtype, double alpha=1, double beta=0 ) const;

    
    void assignTo( SparseMat& m, int type=-1 ) const;

    
    




    void create(int dims, const int* _sizes, int _type);
    
    void clear();
    
    void addref();
    
    void release();

    
    
    
    size_t elemSize() const;
    
    size_t elemSize1() const;

    
    int type() const;
    
    int depth() const;
    
    int channels() const;

    
    const int* size() const;
    
    int size(int i) const;
    
    int dims() const;
    
    size_t nzcount() const;

    
    size_t hash(int i0) const;
    
    size_t hash(int i0, int i1) const;
    
    size_t hash(int i0, int i1, int i2) const;
    
    size_t hash(const int* idx) const;

    
    









    
    uchar* ptr(int i0, bool createMissing, size_t* hashval=0);
    
    uchar* ptr(int i0, int i1, bool createMissing, size_t* hashval=0);
    
    uchar* ptr(int i0, int i1, int i2, bool createMissing, size_t* hashval=0);
    
    uchar* ptr(const int* idx, bool createMissing, size_t* hashval=0);
    

    
    






    
    template<typename _Tp> _Tp& ref(int i0, size_t* hashval=0);
    
    template<typename _Tp> _Tp& ref(int i0, int i1, size_t* hashval=0);
    
    template<typename _Tp> _Tp& ref(int i0, int i1, int i2, size_t* hashval=0);
    
    template<typename _Tp> _Tp& ref(const int* idx, size_t* hashval=0);
    

    
    









    
    template<typename _Tp> _Tp value(int i0, size_t* hashval=0) const;
    
    template<typename _Tp> _Tp value(int i0, int i1, size_t* hashval=0) const;
    
    template<typename _Tp> _Tp value(int i0, int i1, int i2, size_t* hashval=0) const;
    
    template<typename _Tp> _Tp value(const int* idx, size_t* hashval=0) const;
    

    
    






    
    template<typename _Tp> const _Tp* find(int i0, size_t* hashval=0) const;
    
    template<typename _Tp> const _Tp* find(int i0, int i1, size_t* hashval=0) const;
    
    template<typename _Tp> const _Tp* find(int i0, int i1, int i2, size_t* hashval=0) const;
    
    template<typename _Tp> const _Tp* find(const int* idx, size_t* hashval=0) const;
    

    
    void erase(int i0, int i1, size_t* hashval=0);
    
    void erase(int i0, int i1, int i2, size_t* hashval=0);
    
    void erase(const int* idx, size_t* hashval=0);

    
    


    
    SparseMatIterator begin();
    
    template<typename _Tp> SparseMatIterator_<_Tp> begin();
    
    SparseMatConstIterator begin() const;
    
    template<typename _Tp> SparseMatConstIterator_<_Tp> begin() const;
    
    


    
    SparseMatIterator end();
    
    SparseMatConstIterator end() const;
    
    template<typename _Tp> SparseMatIterator_<_Tp> end();
    
    template<typename _Tp> SparseMatConstIterator_<_Tp> end() const;

    
    template<typename _Tp> _Tp& value(Node* n);
    
    template<typename _Tp> const _Tp& value(const Node* n) const;

    
    Node* node(size_t nidx);
    const Node* node(size_t nidx) const;

    uchar* newNode(const int* idx, size_t hashval);
    void removeNode(size_t hidx, size_t nidx, size_t previdx);
    void resizeHashTab(size_t newsize);

    int flags;
    Hdr* hdr;
};
















template<typename _Tp> class SparseMat_ : public SparseMat
{
public:
    typedef SparseMatIterator_<_Tp> iterator;
    typedef SparseMatConstIterator_<_Tp> const_iterator;

    
    SparseMat_();
    
    SparseMat_(int dims, const int* _sizes);
    
    SparseMat_(const SparseMat& m);
    
    SparseMat_(const SparseMat_& m);
    
    SparseMat_(const Mat& m);
    
    
    
    SparseMat_& operator = (const SparseMat& m);
    
    SparseMat_& operator = (const SparseMat_& m);
    
    SparseMat_& operator = (const Mat& m);

    
    SparseMat_ clone() const;
    
    void create(int dims, const int* _sizes);
    
    

    
    int type() const;
    
    int depth() const;
    
    int channels() const;

    
    _Tp& ref(int i0, size_t* hashval=0);
    
    _Tp& ref(int i0, int i1, size_t* hashval=0);
    
    _Tp& ref(int i0, int i1, int i2, size_t* hashval=0);
    
    _Tp& ref(const int* idx, size_t* hashval=0);

    
    _Tp operator()(int i0, size_t* hashval=0) const;
    
    _Tp operator()(int i0, int i1, size_t* hashval=0) const;
    
    _Tp operator()(int i0, int i1, int i2, size_t* hashval=0) const;
    
    _Tp operator()(const int* idx, size_t* hashval=0) const;

    
    SparseMatIterator_<_Tp> begin();
    
    SparseMatConstIterator_<_Tp> begin() const;
    
    SparseMatIterator_<_Tp> end();
    
    SparseMatConstIterator_<_Tp> end() const;
};





class  MatConstIterator
{
public:
    typedef uchar* value_type;
    typedef ptrdiff_t difference_type;
    typedef const uchar** pointer;
    typedef uchar* reference;

    typedef std::random_access_iterator_tag iterator_category;

    
    MatConstIterator();
    
    MatConstIterator(const Mat* _m);
    
    MatConstIterator(const Mat* _m, int _row, int _col=0);
    
    MatConstIterator(const Mat* _m, Point _pt);
    
    MatConstIterator(const Mat* _m, const int* _idx);
    
    MatConstIterator(const MatConstIterator& it);

    
    MatConstIterator& operator = (const MatConstIterator& it);
    
    const uchar* operator *() const;
    
    const uchar* operator [](ptrdiff_t i) const;

    
    MatConstIterator& operator += (ptrdiff_t ofs);
    
    MatConstIterator& operator -= (ptrdiff_t ofs);
    
    MatConstIterator& operator --();
    
    MatConstIterator operator --(int);
    
    MatConstIterator& operator ++();
    
    MatConstIterator operator ++(int);
    
    Point pos() const;
    
    void pos(int* _idx) const;

    ptrdiff_t lpos() const;
    void seek(ptrdiff_t ofs, bool relative = false);
    void seek(const int* _idx, bool relative = false);

    const Mat* m;
    size_t elemSize;
    const uchar* ptr;
    const uchar* sliceStart;
    const uchar* sliceEnd;
};







template<typename _Tp>
class MatConstIterator_ : public MatConstIterator
{
public:
    typedef _Tp value_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp* pointer;
    typedef const _Tp& reference;

    typedef std::random_access_iterator_tag iterator_category;

    
    MatConstIterator_();
    
    MatConstIterator_(const Mat_<_Tp>* _m);
    
    MatConstIterator_(const Mat_<_Tp>* _m, int _row, int _col=0);
    
    MatConstIterator_(const Mat_<_Tp>* _m, Point _pt);
    
    MatConstIterator_(const Mat_<_Tp>* _m, const int* _idx);
    
    MatConstIterator_(const MatConstIterator_& it);

    
    MatConstIterator_& operator = (const MatConstIterator_& it);
    
    const _Tp& operator *() const;
    
    const _Tp& operator [](ptrdiff_t i) const;

    
    MatConstIterator_& operator += (ptrdiff_t ofs);
    
    MatConstIterator_& operator -= (ptrdiff_t ofs);
    
    MatConstIterator_& operator --();
    
    MatConstIterator_ operator --(int);
    
    MatConstIterator_& operator ++();
    
    MatConstIterator_ operator ++(int);
    
    Point pos() const;
};







template<typename _Tp>
class MatIterator_ : public MatConstIterator_<_Tp>
{
public:
    typedef _Tp* pointer;
    typedef _Tp& reference;

    typedef std::random_access_iterator_tag iterator_category;

    
    MatIterator_();
    
    MatIterator_(Mat_<_Tp>* _m);
    
    MatIterator_(Mat_<_Tp>* _m, int _row, int _col=0);
    
    MatIterator_(Mat_<_Tp>* _m, Point _pt);
    
    MatIterator_(Mat_<_Tp>* _m, const int* _idx);
    
    MatIterator_(const MatIterator_& it);
    
    MatIterator_& operator = (const MatIterator_<_Tp>& it );

    
    _Tp& operator *() const;
    
    _Tp& operator [](ptrdiff_t i) const;

    
    MatIterator_& operator += (ptrdiff_t ofs);
    
    MatIterator_& operator -= (ptrdiff_t ofs);
    
    MatIterator_& operator --();
    
    MatIterator_ operator --(int);
    
    MatIterator_& operator ++();
    
    MatIterator_ operator ++(int);
};

















class  SparseMatConstIterator
{
public:
    
    SparseMatConstIterator();
    
    SparseMatConstIterator(const SparseMat* _m);
    
    SparseMatConstIterator(const SparseMatConstIterator& it);

    
    SparseMatConstIterator& operator = (const SparseMatConstIterator& it);

    
    template<typename _Tp> const _Tp& value() const;
    
    const SparseMat::Node* node() const;

    
    SparseMatConstIterator& operator --();
    
    SparseMatConstIterator operator --(int);
    
    SparseMatConstIterator& operator ++();
    
    SparseMatConstIterator operator ++(int);

    
    void seekEnd();

    const SparseMat* m;
    size_t hashidx;
    uchar* ptr;
};










class  SparseMatIterator : public SparseMatConstIterator
{
public:
    
    SparseMatIterator();
    
    SparseMatIterator(SparseMat* _m);
    
    SparseMatIterator(SparseMat* _m, const int* idx);
    
    SparseMatIterator(const SparseMatIterator& it);

    
    SparseMatIterator& operator = (const SparseMatIterator& it);
    
    template<typename _Tp> _Tp& value() const;
    
    SparseMat::Node* node() const;

    
    SparseMatIterator& operator ++();
    
    SparseMatIterator operator ++(int);
};










template<typename _Tp> class SparseMatConstIterator_ : public SparseMatConstIterator
{
public:

    typedef std::forward_iterator_tag iterator_category;

    
    SparseMatConstIterator_();
    
    SparseMatConstIterator_(const SparseMat_<_Tp>* _m);
    SparseMatConstIterator_(const SparseMat* _m);
    
    SparseMatConstIterator_(const SparseMatConstIterator_& it);

    
    SparseMatConstIterator_& operator = (const SparseMatConstIterator_& it);
    
    const _Tp& operator *() const;

    
    SparseMatConstIterator_& operator ++();
    
    SparseMatConstIterator_ operator ++(int);
};










template<typename _Tp> class SparseMatIterator_ : public SparseMatConstIterator_<_Tp>
{
public:

    typedef std::forward_iterator_tag iterator_category;

    
    SparseMatIterator_();
    
    SparseMatIterator_(SparseMat_<_Tp>* _m);
    SparseMatIterator_(SparseMat* _m);
    
    SparseMatIterator_(const SparseMatIterator_& it);

    
    SparseMatIterator_& operator = (const SparseMatIterator_& it);
    
    _Tp& operator *() const;

    
    SparseMatIterator_& operator ++();
    
    SparseMatIterator_ operator ++(int);
};

































































class  NAryMatIterator
{
public:
    
    NAryMatIterator();
    
    NAryMatIterator(const Mat** arrays, uchar** ptrs, int narrays=-1);
    
    NAryMatIterator(const Mat** arrays, Mat* planes, int narrays=-1);
    
    void init(const Mat** arrays, Mat* planes, uchar** ptrs, int narrays=-1);

    
    NAryMatIterator& operator ++();
    
    NAryMatIterator operator ++(int);

    
    const Mat** arrays;
    
    Mat* planes;
    
    uchar** ptrs;
    
    int narrays;
    
    size_t nplanes;
    
    size_t size;
protected:
    int iterdepth;
    size_t idx;
};





class  MatOp
{
public:
    MatOp();
    virtual ~MatOp();

    virtual bool elementWise(const MatExpr& expr) const;
    virtual void assign(const MatExpr& expr, Mat& m, int type=-1) const = 0;
    virtual void roi(const MatExpr& expr, const Range& rowRange,
                     const Range& colRange, MatExpr& res) const;
    virtual void diag(const MatExpr& expr, int d, MatExpr& res) const;
    virtual void augAssignAdd(const MatExpr& expr, Mat& m) const;
    virtual void augAssignSubtract(const MatExpr& expr, Mat& m) const;
    virtual void augAssignMultiply(const MatExpr& expr, Mat& m) const;
    virtual void augAssignDivide(const MatExpr& expr, Mat& m) const;
    virtual void augAssignAnd(const MatExpr& expr, Mat& m) const;
    virtual void augAssignOr(const MatExpr& expr, Mat& m) const;
    virtual void augAssignXor(const MatExpr& expr, Mat& m) const;

    virtual void add(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;
    virtual void add(const MatExpr& expr1, const Scalar& s, MatExpr& res) const;

    virtual void subtract(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;
    virtual void subtract(const Scalar& s, const MatExpr& expr, MatExpr& res) const;

    virtual void multiply(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const;
    virtual void multiply(const MatExpr& expr1, double s, MatExpr& res) const;

    virtual void divide(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res, double scale=1) const;
    virtual void divide(double s, const MatExpr& expr, MatExpr& res) const;

    virtual void abs(const MatExpr& expr, MatExpr& res) const;

    virtual void transpose(const MatExpr& expr, MatExpr& res) const;
    virtual void matmul(const MatExpr& expr1, const MatExpr& expr2, MatExpr& res) const;
    virtual void invert(const MatExpr& expr, int method, MatExpr& res) const;

    virtual Size size(const MatExpr& expr) const;
    virtual int type(const MatExpr& expr) const;
};















































class  MatExpr
{
public:
    MatExpr();
    explicit MatExpr(const Mat& m);

    MatExpr(const MatOp* _op, int _flags, const Mat& _a = Mat(), const Mat& _b = Mat(),
            const Mat& _c = Mat(), double _alpha = 1, double _beta = 1, const Scalar& _s = Scalar());

    operator Mat() const;
    template<typename _Tp> operator Mat_<_Tp>() const;

    Size size() const;
    int type() const;

    MatExpr row(int y) const;
    MatExpr col(int x) const;
    MatExpr diag(int d = 0) const;
    MatExpr operator()( const Range& rowRange, const Range& colRange ) const;
    MatExpr operator()( const Rect& roi ) const;

    MatExpr t() const;
    MatExpr inv(int method = DECOMP_LU) const;
    MatExpr mul(const MatExpr& e, double scale=1) const;
    MatExpr mul(const Mat& m, double scale=1) const;

    Mat cross(const Mat& m) const;
    double dot(const Mat& m) const;

    const MatOp* op;
    int flags;

    Mat a, b, c;
    double alpha, beta;
    Scalar s;
};





 MatExpr operator + (const Mat& a, const Mat& b);
 MatExpr operator + (const Mat& a, const Scalar& s);
 MatExpr operator + (const Scalar& s, const Mat& a);
 MatExpr operator + (const MatExpr& e, const Mat& m);
 MatExpr operator + (const Mat& m, const MatExpr& e);
 MatExpr operator + (const MatExpr& e, const Scalar& s);
 MatExpr operator + (const Scalar& s, const MatExpr& e);
 MatExpr operator + (const MatExpr& e1, const MatExpr& e2);

 MatExpr operator - (const Mat& a, const Mat& b);
 MatExpr operator - (const Mat& a, const Scalar& s);
 MatExpr operator - (const Scalar& s, const Mat& a);
 MatExpr operator - (const MatExpr& e, const Mat& m);
 MatExpr operator - (const Mat& m, const MatExpr& e);
 MatExpr operator - (const MatExpr& e, const Scalar& s);
 MatExpr operator - (const Scalar& s, const MatExpr& e);
 MatExpr operator - (const MatExpr& e1, const MatExpr& e2);

 MatExpr operator - (const Mat& m);
 MatExpr operator - (const MatExpr& e);

 MatExpr operator * (const Mat& a, const Mat& b);
 MatExpr operator * (const Mat& a, double s);
 MatExpr operator * (double s, const Mat& a);
 MatExpr operator * (const MatExpr& e, const Mat& m);
 MatExpr operator * (const Mat& m, const MatExpr& e);
 MatExpr operator * (const MatExpr& e, double s);
 MatExpr operator * (double s, const MatExpr& e);
 MatExpr operator * (const MatExpr& e1, const MatExpr& e2);

 MatExpr operator / (const Mat& a, const Mat& b);
 MatExpr operator / (const Mat& a, double s);
 MatExpr operator / (double s, const Mat& a);
 MatExpr operator / (const MatExpr& e, const Mat& m);
 MatExpr operator / (const Mat& m, const MatExpr& e);
 MatExpr operator / (const MatExpr& e, double s);
 MatExpr operator / (double s, const MatExpr& e);
 MatExpr operator / (const MatExpr& e1, const MatExpr& e2);

 MatExpr operator < (const Mat& a, const Mat& b);
 MatExpr operator < (const Mat& a, double s);
 MatExpr operator < (double s, const Mat& a);

 MatExpr operator <= (const Mat& a, const Mat& b);
 MatExpr operator <= (const Mat& a, double s);
 MatExpr operator <= (double s, const Mat& a);

 MatExpr operator == (const Mat& a, const Mat& b);
 MatExpr operator == (const Mat& a, double s);
 MatExpr operator == (double s, const Mat& a);

 MatExpr operator != (const Mat& a, const Mat& b);
 MatExpr operator != (const Mat& a, double s);
 MatExpr operator != (double s, const Mat& a);

 MatExpr operator >= (const Mat& a, const Mat& b);
 MatExpr operator >= (const Mat& a, double s);
 MatExpr operator >= (double s, const Mat& a);

 MatExpr operator > (const Mat& a, const Mat& b);
 MatExpr operator > (const Mat& a, double s);
 MatExpr operator > (double s, const Mat& a);

 MatExpr operator & (const Mat& a, const Mat& b);
 MatExpr operator & (const Mat& a, const Scalar& s);
 MatExpr operator & (const Scalar& s, const Mat& a);

 MatExpr operator | (const Mat& a, const Mat& b);
 MatExpr operator | (const Mat& a, const Scalar& s);
 MatExpr operator | (const Scalar& s, const Mat& a);

 MatExpr operator ^ (const Mat& a, const Mat& b);
 MatExpr operator ^ (const Mat& a, const Scalar& s);
 MatExpr operator ^ (const Scalar& s, const Mat& a);

 MatExpr operator ~(const Mat& m);

 MatExpr min(const Mat& a, const Mat& b);
 MatExpr min(const Mat& a, double s);
 MatExpr min(double s, const Mat& a);

 MatExpr max(const Mat& a, const Mat& b);
 MatExpr max(const Mat& a, double s);
 MatExpr max(double s, const Mat& a);














 MatExpr abs(const Mat& m);



 MatExpr abs(const MatExpr& e);


} 

#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp"




















































#pragma warning( push )
#pragma warning( disable: 4127 )
#line 56 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp"

namespace cv
{







inline void _InputArray::init(int _flags, const void* _obj)
{ flags = _flags; obj = (void*)_obj; }

inline void _InputArray::init(int _flags, const void* _obj, Size _sz)
{ flags = _flags; obj = (void*)_obj; sz = _sz; }

inline void* _InputArray::getObj() const { return obj; }
inline int _InputArray::getFlags() const { return flags; }
inline Size _InputArray::getSz() const { return sz; }

inline _InputArray::_InputArray() { init(NONE, 0); }
inline _InputArray::_InputArray(int _flags, void* _obj) { init(_flags, _obj); }
inline _InputArray::_InputArray(const Mat& m) { init(MAT+ACCESS_READ, &m); }
inline _InputArray::_InputArray(const std::vector<Mat>& vec) { init(STD_VECTOR_MAT+ACCESS_READ, &vec); }
inline _InputArray::_InputArray(const UMat& m) { init(UMAT+ACCESS_READ, &m); }
inline _InputArray::_InputArray(const std::vector<UMat>& vec) { init(STD_VECTOR_UMAT+ACCESS_READ, &vec); }

template<typename _Tp> inline
_InputArray::_InputArray(const std::vector<_Tp>& vec)
{ init(FIXED_TYPE + STD_VECTOR + DataType<_Tp>::type + ACCESS_READ, &vec); }











inline
_InputArray::_InputArray(const std::vector<bool>& vec)
{ init(FIXED_TYPE + STD_BOOL_VECTOR + DataType<bool>::type + ACCESS_READ, &vec); }

template<typename _Tp> inline
_InputArray::_InputArray(const std::vector<std::vector<_Tp> >& vec)
{ init(FIXED_TYPE + STD_VECTOR_VECTOR + DataType<_Tp>::type + ACCESS_READ, &vec); }

inline
_InputArray::_InputArray(const std::vector<std::vector<bool> >&)
{ cv::error( Error::StsUnsupportedFormat, "std::vector<std::vector<bool> > is not supported!\n",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 107 ); }

template<typename _Tp> inline
_InputArray::_InputArray(const std::vector<Mat_<_Tp> >& vec)
{ init(FIXED_TYPE + STD_VECTOR_MAT + DataType<_Tp>::type + ACCESS_READ, &vec); }

template<typename _Tp, int m, int n> inline
_InputArray::_InputArray(const Matx<_Tp, m, n>& mtx)
{ init(FIXED_TYPE + FIXED_SIZE + MATX + DataType<_Tp>::type + ACCESS_READ, &mtx, Size(n, m)); }

template<typename _Tp> inline
_InputArray::_InputArray(const _Tp* vec, int n)
{ init(FIXED_TYPE + FIXED_SIZE + MATX + DataType<_Tp>::type + ACCESS_READ, vec, Size(n, 1)); }

template<typename _Tp> inline
_InputArray::_InputArray(const Mat_<_Tp>& m)
{ init(FIXED_TYPE + MAT + DataType<_Tp>::type + ACCESS_READ, &m); }

inline _InputArray::_InputArray(const double& val)
{ init(FIXED_TYPE + FIXED_SIZE + MATX + 6 + ACCESS_READ, &val, Size(1,1)); }

inline _InputArray::_InputArray(const MatExpr& expr)
{ init(FIXED_TYPE + FIXED_SIZE + EXPR + ACCESS_READ, &expr); }

inline _InputArray::_InputArray(const cuda::GpuMat& d_mat)
{ init(CUDA_GPU_MAT + ACCESS_READ, &d_mat); }

inline _InputArray::_InputArray(const std::vector<cuda::GpuMat>& d_mat)
{	init(STD_VECTOR_CUDA_GPU_MAT + ACCESS_READ, &d_mat);}

inline _InputArray::_InputArray(const ogl::Buffer& buf)
{ init(OPENGL_BUFFER + ACCESS_READ, &buf); }

inline _InputArray::_InputArray(const cuda::HostMem& cuda_mem)
{ init(CUDA_HOST_MEM + ACCESS_READ, &cuda_mem); }

inline _InputArray::~_InputArray() {}

inline Mat _InputArray::getMat(int i) const
{
    if( kind() == MAT && i < 0 )
        return *(const Mat*)obj;
    return getMat_(i);
}

inline bool _InputArray::isMat() const { return kind() == _InputArray::MAT; }
inline bool _InputArray::isUMat() const  { return kind() == _InputArray::UMAT; }
inline bool _InputArray::isMatVector() const { return kind() == _InputArray::STD_VECTOR_MAT; }
inline bool _InputArray::isUMatVector() const  { return kind() == _InputArray::STD_VECTOR_UMAT; }
inline bool _InputArray::isMatx() const { return kind() == _InputArray::MATX; }
inline bool _InputArray::isVector() const { return kind() == _InputArray::STD_VECTOR ||
                                                   kind() == _InputArray::STD_BOOL_VECTOR ||
                                                   kind() == _InputArray::STD_ARRAY; }
inline bool _InputArray::isGpuMatVector() const { return kind() == _InputArray::STD_VECTOR_CUDA_GPU_MAT; }



inline _OutputArray::_OutputArray() { init(ACCESS_WRITE, 0); }
inline _OutputArray::_OutputArray(int _flags, void* _obj) { init(_flags|ACCESS_WRITE, _obj); }
inline _OutputArray::_OutputArray(Mat& m) { init(MAT+ACCESS_WRITE, &m); }
inline _OutputArray::_OutputArray(std::vector<Mat>& vec) { init(STD_VECTOR_MAT+ACCESS_WRITE, &vec); }
inline _OutputArray::_OutputArray(UMat& m) { init(UMAT+ACCESS_WRITE, &m); }
inline _OutputArray::_OutputArray(std::vector<UMat>& vec) { init(STD_VECTOR_UMAT+ACCESS_WRITE, &vec); }

template<typename _Tp> inline
_OutputArray::_OutputArray(std::vector<_Tp>& vec)
{ init(FIXED_TYPE + STD_VECTOR + DataType<_Tp>::type + ACCESS_WRITE, &vec); }











inline
_OutputArray::_OutputArray(std::vector<bool>&)
{ cv::error( Error::StsUnsupportedFormat, "std::vector<bool> cannot be an output array\n",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 187 ); }

template<typename _Tp> inline
_OutputArray::_OutputArray(std::vector<std::vector<_Tp> >& vec)
{ init(FIXED_TYPE + STD_VECTOR_VECTOR + DataType<_Tp>::type + ACCESS_WRITE, &vec); }

inline
_OutputArray::_OutputArray(std::vector<std::vector<bool> >&)
{ cv::error( Error::StsUnsupportedFormat, "std::vector<std::vector<bool> > cannot be an output array\n",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 195 ); }

template<typename _Tp> inline
_OutputArray::_OutputArray(std::vector<Mat_<_Tp> >& vec)
{ init(FIXED_TYPE + STD_VECTOR_MAT + DataType<_Tp>::type + ACCESS_WRITE, &vec); }

template<typename _Tp> inline
_OutputArray::_OutputArray(Mat_<_Tp>& m)
{ init(FIXED_TYPE + MAT + DataType<_Tp>::type + ACCESS_WRITE, &m); }

template<typename _Tp, int m, int n> inline
_OutputArray::_OutputArray(Matx<_Tp, m, n>& mtx)
{ init(FIXED_TYPE + FIXED_SIZE + MATX + DataType<_Tp>::type + ACCESS_WRITE, &mtx, Size(n, m)); }

template<typename _Tp> inline
_OutputArray::_OutputArray(_Tp* vec, int n)
{ init(FIXED_TYPE + FIXED_SIZE + MATX + DataType<_Tp>::type + ACCESS_WRITE, vec, Size(n, 1)); }

template<typename _Tp> inline
_OutputArray::_OutputArray(const std::vector<_Tp>& vec)
{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR + DataType<_Tp>::type + ACCESS_WRITE, &vec); }











template<typename _Tp> inline
_OutputArray::_OutputArray(const std::vector<std::vector<_Tp> >& vec)
{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_VECTOR + DataType<_Tp>::type + ACCESS_WRITE, &vec); }

template<typename _Tp> inline
_OutputArray::_OutputArray(const std::vector<Mat_<_Tp> >& vec)
{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_MAT + DataType<_Tp>::type + ACCESS_WRITE, &vec); }

template<typename _Tp> inline
_OutputArray::_OutputArray(const Mat_<_Tp>& m)
{ init(FIXED_TYPE + FIXED_SIZE + MAT + DataType<_Tp>::type + ACCESS_WRITE, &m); }

template<typename _Tp, int m, int n> inline
_OutputArray::_OutputArray(const Matx<_Tp, m, n>& mtx)
{ init(FIXED_TYPE + FIXED_SIZE + MATX + DataType<_Tp>::type + ACCESS_WRITE, &mtx, Size(n, m)); }

template<typename _Tp> inline
_OutputArray::_OutputArray(const _Tp* vec, int n)
{ init(FIXED_TYPE + FIXED_SIZE + MATX + DataType<_Tp>::type + ACCESS_WRITE, vec, Size(n, 1)); }

inline _OutputArray::_OutputArray(cuda::GpuMat& d_mat)
{ init(CUDA_GPU_MAT + ACCESS_WRITE, &d_mat); }

inline _OutputArray::_OutputArray(std::vector<cuda::GpuMat>& d_mat)
{	init(STD_VECTOR_CUDA_GPU_MAT + ACCESS_WRITE, &d_mat);}

inline _OutputArray::_OutputArray(ogl::Buffer& buf)
{ init(OPENGL_BUFFER + ACCESS_WRITE, &buf); }

inline _OutputArray::_OutputArray(cuda::HostMem& cuda_mem)
{ init(CUDA_HOST_MEM + ACCESS_WRITE, &cuda_mem); }

inline _OutputArray::_OutputArray(const Mat& m)
{ init(FIXED_TYPE + FIXED_SIZE + MAT + ACCESS_WRITE, &m); }

inline _OutputArray::_OutputArray(const std::vector<Mat>& vec)
{ init(FIXED_SIZE + STD_VECTOR_MAT + ACCESS_WRITE, &vec); }

inline _OutputArray::_OutputArray(const UMat& m)
{ init(FIXED_TYPE + FIXED_SIZE + UMAT + ACCESS_WRITE, &m); }

inline _OutputArray::_OutputArray(const std::vector<UMat>& vec)
{ init(FIXED_SIZE + STD_VECTOR_UMAT + ACCESS_WRITE, &vec); }

inline _OutputArray::_OutputArray(const cuda::GpuMat& d_mat)
{ init(FIXED_TYPE + FIXED_SIZE + CUDA_GPU_MAT + ACCESS_WRITE, &d_mat); }


inline _OutputArray::_OutputArray(const ogl::Buffer& buf)
{ init(FIXED_TYPE + FIXED_SIZE + OPENGL_BUFFER + ACCESS_WRITE, &buf); }

inline _OutputArray::_OutputArray(const cuda::HostMem& cuda_mem)
{ init(FIXED_TYPE + FIXED_SIZE + CUDA_HOST_MEM + ACCESS_WRITE, &cuda_mem); }



inline _InputOutputArray::_InputOutputArray() { init(ACCESS_RW, 0); }
inline _InputOutputArray::_InputOutputArray(int _flags, void* _obj) { init(_flags|ACCESS_RW, _obj); }
inline _InputOutputArray::_InputOutputArray(Mat& m) { init(MAT+ACCESS_RW, &m); }
inline _InputOutputArray::_InputOutputArray(std::vector<Mat>& vec) { init(STD_VECTOR_MAT+ACCESS_RW, &vec); }
inline _InputOutputArray::_InputOutputArray(UMat& m) { init(UMAT+ACCESS_RW, &m); }
inline _InputOutputArray::_InputOutputArray(std::vector<UMat>& vec) { init(STD_VECTOR_UMAT+ACCESS_RW, &vec); }

template<typename _Tp> inline
_InputOutputArray::_InputOutputArray(std::vector<_Tp>& vec)
{ init(FIXED_TYPE + STD_VECTOR + DataType<_Tp>::type + ACCESS_RW, &vec); }











inline _InputOutputArray::_InputOutputArray(std::vector<bool>&)
{ cv::error( Error::StsUnsupportedFormat, "std::vector<bool> cannot be an input/output array\n",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 305 ); }

template<typename _Tp> inline
_InputOutputArray::_InputOutputArray(std::vector<std::vector<_Tp> >& vec)
{ init(FIXED_TYPE + STD_VECTOR_VECTOR + DataType<_Tp>::type + ACCESS_RW, &vec); }

template<typename _Tp> inline
_InputOutputArray::_InputOutputArray(std::vector<Mat_<_Tp> >& vec)
{ init(FIXED_TYPE + STD_VECTOR_MAT + DataType<_Tp>::type + ACCESS_RW, &vec); }

template<typename _Tp> inline
_InputOutputArray::_InputOutputArray(Mat_<_Tp>& m)
{ init(FIXED_TYPE + MAT + DataType<_Tp>::type + ACCESS_RW, &m); }

template<typename _Tp, int m, int n> inline
_InputOutputArray::_InputOutputArray(Matx<_Tp, m, n>& mtx)
{ init(FIXED_TYPE + FIXED_SIZE + MATX + DataType<_Tp>::type + ACCESS_RW, &mtx, Size(n, m)); }

template<typename _Tp> inline
_InputOutputArray::_InputOutputArray(_Tp* vec, int n)
{ init(FIXED_TYPE + FIXED_SIZE + MATX + DataType<_Tp>::type + ACCESS_RW, vec, Size(n, 1)); }

template<typename _Tp> inline
_InputOutputArray::_InputOutputArray(const std::vector<_Tp>& vec)
{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR + DataType<_Tp>::type + ACCESS_RW, &vec); }











template<typename _Tp> inline
_InputOutputArray::_InputOutputArray(const std::vector<std::vector<_Tp> >& vec)
{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_VECTOR + DataType<_Tp>::type + ACCESS_RW, &vec); }

template<typename _Tp> inline
_InputOutputArray::_InputOutputArray(const std::vector<Mat_<_Tp> >& vec)
{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_MAT + DataType<_Tp>::type + ACCESS_RW, &vec); }

template<typename _Tp> inline
_InputOutputArray::_InputOutputArray(const Mat_<_Tp>& m)
{ init(FIXED_TYPE + FIXED_SIZE + MAT + DataType<_Tp>::type + ACCESS_RW, &m); }

template<typename _Tp, int m, int n> inline
_InputOutputArray::_InputOutputArray(const Matx<_Tp, m, n>& mtx)
{ init(FIXED_TYPE + FIXED_SIZE + MATX + DataType<_Tp>::type + ACCESS_RW, &mtx, Size(n, m)); }

template<typename _Tp> inline
_InputOutputArray::_InputOutputArray(const _Tp* vec, int n)
{ init(FIXED_TYPE + FIXED_SIZE + MATX + DataType<_Tp>::type + ACCESS_RW, vec, Size(n, 1)); }

inline _InputOutputArray::_InputOutputArray(cuda::GpuMat& d_mat)
{ init(CUDA_GPU_MAT + ACCESS_RW, &d_mat); }

inline _InputOutputArray::_InputOutputArray(ogl::Buffer& buf)
{ init(OPENGL_BUFFER + ACCESS_RW, &buf); }

inline _InputOutputArray::_InputOutputArray(cuda::HostMem& cuda_mem)
{ init(CUDA_HOST_MEM + ACCESS_RW, &cuda_mem); }

inline _InputOutputArray::_InputOutputArray(const Mat& m)
{ init(FIXED_TYPE + FIXED_SIZE + MAT + ACCESS_RW, &m); }

inline _InputOutputArray::_InputOutputArray(const std::vector<Mat>& vec)
{ init(FIXED_SIZE + STD_VECTOR_MAT + ACCESS_RW, &vec); }

inline _InputOutputArray::_InputOutputArray(const UMat& m)
{ init(FIXED_TYPE + FIXED_SIZE + UMAT + ACCESS_RW, &m); }

inline _InputOutputArray::_InputOutputArray(const std::vector<UMat>& vec)
{ init(FIXED_SIZE + STD_VECTOR_UMAT + ACCESS_RW, &vec); }

inline _InputOutputArray::_InputOutputArray(const cuda::GpuMat& d_mat)
{ init(FIXED_TYPE + FIXED_SIZE + CUDA_GPU_MAT + ACCESS_RW, &d_mat); }

inline _InputOutputArray::_InputOutputArray(const std::vector<cuda::GpuMat>& d_mat)
{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_CUDA_GPU_MAT + ACCESS_RW, &d_mat);}

template<> inline _InputOutputArray::_InputOutputArray(std::vector<cuda::GpuMat>& d_mat)
{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_CUDA_GPU_MAT + ACCESS_RW, &d_mat);}

inline _InputOutputArray::_InputOutputArray(const ogl::Buffer& buf)
{ init(FIXED_TYPE + FIXED_SIZE + OPENGL_BUFFER + ACCESS_RW, &buf); }

inline _InputOutputArray::_InputOutputArray(const cuda::HostMem& cuda_mem)
{ init(FIXED_TYPE + FIXED_SIZE + CUDA_HOST_MEM + ACCESS_RW, &cuda_mem); }





inline
Mat::Mat()
    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
      datalimit(0), allocator(0), u(0), size(&rows), step(0)
{}

inline
Mat::Mat(int _rows, int _cols, int _type)
    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
      datalimit(0), allocator(0), u(0), size(&rows), step(0)
{
    create(_rows, _cols, _type);
}

inline
Mat::Mat(int _rows, int _cols, int _type, const Scalar& _s)
    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
      datalimit(0), allocator(0), u(0), size(&rows), step(0)
{
    create(_rows, _cols, _type);
    *this = _s;
}

inline
Mat::Mat(Size _sz, int _type)
    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
      datalimit(0), allocator(0), u(0), size(&rows), step(0)
{
    create( _sz.height, _sz.width, _type );
}

inline
Mat::Mat(Size _sz, int _type, const Scalar& _s)
    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
      datalimit(0), allocator(0), u(0), size(&rows), step(0)
{
    create(_sz.height, _sz.width, _type);
    *this = _s;
}

inline
Mat::Mat(int _dims, const int* _sz, int _type)
    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
      datalimit(0), allocator(0), u(0), size(&rows), step(0)
{
    create(_dims, _sz, _type);
}

inline
Mat::Mat(int _dims, const int* _sz, int _type, const Scalar& _s)
    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
      datalimit(0), allocator(0), u(0), size(&rows), step(0)
{
    create(_dims, _sz, _type);
    *this = _s;
}

inline
Mat::Mat(const std::vector<int>& _sz, int _type)
    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
      datalimit(0), allocator(0), u(0), size(&rows), step(0)
{
    create(_sz, _type);
}

inline
Mat::Mat(const std::vector<int>& _sz, int _type, const Scalar& _s)
    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
      datalimit(0), allocator(0), u(0), size(&rows), step(0)
{
    create(_sz, _type);
    *this = _s;
}

inline
Mat::Mat(const Mat& m)
    : flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), data(m.data),
      datastart(m.datastart), dataend(m.dataend), datalimit(m.datalimit), allocator(m.allocator),
      u(m.u), size(&rows), step(0)
{
    if( u )
        (int)_InterlockedExchangeAdd((long volatile*)&u->refcount, 1);
    if( m.dims <= 2 )
    {
        step[0] = m.step[0]; step[1] = m.step[1];
    }
    else
    {
        dims = 0;
        copySize(m);
    }
}

inline
Mat::Mat(int _rows, int _cols, int _type, void* _data, size_t _step)
    : flags(MAGIC_VAL + (_type & TYPE_MASK)), dims(2), rows(_rows), cols(_cols),
      data((uchar*)_data), datastart((uchar*)_data), dataend(0), datalimit(0),
      allocator(0), u(0), size(&rows)
{
    if(!!(total() == 0 || data != 0)) ; else cv::error( cv::Error::StsAssert, "total() == 0 || data != NULL",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 500 );

    size_t esz = (((((_type) & ((512 - 1) << 3)) >> 3) + 1) << ((((sizeof(size_t)/4+1)*16384|0x3a50) >> ((_type) & ((1 << 3) - 1))*2) & 3)), esz1 = ((((sizeof(size_t)<<28)|0x8442211) >> ((_type) & ((1 << 3) - 1))*4) & 15);
    size_t minstep = cols * esz;
    if( _step == AUTO_STEP )
    {
        _step = minstep;
        flags |= CONTINUOUS_FLAG;
    }
    else
    {
        if( rows == 1 ) _step = minstep;
        ;

        if (_step % esz1 != 0)
        {
            cv::error( Error::BadStep, "Step must be a multiple of esz1",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 516 );
        }

        flags |= _step == minstep ? CONTINUOUS_FLAG : 0;
    }
    step[0] = _step;
    step[1] = esz;
    datalimit = datastart + _step * rows;
    dataend = datalimit - _step + minstep;
}

inline
Mat::Mat(Size _sz, int _type, void* _data, size_t _step)
    : flags(MAGIC_VAL + (_type & TYPE_MASK)), dims(2), rows(_sz.height), cols(_sz.width),
      data((uchar*)_data), datastart((uchar*)_data), dataend(0), datalimit(0),
      allocator(0), u(0), size(&rows)
{
    if(!!(total() == 0 || data != 0)) ; else cv::error( cv::Error::StsAssert, "total() == 0 || data != NULL",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 533 );

    size_t esz = (((((_type) & ((512 - 1) << 3)) >> 3) + 1) << ((((sizeof(size_t)/4+1)*16384|0x3a50) >> ((_type) & ((1 << 3) - 1))*2) & 3)), esz1 = ((((sizeof(size_t)<<28)|0x8442211) >> ((_type) & ((1 << 3) - 1))*4) & 15);
    size_t minstep = cols*esz;
    if( _step == AUTO_STEP )
    {
        _step = minstep;
        flags |= CONTINUOUS_FLAG;
    }
    else
    {
        if( rows == 1 ) _step = minstep;
        ;

        if (_step % esz1 != 0)
        {
            cv::error( Error::BadStep, "Step must be a multiple of esz1",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 549 );
        }

        flags |= _step == minstep ? CONTINUOUS_FLAG : 0;
    }
    step[0] = _step;
    step[1] = esz;
    datalimit = datastart + _step*rows;
    dataend = datalimit - _step + minstep;
}

template<typename _Tp> inline
Mat::Mat(const std::vector<_Tp>& vec, bool copyData)
    : flags(MAGIC_VAL | DataType<_Tp>::type | (1 << 14)), dims(2), rows((int)vec.size()),
      cols(1), data(0), datastart(0), dataend(0), datalimit(0), allocator(0), u(0), size(&rows), step(0)
{
    if(vec.empty())
        return;
    if( !copyData )
    {
        step[0] = step[1] = sizeof(_Tp);
        datastart = data = (uchar*)&vec[0];
        datalimit = dataend = datastart + rows * step[0];
    }
    else
        Mat((int)vec.size(), 1, DataType<_Tp>::type, (uchar*)&vec[0]).copyTo(*this);
}
































template<typename _Tp, int n> inline
Mat::Mat(const Vec<_Tp, n>& vec, bool copyData)
    : flags(MAGIC_VAL | DataType<_Tp>::type | (1 << 14)), dims(2), rows(n), cols(1), data(0),
      datastart(0), dataend(0), datalimit(0), allocator(0), u(0), size(&rows), step(0)
{
    if( !copyData )
    {
        step[0] = step[1] = sizeof(_Tp);
        datastart = data = (uchar*)vec.val;
        datalimit = dataend = datastart + rows * step[0];
    }
    else
        Mat(n, 1, DataType<_Tp>::type, (void*)vec.val).copyTo(*this);
}


template<typename _Tp, int m, int n> inline
Mat::Mat(const Matx<_Tp,m,n>& M, bool copyData)
    : flags(MAGIC_VAL | DataType<_Tp>::type | (1 << 14)), dims(2), rows(m), cols(n), data(0),
      datastart(0), dataend(0), datalimit(0), allocator(0), u(0), size(&rows), step(0)
{
    if( !copyData )
    {
        step[0] = cols * sizeof(_Tp);
        step[1] = sizeof(_Tp);
        datastart = data = (uchar*)M.val;
        datalimit = dataend = datastart + rows * step[0];
    }
    else
        Mat(m, n, DataType<_Tp>::type, (uchar*)M.val).copyTo(*this);
}

template<typename _Tp> inline
Mat::Mat(const Point_<_Tp>& pt, bool copyData)
    : flags(MAGIC_VAL | DataType<_Tp>::type | (1 << 14)), dims(2), rows(2), cols(1), data(0),
      datastart(0), dataend(0), datalimit(0), allocator(0), u(0), size(&rows), step(0)
{
    if( !copyData )
    {
        step[0] = step[1] = sizeof(_Tp);
        datastart = data = (uchar*)&pt.x;
        datalimit = dataend = datastart + rows * step[0];
    }
    else
    {
        create(2, 1, DataType<_Tp>::type);
        ((_Tp*)data)[0] = pt.x;
        ((_Tp*)data)[1] = pt.y;
    }
}

template<typename _Tp> inline
Mat::Mat(const Point3_<_Tp>& pt, bool copyData)
    : flags(MAGIC_VAL | DataType<_Tp>::type | (1 << 14)), dims(2), rows(3), cols(1), data(0),
      datastart(0), dataend(0), datalimit(0), allocator(0), u(0), size(&rows), step(0)
{
    if( !copyData )
    {
        step[0] = step[1] = sizeof(_Tp);
        datastart = data = (uchar*)&pt.x;
        datalimit = dataend = datastart + rows * step[0];
    }
    else
    {
        create(3, 1, DataType<_Tp>::type);
        ((_Tp*)data)[0] = pt.x;
        ((_Tp*)data)[1] = pt.y;
        ((_Tp*)data)[2] = pt.z;
    }
}

template<typename _Tp> inline
Mat::Mat(const MatCommaInitializer_<_Tp>& commaInitializer)
    : flags(MAGIC_VAL | DataType<_Tp>::type | (1 << 14)), dims(0), rows(0), cols(0), data(0),
      datastart(0), dataend(0), allocator(0), u(0), size(&rows)
{
    *this = commaInitializer.operator Mat_<_Tp>();
}

inline
Mat::~Mat()
{
    release();
    if( step.p != step.buf )
        fastFree(step.p);
}

inline
Mat& Mat::operator = (const Mat& m)
{
    if( this != &m )
    {
        if( m.u )
            (int)_InterlockedExchangeAdd((long volatile*)&m.u->refcount, 1);
        release();
        flags = m.flags;
        if( dims <= 2 && m.dims <= 2 )
        {
            dims = m.dims;
            rows = m.rows;
            cols = m.cols;
            step[0] = m.step[0];
            step[1] = m.step[1];
        }
        else
            copySize(m);
        data = m.data;
        datastart = m.datastart;
        dataend = m.dataend;
        datalimit = m.datalimit;
        allocator = m.allocator;
        u = m.u;
    }
    return *this;
}

inline
Mat Mat::row(int y) const
{
    return Mat(*this, Range(y, y + 1), Range::all());
}

inline
Mat Mat::col(int x) const
{
    return Mat(*this, Range::all(), Range(x, x + 1));
}

inline
Mat Mat::rowRange(int startrow, int endrow) const
{
    return Mat(*this, Range(startrow, endrow), Range::all());
}

inline
Mat Mat::rowRange(const Range& r) const
{
    return Mat(*this, r, Range::all());
}

inline
Mat Mat::colRange(int startcol, int endcol) const
{
    return Mat(*this, Range::all(), Range(startcol, endcol));
}

inline
Mat Mat::colRange(const Range& r) const
{
    return Mat(*this, Range::all(), r);
}

inline
Mat Mat::clone() const
{
    Mat m;
    copyTo(m);
    return m;
}

inline
void Mat::assignTo( Mat& m, int _type ) const
{
    if( _type < 0 )
        m = *this;
    else
        convertTo(m, _type);
}

inline
void Mat::create(int _rows, int _cols, int _type)
{
    _type &= TYPE_MASK;
    if( dims <= 2 && rows == _rows && cols == _cols && type() == _type && data )
        return;
    int sz[] = {_rows, _cols};
    create(2, sz, _type);
}

inline
void Mat::create(Size _sz, int _type)
{
    create(_sz.height, _sz.width, _type);
}

inline
void Mat::addref()
{
    if( u )
        (int)_InterlockedExchangeAdd((long volatile*)&u->refcount, 1);
}

inline
void Mat::release()
{
    if( u && (int)_InterlockedExchangeAdd((long volatile*)&u->refcount, -1) == 1 )
        deallocate();
    u = 0;
    datastart = dataend = datalimit = data = 0;
    for(int i = 0; i < dims; i++)
        size.p[i] = 0;










}

inline
Mat Mat::operator()( Range _rowRange, Range _colRange ) const
{
    return Mat(*this, _rowRange, _colRange);
}

inline
Mat Mat::operator()( const Rect& roi ) const
{
    return Mat(*this, roi);
}

inline
Mat Mat::operator()(const Range* ranges) const
{
    return Mat(*this, ranges);
}

inline
Mat Mat::operator()(const std::vector<Range>& ranges) const
{
    return Mat(*this, ranges);
}

inline
bool Mat::isContinuous() const
{
    return (flags & CONTINUOUS_FLAG) != 0;
}

inline
bool Mat::isSubmatrix() const
{
    return (flags & SUBMATRIX_FLAG) != 0;
}

inline
size_t Mat::elemSize() const
{
    return dims > 0 ? step.p[dims - 1] : 0;
}

inline
size_t Mat::elemSize1() const
{
    return ((((sizeof(size_t)<<28)|0x8442211) >> ((flags) & ((1 << 3) - 1))*4) & 15);
}

inline
int Mat::type() const
{
    return ((flags) & ((1 << 3)*512 - 1));
}

inline
int Mat::depth() const
{
    return ((flags) & ((1 << 3) - 1));
}

inline
int Mat::channels() const
{
    return ((((flags) & ((512 - 1) << 3)) >> 3) + 1);
}

inline
size_t Mat::step1(int i) const
{
    return step.p[i] / elemSize1();
}

inline
bool Mat::empty() const
{
    return data == 0 || total() == 0 || dims == 0;
}

inline
size_t Mat::total() const
{
    if( dims <= 2 )
        return (size_t)rows * cols;
    size_t p = 1;
    for( int i = 0; i < dims; i++ )
        p *= size[i];
    return p;
}

inline
size_t Mat::total(int startDim, int endDim) const
{
    if(!!(0 <= startDim && startDim <= endDim)) ; else cv::error( cv::Error::StsAssert, "0 <= startDim && startDim <= endDim",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 913 );
    size_t p = 1;
    int endDim_ = endDim <= dims ? endDim : dims;
    for( int i = startDim; i < endDim_; i++ )
        p *= size[i];
    return p;
}

inline
uchar* Mat::ptr(int y)
{
    ;
    return data + step.p[0] * y;
}

inline
const uchar* Mat::ptr(int y) const
{
    ;
    return data + step.p[0] * y;
}

template<typename _Tp> inline
_Tp* Mat::ptr(int y)
{
    ;
    return (_Tp*)(data + step.p[0] * y);
}

template<typename _Tp> inline
const _Tp* Mat::ptr(int y) const
{
    ;
    return (const _Tp*)(data + step.p[0] * y);
}

inline
uchar* Mat::ptr(int i0, int i1)
{
    ;
    ;
    ;
    ;
    return data + i0 * step.p[0] + i1 * step.p[1];
}

inline
const uchar* Mat::ptr(int i0, int i1) const
{
    ;
    ;
    ;
    ;
    return data + i0 * step.p[0] + i1 * step.p[1];
}

template<typename _Tp> inline
_Tp* Mat::ptr(int i0, int i1)
{
    ;
    ;
    ;
    ;
    return (_Tp*)(data + i0 * step.p[0] + i1 * step.p[1]);
}

template<typename _Tp> inline
const _Tp* Mat::ptr(int i0, int i1) const
{
    ;
    ;
    ;
    ;
    return (const _Tp*)(data + i0 * step.p[0] + i1 * step.p[1]);
}

inline
uchar* Mat::ptr(int i0, int i1, int i2)
{
    ;
    ;
    ;
    ;
    ;
    return data + i0 * step.p[0] + i1 * step.p[1] + i2 * step.p[2];
}

inline
const uchar* Mat::ptr(int i0, int i1, int i2) const
{
    ;
    ;
    ;
    ;
    ;
    return data + i0 * step.p[0] + i1 * step.p[1] + i2 * step.p[2];
}

template<typename _Tp> inline
_Tp* Mat::ptr(int i0, int i1, int i2)
{
    ;
    ;
    ;
    ;
    ;
    return (_Tp*)(data + i0 * step.p[0] + i1 * step.p[1] + i2 * step.p[2]);
}

template<typename _Tp> inline
const _Tp* Mat::ptr(int i0, int i1, int i2) const
{
    ;
    ;
    ;
    ;
    ;
    return (const _Tp*)(data + i0 * step.p[0] + i1 * step.p[1] + i2 * step.p[2]);
}

inline
uchar* Mat::ptr(const int* idx)
{
    int i, d = dims;
    uchar* p = data;
    ;
    for( i = 0; i < d; i++ )
    {
        ;
        p += idx[i] * step.p[i];
    }
    return p;
}

inline
const uchar* Mat::ptr(const int* idx) const
{
    int i, d = dims;
    uchar* p = data;
    ;
    for( i = 0; i < d; i++ )
    {
        ;
        p += idx[i] * step.p[i];
    }
    return p;
}

template<typename _Tp> inline
_Tp& Mat::at(int i0, int i1)
{
    ;
    ;
    ;
    ;
    ;
    return ((_Tp*)(data + step.p[0] * i0))[i1];
}

template<typename _Tp> inline
const _Tp& Mat::at(int i0, int i1) const
{
    ;
    ;
    ;
    ;
    ;
    return ((const _Tp*)(data + step.p[0] * i0))[i1];
}

template<typename _Tp> inline
_Tp& Mat::at(Point pt)
{
    ;
    ;
    ;
    ;
    ;
    return ((_Tp*)(data + step.p[0] * pt.y))[pt.x];
}

template<typename _Tp> inline
const _Tp& Mat::at(Point pt) const
{
    ;
    ;
    ;
    ;
    ;
    return ((const _Tp*)(data + step.p[0] * pt.y))[pt.x];
}

template<typename _Tp> inline
_Tp& Mat::at(int i0)
{
    ;
    ;
    ;
    ;
    if( isContinuous() || size.p[0] == 1 )
        return ((_Tp*)data)[i0];
    if( size.p[1] == 1 )
        return *(_Tp*)(data + step.p[0] * i0);
    int i = i0 / cols, j = i0 - i * cols;
    return ((_Tp*)(data + step.p[0] * i))[j];
}

template<typename _Tp> inline
const _Tp& Mat::at(int i0) const
{
    ;
    ;
    ;
    ;
    if( isContinuous() || size.p[0] == 1 )
        return ((const _Tp*)data)[i0];
    if( size.p[1] == 1 )
        return *(const _Tp*)(data + step.p[0] * i0);
    int i = i0 / cols, j = i0 - i * cols;
    return ((const _Tp*)(data + step.p[0] * i))[j];
}

template<typename _Tp> inline
_Tp& Mat::at(int i0, int i1, int i2)
{
    ;
    return *(_Tp*)ptr(i0, i1, i2);
}

template<typename _Tp> inline
const _Tp& Mat::at(int i0, int i1, int i2) const
{
    ;
    return *(const _Tp*)ptr(i0, i1, i2);
}

template<typename _Tp> inline
_Tp& Mat::at(const int* idx)
{
    ;
    return *(_Tp*)ptr(idx);
}

template<typename _Tp> inline
const _Tp& Mat::at(const int* idx) const
{
    ;
    return *(const _Tp*)ptr(idx);
}

template<typename _Tp, int n> inline
_Tp& Mat::at(const Vec<int, n>& idx)
{
    ;
    return *(_Tp*)ptr(idx.val);
}

template<typename _Tp, int n> inline
const _Tp& Mat::at(const Vec<int, n>& idx) const
{
    ;
    return *(const _Tp*)ptr(idx.val);
}

template<typename _Tp> inline
MatConstIterator_<_Tp> Mat::begin() const
{
    ;
    return MatConstIterator_<_Tp>((const Mat_<_Tp>*)this);
}

template<typename _Tp> inline
MatConstIterator_<_Tp> Mat::end() const
{
    ;
    MatConstIterator_<_Tp> it((const Mat_<_Tp>*)this);
    it += total();
    return it;
}

template<typename _Tp> inline
MatIterator_<_Tp> Mat::begin()
{
    ;
    return MatIterator_<_Tp>((Mat_<_Tp>*)this);
}

template<typename _Tp> inline
MatIterator_<_Tp> Mat::end()
{
    ;
    MatIterator_<_Tp> it((Mat_<_Tp>*)this);
    it += total();
    return it;
}

template<typename _Tp, typename Functor> inline
void Mat::forEach(const Functor& operation) {
    this->forEach_impl<_Tp>(operation);
}

template<typename _Tp, typename Functor> inline
void Mat::forEach(const Functor& operation) const {
    
    (const_cast<Mat*>(this))->forEach<const _Tp>(operation);
}

template<typename _Tp> inline
Mat::operator std::vector<_Tp>() const
{
    std::vector<_Tp> v;
    copyTo(v);
    return v;
}











template<typename _Tp, int n> inline
Mat::operator Vec<_Tp, n>() const
{
    if(!!(data && dims <= 2 && (rows == 1 || cols == 1) && rows + cols - 1 == n && channels() == 1)) ; else cv::error( cv::Error::StsAssert, "data && dims <= 2 && (rows == 1 || cols == 1) && rows + cols - 1 == n && channels() == 1",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 1242 );
#line 1243 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp"

    if( isContinuous() && type() == DataType<_Tp>::type )
        return Vec<_Tp, n>((_Tp*)data);
    Vec<_Tp, n> v;
    Mat tmp(rows, cols, DataType<_Tp>::type, v.val);
    convertTo(tmp, tmp.type());
    return v;
}

template<typename _Tp, int m, int n> inline
Mat::operator Matx<_Tp, m, n>() const
{
    if(!!(data && dims <= 2 && rows == m && cols == n && channels() == 1)) ; else cv::error( cv::Error::StsAssert, "data && dims <= 2 && rows == m && cols == n && channels() == 1",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 1255 );

    if( isContinuous() && type() == DataType<_Tp>::type )
        return Matx<_Tp, m, n>((_Tp*)data);
    Matx<_Tp, m, n> mtx;
    Mat tmp(rows, cols, DataType<_Tp>::type, mtx.val);
    convertTo(tmp, tmp.type());
    return mtx;
}

template<typename _Tp> inline
void Mat::push_back(const _Tp& elem)
{
    if( !data )
    {
        *this = Mat(1, 1, DataType<_Tp>::type, (void*)&elem).clone();
        return;
    }
    if(!!(DataType<_Tp>::type == type() && cols == 1)) ; else cv::error( cv::Error::StsAssert, "DataType<_Tp>::type == type() && cols == 1",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 1274 );
#line 1275 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp"
    const uchar* tmp = dataend + step[0];
    if( !isSubmatrix() && isContinuous() && tmp <= datalimit )
    {
        *(_Tp*)(data + (size.p[0]++) * step.p[0]) = elem;
        dataend = tmp;
    }
    else
        push_back_(&elem);
}

template<typename _Tp> inline
void Mat::push_back(const Mat_<_Tp>& m)
{
    push_back((const Mat&)m);
}

template<> inline
void Mat::push_back(const MatExpr& expr)
{
    push_back(static_cast<Mat>(expr));
}



inline
Mat::Mat(Mat&& m)
    : flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), data(m.data),
      datastart(m.datastart), dataend(m.dataend), datalimit(m.datalimit), allocator(m.allocator),
      u(m.u), size(&rows)
{
    if (m.dims <= 2)  
    {
        step[0] = m.step[0];
        step[1] = m.step[1];
    }
    else
    {
        ;
        step.p = m.step.p;
        size.p = m.size.p;
        m.step.p = m.step.buf;
        m.size.p = &m.rows;
    }
    m.flags = MAGIC_VAL; m.dims = m.rows = m.cols = 0;
    m.data = 0; m.datastart = 0; m.dataend = 0; m.datalimit = 0;
    m.allocator = 0;
    m.u = 0;
}

inline
Mat& Mat::operator = (Mat&& m)
{
    if (this == &m)
      return *this;

    release();
    flags = m.flags; dims = m.dims; rows = m.rows; cols = m.cols; data = m.data;
    datastart = m.datastart; dataend = m.dataend; datalimit = m.datalimit; allocator = m.allocator;
    u = m.u;
    if (step.p != step.buf) 
    {
        fastFree(step.p);
        step.p = step.buf;
        size.p = &rows;
    }
    if (m.dims <= 2) 
    {
        step[0] = m.step[0];
        step[1] = m.step[1];
    }
    else
    {
        ;
        step.p = m.step.p;
        size.p = m.size.p;
        m.step.p = m.step.buf;
        m.size.p = &m.rows;
    }
    m.flags = MAGIC_VAL; m.dims = m.rows = m.cols = 0;
    m.data = 0; m.datastart = 0; m.dataend = 0; m.datalimit = 0;
    m.allocator = 0;
    m.u = 0;
    return *this;
}

#line 1361 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp"




inline
MatSize::MatSize(int* _p)
    : p(_p) {}

inline
Size MatSize::operator()() const
{
    ;
    return Size(p[1], p[0]);
}

inline
const int& MatSize::operator[](int i) const
{
    return p[i];
}

inline
int& MatSize::operator[](int i)
{
    return p[i];
}

inline
MatSize::operator const int*() const
{
    return p;
}

inline
bool MatSize::operator == (const MatSize& sz) const
{
    int d = p[-1];
    int dsz = sz.p[-1];
    if( d != dsz )
        return false;
    if( d == 2 )
        return p[0] == sz.p[0] && p[1] == sz.p[1];

    for( int i = 0; i < d; i++ )
        if( p[i] != sz.p[i] )
            return false;
    return true;
}

inline
bool MatSize::operator != (const MatSize& sz) const
{
    return !(*this == sz);
}





inline
MatStep::MatStep()
{
    p = buf; p[0] = p[1] = 0;
}

inline
MatStep::MatStep(size_t s)
{
    p = buf; p[0] = s; p[1] = 0;
}

inline
const size_t& MatStep::operator[](int i) const
{
    return p[i];
}

inline
size_t& MatStep::operator[](int i)
{
    return p[i];
}

inline MatStep::operator size_t() const
{
    ;
    return buf[0];
}

inline MatStep& MatStep::operator = (size_t s)
{
    ;
    buf[0] = s;
    return *this;
}





template<typename _Tp> inline
Mat_<_Tp>::Mat_()
    : Mat()
{
    flags = (flags & ~((1 << 3)*512 - 1)) | DataType<_Tp>::type;
}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(int _rows, int _cols)
    : Mat(_rows, _cols, DataType<_Tp>::type)
{
}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(int _rows, int _cols, const _Tp& value)
    : Mat(_rows, _cols, DataType<_Tp>::type)
{
    *this = value;
}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(Size _sz)
    : Mat(_sz.height, _sz.width, DataType<_Tp>::type)
{}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(Size _sz, const _Tp& value)
    : Mat(_sz.height, _sz.width, DataType<_Tp>::type)
{
    *this = value;
}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(int _dims, const int* _sz)
    : Mat(_dims, _sz, DataType<_Tp>::type)
{}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(int _dims, const int* _sz, const _Tp& _s)
    : Mat(_dims, _sz, DataType<_Tp>::type, Scalar(_s))
{}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(int _dims, const int* _sz, _Tp* _data, const size_t* _steps)
    : Mat(_dims, _sz, DataType<_Tp>::type, _data, _steps)
{}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(const Mat_<_Tp>& m, const Range* ranges)
    : Mat(m, ranges)
{}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(const Mat_<_Tp>& m, const std::vector<Range>& ranges)
    : Mat(m, ranges)
{}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(const Mat& m)
    : Mat()
{
    flags = (flags & ~((1 << 3)*512 - 1)) | DataType<_Tp>::type;
    *this = m;
}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(const Mat_& m)
    : Mat(m)
{}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(int _rows, int _cols, _Tp* _data, size_t steps)
    : Mat(_rows, _cols, DataType<_Tp>::type, _data, steps)
{}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(const Mat_& m, const Range& _rowRange, const Range& _colRange)
    : Mat(m, _rowRange, _colRange)
{}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(const Mat_& m, const Rect& roi)
    : Mat(m, roi)
{}

template<typename _Tp> template<int n> inline
Mat_<_Tp>::Mat_(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData)
    : Mat(n / DataType<_Tp>::channels, 1, DataType<_Tp>::type, (void*)&vec)
{
    if(!!(n%DataType<_Tp>::channels == 0)) ; else cv::error( cv::Error::StsAssert, "n%DataType<_Tp>::channels == 0",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 1550 );
    if( copyData )
        *this = clone();
}

template<typename _Tp> template<int m, int n> inline
Mat_<_Tp>::Mat_(const Matx<typename DataType<_Tp>::channel_type, m, n>& M, bool copyData)
    : Mat(m, n / DataType<_Tp>::channels, DataType<_Tp>::type, (void*)&M)
{
    if(!!(n % DataType<_Tp>::channels == 0)) ; else cv::error( cv::Error::StsAssert, "n % DataType<_Tp>::channels == 0",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 1559 );
    if( copyData )
        *this = clone();
}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
    : Mat(2 / DataType<_Tp>::channels, 1, DataType<_Tp>::type, (void*)&pt)
{
    if(!!(2 % DataType<_Tp>::channels == 0)) ; else cv::error( cv::Error::StsAssert, "2 % DataType<_Tp>::channels == 0",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 1568 );
    if( copyData )
        *this = clone();
}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
    : Mat(3 / DataType<_Tp>::channels, 1, DataType<_Tp>::type, (void*)&pt)
{
    if(!!(3 % DataType<_Tp>::channels == 0)) ; else cv::error( cv::Error::StsAssert, "3 % DataType<_Tp>::channels == 0",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 1577 );
    if( copyData )
        *this = clone();
}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(const MatCommaInitializer_<_Tp>& commaInitializer)
    : Mat(commaInitializer)
{}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(const std::vector<_Tp>& vec, bool copyData)
    : Mat(vec, copyData)
{}















template<typename _Tp> inline
Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat& m)
{
    if( DataType<_Tp>::type == m.type() )
    {
        Mat::operator = (m);
        return *this;
    }
    if( DataType<_Tp>::depth == m.depth() )
    {
        return (*this = m.reshape(DataType<_Tp>::channels, m.dims, 0));
    }
    ;
    m.convertTo(*this, type());
    return *this;
}

template<typename _Tp> inline
Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat_& m)
{
    Mat::operator=(m);
    return *this;
}

template<typename _Tp> inline
Mat_<_Tp>& Mat_<_Tp>::operator = (const _Tp& s)
{
    typedef typename DataType<_Tp>::vec_type VT;
    Mat::operator=(Scalar((const VT&)s));
    return *this;
}

template<typename _Tp> inline
void Mat_<_Tp>::create(int _rows, int _cols)
{
    Mat::create(_rows, _cols, DataType<_Tp>::type);
}

template<typename _Tp> inline
void Mat_<_Tp>::create(Size _sz)
{
    Mat::create(_sz, DataType<_Tp>::type);
}

template<typename _Tp> inline
void Mat_<_Tp>::create(int _dims, const int* _sz)
{
    Mat::create(_dims, _sz, DataType<_Tp>::type);
}

template<typename _Tp> inline
void Mat_<_Tp>::release()
{
    Mat::release();



}

template<typename _Tp> inline
Mat_<_Tp> Mat_<_Tp>::cross(const Mat_& m) const
{
    return Mat_<_Tp>(Mat::cross(m));
}

template<typename _Tp> template<typename T2> inline
Mat_<_Tp>::operator Mat_<T2>() const
{
    return Mat_<T2>(*this);
}

template<typename _Tp> inline
Mat_<_Tp> Mat_<_Tp>::row(int y) const
{
    return Mat_(*this, Range(y, y+1), Range::all());
}

template<typename _Tp> inline
Mat_<_Tp> Mat_<_Tp>::col(int x) const
{
    return Mat_(*this, Range::all(), Range(x, x+1));
}

template<typename _Tp> inline
Mat_<_Tp> Mat_<_Tp>::diag(int d) const
{
    return Mat_(Mat::diag(d));
}

template<typename _Tp> inline
Mat_<_Tp> Mat_<_Tp>::clone() const
{
    return Mat_(Mat::clone());
}

template<typename _Tp> inline
size_t Mat_<_Tp>::elemSize() const
{
    ;
    return sizeof(_Tp);
}

template<typename _Tp> inline
size_t Mat_<_Tp>::elemSize1() const
{
    ;
    return sizeof(_Tp) / DataType<_Tp>::channels;
}

template<typename _Tp> inline
int Mat_<_Tp>::type() const
{
    ;
    return DataType<_Tp>::type;
}

template<typename _Tp> inline
int Mat_<_Tp>::depth() const
{
    ;
    return DataType<_Tp>::depth;
}

template<typename _Tp> inline
int Mat_<_Tp>::channels() const
{
    ;
    return DataType<_Tp>::channels;
}

template<typename _Tp> inline
size_t Mat_<_Tp>::stepT(int i) const
{
    return step.p[i] / elemSize();
}

template<typename _Tp> inline
size_t Mat_<_Tp>::step1(int i) const
{
    return step.p[i] / elemSize1();
}

template<typename _Tp> inline
Mat_<_Tp>& Mat_<_Tp>::adjustROI( int dtop, int dbottom, int dleft, int dright )
{
    return (Mat_<_Tp>&)(Mat::adjustROI(dtop, dbottom, dleft, dright));
}

template<typename _Tp> inline
Mat_<_Tp> Mat_<_Tp>::operator()( const Range& _rowRange, const Range& _colRange ) const
{
    return Mat_<_Tp>(*this, _rowRange, _colRange);
}

template<typename _Tp> inline
Mat_<_Tp> Mat_<_Tp>::operator()( const Rect& roi ) const
{
    return Mat_<_Tp>(*this, roi);
}

template<typename _Tp> inline
Mat_<_Tp> Mat_<_Tp>::operator()( const Range* ranges ) const
{
    return Mat_<_Tp>(*this, ranges);
}

template<typename _Tp> inline
Mat_<_Tp> Mat_<_Tp>::operator()(const std::vector<Range>& ranges) const
{
    return Mat_<_Tp>(*this, ranges);
}

template<typename _Tp> inline
_Tp* Mat_<_Tp>::operator [](int y)
{
    ;
    return (_Tp*)(data + y*step.p[0]);
}

template<typename _Tp> inline
const _Tp* Mat_<_Tp>::operator [](int y) const
{
    ;
    return (const _Tp*)(data + y*step.p[0]);
}

template<typename _Tp> inline
_Tp& Mat_<_Tp>::operator ()(int i0, int i1)
{
    ;
    ;
    ;
    ;
    ;
    return ((_Tp*)(data + step.p[0] * i0))[i1];
}

template<typename _Tp> inline
const _Tp& Mat_<_Tp>::operator ()(int i0, int i1) const
{
    ;
    ;
    ;
    ;
    ;
    return ((const _Tp*)(data + step.p[0] * i0))[i1];
}

template<typename _Tp> inline
_Tp& Mat_<_Tp>::operator ()(Point pt)
{
    ;
    ;
    ;
    ;
    ;
    return ((_Tp*)(data + step.p[0] * pt.y))[pt.x];
}

template<typename _Tp> inline
const _Tp& Mat_<_Tp>::operator ()(Point pt) const
{
    ;
    ;
    ;
    ;
    ;
    return ((const _Tp*)(data + step.p[0] * pt.y))[pt.x];
}

template<typename _Tp> inline
_Tp& Mat_<_Tp>::operator ()(const int* idx)
{
    return Mat::at<_Tp>(idx);
}

template<typename _Tp> inline
const _Tp& Mat_<_Tp>::operator ()(const int* idx) const
{
    return Mat::at<_Tp>(idx);
}

template<typename _Tp> template<int n> inline
_Tp& Mat_<_Tp>::operator ()(const Vec<int, n>& idx)
{
    return Mat::at<_Tp>(idx);
}

template<typename _Tp> template<int n> inline
const _Tp& Mat_<_Tp>::operator ()(const Vec<int, n>& idx) const
{
    return Mat::at<_Tp>(idx);
}

template<typename _Tp> inline
_Tp& Mat_<_Tp>::operator ()(int i0)
{
    return this->at<_Tp>(i0);
}

template<typename _Tp> inline
const _Tp& Mat_<_Tp>::operator ()(int i0) const
{
    return this->at<_Tp>(i0);
}

template<typename _Tp> inline
_Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2)
{
    return this->at<_Tp>(i0, i1, i2);
}

template<typename _Tp> inline
const _Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2) const
{
    return this->at<_Tp>(i0, i1, i2);
}

template<typename _Tp> inline
Mat_<_Tp>::operator std::vector<_Tp>() const
{
    std::vector<_Tp> v;
    copyTo(v);
    return v;
}











template<typename _Tp> template<int n> inline
Mat_<_Tp>::operator Vec<typename DataType<_Tp>::channel_type, n>() const
{
    if(!!(n % DataType<_Tp>::channels == 0)) ; else cv::error( cv::Error::StsAssert, "n % DataType<_Tp>::channels == 0",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 1905 );


    const Mat* pMat = (const Mat*)this; 
    return pMat->operator Vec<typename DataType<_Tp>::channel_type, n>();


#line 1913 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp"
}

template<typename _Tp> template<int m, int n> inline
Mat_<_Tp>::operator Matx<typename DataType<_Tp>::channel_type, m, n>() const
{
    if(!!(n % DataType<_Tp>::channels == 0)) ; else cv::error( cv::Error::StsAssert, "n % DataType<_Tp>::channels == 0",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 1918 );


    const Mat* pMat = (const Mat*)this; 
    Matx<typename DataType<_Tp>::channel_type, m, n> res = pMat->operator Matx<typename DataType<_Tp>::channel_type, m, n>();
    return res;



#line 1928 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp"
}

template<typename _Tp> inline
MatConstIterator_<_Tp> Mat_<_Tp>::begin() const
{
    return Mat::begin<_Tp>();
}

template<typename _Tp> inline
MatConstIterator_<_Tp> Mat_<_Tp>::end() const
{
    return Mat::end<_Tp>();
}

template<typename _Tp> inline
MatIterator_<_Tp> Mat_<_Tp>::begin()
{
    return Mat::begin<_Tp>();
}

template<typename _Tp> inline
MatIterator_<_Tp> Mat_<_Tp>::end()
{
    return Mat::end<_Tp>();
}

template<typename _Tp> template<typename Functor> inline
void Mat_<_Tp>::forEach(const Functor& operation) {
    Mat::forEach<_Tp, Functor>(operation);
}

template<typename _Tp> template<typename Functor> inline
void Mat_<_Tp>::forEach(const Functor& operation) const {
    Mat::forEach<_Tp, Functor>(operation);
}



template<typename _Tp> inline
Mat_<_Tp>::Mat_(Mat_&& m)
    : Mat(m)
{
}

template<typename _Tp> inline
Mat_<_Tp>& Mat_<_Tp>::operator = (Mat_&& m)
{
    Mat::operator = (std::move(m));
    return *this;
}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(Mat&& m)
    : Mat()
{
    flags = (flags & ~((1 << 3)*512 - 1)) | DataType<_Tp>::type;
    *this = m;
}

template<typename _Tp> inline
Mat_<_Tp>& Mat_<_Tp>::operator = (Mat&& m)
{
    if( DataType<_Tp>::type == m.type() )
    {
        Mat::operator = ((Mat&&)m);
        return *this;
    }
    if( DataType<_Tp>::depth == m.depth() )
    {
        Mat::operator = ((Mat&&)m.reshape(DataType<_Tp>::channels, m.dims, 0));
        return *this;
    }
    ;
    m.convertTo(*this, type());
    return *this;
}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(MatExpr&& e)
    : Mat()
{
    flags = (flags & ~((1 << 3)*512 - 1)) | DataType<_Tp>::type;
    *this = Mat(e);
}

#line 2014 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp"



inline
SparseMat::SparseMat()
    : flags(MAGIC_VAL), hdr(0)
{}

inline
SparseMat::SparseMat(int _dims, const int* _sizes, int _type)
    : flags(MAGIC_VAL), hdr(0)
{
    create(_dims, _sizes, _type);
}

inline
SparseMat::SparseMat(const SparseMat& m)
    : flags(m.flags), hdr(m.hdr)
{
    addref();
}

inline
SparseMat::~SparseMat()
{
    release();
}

inline
SparseMat& SparseMat::operator = (const SparseMat& m)
{
    if( this != &m )
    {
        if( m.hdr )
            (int)_InterlockedExchangeAdd((long volatile*)&m.hdr->refcount, 1);
        release();
        flags = m.flags;
        hdr = m.hdr;
    }
    return *this;
}

inline
SparseMat& SparseMat::operator = (const Mat& m)
{
    return (*this = SparseMat(m));
}

inline
SparseMat SparseMat::clone() const
{
    SparseMat temp;
    this->copyTo(temp);
    return temp;
}

inline
void SparseMat::assignTo( SparseMat& m, int _type ) const
{
    if( _type < 0 )
        m = *this;
    else
        convertTo(m, _type);
}

inline
void SparseMat::addref()
{
    if( hdr )
        (int)_InterlockedExchangeAdd((long volatile*)&hdr->refcount, 1);
}

inline
void SparseMat::release()
{
    if( hdr && (int)_InterlockedExchangeAdd((long volatile*)&hdr->refcount, -1) == 1 )
        delete hdr;
    hdr = 0;
}

inline
size_t SparseMat::elemSize() const
{
    return (((((flags) & ((512 - 1) << 3)) >> 3) + 1) << ((((sizeof(size_t)/4+1)*16384|0x3a50) >> ((flags) & ((1 << 3) - 1))*2) & 3));
}

inline
size_t SparseMat::elemSize1() const
{
    return ((((sizeof(size_t)<<28)|0x8442211) >> ((flags) & ((1 << 3) - 1))*4) & 15);
}

inline
int SparseMat::type() const
{
    return ((flags) & ((1 << 3)*512 - 1));
}

inline
int SparseMat::depth() const
{
    return ((flags) & ((1 << 3) - 1));
}

inline
int SparseMat::channels() const
{
    return ((((flags) & ((512 - 1) << 3)) >> 3) + 1);
}

inline
const int* SparseMat::size() const
{
    return hdr ? hdr->size : 0;
}

inline
int SparseMat::size(int i) const
{
    if( hdr )
    {
        ;
        return hdr->size[i];
    }
    return 0;
}

inline
int SparseMat::dims() const
{
    return hdr ? hdr->dims : 0;
}

inline
size_t SparseMat::nzcount() const
{
    return hdr ? hdr->nodeCount : 0;
}

inline
size_t SparseMat::hash(int i0) const
{
    return (size_t)i0;
}

inline
size_t SparseMat::hash(int i0, int i1) const
{
    return (size_t)(unsigned)i0 * HASH_SCALE + (unsigned)i1;
}

inline
size_t SparseMat::hash(int i0, int i1, int i2) const
{
    return ((size_t)(unsigned)i0 * HASH_SCALE + (unsigned)i1) * HASH_SCALE + (unsigned)i2;
}

inline
size_t SparseMat::hash(const int* idx) const
{
    size_t h = (unsigned)idx[0];
    if( !hdr )
        return 0;
    int d = hdr->dims;
    for(int i = 1; i < d; i++ )
        h = h * HASH_SCALE + (unsigned)idx[i];
    return h;
}

template<typename _Tp> inline
_Tp& SparseMat::ref(int i0, size_t* hashval)
{
    return *(_Tp*)((SparseMat*)this)->ptr(i0, true, hashval);
}

template<typename _Tp> inline
_Tp& SparseMat::ref(int i0, int i1, size_t* hashval)
{
    return *(_Tp*)((SparseMat*)this)->ptr(i0, i1, true, hashval);
}

template<typename _Tp> inline
_Tp& SparseMat::ref(int i0, int i1, int i2, size_t* hashval)
{
    return *(_Tp*)((SparseMat*)this)->ptr(i0, i1, i2, true, hashval);
}

template<typename _Tp> inline
_Tp& SparseMat::ref(const int* idx, size_t* hashval)
{
    return *(_Tp*)((SparseMat*)this)->ptr(idx, true, hashval);
}

template<typename _Tp> inline
_Tp SparseMat::value(int i0, size_t* hashval) const
{
    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(i0, false, hashval);
    return p ? *p : _Tp();
}

template<typename _Tp> inline
_Tp SparseMat::value(int i0, int i1, size_t* hashval) const
{
    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(i0, i1, false, hashval);
    return p ? *p : _Tp();
}

template<typename _Tp> inline
_Tp SparseMat::value(int i0, int i1, int i2, size_t* hashval) const
{
    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(i0, i1, i2, false, hashval);
    return p ? *p : _Tp();
}

template<typename _Tp> inline
_Tp SparseMat::value(const int* idx, size_t* hashval) const
{
    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(idx, false, hashval);
    return p ? *p : _Tp();
}

template<typename _Tp> inline
const _Tp* SparseMat::find(int i0, size_t* hashval) const
{
    return (const _Tp*)((SparseMat*)this)->ptr(i0, false, hashval);
}

template<typename _Tp> inline
const _Tp* SparseMat::find(int i0, int i1, size_t* hashval) const
{
    return (const _Tp*)((SparseMat*)this)->ptr(i0, i1, false, hashval);
}

template<typename _Tp> inline
const _Tp* SparseMat::find(int i0, int i1, int i2, size_t* hashval) const
{
    return (const _Tp*)((SparseMat*)this)->ptr(i0, i1, i2, false, hashval);
}

template<typename _Tp> inline
const _Tp* SparseMat::find(const int* idx, size_t* hashval) const
{
    return (const _Tp*)((SparseMat*)this)->ptr(idx, false, hashval);
}

template<typename _Tp> inline
_Tp& SparseMat::value(Node* n)
{
    return *(_Tp*)((uchar*)n + hdr->valueOffset);
}

template<typename _Tp> inline
const _Tp& SparseMat::value(const Node* n) const
{
    return *(const _Tp*)((const uchar*)n + hdr->valueOffset);
}

inline
SparseMat::Node* SparseMat::node(size_t nidx)
{
    return (Node*)(void*)&hdr->pool[nidx];
}

inline
const SparseMat::Node* SparseMat::node(size_t nidx) const
{
    return (const Node*)(const void*)&hdr->pool[nidx];
}

inline
SparseMatIterator SparseMat::begin()
{
    return SparseMatIterator(this);
}

inline
SparseMatConstIterator SparseMat::begin() const
{
    return SparseMatConstIterator(this);
}

inline
SparseMatIterator SparseMat::end()
{
    SparseMatIterator it(this);
    it.seekEnd();
    return it;
}

inline
SparseMatConstIterator SparseMat::end() const
{
    SparseMatConstIterator it(this);
    it.seekEnd();
    return it;
}

template<typename _Tp> inline
SparseMatIterator_<_Tp> SparseMat::begin()
{
    return SparseMatIterator_<_Tp>(this);
}

template<typename _Tp> inline
SparseMatConstIterator_<_Tp> SparseMat::begin() const
{
    return SparseMatConstIterator_<_Tp>(this);
}

template<typename _Tp> inline
SparseMatIterator_<_Tp> SparseMat::end()
{
    SparseMatIterator_<_Tp> it(this);
    it.seekEnd();
    return it;
}

template<typename _Tp> inline
SparseMatConstIterator_<_Tp> SparseMat::end() const
{
    SparseMatConstIterator_<_Tp> it(this);
    it.seekEnd();
    return it;
}





template<typename _Tp> inline
SparseMat_<_Tp>::SparseMat_()
{
    flags = MAGIC_VAL | DataType<_Tp>::type;
}

template<typename _Tp> inline
SparseMat_<_Tp>::SparseMat_(int _dims, const int* _sizes)
    : SparseMat(_dims, _sizes, DataType<_Tp>::type)
{}

template<typename _Tp> inline
SparseMat_<_Tp>::SparseMat_(const SparseMat& m)
{
    if( m.type() == DataType<_Tp>::type )
        *this = (const SparseMat_<_Tp>&)m;
    else
        m.convertTo(*this, DataType<_Tp>::type);
}

template<typename _Tp> inline
SparseMat_<_Tp>::SparseMat_(const SparseMat_<_Tp>& m)
{
    this->flags = m.flags;
    this->hdr = m.hdr;
    if( this->hdr )
        (int)_InterlockedExchangeAdd((long volatile*)&this->hdr->refcount, 1);
}

template<typename _Tp> inline
SparseMat_<_Tp>::SparseMat_(const Mat& m)
{
    SparseMat sm(m);
    *this = sm;
}

template<typename _Tp> inline
SparseMat_<_Tp>& SparseMat_<_Tp>::operator = (const SparseMat_<_Tp>& m)
{
    if( this != &m )
    {
        if( m.hdr ) (int)_InterlockedExchangeAdd((long volatile*)&m.hdr->refcount, 1);
        release();
        flags = m.flags;
        hdr = m.hdr;
    }
    return *this;
}

template<typename _Tp> inline
SparseMat_<_Tp>& SparseMat_<_Tp>::operator = (const SparseMat& m)
{
    if( m.type() == DataType<_Tp>::type )
        return (*this = (const SparseMat_<_Tp>&)m);
    m.convertTo(*this, DataType<_Tp>::type);
    return *this;
}

template<typename _Tp> inline
SparseMat_<_Tp>& SparseMat_<_Tp>::operator = (const Mat& m)
{
    return (*this = SparseMat(m));
}

template<typename _Tp> inline
SparseMat_<_Tp> SparseMat_<_Tp>::clone() const
{
    SparseMat_<_Tp> m;
    this->copyTo(m);
    return m;
}

template<typename _Tp> inline
void SparseMat_<_Tp>::create(int _dims, const int* _sizes)
{
    SparseMat::create(_dims, _sizes, DataType<_Tp>::type);
}

template<typename _Tp> inline
int SparseMat_<_Tp>::type() const
{
    return DataType<_Tp>::type;
}

template<typename _Tp> inline
int SparseMat_<_Tp>::depth() const
{
    return DataType<_Tp>::depth;
}

template<typename _Tp> inline
int SparseMat_<_Tp>::channels() const
{
    return DataType<_Tp>::channels;
}

template<typename _Tp> inline
_Tp& SparseMat_<_Tp>::ref(int i0, size_t* hashval)
{
    return SparseMat::ref<_Tp>(i0, hashval);
}

template<typename _Tp> inline
_Tp SparseMat_<_Tp>::operator()(int i0, size_t* hashval) const
{
    return SparseMat::value<_Tp>(i0, hashval);
}

template<typename _Tp> inline
_Tp& SparseMat_<_Tp>::ref(int i0, int i1, size_t* hashval)
{
    return SparseMat::ref<_Tp>(i0, i1, hashval);
}

template<typename _Tp> inline
_Tp SparseMat_<_Tp>::operator()(int i0, int i1, size_t* hashval) const
{
    return SparseMat::value<_Tp>(i0, i1, hashval);
}

template<typename _Tp> inline
_Tp& SparseMat_<_Tp>::ref(int i0, int i1, int i2, size_t* hashval)
{
    return SparseMat::ref<_Tp>(i0, i1, i2, hashval);
}

template<typename _Tp> inline
_Tp SparseMat_<_Tp>::operator()(int i0, int i1, int i2, size_t* hashval) const
{
    return SparseMat::value<_Tp>(i0, i1, i2, hashval);
}

template<typename _Tp> inline
_Tp& SparseMat_<_Tp>::ref(const int* idx, size_t* hashval)
{
    return SparseMat::ref<_Tp>(idx, hashval);
}

template<typename _Tp> inline
_Tp SparseMat_<_Tp>::operator()(const int* idx, size_t* hashval) const
{
    return SparseMat::value<_Tp>(idx, hashval);
}

template<typename _Tp> inline
SparseMatIterator_<_Tp> SparseMat_<_Tp>::begin()
{
    return SparseMatIterator_<_Tp>(this);
}

template<typename _Tp> inline
SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::begin() const
{
    return SparseMatConstIterator_<_Tp>(this);
}

template<typename _Tp> inline
SparseMatIterator_<_Tp> SparseMat_<_Tp>::end()
{
    SparseMatIterator_<_Tp> it(this);
    it.seekEnd();
    return it;
}

template<typename _Tp> inline
SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::end() const
{
    SparseMatConstIterator_<_Tp> it(this);
    it.seekEnd();
    return it;
}





inline
MatConstIterator::MatConstIterator()
    : m(0), elemSize(0), ptr(0), sliceStart(0), sliceEnd(0)
{}

inline
MatConstIterator::MatConstIterator(const Mat* _m)
    : m(_m), elemSize(_m->elemSize()), ptr(0), sliceStart(0), sliceEnd(0)
{
    if( m && m->isContinuous() )
    {
        sliceStart = m->ptr();
        sliceEnd = sliceStart + m->total()*elemSize;
    }
    seek((const int*)0);
}

inline
MatConstIterator::MatConstIterator(const Mat* _m, int _row, int _col)
    : m(_m), elemSize(_m->elemSize()), ptr(0), sliceStart(0), sliceEnd(0)
{
    if(!!(m && m->dims <= 2)) ; else cv::error( cv::Error::StsAssert, "m && m->dims <= 2",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 2540 );
    if( m->isContinuous() )
    {
        sliceStart = m->ptr();
        sliceEnd = sliceStart + m->total()*elemSize;
    }
    int idx[] = {_row, _col};
    seek(idx);
}

inline
MatConstIterator::MatConstIterator(const Mat* _m, Point _pt)
    : m(_m), elemSize(_m->elemSize()), ptr(0), sliceStart(0), sliceEnd(0)
{
    if(!!(m && m->dims <= 2)) ; else cv::error( cv::Error::StsAssert, "m && m->dims <= 2",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 2554 );
    if( m->isContinuous() )
    {
        sliceStart = m->ptr();
        sliceEnd = sliceStart + m->total()*elemSize;
    }
    int idx[] = {_pt.y, _pt.x};
    seek(idx);
}

inline
MatConstIterator::MatConstIterator(const MatConstIterator& it)
    : m(it.m), elemSize(it.elemSize), ptr(it.ptr), sliceStart(it.sliceStart), sliceEnd(it.sliceEnd)
{}

inline
MatConstIterator& MatConstIterator::operator = (const MatConstIterator& it )
{
    m = it.m; elemSize = it.elemSize; ptr = it.ptr;
    sliceStart = it.sliceStart; sliceEnd = it.sliceEnd;
    return *this;
}

inline
const uchar* MatConstIterator::operator *() const
{
    return ptr;
}

inline MatConstIterator& MatConstIterator::operator += (ptrdiff_t ofs)
{
    if( !m || ofs == 0 )
        return *this;
    ptrdiff_t ofsb = ofs*elemSize;
    ptr += ofsb;
    if( ptr < sliceStart || sliceEnd <= ptr )
    {
        ptr -= ofsb;
        seek(ofs, true);
    }
    return *this;
}

inline
MatConstIterator& MatConstIterator::operator -= (ptrdiff_t ofs)
{
    return (*this += -ofs);
}

inline
MatConstIterator& MatConstIterator::operator --()
{
    if( m && (ptr -= elemSize) < sliceStart )
    {
        ptr += elemSize;
        seek(-1, true);
    }
    return *this;
}

inline
MatConstIterator MatConstIterator::operator --(int)
{
    MatConstIterator b = *this;
    *this += -1;
    return b;
}

inline
MatConstIterator& MatConstIterator::operator ++()
{
    if( m && (ptr += elemSize) >= sliceEnd )
    {
        ptr -= elemSize;
        seek(1, true);
    }
    return *this;
}

inline MatConstIterator MatConstIterator::operator ++(int)
{
    MatConstIterator b = *this;
    *this += 1;
    return b;
}


static inline
bool operator == (const MatConstIterator& a, const MatConstIterator& b)
{
    return a.m == b.m && a.ptr == b.ptr;
}

static inline
bool operator != (const MatConstIterator& a, const MatConstIterator& b)
{
    return !(a == b);
}

static inline
bool operator < (const MatConstIterator& a, const MatConstIterator& b)
{
    return a.ptr < b.ptr;
}

static inline
bool operator > (const MatConstIterator& a, const MatConstIterator& b)
{
    return a.ptr > b.ptr;
}

static inline
bool operator <= (const MatConstIterator& a, const MatConstIterator& b)
{
    return a.ptr <= b.ptr;
}

static inline
bool operator >= (const MatConstIterator& a, const MatConstIterator& b)
{
    return a.ptr >= b.ptr;
}

static inline
ptrdiff_t operator - (const MatConstIterator& b, const MatConstIterator& a)
{
    if( a.m != b.m )
        return ((size_t)(-1) >> 1);
    if( a.sliceEnd == b.sliceEnd )
        return (b.ptr - a.ptr)/static_cast<ptrdiff_t>(b.elemSize);

    return b.lpos() - a.lpos();
}

static inline
MatConstIterator operator + (const MatConstIterator& a, ptrdiff_t ofs)
{
    MatConstIterator b = a;
    return b += ofs;
}

static inline
MatConstIterator operator + (ptrdiff_t ofs, const MatConstIterator& a)
{
    MatConstIterator b = a;
    return b += ofs;
}

static inline
MatConstIterator operator - (const MatConstIterator& a, ptrdiff_t ofs)
{
    MatConstIterator b = a;
    return b += -ofs;
}


inline
const uchar* MatConstIterator::operator [](ptrdiff_t i) const
{
    return *(*this + i);
}





template<typename _Tp> inline
MatConstIterator_<_Tp>::MatConstIterator_()
{}

template<typename _Tp> inline
MatConstIterator_<_Tp>::MatConstIterator_(const Mat_<_Tp>* _m)
    : MatConstIterator(_m)
{}

template<typename _Tp> inline
MatConstIterator_<_Tp>::MatConstIterator_(const Mat_<_Tp>* _m, int _row, int _col)
    : MatConstIterator(_m, _row, _col)
{}

template<typename _Tp> inline
MatConstIterator_<_Tp>::MatConstIterator_(const Mat_<_Tp>* _m, Point _pt)
    : MatConstIterator(_m, _pt)
{}

template<typename _Tp> inline
MatConstIterator_<_Tp>::MatConstIterator_(const MatConstIterator_& it)
    : MatConstIterator(it)
{}

template<typename _Tp> inline
MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator = (const MatConstIterator_& it )
{
    MatConstIterator::operator = (it);
    return *this;
}

template<typename _Tp> inline
const _Tp& MatConstIterator_<_Tp>::operator *() const
{
    return *(_Tp*)(this->ptr);
}

template<typename _Tp> inline
MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator += (ptrdiff_t ofs)
{
    MatConstIterator::operator += (ofs);
    return *this;
}

template<typename _Tp> inline
MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator -= (ptrdiff_t ofs)
{
    return (*this += -ofs);
}

template<typename _Tp> inline
MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator --()
{
    MatConstIterator::operator --();
    return *this;
}

template<typename _Tp> inline
MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator --(int)
{
    MatConstIterator_ b = *this;
    MatConstIterator::operator --();
    return b;
}

template<typename _Tp> inline
MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator ++()
{
    MatConstIterator::operator ++();
    return *this;
}

template<typename _Tp> inline
MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator ++(int)
{
    MatConstIterator_ b = *this;
    MatConstIterator::operator ++();
    return b;
}


template<typename _Tp> inline
Point MatConstIterator_<_Tp>::pos() const
{
    if( !m )
        return Point();
    ;
    if( m->isContinuous() )
    {
        ptrdiff_t ofs = (const _Tp*)ptr - (const _Tp*)m->data;
        int y = (int)(ofs / m->cols);
        int x = (int)(ofs - (ptrdiff_t)y * m->cols);
        return Point(x, y);
    }
    else
    {
        ptrdiff_t ofs = (uchar*)ptr - m->data;
        int y = (int)(ofs / m->step);
        int x = (int)((ofs - y * m->step)/sizeof(_Tp));
        return Point(x, y);
    }
}


template<typename _Tp> static inline
bool operator == (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
{
    return a.m == b.m && a.ptr == b.ptr;
}

template<typename _Tp> static inline
bool operator != (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
{
    return a.m != b.m || a.ptr != b.ptr;
}

template<typename _Tp> static inline
MatConstIterator_<_Tp> operator + (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
{
    MatConstIterator t = (const MatConstIterator&)a + ofs;
    return (MatConstIterator_<_Tp>&)t;
}

template<typename _Tp> static inline
MatConstIterator_<_Tp> operator + (ptrdiff_t ofs, const MatConstIterator_<_Tp>& a)
{
    MatConstIterator t = (const MatConstIterator&)a + ofs;
    return (MatConstIterator_<_Tp>&)t;
}

template<typename _Tp> static inline
MatConstIterator_<_Tp> operator - (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
{
    MatConstIterator t = (const MatConstIterator&)a - ofs;
    return (MatConstIterator_<_Tp>&)t;
}

template<typename _Tp> inline
const _Tp& MatConstIterator_<_Tp>::operator [](ptrdiff_t i) const
{
    return *(_Tp*)MatConstIterator::operator [](i);
}





template<typename _Tp> inline
MatIterator_<_Tp>::MatIterator_()
    : MatConstIterator_<_Tp>()
{}

template<typename _Tp> inline
MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m)
    : MatConstIterator_<_Tp>(_m)
{}

template<typename _Tp> inline
MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m, int _row, int _col)
    : MatConstIterator_<_Tp>(_m, _row, _col)
{}

template<typename _Tp> inline
MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m, Point _pt)
    : MatConstIterator_<_Tp>(_m, _pt)
{}

template<typename _Tp> inline
MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m, const int* _idx)
    : MatConstIterator_<_Tp>(_m, _idx)
{}

template<typename _Tp> inline
MatIterator_<_Tp>::MatIterator_(const MatIterator_& it)
    : MatConstIterator_<_Tp>(it)
{}

template<typename _Tp> inline
MatIterator_<_Tp>& MatIterator_<_Tp>::operator = (const MatIterator_<_Tp>& it )
{
    MatConstIterator::operator = (it);
    return *this;
}

template<typename _Tp> inline
_Tp& MatIterator_<_Tp>::operator *() const
{
    return *(_Tp*)(this->ptr);
}

template<typename _Tp> inline
MatIterator_<_Tp>& MatIterator_<_Tp>::operator += (ptrdiff_t ofs)
{
    MatConstIterator::operator += (ofs);
    return *this;
}

template<typename _Tp> inline
MatIterator_<_Tp>& MatIterator_<_Tp>::operator -= (ptrdiff_t ofs)
{
    MatConstIterator::operator += (-ofs);
    return *this;
}

template<typename _Tp> inline
MatIterator_<_Tp>& MatIterator_<_Tp>::operator --()
{
    MatConstIterator::operator --();
    return *this;
}

template<typename _Tp> inline
MatIterator_<_Tp> MatIterator_<_Tp>::operator --(int)
{
    MatIterator_ b = *this;
    MatConstIterator::operator --();
    return b;
}

template<typename _Tp> inline
MatIterator_<_Tp>& MatIterator_<_Tp>::operator ++()
{
    MatConstIterator::operator ++();
    return *this;
}

template<typename _Tp> inline
MatIterator_<_Tp> MatIterator_<_Tp>::operator ++(int)
{
    MatIterator_ b = *this;
    MatConstIterator::operator ++();
    return b;
}

template<typename _Tp> inline
_Tp& MatIterator_<_Tp>::operator [](ptrdiff_t i) const
{
    return *(*this + i);
}


template<typename _Tp> static inline
bool operator == (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
{
    return a.m == b.m && a.ptr == b.ptr;
}

template<typename _Tp> static inline
bool operator != (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
{
    return a.m != b.m || a.ptr != b.ptr;
}

template<typename _Tp> static inline
MatIterator_<_Tp> operator + (const MatIterator_<_Tp>& a, ptrdiff_t ofs)
{
    MatConstIterator t = (const MatConstIterator&)a + ofs;
    return (MatIterator_<_Tp>&)t;
}

template<typename _Tp> static inline
MatIterator_<_Tp> operator + (ptrdiff_t ofs, const MatIterator_<_Tp>& a)
{
    MatConstIterator t = (const MatConstIterator&)a + ofs;
    return (MatIterator_<_Tp>&)t;
}

template<typename _Tp> static inline
MatIterator_<_Tp> operator - (const MatIterator_<_Tp>& a, ptrdiff_t ofs)
{
    MatConstIterator t = (const MatConstIterator&)a - ofs;
    return (MatIterator_<_Tp>&)t;
}





inline
SparseMatConstIterator::SparseMatConstIterator()
    : m(0), hashidx(0), ptr(0)
{}

inline
SparseMatConstIterator::SparseMatConstIterator(const SparseMatConstIterator& it)
    : m(it.m), hashidx(it.hashidx), ptr(it.ptr)
{}

inline SparseMatConstIterator& SparseMatConstIterator::operator = (const SparseMatConstIterator& it)
{
    if( this != &it )
    {
        m = it.m;
        hashidx = it.hashidx;
        ptr = it.ptr;
    }
    return *this;
}

template<typename _Tp> inline
const _Tp& SparseMatConstIterator::value() const
{
    return *(const _Tp*)ptr;
}

inline
const SparseMat::Node* SparseMatConstIterator::node() const
{
    return (ptr && m && m->hdr) ? (const SparseMat::Node*)(const void*)(ptr - m->hdr->valueOffset) : 0;
}

inline
SparseMatConstIterator SparseMatConstIterator::operator ++(int)
{
    SparseMatConstIterator it = *this;
    ++*this;
    return it;
}

inline
void SparseMatConstIterator::seekEnd()
{
    if( m && m->hdr )
    {
        hashidx = m->hdr->hashtab.size();
        ptr = 0;
    }
}


static inline
bool operator == (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
{
    return it1.m == it2.m && it1.ptr == it2.ptr;
}

static inline
bool operator != (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
{
    return !(it1 == it2);
}





inline
SparseMatIterator::SparseMatIterator()
{}

inline
SparseMatIterator::SparseMatIterator(SparseMat* _m)
    : SparseMatConstIterator(_m)
{}

inline
SparseMatIterator::SparseMatIterator(const SparseMatIterator& it)
    : SparseMatConstIterator(it)
{}

inline
SparseMatIterator& SparseMatIterator::operator = (const SparseMatIterator& it)
{
    (SparseMatConstIterator&)*this = it;
    return *this;
}

template<typename _Tp> inline
_Tp& SparseMatIterator::value() const
{
    return *(_Tp*)ptr;
}

inline
SparseMat::Node* SparseMatIterator::node() const
{
    return (SparseMat::Node*)SparseMatConstIterator::node();
}

inline
SparseMatIterator& SparseMatIterator::operator ++()
{
    SparseMatConstIterator::operator ++();
    return *this;
}

inline
SparseMatIterator SparseMatIterator::operator ++(int)
{
    SparseMatIterator it = *this;
    ++*this;
    return it;
}





template<typename _Tp> inline
SparseMatConstIterator_<_Tp>::SparseMatConstIterator_()
{}

template<typename _Tp> inline
SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMat_<_Tp>* _m)
    : SparseMatConstIterator(_m)
{}

template<typename _Tp> inline
SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMat* _m)
    : SparseMatConstIterator(_m)
{
    if(!!(_m->type() == DataType<_Tp>::type)) ; else cv::error( cv::Error::StsAssert, "_m->type() == DataType<_Tp>::type",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 3131 );
}

template<typename _Tp> inline
SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMatConstIterator_<_Tp>& it)
    : SparseMatConstIterator(it)
{}

template<typename _Tp> inline
SparseMatConstIterator_<_Tp>& SparseMatConstIterator_<_Tp>::operator = (const SparseMatConstIterator_<_Tp>& it)
{
    return reinterpret_cast<SparseMatConstIterator_<_Tp>&>
         (*reinterpret_cast<SparseMatConstIterator*>(this) =
           reinterpret_cast<const SparseMatConstIterator&>(it));
}

template<typename _Tp> inline
const _Tp& SparseMatConstIterator_<_Tp>::operator *() const
{
    return *(const _Tp*)this->ptr;
}

template<typename _Tp> inline
SparseMatConstIterator_<_Tp>& SparseMatConstIterator_<_Tp>::operator ++()
{
    SparseMatConstIterator::operator ++();
    return *this;
}

template<typename _Tp> inline
SparseMatConstIterator_<_Tp> SparseMatConstIterator_<_Tp>::operator ++(int)
{
    SparseMatConstIterator_<_Tp> it = *this;
    SparseMatConstIterator::operator ++();
    return it;
}





template<typename _Tp> inline
SparseMatIterator_<_Tp>::SparseMatIterator_()
{}

template<typename _Tp> inline
SparseMatIterator_<_Tp>::SparseMatIterator_(SparseMat_<_Tp>* _m)
    : SparseMatConstIterator_<_Tp>(_m)
{}

template<typename _Tp> inline
SparseMatIterator_<_Tp>::SparseMatIterator_(SparseMat* _m)
    : SparseMatConstIterator_<_Tp>(_m)
{}

template<typename _Tp> inline
SparseMatIterator_<_Tp>::SparseMatIterator_(const SparseMatIterator_<_Tp>& it)
    : SparseMatConstIterator_<_Tp>(it)
{}

template<typename _Tp> inline
SparseMatIterator_<_Tp>& SparseMatIterator_<_Tp>::operator = (const SparseMatIterator_<_Tp>& it)
{
    return reinterpret_cast<SparseMatIterator_<_Tp>&>
         (*reinterpret_cast<SparseMatConstIterator*>(this) =
           reinterpret_cast<const SparseMatConstIterator&>(it));
}

template<typename _Tp> inline
_Tp& SparseMatIterator_<_Tp>::operator *() const
{
    return *(_Tp*)this->ptr;
}

template<typename _Tp> inline
SparseMatIterator_<_Tp>& SparseMatIterator_<_Tp>::operator ++()
{
    SparseMatConstIterator::operator ++();
    return *this;
}

template<typename _Tp> inline
SparseMatIterator_<_Tp> SparseMatIterator_<_Tp>::operator ++(int)
{
    SparseMatIterator_<_Tp> it = *this;
    SparseMatConstIterator::operator ++();
    return it;
}





template<typename _Tp> inline
MatCommaInitializer_<_Tp>::MatCommaInitializer_(Mat_<_Tp>* _m)
    : it(_m)
{}

template<typename _Tp> template<typename T2> inline
MatCommaInitializer_<_Tp>& MatCommaInitializer_<_Tp>::operator , (T2 v)
{
    ;
    *this->it = _Tp(v);
    ++this->it;
    return *this;
}

template<typename _Tp> inline
MatCommaInitializer_<_Tp>::operator Mat_<_Tp>() const
{
    ;
    return Mat_<_Tp>(*this->it.m);
}


template<typename _Tp, typename T2> static inline
MatCommaInitializer_<_Tp> operator << (const Mat_<_Tp>& m, T2 val)
{
    MatCommaInitializer_<_Tp> commaInitializer((Mat_<_Tp>*)&m);
    return (commaInitializer, val);
}





inline
Mat& Mat::operator = (const MatExpr& e)
{
    e.op->assign(e, *this);
    return *this;
}

template<typename _Tp> inline
Mat_<_Tp>::Mat_(const MatExpr& e)
{
    e.op->assign(e, *this, DataType<_Tp>::type);
}

template<typename _Tp> inline
Mat_<_Tp>& Mat_<_Tp>::operator = (const MatExpr& e)
{
    e.op->assign(e, *this, DataType<_Tp>::type);
    return *this;
}

template<typename _Tp> inline
MatExpr Mat_<_Tp>::zeros(int rows, int cols)
{
    return Mat::zeros(rows, cols, DataType<_Tp>::type);
}

template<typename _Tp> inline
MatExpr Mat_<_Tp>::zeros(Size sz)
{
    return Mat::zeros(sz, DataType<_Tp>::type);
}

template<typename _Tp> inline
MatExpr Mat_<_Tp>::ones(int rows, int cols)
{
    return Mat::ones(rows, cols, DataType<_Tp>::type);
}

template<typename _Tp> inline
MatExpr Mat_<_Tp>::ones(Size sz)
{
    return Mat::ones(sz, DataType<_Tp>::type);
}

template<typename _Tp> inline
MatExpr Mat_<_Tp>::eye(int rows, int cols)
{
    return Mat::eye(rows, cols, DataType<_Tp>::type);
}

template<typename _Tp> inline
MatExpr Mat_<_Tp>::eye(Size sz)
{
    return Mat::eye(sz, DataType<_Tp>::type);
}

inline
MatExpr::MatExpr()
    : op(0), flags(0), a(Mat()), b(Mat()), c(Mat()), alpha(0), beta(0), s()
{}

inline
MatExpr::MatExpr(const MatOp* _op, int _flags, const Mat& _a, const Mat& _b,
                 const Mat& _c, double _alpha, double _beta, const Scalar& _s)
    : op(_op), flags(_flags), a(_a), b(_b), c(_c), alpha(_alpha), beta(_beta), s(_s)
{}

inline
MatExpr::operator Mat() const
{
    Mat m;
    op->assign(*this, m);
    return m;
}

template<typename _Tp> inline
MatExpr::operator Mat_<_Tp>() const
{
    Mat_<_Tp> m;
    op->assign(*this, m, DataType<_Tp>::type);
    return m;
}


template<typename _Tp> static inline
MatExpr min(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
{
    return cv::min((const Mat&)a, (const Mat&)b);
}

template<typename _Tp> static inline
MatExpr min(const Mat_<_Tp>& a, double s)
{
    return cv::min((const Mat&)a, s);
}

template<typename _Tp> static inline
MatExpr min(double s, const Mat_<_Tp>& a)
{
    return cv::min((const Mat&)a, s);
}

template<typename _Tp> static inline
MatExpr max(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
{
    return cv::max((const Mat&)a, (const Mat&)b);
}

template<typename _Tp> static inline
MatExpr max(const Mat_<_Tp>& a, double s)
{
    return cv::max((const Mat&)a, s);
}

template<typename _Tp> static inline
MatExpr max(double s, const Mat_<_Tp>& a)
{
    return cv::max((const Mat&)a, s);
}

template<typename _Tp> static inline
MatExpr abs(const Mat_<_Tp>& m)
{
    return cv::abs((const Mat&)m);
}


static inline
Mat& operator += (Mat& a, const MatExpr& b)
{
    b.op->augAssignAdd(b, a);
    return a;
}

static inline
const Mat& operator += (const Mat& a, const MatExpr& b)
{
    b.op->augAssignAdd(b, (Mat&)a);
    return a;
}

template<typename _Tp> static inline
Mat_<_Tp>& operator += (Mat_<_Tp>& a, const MatExpr& b)
{
    b.op->augAssignAdd(b, a);
    return a;
}

template<typename _Tp> static inline
const Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const MatExpr& b)
{
    b.op->augAssignAdd(b, (Mat&)a);
    return a;
}

static inline
Mat& operator -= (Mat& a, const MatExpr& b)
{
    b.op->augAssignSubtract(b, a);
    return a;
}

static inline
const Mat& operator -= (const Mat& a, const MatExpr& b)
{
    b.op->augAssignSubtract(b, (Mat&)a);
    return a;
}

template<typename _Tp> static inline
Mat_<_Tp>& operator -= (Mat_<_Tp>& a, const MatExpr& b)
{
    b.op->augAssignSubtract(b, a);
    return a;
}

template<typename _Tp> static inline
const Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const MatExpr& b)
{
    b.op->augAssignSubtract(b, (Mat&)a);
    return a;
}

static inline
Mat& operator *= (Mat& a, const MatExpr& b)
{
    b.op->augAssignMultiply(b, a);
    return a;
}

static inline
const Mat& operator *= (const Mat& a, const MatExpr& b)
{
    b.op->augAssignMultiply(b, (Mat&)a);
    return a;
}

template<typename _Tp> static inline
Mat_<_Tp>& operator *= (Mat_<_Tp>& a, const MatExpr& b)
{
    b.op->augAssignMultiply(b, a);
    return a;
}

template<typename _Tp> static inline
const Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const MatExpr& b)
{
    b.op->augAssignMultiply(b, (Mat&)a);
    return a;
}

static inline
Mat& operator /= (Mat& a, const MatExpr& b)
{
    b.op->augAssignDivide(b, a);
    return a;
}

static inline
const Mat& operator /= (const Mat& a, const MatExpr& b)
{
    b.op->augAssignDivide(b, (Mat&)a);
    return a;
}

template<typename _Tp> static inline
Mat_<_Tp>& operator /= (Mat_<_Tp>& a, const MatExpr& b)
{
    b.op->augAssignDivide(b, a);
    return a;
}

template<typename _Tp> static inline
const Mat_<_Tp>& operator /= (const Mat_<_Tp>& a, const MatExpr& b)
{
    b.op->augAssignDivide(b, (Mat&)a);
    return a;
}




inline
UMat::UMat(UMatUsageFlags _usageFlags)
: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
{}

inline
UMat::UMat(int _rows, int _cols, int _type, UMatUsageFlags _usageFlags)
: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
{
    create(_rows, _cols, _type);
}

inline
UMat::UMat(int _rows, int _cols, int _type, const Scalar& _s, UMatUsageFlags _usageFlags)
: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
{
    create(_rows, _cols, _type);
    *this = _s;
}

inline
UMat::UMat(Size _sz, int _type, UMatUsageFlags _usageFlags)
: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
{
    create( _sz.height, _sz.width, _type );
}

inline
UMat::UMat(Size _sz, int _type, const Scalar& _s, UMatUsageFlags _usageFlags)
: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
{
    create(_sz.height, _sz.width, _type);
    *this = _s;
}

inline
UMat::UMat(int _dims, const int* _sz, int _type, UMatUsageFlags _usageFlags)
: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
{
    create(_dims, _sz, _type);
}

inline
UMat::UMat(int _dims, const int* _sz, int _type, const Scalar& _s, UMatUsageFlags _usageFlags)
: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
{
    create(_dims, _sz, _type);
    *this = _s;
}

inline
UMat::UMat(const UMat& m)
: flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), allocator(m.allocator),
  usageFlags(m.usageFlags), u(m.u), offset(m.offset), size(&rows)
{
    addref();
    if( m.dims <= 2 )
    {
        step[0] = m.step[0]; step[1] = m.step[1];
    }
    else
    {
        dims = 0;
        copySize(m);
    }
}


template<typename _Tp> inline
UMat::UMat(const std::vector<_Tp>& vec, bool copyData)
: flags(MAGIC_VAL | DataType<_Tp>::type | (1 << 14)), dims(2), rows((int)vec.size()),
cols(1), allocator(0), usageFlags(USAGE_DEFAULT), u(0), offset(0), size(&rows)
{
    if(vec.empty())
        return;
    if( !copyData )
    {
        
        cv::error( Error::StsNotImplemented, "",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp", 3577 );
    }
    else
        Mat((int)vec.size(), 1, DataType<_Tp>::type, (uchar*)&vec[0]).copyTo(*this);
}

inline
UMat& UMat::operator = (const UMat& m)
{
    if( this != &m )
    {
        const_cast<UMat&>(m).addref();
        release();
        flags = m.flags;
        if( dims <= 2 && m.dims <= 2 )
        {
            dims = m.dims;
            rows = m.rows;
            cols = m.cols;
            step[0] = m.step[0];
            step[1] = m.step[1];
        }
        else
            copySize(m);
        allocator = m.allocator;
        if (usageFlags == USAGE_DEFAULT)
            usageFlags = m.usageFlags;
        u = m.u;
        offset = m.offset;
    }
    return *this;
}

inline
UMat UMat::row(int y) const
{
    return UMat(*this, Range(y, y + 1), Range::all());
}

inline
UMat UMat::col(int x) const
{
    return UMat(*this, Range::all(), Range(x, x + 1));
}

inline
UMat UMat::rowRange(int startrow, int endrow) const
{
    return UMat(*this, Range(startrow, endrow), Range::all());
}

inline
UMat UMat::rowRange(const Range& r) const
{
    return UMat(*this, r, Range::all());
}

inline
UMat UMat::colRange(int startcol, int endcol) const
{
    return UMat(*this, Range::all(), Range(startcol, endcol));
}

inline
UMat UMat::colRange(const Range& r) const
{
    return UMat(*this, Range::all(), r);
}

inline
UMat UMat::clone() const
{
    UMat m;
    copyTo(m);
    return m;
}

inline
void UMat::assignTo( UMat& m, int _type ) const
{
    if( _type < 0 )
        m = *this;
    else
        convertTo(m, _type);
}

inline
void UMat::create(int _rows, int _cols, int _type, UMatUsageFlags _usageFlags)
{
    _type &= TYPE_MASK;
    if( dims <= 2 && rows == _rows && cols == _cols && type() == _type && u )
        return;
    int sz[] = {_rows, _cols};
    create(2, sz, _type, _usageFlags);
}

inline
void UMat::create(Size _sz, int _type, UMatUsageFlags _usageFlags)
{
    create(_sz.height, _sz.width, _type, _usageFlags);
}

inline
void UMat::addref()
{
    if( u )
        (int)_InterlockedExchangeAdd((long volatile*)&(u->urefcount), 1);
}

inline void UMat::release()
{
    if( u && (int)_InterlockedExchangeAdd((long volatile*)&(u->urefcount), -1) == 1 )
        deallocate();
    for(int i = 0; i < dims; i++)
        size.p[i] = 0;
    u = 0;
}

inline
UMat UMat::operator()( Range _rowRange, Range _colRange ) const
{
    return UMat(*this, _rowRange, _colRange);
}

inline
UMat UMat::operator()( const Rect& roi ) const
{
    return UMat(*this, roi);
}

inline
UMat UMat::operator()(const Range* ranges) const
{
    return UMat(*this, ranges);
}

inline
UMat UMat::operator()(const std::vector<Range>& ranges) const
{
    return UMat(*this, ranges);
}

inline
bool UMat::isContinuous() const
{
    return (flags & CONTINUOUS_FLAG) != 0;
}

inline
bool UMat::isSubmatrix() const
{
    return (flags & SUBMATRIX_FLAG) != 0;
}

inline
size_t UMat::elemSize() const
{
    return dims > 0 ? step.p[dims - 1] : 0;
}

inline
size_t UMat::elemSize1() const
{
    return ((((sizeof(size_t)<<28)|0x8442211) >> ((flags) & ((1 << 3) - 1))*4) & 15);
}

inline
int UMat::type() const
{
    return ((flags) & ((1 << 3)*512 - 1));
}

inline
int UMat::depth() const
{
    return ((flags) & ((1 << 3) - 1));
}

inline
int UMat::channels() const
{
    return ((((flags) & ((512 - 1) << 3)) >> 3) + 1);
}

inline
size_t UMat::step1(int i) const
{
    return step.p[i] / elemSize1();
}

inline
bool UMat::empty() const
{
    return u == 0 || total() == 0 || dims == 0;
}

inline
size_t UMat::total() const
{
    if( dims <= 2 )
        return (size_t)rows * cols;
    size_t p = 1;
    for( int i = 0; i < dims; i++ )
        p *= size[i];
    return p;
}



inline
UMat::UMat(UMat&& m)
: flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), allocator(m.allocator),
  usageFlags(m.usageFlags), u(m.u), offset(m.offset), size(&rows)
{
    if (m.dims <= 2)  
    {
        step[0] = m.step[0];
        step[1] = m.step[1];
    }
    else
    {
        ;
        step.p = m.step.p;
        size.p = m.size.p;
        m.step.p = m.step.buf;
        m.size.p = &m.rows;
    }
    m.flags = MAGIC_VAL; m.dims = m.rows = m.cols = 0;
    m.allocator = 0;
    m.u = 0;
    m.offset = 0;
}

inline
UMat& UMat::operator = (UMat&& m)
{
    if (this == &m)
      return *this;
    release();
    flags = m.flags; dims = m.dims; rows = m.rows; cols = m.cols;
    allocator = m.allocator; usageFlags = m.usageFlags;
    u = m.u;
    offset = m.offset;
    if (step.p != step.buf) 
    {
        fastFree(step.p);
        step.p = step.buf;
        size.p = &rows;
    }
    if (m.dims <= 2) 
    {
        step[0] = m.step[0];
        step[1] = m.step[1];
    }
    else
    {
        ;
        step.p = m.step.p;
        size.p = m.size.p;
        m.step.p = m.step.buf;
        m.size.p = &m.rows;
    }
    m.flags = MAGIC_VAL; m.dims = m.rows = m.cols = 0;
    m.allocator = 0;
    m.u = 0;
    m.offset = 0;
    return *this;
}

#line 3847 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp"


inline bool UMatData::hostCopyObsolete() const { return (flags & HOST_COPY_OBSOLETE) != 0; }
inline bool UMatData::deviceCopyObsolete() const { return (flags & DEVICE_COPY_OBSOLETE) != 0; }
inline bool UMatData::deviceMemMapped() const { return (flags & DEVICE_MEM_MAPPED) != 0; }
inline bool UMatData::copyOnMap() const { return (flags & COPY_ON_MAP) != 0; }
inline bool UMatData::tempUMat() const { return (flags & TEMP_UMAT) != 0; }
inline bool UMatData::tempCopiedUMat() const { return (flags & TEMP_COPIED_UMAT) == TEMP_COPIED_UMAT; }

inline void UMatData::markDeviceMemMapped(bool flag)
{
  if(flag)
    flags |= DEVICE_MEM_MAPPED;
  else
    flags &= ~DEVICE_MEM_MAPPED;
}

inline void UMatData::markHostCopyObsolete(bool flag)
{
    if(flag)
        flags |= HOST_COPY_OBSOLETE;
    else
        flags &= ~HOST_COPY_OBSOLETE;
}
inline void UMatData::markDeviceCopyObsolete(bool flag)
{
    if(flag)
        flags |= DEVICE_COPY_OBSOLETE;
    else
        flags &= ~DEVICE_COPY_OBSOLETE;
}

inline UMatDataAutoLock::UMatDataAutoLock(UMatData* _u) : u(_u) { u->lock(); }
inline UMatDataAutoLock::~UMatDataAutoLock() { u->unlock(); }



} 


#pragma warning( pop )
#line 3889 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp"

#line 3891 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.inl.hpp"

#line 3629 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.hpp"

#line 3631 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.hpp"

#line 60 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/persistence.hpp"



























































































typedef struct CvFileStorage CvFileStorage;
typedef struct CvFileNode CvFileNode;
typedef struct CvMat CvMat;
typedef struct CvMatND CvMatND;



#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types.hpp"






















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 100 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/persistence.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/mat.hpp"















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 101 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/persistence.hpp"

namespace cv {

































































































































































































class  FileNode;
class  FileNodeIterator;




class  FileStorage
{
public:
    
    enum Mode
    {
        READ        = 0, 
        WRITE       = 1, 
        APPEND      = 2, 
        MEMORY      = 4, 
                         
        FORMAT_MASK = (7<<3), 
        FORMAT_AUTO = 0,      
        FORMAT_XML  = (1<<3), 
        FORMAT_YAML = (2<<3), 
        FORMAT_JSON = (3<<3), 

        BASE64      = 64,     
        WRITE_BASE64 = BASE64 | WRITE, 
    };
    enum
    {
        UNDEFINED      = 0,
        VALUE_EXPECTED = 1,
        NAME_EXPECTED  = 2,
        INSIDE_MAP     = 4
    };

    




     FileStorage();

    









     FileStorage(const String& source, int flags, const String& encoding=String());

    
    FileStorage(CvFileStorage* fs, bool owning=true);

    
    virtual ~FileStorage();

    














     virtual bool open(const String& filename, int flags, const String& encoding=String());

    




     virtual bool isOpened() const;

    



     virtual void release();

    




     virtual String releaseAndGetString();

    


     FileNode getFirstTopLevelNode() const;

    




     FileNode root(int streamidx=0) const;

    



    FileNode operator[](const String& nodename) const;

    
     FileNode operator[](const char* nodename) const;

    


    CvFileStorage* operator *() { return fs.get(); }

    
    const CvFileStorage* operator *() const { return fs.get(); }

    







    void writeRaw( const String& fmt, const uchar* vec, size_t len );

    




    void writeObj( const String& name, const void* obj );

    




     void write(const String& name, double val);
    
     void write(const String& name, const String& val);
    
     void write(const String& name, InputArray val);

    







     void writeComment(const String& comment, bool append = false);

    



    static String getDefaultObjectName(const String& filename);

    


     int getFormat() const;

    Ptr<CvFileStorage> fs; 
    String elname; 
    std::vector<char> structs; 
    int state; 
};

template<>  void DefaultDeleter<CvFileStorage>::operator ()(CvFileStorage* obj) const;













class  FileNode
{
public:
    
    enum Type
    {
        NONE      = 0, 
        INT       = 1, 
        REAL      = 2, 
        FLOAT     = REAL, 
        STR       = 3, 
        STRING    = STR, 
        REF       = 4, 
        SEQ       = 5, 
        MAP       = 6, 
        TYPE_MASK = 7,
        FLOW      = 8,  
        USER      = 16, 
        EMPTY     = 32, 
        NAMED     = 64  
    };
    




     FileNode();

    



    FileNode(const CvFileStorage* fs, const CvFileNode* node);

    


    FileNode(const FileNode& node);

    



    FileNode operator[](const String& nodename) const;

    


     FileNode operator[](const char* nodename) const;

    


     FileNode operator[](int i) const;

    


     int type() const;

    
     bool empty() const;
    
     bool isNone() const;
    
     bool isSeq() const;
    
     bool isMap() const;
    
     bool isInt() const;
    
     bool isReal() const;
    
     bool isString() const;
    
     bool isNamed() const;
    
     String name() const;
    
     size_t size() const;
    
    operator int() const;
    
    operator float() const;
    
    operator double() const;
    
    operator String() const;
    operator std::string() const;

    
    CvFileNode* operator *();
    
    const CvFileNode* operator* () const;

    
    FileNodeIterator begin() const;
    
    FileNodeIterator end() const;

    







    void readRaw( const String& fmt, uchar* vec, size_t len ) const;

    
    void* readObj() const;

    
     double real() const;
    
     String string() const;
    
     Mat mat() const;

    
    const CvFileStorage* fs;
    const CvFileNode* node;
};







class  FileNodeIterator
{
public:
    




    FileNodeIterator();

    




    FileNodeIterator(const CvFileStorage* fs, const CvFileNode* node, size_t ofs=0);

    


    FileNodeIterator(const FileNodeIterator& it);

    
    FileNode operator *() const;
    
    FileNode operator ->() const;

    
    FileNodeIterator& operator ++ ();
    
    FileNodeIterator operator ++ (int);
    
    FileNodeIterator& operator -- ();
    
    FileNodeIterator operator -- (int);
    
    FileNodeIterator& operator += (int ofs);
    
    FileNodeIterator& operator -= (int ofs);

    







    FileNodeIterator& readRaw( const String& fmt, uchar* vec,
                               size_t maxCount=(size_t)2147483647 );

    struct SeqReader
    {
      int          header_size;
      void*        seq;        
      void*        block;      
      schar*       ptr;        
      schar*       block_min;  
      schar*       block_max;  
      int          delta_index;
      schar*       prev_elem;  
    };

    const CvFileStorage* fs;
    const CvFileNode* container;
    SeqReader reader;
    size_t remaining;
};








 void write( FileStorage& fs, const String& name, int value );
 void write( FileStorage& fs, const String& name, float value );
 void write( FileStorage& fs, const String& name, double value );
 void write( FileStorage& fs, const String& name, const String& value );
 void write( FileStorage& fs, const String& name, const Mat& value );
 void write( FileStorage& fs, const String& name, const SparseMat& value );
 void write( FileStorage& fs, const String& name, const std::vector<KeyPoint>& value);
 void write( FileStorage& fs, const String& name, const std::vector<DMatch>& value);

 void writeScalar( FileStorage& fs, int value );
 void writeScalar( FileStorage& fs, float value );
 void writeScalar( FileStorage& fs, double value );
 void writeScalar( FileStorage& fs, const String& value );






 void read(const FileNode& node, int& value, int default_value);
 void read(const FileNode& node, float& value, float default_value);
 void read(const FileNode& node, double& value, double default_value);
 void read(const FileNode& node, String& value, const String& default_value);
 void read(const FileNode& node, std::string& value, const std::string& default_value);
 void read(const FileNode& node, Mat& mat, const Mat& default_mat = Mat() );
 void read(const FileNode& node, SparseMat& mat, const SparseMat& default_mat = SparseMat() );
 void read(const FileNode& node, std::vector<KeyPoint>& keypoints);
 void read(const FileNode& node, std::vector<DMatch>& matches);

template<typename _Tp> static inline void read(const FileNode& node, Point_<_Tp>& value, const Point_<_Tp>& default_value)
{
    std::vector<_Tp> temp; FileNodeIterator it = node.begin(); it >> temp;
    value = temp.size() != 2 ? default_value : Point_<_Tp>(saturate_cast<_Tp>(temp[0]), saturate_cast<_Tp>(temp[1]));
}

template<typename _Tp> static inline void read(const FileNode& node, Point3_<_Tp>& value, const Point3_<_Tp>& default_value)
{
    std::vector<_Tp> temp; FileNodeIterator it = node.begin(); it >> temp;
    value = temp.size() != 3 ? default_value : Point3_<_Tp>(saturate_cast<_Tp>(temp[0]), saturate_cast<_Tp>(temp[1]),
                                                            saturate_cast<_Tp>(temp[2]));
}

template<typename _Tp> static inline void read(const FileNode& node, Size_<_Tp>& value, const Size_<_Tp>& default_value)
{
    std::vector<_Tp> temp; FileNodeIterator it = node.begin(); it >> temp;
    value = temp.size() != 2 ? default_value : Size_<_Tp>(saturate_cast<_Tp>(temp[0]), saturate_cast<_Tp>(temp[1]));
}

template<typename _Tp> static inline void read(const FileNode& node, Complex<_Tp>& value, const Complex<_Tp>& default_value)
{
    std::vector<_Tp> temp; FileNodeIterator it = node.begin(); it >> temp;
    value = temp.size() != 2 ? default_value : Complex<_Tp>(saturate_cast<_Tp>(temp[0]), saturate_cast<_Tp>(temp[1]));
}

template<typename _Tp> static inline void read(const FileNode& node, Rect_<_Tp>& value, const Rect_<_Tp>& default_value)
{
    std::vector<_Tp> temp; FileNodeIterator it = node.begin(); it >> temp;
    value = temp.size() != 4 ? default_value : Rect_<_Tp>(saturate_cast<_Tp>(temp[0]), saturate_cast<_Tp>(temp[1]),
                                                          saturate_cast<_Tp>(temp[2]), saturate_cast<_Tp>(temp[3]));
}

template<typename _Tp, int cn> static inline void read(const FileNode& node, Vec<_Tp, cn>& value, const Vec<_Tp, cn>& default_value)
{
    std::vector<_Tp> temp; FileNodeIterator it = node.begin(); it >> temp;
    value = temp.size() != cn ? default_value : Vec<_Tp, cn>(&temp[0]);
}

template<typename _Tp> static inline void read(const FileNode& node, Scalar_<_Tp>& value, const Scalar_<_Tp>& default_value)
{
    std::vector<_Tp> temp; FileNodeIterator it = node.begin(); it >> temp;
    value = temp.size() != 4 ? default_value : Scalar_<_Tp>(saturate_cast<_Tp>(temp[0]), saturate_cast<_Tp>(temp[1]),
                                                            saturate_cast<_Tp>(temp[2]), saturate_cast<_Tp>(temp[3]));
}

static inline void read(const FileNode& node, Range& value, const Range& default_value)
{
    Point2i temp(value.start, value.end); const Point2i default_temp = Point2i(default_value.start, default_value.end);
    read(node, temp, default_temp);
    value.start = temp.x; value.end = temp.y;
}






 FileStorage& operator << (FileStorage& fs, const String& str);



namespace internal
{
    class  WriteStructContext
    {
    public:
        WriteStructContext(FileStorage& _fs, const String& name, int flags, const String& typeName = String());
        ~WriteStructContext();
    private:
        FileStorage* fs;
    };

    template<typename _Tp, int numflag> class VecWriterProxy
    {
    public:
        VecWriterProxy( FileStorage* _fs ) : fs(_fs) {}
        void operator()(const std::vector<_Tp>& vec) const
        {
            size_t count = vec.size();
            for (size_t i = 0; i < count; i++)
                write(*fs, vec[i]);
        }
    private:
        FileStorage* fs;
    };

    template<typename _Tp> class VecWriterProxy<_Tp, 1>
    {
    public:
        VecWriterProxy( FileStorage* _fs ) : fs(_fs) {}
        void operator()(const std::vector<_Tp>& vec) const
        {
            int _fmt = DataType<_Tp>::fmt;
            char fmt[] = { (char)((_fmt >> 8) + '1'), (char)_fmt, '\0' };
            fs->writeRaw(fmt, !vec.empty() ? (uchar*)&vec[0] : 0, vec.size() * sizeof(_Tp));
        }
    private:
        FileStorage* fs;
    };

    template<typename _Tp, int numflag> class VecReaderProxy
    {
    public:
        VecReaderProxy( FileNodeIterator* _it ) : it(_it) {}
        void operator()(std::vector<_Tp>& vec, size_t count) const
        {
            count = std::min(count, it->remaining);
            vec.resize(count);
            for (size_t i = 0; i < count; i++, ++(*it))
                read(**it, vec[i], _Tp());
        }
    private:
        FileNodeIterator* it;
    };

    template<typename _Tp> class VecReaderProxy<_Tp, 1>
    {
    public:
        VecReaderProxy( FileNodeIterator* _it ) : it(_it) {}
        void operator()(std::vector<_Tp>& vec, size_t count) const
        {
            size_t remaining = it->remaining;
            size_t cn = DataType<_Tp>::channels;
            int _fmt = DataType<_Tp>::fmt;
            char fmt[] = { (char)((_fmt >> 8)+'1'), (char)_fmt, '\0' };
            size_t remaining1 = remaining / cn;
            count = count < remaining1 ? count : remaining1;
            vec.resize(count);
            it->readRaw(fmt, !vec.empty() ? (uchar*)&vec[0] : 0, count*sizeof(_Tp));
        }
    private:
        FileNodeIterator* it;
    };

} 






template<typename _Tp> static inline
void write(FileStorage& fs, const _Tp& value)
{
    write(fs, String(), value);
}

template<> inline
void write( FileStorage& fs, const int& value )
{
    writeScalar(fs, value);
}

template<> inline
void write( FileStorage& fs, const float& value )
{
    writeScalar(fs, value);
}

template<> inline
void write( FileStorage& fs, const double& value )
{
    writeScalar(fs, value);
}

template<> inline
void write( FileStorage& fs, const String& value )
{
    writeScalar(fs, value);
}

template<typename _Tp> static inline
void write(FileStorage& fs, const Point_<_Tp>& pt )
{
    write(fs, pt.x);
    write(fs, pt.y);
}

template<typename _Tp> static inline
void write(FileStorage& fs, const Point3_<_Tp>& pt )
{
    write(fs, pt.x);
    write(fs, pt.y);
    write(fs, pt.z);
}

template<typename _Tp> static inline
void write(FileStorage& fs, const Size_<_Tp>& sz )
{
    write(fs, sz.width);
    write(fs, sz.height);
}

template<typename _Tp> static inline
void write(FileStorage& fs, const Complex<_Tp>& c )
{
    write(fs, c.re);
    write(fs, c.im);
}

template<typename _Tp> static inline
void write(FileStorage& fs, const Rect_<_Tp>& r )
{
    write(fs, r.x);
    write(fs, r.y);
    write(fs, r.width);
    write(fs, r.height);
}

template<typename _Tp, int cn> static inline
void write(FileStorage& fs, const Vec<_Tp, cn>& v )
{
    for(int i = 0; i < cn; i++)
        write(fs, v.val[i]);
}

template<typename _Tp> static inline
void write(FileStorage& fs, const Scalar_<_Tp>& s )
{
    write(fs, s.val[0]);
    write(fs, s.val[1]);
    write(fs, s.val[2]);
    write(fs, s.val[3]);
}

static inline
void write(FileStorage& fs, const KeyPoint& kpt )
{
    write(fs, kpt.pt.x);
    write(fs, kpt.pt.y);
    write(fs, kpt.size);
    write(fs, kpt.angle);
    write(fs, kpt.response);
    write(fs, kpt.octave);
    write(fs, kpt.class_id);
}

static inline
void write(FileStorage& fs, const DMatch& m )
{
    write(fs, m.queryIdx);
    write(fs, m.trainIdx);
    write(fs, m.imgIdx);
    write(fs, m.distance);
}

static inline
void write(FileStorage& fs, const Range& r )
{
    write(fs, r.start);
    write(fs, r.end);
}

static inline
void write( FileStorage& fs, const std::vector<KeyPoint>& vec )
{
    size_t npoints = vec.size();
    for(size_t i = 0; i < npoints; i++ )
    {
        write(fs, vec[i]);
    }
}

static inline
void write( FileStorage& fs, const std::vector<DMatch>& vec )
{
    size_t npoints = vec.size();
    for(size_t i = 0; i < npoints; i++ )
    {
        write(fs, vec[i]);
    }
}

template<typename _Tp> static inline
void write( FileStorage& fs, const std::vector<_Tp>& vec )
{
    cv::internal::VecWriterProxy<_Tp, DataType<_Tp>::fmt != 0> w(&fs);
    w(vec);
}

template<typename _Tp> static inline
void write(FileStorage& fs, const String& name, const Point_<_Tp>& pt )
{
    cv::internal::WriteStructContext ws(fs, name, FileNode::SEQ+FileNode::FLOW);
    write(fs, pt);
}

template<typename _Tp> static inline
void write(FileStorage& fs, const String& name, const Point3_<_Tp>& pt )
{
    cv::internal::WriteStructContext ws(fs, name, FileNode::SEQ+FileNode::FLOW);
    write(fs, pt);
}

template<typename _Tp> static inline
void write(FileStorage& fs, const String& name, const Size_<_Tp>& sz )
{
    cv::internal::WriteStructContext ws(fs, name, FileNode::SEQ+FileNode::FLOW);
    write(fs, sz);
}

template<typename _Tp> static inline
void write(FileStorage& fs, const String& name, const Complex<_Tp>& c )
{
    cv::internal::WriteStructContext ws(fs, name, FileNode::SEQ+FileNode::FLOW);
    write(fs, c);
}

template<typename _Tp> static inline
void write(FileStorage& fs, const String& name, const Rect_<_Tp>& r )
{
    cv::internal::WriteStructContext ws(fs, name, FileNode::SEQ+FileNode::FLOW);
    write(fs, r);
}

template<typename _Tp, int cn> static inline
void write(FileStorage& fs, const String& name, const Vec<_Tp, cn>& v )
{
    cv::internal::WriteStructContext ws(fs, name, FileNode::SEQ+FileNode::FLOW);
    write(fs, v);
}

template<typename _Tp> static inline
void write(FileStorage& fs, const String& name, const Scalar_<_Tp>& s )
{
    cv::internal::WriteStructContext ws(fs, name, FileNode::SEQ+FileNode::FLOW);
    write(fs, s);
}

static inline
void write(FileStorage& fs, const String& name, const Range& r )
{
    cv::internal::WriteStructContext ws(fs, name, FileNode::SEQ+FileNode::FLOW);
    write(fs, r);
}

static inline
void write(FileStorage& fs, const String& name, const KeyPoint& r )
{
    cv::internal::WriteStructContext ws(fs, name, FileNode::SEQ+FileNode::FLOW);
    write(fs, r);
}

static inline
void write(FileStorage& fs, const String& name, const DMatch& r )
{
    cv::internal::WriteStructContext ws(fs, name, FileNode::SEQ+FileNode::FLOW);
    write(fs, r);
}

template<typename _Tp> static inline
void write( FileStorage& fs, const String& name, const std::vector<_Tp>& vec )
{
    cv::internal::WriteStructContext ws(fs, name, FileNode::SEQ+(DataType<_Tp>::fmt != 0 ? FileNode::FLOW : 0));
    write(fs, vec);
}

template<typename _Tp> static inline
void write( FileStorage& fs, const String& name, const std::vector< std::vector<_Tp> >& vec )
{
    cv::internal::WriteStructContext ws(fs, name, FileNode::SEQ);
    for(size_t i = 0; i < vec.size(); i++)
    {
        cv::internal::WriteStructContext ws_(fs, name, FileNode::SEQ+(DataType<_Tp>::fmt != 0 ? FileNode::FLOW : 0));
        write(fs, vec[i]);
    }
}






static inline
void read(const FileNode& node, bool& value, bool default_value)
{
    int temp;
    read(node, temp, (int)default_value);
    value = temp != 0;
}

static inline
void read(const FileNode& node, uchar& value, uchar default_value)
{
    int temp;
    read(node, temp, (int)default_value);
    value = saturate_cast<uchar>(temp);
}

static inline
void read(const FileNode& node, schar& value, schar default_value)
{
    int temp;
    read(node, temp, (int)default_value);
    value = saturate_cast<schar>(temp);
}

static inline
void read(const FileNode& node, ushort& value, ushort default_value)
{
    int temp;
    read(node, temp, (int)default_value);
    value = saturate_cast<ushort>(temp);
}

static inline
void read(const FileNode& node, short& value, short default_value)
{
    int temp;
    read(node, temp, (int)default_value);
    value = saturate_cast<short>(temp);
}

template<typename _Tp> static inline
void read( FileNodeIterator& it, std::vector<_Tp>& vec, size_t maxCount = (size_t)2147483647 )
{
    cv::internal::VecReaderProxy<_Tp, DataType<_Tp>::fmt != 0> r(&it);
    r(vec, maxCount);
}

template<typename _Tp> static inline
void read( const FileNode& node, std::vector<_Tp>& vec, const std::vector<_Tp>& default_value = std::vector<_Tp>() )
{
    if(!node.node)
        vec = default_value;
    else
    {
        FileNodeIterator it = node.begin();
        read( it, vec );
    }
}

static inline
void read( const FileNode& node, std::vector<KeyPoint>& vec, const std::vector<KeyPoint>& default_value )
{
    if(!node.node)
        vec = default_value;
    else
        read(node, vec);
}

static inline
void read( const FileNode& node, std::vector<DMatch>& vec, const std::vector<DMatch>& default_value )
{
    if(!node.node)
        vec = default_value;
    else
        read(node, vec);
}








template<typename _Tp> static inline
FileStorage& operator << (FileStorage& fs, const _Tp& value)
{
    if( !fs.isOpened() )
        return fs;
    if( fs.state == FileStorage::NAME_EXPECTED + FileStorage::INSIDE_MAP )
        cv::error( Error::StsError, "No element name has been given",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/persistence.hpp", 1189 );
    write( fs, fs.elname, value );
    if( fs.state & FileStorage::INSIDE_MAP )
        fs.state = FileStorage::NAME_EXPECTED + FileStorage::INSIDE_MAP;
    return fs;
}



static inline
FileStorage& operator << (FileStorage& fs, const char* str)
{
    return (fs << String(str));
}



static inline
FileStorage& operator << (FileStorage& fs, char* value)
{
    return (fs << String(value));
}








template<typename _Tp> static inline
FileNodeIterator& operator >> (FileNodeIterator& it, _Tp& value)
{
    read( *it, value, _Tp());
    return ++it;
}



template<typename _Tp> static inline
FileNodeIterator& operator >> (FileNodeIterator& it, std::vector<_Tp>& vec)
{
    cv::internal::VecReaderProxy<_Tp, DataType<_Tp>::fmt != 0> r(&it);
    r(vec, (size_t)2147483647);
    return it;
}








template<typename _Tp> static inline
void operator >> (const FileNode& n, _Tp& value)
{
    read( n, value, _Tp());
}



template<typename _Tp> static inline
void operator >> (const FileNode& n, std::vector<_Tp>& vec)
{
    FileNodeIterator it = n.begin();
    it >> vec;
}




static inline
void operator >> (const FileNode& n, std::vector<KeyPoint>& vec)
{
    read(n, vec);
}

static inline
void operator >> (const FileNode& n, KeyPoint& kpt)
{
    FileNodeIterator it = n.begin();
    it >> kpt.pt.x >> kpt.pt.y >> kpt.size >> kpt.angle >> kpt.response >> kpt.octave >> kpt.class_id;
}




static inline
void operator >> (const FileNode& n, std::vector<DMatch>& vec)
{
    read(n, vec);
}

static inline
void operator >> (const FileNode& n, DMatch& m)
{
    FileNodeIterator it = n.begin();
    it >> m.queryIdx >> m.trainIdx >> m.imgIdx >> m.distance;
}






static inline
bool operator == (const FileNodeIterator& it1, const FileNodeIterator& it2)
{
    return it1.fs == it2.fs && it1.container == it2.container &&
        it1.reader.ptr == it2.reader.ptr && it1.remaining == it2.remaining;
}

static inline
bool operator != (const FileNodeIterator& it1, const FileNodeIterator& it2)
{
    return !(it1 == it2);
}

static inline
ptrdiff_t operator - (const FileNodeIterator& it1, const FileNodeIterator& it2)
{
    return it2.remaining - it1.remaining;
}

static inline
bool operator < (const FileNodeIterator& it1, const FileNodeIterator& it2)
{
    return it1.remaining > it2.remaining;
}





inline FileNode FileStorage::getFirstTopLevelNode() const { FileNode r = root(); FileNodeIterator it = r.begin(); return it != r.end() ? *it : FileNode(); }
inline FileNode::FileNode() : fs(0), node(0) {}
inline FileNode::FileNode(const CvFileStorage* _fs, const CvFileNode* _node) : fs(_fs), node(_node) {}
inline FileNode::FileNode(const FileNode& _node) : fs(_node.fs), node(_node.node) {}
inline bool FileNode::empty() const    { return node   == 0;    }
inline bool FileNode::isNone() const   { return type() == NONE; }
inline bool FileNode::isSeq() const    { return type() == SEQ;  }
inline bool FileNode::isMap() const    { return type() == MAP;  }
inline bool FileNode::isInt() const    { return type() == INT;  }
inline bool FileNode::isReal() const   { return type() == REAL; }
inline bool FileNode::isString() const { return type() == STR;  }
inline CvFileNode* FileNode::operator *() { return (CvFileNode*)node; }
inline const CvFileNode* FileNode::operator* () const { return node; }
inline FileNode::operator int() const    { int value;    read(*this, value, 0);     return value; }
inline FileNode::operator float() const  { float value;  read(*this, value, 0.f);   return value; }
inline FileNode::operator double() const { double value; read(*this, value, 0.);    return value; }
inline FileNode::operator String() const { String value; read(*this, value, value); return value; }
inline double FileNode::real() const  { return double(*this); }
inline String FileNode::string() const { return String(*this); }
inline Mat FileNode::mat() const { Mat value; read(*this, value, value);    return value; }
inline FileNodeIterator FileNode::begin() const { return FileNodeIterator(fs, node); }
inline FileNodeIterator FileNode::end() const   { return FileNodeIterator(fs, node, size()); }
inline void FileNode::readRaw( const String& fmt, uchar* vec, size_t len ) const { begin().readRaw( fmt, vec, len ); }
inline FileNode FileNodeIterator::operator *() const  { return FileNode(fs, (const CvFileNode*)(const void*)reader.ptr); }
inline FileNode FileNodeIterator::operator ->() const { return FileNode(fs, (const CvFileNode*)(const void*)reader.ptr); }
inline String::String(const FileNode& fn): cstr_(0), len_(0) { read(fn, *this, *this); }




 void cvStartWriteRawData_Base64(::CvFileStorage * fs, const char* name, int len, const char* dt);

 void cvWriteRawData_Base64(::CvFileStorage * fs, const void* _data, int len);

 void cvEndWriteRawData_Base64(::CvFileStorage * fs);

 void cvWriteMat_Base64(::CvFileStorage* fs, const char* name, const ::CvMat* mat);

 void cvWriteMatND_Base64(::CvFileStorage* fs, const char* name, const ::CvMatND* mat);

} 

#line 1367 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/persistence.hpp"

#line 61 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"




































namespace cv {











class  Exception : public std::exception
{
public:
    


    Exception();
    



    Exception(int _code, const String& _err, const String& _func, const String& _file, int _line);
    virtual ~Exception() throw();

    


    virtual const char *what() const throw();
    void formatMessage();

    String msg; 

    int code; 
    String err; 
    String func; 
    String file; 
    int line; 
};









 void error( const Exception& exc );

enum SortFlags { SORT_EVERY_ROW    = 0, 
                 SORT_EVERY_COLUMN = 1, 
                                        
                                        
                 SORT_ASCENDING    = 0, 
                                        
                 SORT_DESCENDING   = 16 
                                        
                                        
               };







enum CovarFlags {
    






    COVAR_SCRAMBLED = 0,
    



    COVAR_NORMAL    = 1,
    




    COVAR_USE_AVG   = 2,
    



    COVAR_SCALE     = 4,
    


    COVAR_ROWS      = 8,
    


    COVAR_COLS      = 16
};


enum KmeansFlags {
    
    KMEANS_RANDOM_CENTERS     = 0,
    
    KMEANS_PP_CENTERS         = 2,
    



    KMEANS_USE_INITIAL_LABELS = 1
};


enum LineTypes {
    FILLED  = -1,
    LINE_4  = 4, 
    LINE_8  = 8, 
    LINE_AA = 16 
};



enum HersheyFonts {
    FONT_HERSHEY_SIMPLEX        = 0, 
    FONT_HERSHEY_PLAIN          = 1, 
    FONT_HERSHEY_DUPLEX         = 2, 
    FONT_HERSHEY_COMPLEX        = 3, 
    FONT_HERSHEY_TRIPLEX        = 4, 
    FONT_HERSHEY_COMPLEX_SMALL  = 5, 
    FONT_HERSHEY_SCRIPT_SIMPLEX = 6, 
    FONT_HERSHEY_SCRIPT_COMPLEX = 7, 
    FONT_ITALIC                 = 16 
};

enum ReduceTypes { REDUCE_SUM = 0, 
                   REDUCE_AVG = 1, 
                   REDUCE_MAX = 2, 
                   REDUCE_MIN = 3  
                 };




 void swap(Mat& a, Mat& b);

 void swap( UMat& a, UMat& b );



























 int borderInterpolate(int p, int len, int borderType);















































 void copyMakeBorder(InputArray src, OutputArray dst,
                                 int top, int bottom, int left, int right,
                                 int borderType, const Scalar& value = Scalar() );





































 void add(InputArray src1, InputArray src2, OutputArray dst,
                      InputArray mask = noArray(), int dtype = -1);






































 void subtract(InputArray src1, InputArray src2, OutputArray dst,
                           InputArray mask = noArray(), int dtype = -1);























 void multiply(InputArray src1, InputArray src2,
                           OutputArray dst, double scale = 1, int dtype = -1);





















 void divide(InputArray src1, InputArray src2, OutputArray dst,
                         double scale = 1, int dtype = -1);


 void divide(double scale, InputArray src2,
                         OutputArray dst, int dtype = -1);



















 void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst);


























 void addWeighted(InputArray src1, double alpha, InputArray src2,
                              double beta, double gamma, OutputArray dst, int dtype = -1);


























 void convertScaleAbs(InputArray src, OutputArray dst,
                                  double alpha = 1, double beta = 0);










 void convertFp16(InputArray src, OutputArray dst);















 void LUT(InputArray src, InputArray lut, OutputArray dst);








 Scalar sum(InputArray src);








 int countNonZero( InputArray src );



























 void findNonZero( InputArray src, OutputArray idx );












 Scalar mean(InputArray src, InputArray mask = noArray());





















 void meanStdDev(InputArray src, OutputArray mean, OutputArray stddev,
                             InputArray mask=noArray());



































 double norm(InputArray src1, int normType = NORM_L2, InputArray mask = noArray());







 double norm(InputArray src1, InputArray src2,
                         int normType = NORM_L2, InputArray mask = noArray());




 double norm( const SparseMat& src, int normType );






 double PSNR(InputArray src1, InputArray src2);






 void batchDistance(InputArray src1, InputArray src2,
                                OutputArray dist, int dtype, OutputArray nidx,
                                int normType = NORM_L2, int K = 0,
                                InputArray mask = noArray(), int update = 0,
                                bool crosscheck = false);



























































 void normalize( InputArray src, InputOutputArray dst, double alpha = 1, double beta = 0,
                             int norm_type = NORM_L2, int dtype = -1, InputArray mask = noArray());








 void normalize( const SparseMat& src, SparseMat& dst, double alpha, int normType );



















 void minMaxLoc(InputArray src,  double* minVal,
                             double* maxVal = 0,  Point* minLoc = 0,
                             Point* maxLoc = 0, InputArray mask = noArray());

























 void minMaxIdx(InputArray src, double* minVal, double* maxVal = 0,
                          int* minIdx = 0, int* maxIdx = 0, InputArray mask = noArray());










 void minMaxLoc(const SparseMat& a, double* minVal,
                          double* maxVal, int* minIdx = 0, int* maxIdx = 0);


















 void reduce(InputArray src, OutputArray dst, int dim, int rtype, int dtype = -1);
















 void merge(const Mat* mv, size_t count, OutputArray dst);







 void merge(InputArrayOfArrays mv, OutputArray dst);












 void split(const Mat& src, Mat* mvbegin);





 void split(InputArray m, OutputArrayOfArrays mv);










































 void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts,
                            const int* fromTo, size_t npairs);















 void mixChannels(InputArrayOfArrays src, InputOutputArrayOfArrays dst,
                            const int* fromTo, size_t npairs);














 void mixChannels(InputArrayOfArrays src, InputOutputArrayOfArrays dst,
                              const std::vector<int>& fromTo);







 void extractChannel(InputArray src, OutputArray dst, int coi);







 void insertChannel(InputArray src, InputOutputArray dst, int coi);

































 void flip(InputArray src, OutputArray dst, int flipCode);

enum RotateFlags {
    ROTATE_90_CLOCKWISE = 0, 
    ROTATE_180 = 1, 
    ROTATE_90_COUNTERCLOCKWISE = 2, 
};











 void rotate(InputArray src, OutputArray dst, int rotateCode);














 void repeat(InputArray src, int ny, int nx, OutputArray dst);








 Mat repeat(const Mat& src, int ny, int nx);






















 void hconcat(const Mat* src, size_t nsrc, OutputArray dst);




















 void hconcat(InputArray src1, InputArray src2, OutputArray dst);


















 void hconcat(InputArrayOfArrays src, OutputArray dst);





















 void vconcat(const Mat* src, size_t nsrc, OutputArray dst);























 void vconcat(InputArray src1, InputArray src2, OutputArray dst);

















 void vconcat(InputArrayOfArrays src, OutputArray dst);


























 void bitwise_and(InputArray src1, InputArray src2,
                              OutputArray dst, InputArray mask = noArray());

























 void bitwise_or(InputArray src1, InputArray src2,
                             OutputArray dst, InputArray mask = noArray());


























 void bitwise_xor(InputArray src1, InputArray src2,
                              OutputArray dst, InputArray mask = noArray());















 void bitwise_not(InputArray src, OutputArray dst,
                              InputArray mask = noArray());
























 void absdiff(InputArray src1, InputArray src2, OutputArray dst);




















 void inRange(InputArray src, InputArray lowerb,
                          InputArray upperb, OutputArray dst);



























 void compare(InputArray src1, InputArray src2, OutputArray dst, int cmpop);












 void min(InputArray src1, InputArray src2, OutputArray dst);



 void min(const Mat& src1, const Mat& src2, Mat& dst);



 void min(const UMat& src1, const UMat& src2, UMat& dst);












 void max(InputArray src1, InputArray src2, OutputArray dst);



 void max(const Mat& src1, const Mat& src2, Mat& dst);



 void max(const UMat& src1, const UMat& src2, UMat& dst);










 void sqrt(InputArray src, OutputArray dst);
























 void pow(InputArray src, double power, OutputArray dst);















 void exp(InputArray src, OutputArray dst);












 void log(InputArray src, OutputArray dst);





















 void polarToCart(InputArray magnitude, InputArray angle,
                              OutputArray x, OutputArray y, bool angleInDegrees = false);



















 void cartToPolar(InputArray x, InputArray y,
                              OutputArray magnitude, OutputArray angle,
                              bool angleInDegrees = false);

















 void phase(InputArray x, InputArray y, OutputArray angle,
                        bool angleInDegrees = false);












 void magnitude(InputArray x, InputArray y, OutputArray magnitude);
















 bool checkRange(InputArray a, bool quiet = true,  Point* pos = 0,
                            double minVal = -1.7976931348623158e+308, double maxVal = 1.7976931348623158e+308);



 void patchNaNs(InputOutputArray a, double val = 0);





























 void gemm(InputArray src1, InputArray src2, double alpha,
                       InputArray src3, double beta, OutputArray dst, int flags = 0);





























 void mulTransposed( InputArray src, OutputArray dst, bool aTa,
                                 InputArray delta = noArray(),
                                 double scale = 1, int dtype = -1 );










 void transpose(InputArray src, OutputArray dst);

























 void transform(InputArray src, OutputArray dst, InputArray m );


























 void perspectiveTransform(InputArray src, OutputArray dst, InputArray m );














 void completeSymm(InputOutputArray mtx, bool lowerToUpper = false);
















 void setIdentity(InputOutputArray mtx, const Scalar& s = Scalar(1));














 double determinant(InputArray mtx);








 Scalar trace(InputArray mtx);


























 double invert(InputArray src, OutputArray dst, int flags = DECOMP_LU);























 bool solve(InputArray src1, InputArray src2,
                        OutputArray dst, int flags = DECOMP_LU);














 void sort(InputArray src, OutputArray dst, int flags);



















 void sortIdx(InputArray src, OutputArray dst, int flags);













 int solveCubic(InputArray coeffs, OutputArray roots);









 double solvePoly(InputArray coeffs, OutputArray roots, int maxIters = 300);



















 bool eigen(InputArray src, OutputArray eigenvalues,
                        OutputArray eigenvectors = noArray());














 void calcCovarMatrix( const Mat* samples, int nsamples, Mat& covar, Mat& mean,
                                 int flags, int ctype = 6);









 void calcCovarMatrix( InputArray samples, OutputArray covar,
                                   InputOutputArray mean, int flags, int ctype = 6);


 void PCACompute(InputArray data, InputOutputArray mean,
                             OutputArray eigenvectors, int maxComponents = 0);


 void PCACompute(InputArray data, InputOutputArray mean,
                             OutputArray eigenvectors, double retainedVariance);


 void PCAProject(InputArray data, InputArray mean,
                             InputArray eigenvectors, OutputArray result);


 void PCABackProject(InputArray data, InputArray mean,
                                 InputArray eigenvectors, OutputArray result);


 void SVDecomp( InputArray src, OutputArray w, OutputArray u, OutputArray vt, int flags = 0 );


 void SVBackSubst( InputArray w, InputArray u, InputArray vt,
                               InputArray rhs, OutputArray dst );











 double Mahalanobis(InputArray v1, InputArray v2, InputArray icovar);





































































































































 void dft(InputArray src, OutputArray dst, int flags = 0, int nonzeroRows = 0);













 void idft(InputArray src, OutputArray dst, int flags = 0, int nonzeroRows = 0);








































 void dct(InputArray src, OutputArray dst, int flags = 0);









 void idct(InputArray src, OutputArray dst, int flags = 0);


















 void mulSpectrums(InputArray a, InputArray b, OutputArray c,
                               int flags, bool conjB = false);






















 int getOptimalDFTSize(int vecsize);










 RNG& theRNG();







 void setRNGSeed(int seed);











 void randu(InputOutputArray dst, InputArray low, InputArray high);












 void randn(InputOutputArray dst, InputArray mean, InputArray stddev);












 void randShuffle(InputOutputArray dst, double iterFactor = 1., RNG* rng = 0);


































































class  PCA
{
public:
    enum Flags { DATA_AS_ROW = 0, 
                 DATA_AS_COL = 1, 
                 USE_AVG     = 2  
               };

    




    PCA();

    








    PCA(InputArray data, InputArray mean, int flags, int maxComponents = 0);

    









    PCA(InputArray data, InputArray mean, int flags, double retainedVariance);

    



















    PCA& operator()(InputArray data, InputArray mean, int flags, int maxComponents = 0);

    










    PCA& operator()(InputArray data, InputArray mean, int flags, double retainedVariance);

    













    Mat project(InputArray vec) const;

    











    void project(InputArray vec, OutputArray result) const;

    












    Mat backProject(InputArray vec) const;

    






    void backProject(InputArray vec, OutputArray result) const;

    



    void write(FileStorage& fs) const;

    



    void read(const FileNode& fn);

    Mat eigenvectors; 
    Mat eigenvalues; 
    Mat mean; 
};









class  LDA
{
public:
    


    explicit LDA(int num_components = 0);

    




    LDA(InputArrayOfArrays src, InputArray labels, int num_components = 0);

    

    void save(const String& filename) const;

    

    void load(const String& filename);

    

    void save(FileStorage& fs) const;

    

    void load(const FileStorage& node);

    

    ~LDA();

    

    void compute(InputArrayOfArrays src, InputArray labels);

    


    Mat project(InputArray src);

    


    Mat reconstruct(InputArray src);

    

    Mat eigenvectors() const { return _eigenvectors; }

    

    Mat eigenvalues() const { return _eigenvalues; }

    static Mat subspaceProject(InputArray W, InputArray mean, InputArray src);
    static Mat subspaceReconstruct(InputArray W, InputArray mean, InputArray src);

protected:
    bool _dataAsRow; 
    int _num_components;
    Mat _eigenvectors;
    Mat _eigenvalues;
    void lda(InputArrayOfArrays src, InputArray labels);
};















class  SVD
{
public:
    enum Flags {
        

        MODIFY_A = 1,
        

        NO_UV    = 2,
        


        FULL_UV  = 4
    };

    



    SVD();

    




    SVD( InputArray src, int flags = 0 );

    










    SVD& operator ()( InputArray src, int flags = 0 );

    
















    static void compute( InputArray src, OutputArray w,
                         OutputArray u, OutputArray vt, int flags = 0 );

    





    static void compute( InputArray src, OutputArray w, int flags = 0 );

    

    static void backSubst( InputArray w, InputArray u,
                           InputArray vt, InputArray rhs,
                           OutputArray dst );

    









    static void solveZ( InputArray src, OutputArray dst );

    





















    void backSubst( InputArray rhs, OutputArray dst ) const;

    
    template<typename _Tp, int m, int n, int nm> static
    void compute( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w, Matx<_Tp, m, nm>& u, Matx<_Tp, n, nm>& vt );

    
    template<typename _Tp, int m, int n, int nm> static
    void compute( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w );

    
    template<typename _Tp, int m, int n, int nm, int nb> static
    void backSubst( const Matx<_Tp, nm, 1>& w, const Matx<_Tp, m, nm>& u, const Matx<_Tp, n, nm>& vt, const Matx<_Tp, m, nb>& rhs, Matx<_Tp, n, nb>& dst );

    Mat u, w, vt;
};













class  RNG
{
public:
    enum { UNIFORM = 0,
           NORMAL  = 1
         };

    







    RNG();
    


    RNG(uint64 state);
    

    unsigned next();

    





    operator uchar();
    
    operator schar();
    
    operator ushort();
    
    operator short();
    
    operator unsigned();
    
    operator int();
    
    operator float();
    
    operator double();

    






    unsigned operator ()();
    


    unsigned operator ()(unsigned N);

    



































    int uniform(int a, int b);
    
    float uniform(float a, float b);
    
    double uniform(double a, double b);

    

































    void fill( InputOutputArray mat, int distType, InputArray a, InputArray b, bool saturateRange = false );

    







    double gaussian(double sigma);

    uint64 state;

    bool operator ==(const RNG& other) const;
};






class  RNG_MT19937
{
public:
    RNG_MT19937();
    RNG_MT19937(unsigned s);
    void seed(unsigned s);

    unsigned next();

    operator int();
    operator unsigned();
    operator float();
    operator double();

    unsigned operator ()(unsigned N);
    unsigned operator ()();

    


    int uniform(int a, int b);
    


    float uniform(float a, float b);
    


    double uniform(double a, double b);

private:
    enum PeriodParameters {N = 624, M = 397};
    unsigned state[N];
    int mti;
};











































 double kmeans( InputArray data, int K, InputOutputArray bestLabels,
                            TermCriteria criteria, int attempts,
                            int flags, OutputArray centers = noArray() );









class  Formatted
{
public:
    virtual const char* next() = 0;
    virtual void reset() = 0;
    virtual ~Formatted();
};


class  Formatter
{
public:
    enum { FMT_DEFAULT = 0,
           FMT_MATLAB  = 1,
           FMT_CSV     = 2,
           FMT_PYTHON  = 3,
           FMT_NUMPY   = 4,
           FMT_C       = 5
         };

    virtual ~Formatter();

    virtual Ptr<Formatted> format(const Mat& mtx) const = 0;

    virtual void set32fPrecision(int p = 8) = 0;
    virtual void set64fPrecision(int p = 16) = 0;
    virtual void setMultiline(bool ml = true) = 0;

    static Ptr<Formatter> get(int fmt = FMT_DEFAULT);

};

static inline
String& operator << (String& out, Ptr<Formatted> fmtd)
{
    fmtd->reset();
    for(const char* str = fmtd->next(); str; str = fmtd->next())
        out += cv::String(str);
    return out;
}

static inline
String& operator << (String& out, const Mat& mtx)
{
    return out << Formatter::get()->format(mtx);
}



class  Algorithm;

template<typename _Tp> struct ParamType {};




































class  Algorithm
{
public:
    Algorithm();
    virtual ~Algorithm();

    

     virtual void clear() {}

    

    virtual void write(FileStorage& fs) const { (void)fs; }

    

    virtual void read(const FileNode& fn) { (void)fn; }

    

    virtual bool empty() const { return false; }

    










    template<typename _Tp> static Ptr<_Tp> read(const FileNode& fn)
    {
        Ptr<_Tp> obj = _Tp::create();
        obj->read(fn);
        return !obj->empty() ? obj : Ptr<_Tp>();
    }

    











    template<typename _Tp> static Ptr<_Tp> load(const String& filename, const String& objname=String())
    {
        FileStorage fs(filename, FileStorage::READ);
        FileNode fn = objname.empty() ? fs.getFirstTopLevelNode() : fs[objname];
        if (fn.empty()) return Ptr<_Tp>();
        Ptr<_Tp> obj = _Tp::create();
        obj->read(fn);
        return !obj->empty() ? obj : Ptr<_Tp>();
    }

    









    template<typename _Tp> static Ptr<_Tp> loadFromString(const String& strModel, const String& objname=String())
    {
        FileStorage fs(strModel, FileStorage::READ + FileStorage::MEMORY);
        FileNode fn = objname.empty() ? fs.getFirstTopLevelNode() : fs[objname];
        Ptr<_Tp> obj = _Tp::create();
        obj->read(fn);
        return !obj->empty() ? obj : Ptr<_Tp>();
    }

    

     virtual void save(const String& filename) const;

    

     virtual String getDefaultName() const;

protected:
    void writeFormat(FileStorage& fs) const;
};

struct Param {
    enum { INT=0, BOOLEAN=1, REAL=2, STRING=3, MAT=4, MAT_VECTOR=5, ALGORITHM=6, FLOAT=7,
           UNSIGNED_INT=8, UINT64=9, UCHAR=11 };
};



template<> struct ParamType<bool>
{
    typedef bool const_param_type;
    typedef bool member_type;

    enum { type = Param::BOOLEAN };
};

template<> struct ParamType<int>
{
    typedef int const_param_type;
    typedef int member_type;

    enum { type = Param::INT };
};

template<> struct ParamType<double>
{
    typedef double const_param_type;
    typedef double member_type;

    enum { type = Param::REAL };
};

template<> struct ParamType<String>
{
    typedef const String& const_param_type;
    typedef String member_type;

    enum { type = Param::STRING };
};

template<> struct ParamType<Mat>
{
    typedef const Mat& const_param_type;
    typedef Mat member_type;

    enum { type = Param::MAT };
};

template<> struct ParamType<std::vector<Mat> >
{
    typedef const std::vector<Mat>& const_param_type;
    typedef std::vector<Mat> member_type;

    enum { type = Param::MAT_VECTOR };
};

template<> struct ParamType<Algorithm>
{
    typedef const Ptr<Algorithm>& const_param_type;
    typedef Ptr<Algorithm> member_type;

    enum { type = Param::ALGORITHM };
};

template<> struct ParamType<float>
{
    typedef float const_param_type;
    typedef float member_type;

    enum { type = Param::FLOAT };
};

template<> struct ParamType<unsigned>
{
    typedef unsigned const_param_type;
    typedef unsigned member_type;

    enum { type = Param::UNSIGNED_INT };
};

template<> struct ParamType<uint64>
{
    typedef uint64 const_param_type;
    typedef uint64 member_type;

    enum { type = Param::UINT64 };
};

template<> struct ParamType<uchar>
{
    typedef uchar const_param_type;
    typedef uchar member_type;

    enum { type = Param::UCHAR };
};



} 

#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/operations.hpp"























































namespace cv
{



namespace internal
{

template<typename _Tp, int m> struct Matx_FastInvOp
{
    bool operator()(const Matx<_Tp, m, m>& a, Matx<_Tp, m, m>& b, int method) const
    {
        Matx<_Tp, m, m> temp = a;

        
        for( int i = 0; i < m; i++ )
            b(i, i) = (_Tp)1;

        if( method == DECOMP_CHOLESKY )
            return Cholesky(temp.val, m*sizeof(_Tp), m, b.val, m*sizeof(_Tp), m);

        return LU(temp.val, m*sizeof(_Tp), m, b.val, m*sizeof(_Tp), m) != 0;
    }
};

template<typename _Tp> struct Matx_FastInvOp<_Tp, 2>
{
    bool operator()(const Matx<_Tp, 2, 2>& a, Matx<_Tp, 2, 2>& b, int) const
    {
        _Tp d = (_Tp)determinant(a);
        if( d == 0 )
            return false;
        d = 1/d;
        b(1,1) = a(0,0)*d;
        b(0,0) = a(1,1)*d;
        b(0,1) = -a(0,1)*d;
        b(1,0) = -a(1,0)*d;
        return true;
    }
};

template<typename _Tp> struct Matx_FastInvOp<_Tp, 3>
{
    bool operator()(const Matx<_Tp, 3, 3>& a, Matx<_Tp, 3, 3>& b, int) const
    {
        _Tp d = (_Tp)determinant(a);
        if( d == 0 )
            return false;
        d = 1/d;
        b(0,0) = (a(1,1) * a(2,2) - a(1,2) * a(2,1)) * d;
        b(0,1) = (a(0,2) * a(2,1) - a(0,1) * a(2,2)) * d;
        b(0,2) = (a(0,1) * a(1,2) - a(0,2) * a(1,1)) * d;

        b(1,0) = (a(1,2) * a(2,0) - a(1,0) * a(2,2)) * d;
        b(1,1) = (a(0,0) * a(2,2) - a(0,2) * a(2,0)) * d;
        b(1,2) = (a(0,2) * a(1,0) - a(0,0) * a(1,2)) * d;

        b(2,0) = (a(1,0) * a(2,1) - a(1,1) * a(2,0)) * d;
        b(2,1) = (a(0,1) * a(2,0) - a(0,0) * a(2,1)) * d;
        b(2,2) = (a(0,0) * a(1,1) - a(0,1) * a(1,0)) * d;
        return true;
    }
};


template<typename _Tp, int m, int n> struct Matx_FastSolveOp
{
    bool operator()(const Matx<_Tp, m, m>& a, const Matx<_Tp, m, n>& b,
                    Matx<_Tp, m, n>& x, int method) const
    {
        Matx<_Tp, m, m> temp = a;
        x = b;
        if( method == DECOMP_CHOLESKY )
            return Cholesky(temp.val, m*sizeof(_Tp), m, x.val, n*sizeof(_Tp), n);

        return LU(temp.val, m*sizeof(_Tp), m, x.val, n*sizeof(_Tp), n) != 0;
    }
};

template<typename _Tp> struct Matx_FastSolveOp<_Tp, 2, 1>
{
    bool operator()(const Matx<_Tp, 2, 2>& a, const Matx<_Tp, 2, 1>& b,
                    Matx<_Tp, 2, 1>& x, int) const
    {
        _Tp d = (_Tp)determinant(a);
        if( d == 0 )
            return false;
        d = 1/d;
        x(0) = (b(0)*a(1,1) - b(1)*a(0,1))*d;
        x(1) = (b(1)*a(0,0) - b(0)*a(1,0))*d;
        return true;
    }
};

template<typename _Tp> struct Matx_FastSolveOp<_Tp, 3, 1>
{
    bool operator()(const Matx<_Tp, 3, 3>& a, const Matx<_Tp, 3, 1>& b,
                    Matx<_Tp, 3, 1>& x, int) const
    {
        _Tp d = (_Tp)determinant(a);
        if( d == 0 )
            return false;
        d = 1/d;
        x(0) = d*(b(0)*(a(1,1)*a(2,2) - a(1,2)*a(2,1)) -
                a(0,1)*(b(1)*a(2,2) - a(1,2)*b(2)) +
                a(0,2)*(b(1)*a(2,1) - a(1,1)*b(2)));

        x(1) = d*(a(0,0)*(b(1)*a(2,2) - a(1,2)*b(2)) -
                b(0)*(a(1,0)*a(2,2) - a(1,2)*a(2,0)) +
                a(0,2)*(a(1,0)*b(2) - b(1)*a(2,0)));

        x(2) = d*(a(0,0)*(a(1,1)*b(2) - b(1)*a(2,1)) -
                a(0,1)*(a(1,0)*b(2) - b(1)*a(2,0)) +
                b(0)*(a(1,0)*a(2,1) - a(1,1)*a(2,0)));
        return true;
    }
};

} 

template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n> Matx<_Tp,m,n>::randu(_Tp a, _Tp b)
{
    Matx<_Tp,m,n> M;
    cv::randu(M, Scalar(a), Scalar(b));
    return M;
}

template<typename _Tp, int m, int n> inline
Matx<_Tp,m,n> Matx<_Tp,m,n>::randn(_Tp a, _Tp b)
{
    Matx<_Tp,m,n> M;
    cv::randn(M, Scalar(a), Scalar(b));
    return M;
}

template<typename _Tp, int m, int n> inline
Matx<_Tp, n, m> Matx<_Tp, m, n>::inv(int method, bool *p_is_ok ) const
{
    Matx<_Tp, n, m> b;
    bool ok;
    if( method == DECOMP_LU || method == DECOMP_CHOLESKY )
        ok = cv::internal::Matx_FastInvOp<_Tp, m>()(*this, b, method);
    else
    {
        Mat A(*this, false), B(b, false);
        ok = (invert(A, B, method) != 0);
    }
    if( 0 != p_is_ok ) { *p_is_ok = ok; }
    return ok ? b : Matx<_Tp, n, m>::zeros();
}

template<typename _Tp, int m, int n> template<int l> inline
Matx<_Tp, n, l> Matx<_Tp, m, n>::solve(const Matx<_Tp, m, l>& rhs, int method) const
{
    Matx<_Tp, n, l> x;
    bool ok;
    if( method == DECOMP_LU || method == DECOMP_CHOLESKY )
        ok = cv::internal::Matx_FastSolveOp<_Tp, m, l>()(*this, rhs, x, method);
    else
    {
        Mat A(*this, false), B(rhs, false), X(x, false);
        ok = cv::solve(A, B, X, method);
    }

    return ok ? x : Matx<_Tp, n, l>::zeros();
}
















static inline Mat& operator += (Mat& a, const Mat& b) { cv::add(a,b,a); return a; } static inline const Mat& operator += (const Mat& a, const Mat& b) { cv::add(a,b,a); return a; }
static inline Mat& operator += (Mat& a, const Scalar& b) { cv::add(a,b,a); return a; } static inline const Mat& operator += (const Mat& a, const Scalar& b) { cv::add(a,b,a); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator += (Mat_<_Tp>& a, const Mat& b) { cv::add(a,b,a); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const Mat& b) { cv::add(a,b,a); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator += (Mat_<_Tp>& a, const Scalar& b) { cv::add(a,b,a); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const Scalar& b) { cv::add(a,b,a); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator += (Mat_<_Tp>& a, const Mat_<_Tp>& b) { cv::add(a,b,a); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const Mat_<_Tp>& b) { cv::add(a,b,a); return a; }

static inline Mat& operator -= (Mat& a, const Mat& b) { cv::subtract(a,b,a); return a; } static inline const Mat& operator -= (const Mat& a, const Mat& b) { cv::subtract(a,b,a); return a; }
static inline Mat& operator -= (Mat& a, const Scalar& b) { cv::subtract(a,b,a); return a; } static inline const Mat& operator -= (const Mat& a, const Scalar& b) { cv::subtract(a,b,a); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator -= (Mat_<_Tp>& a, const Mat& b) { cv::subtract(a,b,a); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const Mat& b) { cv::subtract(a,b,a); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator -= (Mat_<_Tp>& a, const Scalar& b) { cv::subtract(a,b,a); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const Scalar& b) { cv::subtract(a,b,a); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator -= (Mat_<_Tp>& a, const Mat_<_Tp>& b) { cv::subtract(a,b,a); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const Mat_<_Tp>& b) { cv::subtract(a,b,a); return a; }

static inline Mat& operator *= (Mat& a, const Mat& b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; } static inline const Mat& operator *= (const Mat& a, const Mat& b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator *= (Mat_<_Tp>& a, const Mat& b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const Mat& b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator *= (Mat_<_Tp>& a, const Mat_<_Tp>& b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const Mat_<_Tp>& b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; }
static inline Mat& operator *= (Mat& a, const double& b) { a.convertTo(a, -1, b); return a; } static inline const Mat& operator *= (const Mat& a, const double& b) { a.convertTo(a, -1, b); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator *= (Mat_<_Tp>& a, const double& b) { a.convertTo(a, -1, b); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const double& b) { a.convertTo(a, -1, b); return a; }

static inline Mat& operator /= (Mat& a, const Mat& b) { cv::divide(a,b,a); return a; } static inline const Mat& operator /= (const Mat& a, const Mat& b) { cv::divide(a,b,a); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator /= (Mat_<_Tp>& a, const Mat& b) { cv::divide(a,b,a); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator /= (const Mat_<_Tp>& a, const Mat& b) { cv::divide(a,b,a); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator /= (Mat_<_Tp>& a, const Mat_<_Tp>& b) { cv::divide(a,b,a); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator /= (const Mat_<_Tp>& a, const Mat_<_Tp>& b) { cv::divide(a,b,a); return a; }
static inline Mat& operator /= (Mat& a, const double& b) { a.convertTo((Mat&)a, -1, 1./b); return a; } static inline const Mat& operator /= (const Mat& a, const double& b) { a.convertTo((Mat&)a, -1, 1./b); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator /= (Mat_<_Tp>& a, const double& b) { a.convertTo((Mat&)a, -1, 1./b); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator /= (const Mat_<_Tp>& a, const double& b) { a.convertTo((Mat&)a, -1, 1./b); return a; }

static inline Mat& operator &= (Mat& a, const Mat& b) { cv::bitwise_and(a,b,a); return a; } static inline const Mat& operator &= (const Mat& a, const Mat& b) { cv::bitwise_and(a,b,a); return a; }
static inline Mat& operator &= (Mat& a, const Scalar& b) { cv::bitwise_and(a,b,a); return a; } static inline const Mat& operator &= (const Mat& a, const Scalar& b) { cv::bitwise_and(a,b,a); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator &= (Mat_<_Tp>& a, const Mat& b) { cv::bitwise_and(a,b,a); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator &= (const Mat_<_Tp>& a, const Mat& b) { cv::bitwise_and(a,b,a); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator &= (Mat_<_Tp>& a, const Scalar& b) { cv::bitwise_and(a,b,a); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator &= (const Mat_<_Tp>& a, const Scalar& b) { cv::bitwise_and(a,b,a); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator &= (Mat_<_Tp>& a, const Mat_<_Tp>& b) { cv::bitwise_and(a,b,a); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator &= (const Mat_<_Tp>& a, const Mat_<_Tp>& b) { cv::bitwise_and(a,b,a); return a; }

static inline Mat& operator |= (Mat& a, const Mat& b) { cv::bitwise_or(a,b,a); return a; } static inline const Mat& operator |= (const Mat& a, const Mat& b) { cv::bitwise_or(a,b,a); return a; }
static inline Mat& operator |= (Mat& a, const Scalar& b) { cv::bitwise_or(a,b,a); return a; } static inline const Mat& operator |= (const Mat& a, const Scalar& b) { cv::bitwise_or(a,b,a); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator |= (Mat_<_Tp>& a, const Mat& b) { cv::bitwise_or(a,b,a); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator |= (const Mat_<_Tp>& a, const Mat& b) { cv::bitwise_or(a,b,a); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator |= (Mat_<_Tp>& a, const Scalar& b) { cv::bitwise_or(a,b,a); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator |= (const Mat_<_Tp>& a, const Scalar& b) { cv::bitwise_or(a,b,a); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator |= (Mat_<_Tp>& a, const Mat_<_Tp>& b) { cv::bitwise_or(a,b,a); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator |= (const Mat_<_Tp>& a, const Mat_<_Tp>& b) { cv::bitwise_or(a,b,a); return a; }

static inline Mat& operator ^= (Mat& a, const Mat& b) { cv::bitwise_xor(a,b,a); return a; } static inline const Mat& operator ^= (const Mat& a, const Mat& b) { cv::bitwise_xor(a,b,a); return a; }
static inline Mat& operator ^= (Mat& a, const Scalar& b) { cv::bitwise_xor(a,b,a); return a; } static inline const Mat& operator ^= (const Mat& a, const Scalar& b) { cv::bitwise_xor(a,b,a); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator ^= (Mat_<_Tp>& a, const Mat& b) { cv::bitwise_xor(a,b,a); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator ^= (const Mat_<_Tp>& a, const Mat& b) { cv::bitwise_xor(a,b,a); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator ^= (Mat_<_Tp>& a, const Scalar& b) { cv::bitwise_xor(a,b,a); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator ^= (const Mat_<_Tp>& a, const Scalar& b) { cv::bitwise_xor(a,b,a); return a; }
template<typename _Tp> static inline Mat_<_Tp>& operator ^= (Mat_<_Tp>& a, const Mat_<_Tp>& b) { cv::bitwise_xor(a,b,a); return a; } template<typename _Tp> static inline const Mat_<_Tp>& operator ^= (const Mat_<_Tp>& a, const Mat_<_Tp>& b) { cv::bitwise_xor(a,b,a); return a; }









inline SVD::SVD() {}
inline SVD::SVD( InputArray m, int flags ) { operator ()(m, flags); }
inline void SVD::solveZ( InputArray m, OutputArray _dst )
{
    Mat mtx = m.getMat();
    SVD svd(mtx, (mtx.rows >= mtx.cols ? 0 : SVD::FULL_UV));
    _dst.create(svd.vt.cols, 1, svd.vt.type());
    Mat dst = _dst.getMat();
    svd.vt.row(svd.vt.rows-1).reshape(1,svd.vt.cols).copyTo(dst);
}

template<typename _Tp, int m, int n, int nm> inline void
    SVD::compute( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w, Matx<_Tp, m, nm>& u, Matx<_Tp, n, nm>& vt )
{
    static_assert((nm == ((m) > (n) ? (n) : (m))), "Invalid size of output vector." " " "nm == MIN(m, n)");
    Mat _a(a, false), _u(u, false), _w(w, false), _vt(vt, false);
    SVD::compute(_a, _w, _u, _vt);
    if(!!(_w.data == (uchar*)&w.val[0] && _u.data == (uchar*)&u.val[0] && _vt.data == (uchar*)&vt.val[0])) ; else cv::error( cv::Error::StsAssert, "_w.data == (uchar*)&w.val[0] && _u.data == (uchar*)&u.val[0] && _vt.data == (uchar*)&vt.val[0]",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/operations.hpp", 306 );
}

template<typename _Tp, int m, int n, int nm> inline void
SVD::compute( const Matx<_Tp, m, n>& a, Matx<_Tp, nm, 1>& w )
{
    static_assert((nm == ((m) > (n) ? (n) : (m))), "Invalid size of output vector." " " "nm == MIN(m, n)");
    Mat _a(a, false), _w(w, false);
    SVD::compute(_a, _w);
    if(!!(_w.data == (uchar*)&w.val[0])) ; else cv::error( cv::Error::StsAssert, "_w.data == (uchar*)&w.val[0]",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/operations.hpp", 315 );
}

template<typename _Tp, int m, int n, int nm, int nb> inline void
SVD::backSubst( const Matx<_Tp, nm, 1>& w, const Matx<_Tp, m, nm>& u,
                const Matx<_Tp, n, nm>& vt, const Matx<_Tp, m, nb>& rhs,
                Matx<_Tp, n, nb>& dst )
{
    static_assert((nm == ((m) > (n) ? (n) : (m))), "Invalid size of output vector." " " "nm == MIN(m, n)");
    Mat _u(u, false), _w(w, false), _vt(vt, false), _rhs(rhs, false), _dst(dst, false);
    SVD::backSubst(_w, _u, _vt, _rhs, _dst);
    if(!!(_dst.data == (uchar*)&dst.val[0])) ; else cv::error( cv::Error::StsAssert, "_dst.data == (uchar*)&dst.val[0]",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/operations.hpp", 326 );
}





inline RNG::RNG()              { state = 0xffffffff; }
inline RNG::RNG(uint64 _state) { state = _state ? _state : 0xffffffff; }

inline RNG::operator uchar()    { return (uchar)next(); }
inline RNG::operator schar()    { return (schar)next(); }
inline RNG::operator ushort()   { return (ushort)next(); }
inline RNG::operator short()    { return (short)next(); }
inline RNG::operator int()      { return (int)next(); }
inline RNG::operator unsigned() { return next(); }
inline RNG::operator float()    { return next()*2.3283064365386962890625e-10f; }
inline RNG::operator double()   { unsigned t = next(); return (((uint64)t << 32) | next()) * 5.4210108624275221700372640043497e-20; }

inline unsigned RNG::operator ()(unsigned N) { return (unsigned)uniform(0,N); }
inline unsigned RNG::operator ()()           { return next(); }

inline int    RNG::uniform(int a, int b)       { return a == b ? a : (int)(next() % (b - a) + a); }
inline float  RNG::uniform(float a, float b)   { return ((float)*this)*(b - a) + a; }
inline double RNG::uniform(double a, double b) { return ((double)*this)*(b - a) + a; }

inline bool RNG::operator ==(const RNG& other) const { return state == other.state; }

inline unsigned RNG::next()
{
    state = (uint64)(unsigned)state*  4164903690U + (unsigned)(state >> 32);
    return (unsigned)state;
}


template<typename _Tp> static inline _Tp randu()
{
  return (_Tp)theRNG();
}



 String format( const char* fmt, ... );



static inline
Ptr<Formatted> format(InputArray mtx, int fmt)
{
    return Formatter::get(fmt)->format(mtx.getMat());
}

static inline
int print(Ptr<Formatted> fmtd, FILE* stream = (&__iob_func()[1]))
{
    int written = 0;
    fmtd->reset();
    for(const char* str = fmtd->next(); str; str = fmtd->next())
        written += fputs(str, stream);

    return written;
}

static inline
int print(const Mat& mtx, FILE* stream = (&__iob_func()[1]))
{
    return print(Formatter::get()->format(mtx), stream);
}

static inline
int print(const UMat& mtx, FILE* stream = (&__iob_func()[1]))
{
    return print(Formatter::get()->format(mtx.getMat(ACCESS_READ)), stream);
}

template<typename _Tp> static inline
int print(const std::vector<Point_<_Tp> >& vec, FILE* stream = (&__iob_func()[1]))
{
    return print(Formatter::get()->format(Mat(vec)), stream);
}

template<typename _Tp> static inline
int print(const std::vector<Point3_<_Tp> >& vec, FILE* stream = (&__iob_func()[1]))
{
    return print(Formatter::get()->format(Mat(vec)), stream);
}

template<typename _Tp, int m, int n> static inline
int print(const Matx<_Tp, m, n>& matx, FILE* stream = (&__iob_func()[1]))
{
    return print(Formatter::get()->format(cv::Mat(matx)), stream);
}






















template<typename _Tp, class _EqPredicate> int
partition( const std::vector<_Tp>& _vec, std::vector<int>& labels,
          _EqPredicate predicate=_EqPredicate())
{
    int i, j, N = (int)_vec.size();
    const _Tp* vec = &_vec[0];

    const int PARENT=0;
    const int RANK=1;

    std::vector<int> _nodes(N*2);
    int (*nodes)[2] = (int(*)[2])&_nodes[0];

    
    for(i = 0; i < N; i++)
    {
        nodes[i][PARENT]=-1;
        nodes[i][RANK] = 0;
    }

    
    for( i = 0; i < N; i++ )
    {
        int root = i;

        
        while( nodes[root][PARENT] >= 0 )
            root = nodes[root][PARENT];

        for( j = 0; j < N; j++ )
        {
            if( i == j || !predicate(vec[i], vec[j]))
                continue;
            int root2 = j;

            while( nodes[root2][PARENT] >= 0 )
                root2 = nodes[root2][PARENT];

            if( root2 != root )
            {
                
                int rank = nodes[root][RANK], rank2 = nodes[root2][RANK];
                if( rank > rank2 )
                    nodes[root2][PARENT] = root;
                else
                {
                    nodes[root][PARENT] = root2;
                    nodes[root2][RANK] += rank == rank2;
                    root = root2;
                }
                if(!!(nodes[root][PARENT] < 0)) ; else cv::error( cv::Error::StsAssert, "nodes[root][PARENT] < 0",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/operations.hpp", 490 );

                int k = j, parent;

                
                while( (parent = nodes[k][PARENT]) >= 0 )
                {
                    nodes[k][PARENT] = root;
                    k = parent;
                }

                
                k = i;
                while( (parent = nodes[k][PARENT]) >= 0 )
                {
                    nodes[k][PARENT] = root;
                    k = parent;
                }
            }
        }
    }

    
    labels.resize(N);
    int nclasses = 0;

    for( i = 0; i < N; i++ )
    {
        int root = i;
        while( nodes[root][PARENT] >= 0 )
            root = nodes[root][PARENT];
        
        if( nodes[root][RANK] >= 0 )
            nodes[root][RANK] = ~nclasses++;
        labels[i] = ~nodes[root][RANK];
    }

    return nclasses;
}

} 

#line 533 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/operations.hpp"
#line 3223 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvstd.inl.hpp"














































#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\complex"

#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\ccomplex"







#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\complex"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sstream"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {
 #pragma warning(disable: 4250 4251)

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_stringbuf
		: public basic_streambuf<_Elem, _Traits>
	{	
public:
	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Myt;
	typedef _Alloc allocator_type;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;

	explicit basic_stringbuf(ios_base::openmode _Mode =
		ios_base::in | ios_base::out)
		{	
		_Init(0, 0, _Getstate(_Mode));
		}

	explicit basic_stringbuf(const _Mystr& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));
		}

	basic_stringbuf(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Tidy();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mysb::swap(_Right);
			::std:: swap(_Seekhigh, _Right._Seekhigh);
			::std:: swap(_Mystate, _Right._Mystate);
			_Swap_adl(_Al, _Right._Al);
			}
		}

private:
		basic_stringbuf(const _Myt& _Right);	
		_Myt& operator=(const _Myt&);	
public:
	virtual ~basic_stringbuf() throw ()
		{	
		_Tidy();
		}

	enum
		{	
		_Allocated = 1,	
		_Constant = 2,	
		_Noread = 4,	
		_Append = 8,	
		_Atend = 16};	
	typedef int _Strstate;

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	_Mystr str() const
		{	
		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)
			{	
			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()
				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
			return (_Str);
			}
		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)
			{	
			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());
			return (_Str);
			}
		else
			{	
			_Mystr _Nul;
			return (_Nul);
			}
		}

	void str(const _Mystr& _Newstr)
		{	
		_Tidy();
		_Init(_Newstr.c_str(), _Newstr.size(), _Mystate);
		}

protected:
	virtual int_type overflow(int_type _Meta = _Traits::eof())
		{	
		if (_Mystate & _Constant)
			return (_Traits::eof());	
		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			return (_Traits::not_eof(_Meta));	

		if (_Mystate & _Append
			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)
			_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());

		if (_Mysb::pptr() != 0
			&& _Mysb::pptr() < _Mysb::epptr())
			{	
			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
			return (_Meta);
			}
		else
			{	
			size_t _Oldsize = _Mysb::pptr() == 0
				? 0 : _Mysb::epptr() - _Mysb::eback();
			size_t _Newsize = _Oldsize;
			size_t _Inc = _Newsize / 2 < _MINSIZE
				? _MINSIZE : _Newsize / 2;	

			while (0 < _Inc && 2147483647 - _Inc < _Newsize)
				_Inc /= 2;	
			if (_Inc == 0)
				return (_Traits::eof());	

			_Newsize += _Inc;

			_Elem *_Newptr = _Al.allocate(_Newsize);
			_Elem *_Oldptr = _Mysb::eback();

			if (0 < _Oldsize)
				_Traits::copy(_Newptr, _Oldptr, _Oldsize);

			if (_Oldsize == 0)
				{	
				_Seekhigh = _Newptr;
				_Mysb::setp(_Newptr, _Newptr + _Newsize);
				if (_Mystate & _Noread)
					_Mysb::setg(_Newptr, 0, _Newptr);
				else
					_Mysb::setg(_Newptr, _Newptr, _Newptr + 1);
				}
			else
				{	
				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);
				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),
					_Newptr + (_Mysb::pptr() - _Oldptr),
					_Newptr + _Newsize);
				if (_Mystate & _Noread)
					_Mysb::setg(_Newptr, 0, _Newptr);
				else
					_Mysb::setg(_Newptr,
						_Newptr + (_Mysb::gptr() - _Oldptr),
						_Mysb::pptr() + 1);
				}

			if (_Mystate & _Allocated)
				_Al.deallocate(_Oldptr, _Oldsize);
			_Mystate |= _Allocated;

			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
			return (_Meta);
			}
		}

	virtual int_type pbackfail(int_type _Meta = _Traits::eof())
		{	
		if (_Mysb::gptr() == 0
			|| _Mysb::gptr() <= _Mysb::eback()
			|| !_Traits::eq_int_type(_Traits::eof(), _Meta)
			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
			&& _Mystate & _Constant)
			return (_Traits::eof());	
		else
			{	
			_Mysb::gbump(-1);
			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
				*_Mysb::gptr() = _Traits::to_char_type(_Meta);
			return (_Traits::not_eof(_Meta));
			}
		}

	virtual int_type underflow()
		{	
		if (_Mysb::gptr() == 0)
			return (_Traits::eof());	
		else if (_Mysb::gptr() < _Mysb::egptr())
			return (_Traits::to_int_type(*_Mysb::gptr()));	
		else if (_Mystate & _Noread || _Mysb::pptr() == 0
			|| _Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr())
			return (_Traits::eof());	
		else
			{	
			if (_Seekhigh < _Mysb::pptr())
				_Seekhigh = _Mysb::pptr();
			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);
			return (_Traits::to_int_type(*_Mysb::gptr()));
			}
		}

	virtual pos_type seekoff(off_type _Off,
		ios_base::seekdir _Way,
		ios_base::openmode _Which = ios_base::in | ios_base::out)
		{	
		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
			_Seekhigh = _Mysb::pptr();	

		if (_Which & ios_base::in && _Mysb::gptr() != 0)
			{	
			if (_Way == ios_base::end)
				_Off += (off_type)(_Seekhigh - _Mysb::eback());
			else if (_Way == ios_base::cur
				&& (_Which & ios_base::out) == 0)
				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());
			else if (_Way != ios_base::beg)
				_Off = _BADOFF;

			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
				{	
				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
				if (_Which & ios_base::out && _Mysb::pptr() != 0)
					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
						_Mysb::epptr());	
				}
			else
				_Off = _BADOFF;
			}
		else if (_Which & ios_base::out && _Mysb::pptr() != 0)
			{	
			if (_Way == ios_base::end)
				_Off += (off_type)(_Seekhigh - _Mysb::eback());
			else if (_Way == ios_base::cur)
				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());
			else if (_Way != ios_base::beg)
				_Off = _BADOFF;

			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
				_Mysb::pbump((int)(_Mysb::eback()
					- _Mysb::pptr() + _Off));	
			else
				_Off = _BADOFF;
			}

 
		else if (_Off != 0)

 

#line 274 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sstream"

			_Off = _BADOFF;	
		return (pos_type(_Off));
		}

	virtual pos_type seekpos(pos_type _Ptr,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		streamoff _Off = (streamoff)_Ptr;
		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
			_Seekhigh = _Mysb::pptr();	

		if (_Off == _BADOFF)
			;
		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)
			{	
			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
				{	
				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
				if (_Mode & ios_base::out && _Mysb::pptr() != 0)
					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
						_Mysb::epptr());	
				}
			else
				_Off = _BADOFF;
			}
		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)
			{	
			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
				_Mysb::pbump((int)(_Mysb::eback()
					- _Mysb::pptr() + _Off));	
			else
				_Off = _BADOFF;
			}
		else
			_Off = _BADOFF;	
		return (streampos(_Off));
		}

	void _Init(const _Elem *_Ptr,
		size_t _Count, _Strstate _State)
		{	
		_Seekhigh = 0;
		_Mystate = _State;

		if (_Count != 0
			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
			{	
			_Elem *_Pnew = _Al.allocate(_Count);
			_Traits::copy(_Pnew, _Ptr, _Count);
			_Seekhigh = _Pnew + _Count;

			if (!(_Mystate & _Noread))
				_Mysb::setg(_Pnew, _Pnew,
					_Pnew + _Count);	
			if (!(_Mystate & _Constant))
				{	
				_Mysb::setp(_Pnew,
					(_Mystate & _Atend) ? _Pnew + _Count : _Pnew,
					_Pnew + _Count);
				if (_Mysb::gptr() == 0)
					_Mysb::setg(_Pnew, 0, _Pnew);
				}
			_Mystate |= _Allocated;
			}
		}

	void _Tidy()
		{	
		if (_Mystate & _Allocated)
			_Al.deallocate(_Mysb::eback(),
				(_Mysb::pptr() != 0 ? _Mysb::epptr()
					: _Mysb::egptr()) - _Mysb::eback());
		_Mysb::setg(0, 0, 0);
		_Mysb::setp(0, 0);
		_Seekhigh = 0;
		_Mystate &= ~_Allocated;
		}

private:
	enum
		{	
		_MINSIZE = 32};

	_Strstate _Getstate(ios_base::openmode _Mode)
		{	
		_Strstate _State = (_Strstate)0;
		if (!(_Mode & ios_base::in))
			_State |= _Noread;
		if (!(_Mode & ios_base::out))
			_State |= _Constant;
		if (_Mode & ios_base::app)
			_State |= _Append;
		if (_Mode & ios_base::ate)
			_State |= _Atend;
		return (_State);
		}

	_Elem *_Seekhigh;	
	_Strstate _Mystate;	
	allocator_type _Al;	
	};

	
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_istringstream
		: public basic_istream<_Elem, _Traits>
	{	
public:
	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
	typedef basic_istream<_Elem, _Traits> _Mybase;
	typedef _Alloc allocator_type;
	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;

	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Mode | ios_base::in)
		{	
		}

	explicit basic_istringstream(const _Mystr& _Str,
		ios_base::openmode _Mode = ios_base::in)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Str, _Mode | ios_base::in)
		{	
		}

	basic_istringstream(_Myt&& _Right)
		: _Mybase(&_Stringbuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Stringbuffer.str(_Mystr());
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Stringbuffer.swap(_Right._Stringbuffer);
			}
		}

private:
		basic_istringstream(const _Myt& _Right);	
		_Myt& operator=(const _Myt&);	
public:
	virtual ~basic_istringstream() throw ()
		{	
		}

	_Mysb *rdbuf() const
		{	
		return ((_Mysb *)&_Stringbuffer);
		}

	_Mystr str() const
		{	
		return (_Stringbuffer.str());
		}

	void str(const _Mystr& _Newstr)
		{	
		_Stringbuffer.str(_Newstr);
		}

private:
	_Mysb _Stringbuffer;	
	};

	
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_ostringstream
		: public basic_ostream<_Elem, _Traits>
	{	
public:
	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
	typedef basic_ostream<_Elem, _Traits> _Mybase;
	typedef _Alloc allocator_type;
	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;

	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Mode | ios_base::out)
		{	
		}

	explicit basic_ostringstream(const _Mystr& _Str,
		ios_base::openmode _Mode = ios_base::out)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Str, _Mode | ios_base::out)
		{	
		}

	basic_ostringstream(_Myt&& _Right)
		: _Mybase(&_Stringbuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Stringbuffer.str(_Mystr());
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Stringbuffer.swap(_Right._Stringbuffer);
			}
		}

private:
		basic_ostringstream(const _Myt& _Right);	
		_Myt& operator=(const _Myt&);	
public:
	virtual ~basic_ostringstream() throw ()
		{	
		}

	_Mysb *rdbuf() const
		{	
		return ((_Mysb *)&_Stringbuffer);
		}

	_Mystr str() const
		{	
		return (_Stringbuffer.str());
		}

	void str(const _Mystr& _Newstr)
		{	
		_Stringbuffer.str(_Newstr);
		}

private:
	_Mysb _Stringbuffer;	
	};

	
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left,
		basic_ostringstream<_Elem, _Traits, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_stringstream
		: public basic_iostream<_Elem, _Traits>
	{	
public:
	typedef basic_stringstream<_Elem, _Traits, _Alloc> _Myt;
	typedef basic_iostream<_Elem, _Traits> _Mybase;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef _Alloc allocator_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;
	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;

	explicit basic_stringstream(ios_base::openmode _Mode =
		ios_base::in | ios_base::out)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Mode)
		{	
		}

	explicit basic_stringstream(const _Mystr& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Str, _Mode)
		{	
		}

	basic_stringstream(_Myt&& _Right)
		: _Mybase(&_Stringbuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Stringbuffer.str(_Mystr());
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Stringbuffer.swap(_Right._Stringbuffer);
			}
		}

private:
		basic_stringstream(const _Myt& _Right);	
		_Myt& operator=(const _Myt&);	
public:
	virtual ~basic_stringstream() throw ()
		{	
		}

	_Mysb *rdbuf() const
		{	
		return ((_Mysb *)&_Stringbuffer);
		}

	_Mystr str() const
		{	
		return (_Stringbuffer.str());
		}

	void str(const _Mystr& _Newstr)
		{	
		_Stringbuffer.str(_Newstr);
		}

private:
	_Mysb _Stringbuffer;	
	};

	
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_stringstream<_Elem, _Traits, _Alloc>& _Left,
		basic_stringstream<_Elem, _Traits, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 679 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sstream"
#line 680 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\sstream"





#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\complex"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4244)


 
  

typedef struct _C_double_complex
	{	
	double _Val[2];
	} _C_double_complex;

typedef struct _C_float_complex
	{	
	float _Val[2];
	} _C_float_complex;

typedef struct _C_ldouble_complex
	{	
	long double _Val[2];
	} _C_ldouble_complex;
 #line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\complex"


	
 
 

namespace std {
typedef :: _C_double_complex _Dcomplex_value;
typedef :: _C_float_complex _Fcomplex_value;
typedef :: _C_ldouble_complex _Lcomplex_value;

template<class _Ty>
	class complex;
template<>
	class complex<float>;
template<>
	class complex<double>;
template<>
	class complex<long double>;

		
template<class _Ty>
	class _Ctraits
	{	
public:
	static _Ty _Flt_eps()
		{	
		return (numeric_limits<_Ty>::epsilon());
		}

	static _Ty _Flt_max()
		{	
		return ((numeric_limits<_Ty>::max)());
		}

	static _Ty _Cosh(_Ty _Left, _Ty _Right)
		{	
		return (:: _Cosh((double)_Left, (double)_Right));
		}

	static short _Exp(_Ty *_Pleft, _Ty _Right, short _Exponent)
		{	
		double _Tmp = (double)*_Pleft;
		short _Ans = :: _Exp(&_Tmp, (double)_Right, _Exponent);
		*_Pleft = (_Ty)_Tmp;
		return (_Ans);
		}

	static _Ty _Infv(_Ty)
		{	
		return (:: _Inf._Double);
		}

	static bool _Isinf(_Ty _Left)
		{	
		double _Tmp = (double)_Left;
		return (:: _Dtest(&_Tmp) == 1);
		}

	static bool _Isnan(_Ty _Left)
		{	
		double _Tmp = (double)_Left;
		return (:: _Dtest(&_Tmp) == 2);
		}

	static _Ty _Nanv(_Ty)
		{	
		return (:: _Nan._Double);
		}

	static _Ty _Sinh(_Ty _Left, _Ty _Right)
		{	
		return (:: _Sinh((double)_Left, (double)_Right));
		}

	static _Ty asinh(_Ty _Left)
		{	
		static const _Ty _Ln2 = 0.69314718055994530941723212145817658L;

		bool _Neg = _Left < 0;
		_Ty _Ans;

		if (_Neg)
			_Left = -_Left;
		if (_Left < 2 / _Flt_eps())
			_Ans = log1p(_Left
				+ _Left * _Left / (1 + sqrt(_Left * _Left + 1)));
		else
			_Ans = log(_Left) + _Ln2;
		return (_Neg ? -_Ans : _Ans);
		}

	static _Ty atan2(_Ty _Yval, _Ty _Xval)
		{	
		return (:: atan2((double)_Yval, (double)_Xval));
		}

	static _Ty cos(_Ty _Left)
		{	
		return (:: cos((double)_Left));
		}

	static _Ty exp(_Ty _Left)
		{	
		return (:: exp((double)_Left));
		}

	static _Ty ldexp(_Ty _Left, int _Exponent)
		{	
		return (:: ldexp((double)_Left, _Exponent));
		}

	static _Ty log(_Ty _Left)
		{	
		return (:: log((double)_Left));
		}

	static _Ty log1p(_Ty _Left)
		{	
		if (_Left < -1)
			return (_Nanv(_Left));
		else if (_Left == 0)
			return (_Left);
		else
			{	
			_Ty _Leftp1 = 1 + _Left;
			return (log(_Leftp1) - ((_Leftp1 - 1) - _Left) / _Leftp1);
			}
		}

	static _Ty pow(_Ty _Left, _Ty _Right)
		{	
		return (:: pow((double)_Left, (double)_Right));
		}

	static _Ty sin(_Ty _Left)
		{	
		return (:: sin((double)_Left));
		}

	static _Ty sqrt(_Ty _Left)
		{	
		return (:: sqrt((double)_Left));
		}

	static _Ty tan(_Ty _Left)
		{	
		return (:: tan((double)_Left));
		}
	};

		
template<>
	class _Ctraits<long double>
	{	
public:
	typedef long double _Ty;

	static _Ty _Flt_eps()
		{	
		return (2.2204460492503131e-016);
		}

	static _Ty _Flt_max()
		{	
		return (1.7976931348623158e+308);
		}

	static _Ty _Cosh(_Ty _Left, _Ty _Right)
		{	
		return (:: _LCosh(_Left, _Right));
		}

	static short _Exp(_Ty *_Pleft, _Ty _Right, short _Exponent)
		{	
		return (:: _LExp(_Pleft, _Right, _Exponent));
		}

	static _Ty _Infv(_Ty)
		{	
		return (:: _LInf._Long_double);
		}

	static bool _Isinf(_Ty _Left)
		{	
		return (:: _LDtest(&_Left) == 1);
		}

	static bool _Isnan(_Ty _Left)
		{	
		return (:: _LDtest(&_Left) == 2);
		}

	static _Ty _Nanv(_Ty)
		{	
		return (:: _LNan._Long_double);
		}

	static _Ty _Sinh(_Ty _Left, _Ty _Right)
		{	
		return (:: _LSinh(_Left, _Right));
		}

	static _Ty asinh(_Ty _Left)
		{	
		static const _Ty _Ln2 = 0.69314718055994530941723212145817658L;

		bool _Neg = _Left < 0;
		_Ty _Ans;

		if (_Neg)
			_Left = -_Left;
		if (_Left < 2 / _Flt_eps())
			_Ans = log1p(_Left
				+ _Left * _Left / (1 + sqrt(_Left * _Left + 1)));
		else
			_Ans = log(_Left) + _Ln2;
		return (_Neg ? -_Ans : _Ans);
		}

	static _Ty atan2(_Ty _Yval, _Ty _Xval)
		{	
		return (:: atan2l(_Yval, _Xval));
		}

	static _Ty cos(_Ty _Left)
		{	
		return (:: cosl(_Left));
		}

	static _Ty exp(_Ty _Left)
		{	
		return (:: expl(_Left));
		}

	static _Ty ldexp(_Ty _Left, int _Exponent)
		{	
		return (:: ldexpl(_Left, _Exponent));
		}

	static _Ty log(_Ty _Left)
		{	
		return (:: logl(_Left));
		}

	static _Ty log1p(_Ty _Left)
		{	
		if (_Left < -1)
			return (_Nanv(_Left));
		else if (_Left == 0)
			return (_Left);
		else
			{	
			_Ty _Leftp1 = 1 + _Left;
			return (log(_Leftp1) - ((_Leftp1 - 1) - _Left) / _Leftp1);
			}
		}

	static _Ty pow(_Ty _Left, _Ty _Right)
		{	
		return (:: powl(_Left, _Right));
		}

	static _Ty sin(_Ty _Left)
		{	
		return (:: sinl(_Left));
		}

	static _Ty sqrt(_Ty _Left)
		{	
		return (:: sqrtl(_Left));
		}

	static _Ty tan(_Ty _Left)
		{	
		return (:: tanl(_Left));
		}
	};

		
template<>
	class _Ctraits<double>
	{	
public:
	typedef double _Ty;

	static _Ty _Flt_eps()
		{	
		return (2.2204460492503131e-016);
		}

	static _Ty _Flt_max()
		{	
		return (1.7976931348623158e+308);
		}

	static _Ty _Cosh(_Ty _Left, _Ty _Right)
		{	
		return (:: _Cosh(_Left, _Right));
		}

	static short _Exp(_Ty *_Pleft, _Ty _Right, short _Exponent)
		{	
		return (:: _Exp(_Pleft, _Right, _Exponent));
		}

	static _Ty _Infv(_Ty)
		{	
		return (:: _Inf._Double);
		}

	static bool _Isinf(_Ty _Left)
		{	
		return (:: _Dtest(&_Left) == 1);
		}

	static bool _Isnan(_Ty _Left)
		{	
		return (:: _Dtest(&_Left) == 2);
		}

	static _Ty _Nanv(_Ty)
		{	
		return (:: _Nan._Double);
		}

	static _Ty _Sinh(_Ty _Left, _Ty _Right)
		{	
		return (:: _Sinh(_Left, _Right));
		}

	static _Ty asinh(_Ty _Left)
		{	
		if (_Isnan(_Left) || _Isinf(_Left) || _Left == 0)
			return (0);
		else
			{	
			bool _Neg = _Left < 0;
			_Ty _Ans;

			if (_Neg)
				_Left = -_Left;
			if (_Left < 2 / _Flt_eps())
				_Ans = log1p(_Left
					+ _Left * _Left / (1 + sqrt(_Left * _Left + 1)));
			else
				_Ans = log(_Left)	
					+ (_Ty)0.69314718055994530941723212145817658L;
			return (_Neg ? -_Ans : _Ans);
			}
		}

	static _Ty atan2(_Ty _Yval, _Ty _Xval)
		{	
		return (:: atan2(_Yval, _Xval));
		}

	static _Ty cos(_Ty _Left)
		{	
		return (:: cos(_Left));
		}

	static _Ty exp(_Ty _Left)
		{	
		return (:: exp(_Left));
		}

	static _Ty ldexp(_Ty _Left, int _Exponent)
		{	
		return (:: ldexp(_Left, _Exponent));
		}

	static _Ty log(_Ty _Left)
		{	
		return (:: log(_Left));
		}

	static _Ty log1p(_Ty _Left)
		{	
		if (_Isnan(_Left) || _Left == 0 || _Isinf(_Left) && 0 < _Left)
			return (_Left);
		else if (_Left < -1)
			return (_Nanv(_Left));
		else if (_Left == -1)
			return (-_Infv(_Left));
		else if (_Left == 0)
			return (_Left);
		else
			{	
			_Ty _Leftp1 = 1 + _Left;
			return (log(_Leftp1) - ((_Leftp1 - 1) - _Left) / _Leftp1);
			}
		}

	static _Ty pow(_Ty _Left, _Ty _Right)
		{	
		return (:: pow(_Left, _Right));
		}

	static _Ty sin(_Ty _Left)
		{	
		return (:: sin(_Left));
		}

	static _Ty sqrt(_Ty _Left)
		{	
		return (:: sqrt(_Left));
		}

	static _Ty tan(_Ty _Left)
		{	
		return (:: tan(_Left));
		}
	};

		
template<>
	class _Ctraits<float>
	{	
public:
	typedef float _Ty;

	static _Ty _Flt_eps()
		{	
		return (1.192092896e-07F);
		}

	static _Ty _Flt_max()
		{	
		return (3.402823466e+38F);
		}

	static _Ty _Cosh(_Ty _Left, _Ty _Right)
		{	
		return (:: _FCosh(_Left, _Right));
		}

	static short _Exp(_Ty *_Pleft, _Ty _Right, short _Exponent)
		{	
		return (:: _FExp(_Pleft, _Right, _Exponent));
		}

	static _Ty _Infv(_Ty)
		{	
		return (:: _FInf._Float);
		}

	static bool _Isinf(_Ty _Left)
		{	
		return (:: _FDtest(&_Left) == 1);
		}

	static bool _Isnan(_Ty _Left)
		{	
		return (:: _FDtest(&_Left) == 2);
		}

	static _Ty _Nanv(_Ty)
		{	
		return (:: _FNan._Float);
		}

	static _Ty _Sinh(_Ty _Left, _Ty _Right)
		{	
		return (:: _FSinh(_Left, _Right));
		}

	static _Ty asinh(_Ty _Left)
		{	
		static const _Ty _Ln2 = 0.69314718055994530941723212145817658F;

		bool _Neg = _Left < 0;
		_Ty _Ans;

		if (_Neg)
			_Left = -_Left;
		if (_Left < 2 / _Flt_eps())
			_Ans = log1p(_Left
				+ _Left * _Left / (1 + sqrt(_Left * _Left + 1)));
		else
			_Ans = log(_Left) + _Ln2;
		return (_Neg ? -_Ans : _Ans);
		}

	static _Ty atan2(_Ty _Yval, _Ty _Xval)
		{	
		return (:: atan2f(_Yval, _Xval));
		}

	static _Ty cos(_Ty _Left)
		{	
		return (:: cosf(_Left));
		}

	static _Ty exp(_Ty _Left)
		{	
		return (:: expf(_Left));
		}

	static _Ty ldexp(_Ty _Left, int _Exponent)
		{	
		return (:: ldexpf(_Left, _Exponent));
		}

	static _Ty log(_Ty _Left)
		{	
		return (:: logf(_Left));
		}

	static _Ty log1p(_Ty _Left)
		{	
		if (_Left < -1)
			return (_Nanv(_Left));
		else if (_Left == 0)
			return (_Left);
		else
			{	
			_Ty _Leftp1 = 1 + _Left;
			return (log(_Leftp1) - ((_Leftp1 - 1) - _Left) / _Leftp1);
			}
		}

	static _Ty pow(_Ty _Left, _Ty _Right)
		{	
		return (:: powf(_Left, _Right));
		}

	static _Ty sin(_Ty _Left)
		{	
		return (:: sinf(_Left));
		}

	static _Ty sqrt(_Ty _Left)
		{	
		return (:: sqrtf(_Left));
		}

	static _Ty tan(_Ty _Left)
		{	
		return (:: tanf(_Left));
		}
	};

		
template<class _Ty>
	struct _Complex_value
	{	
	enum {_Re = 0, _Im = 1};
	_Ty _Val[2];
	};

		
template<class _Ty,
	class _Valbase>
	class _Complex_base
		: public _Valbase
	{	
public:
	typedef _Ctraits<_Ty> _Myctraits;
	typedef _Complex_base<_Ty, _Valbase> _Myt;
	typedef _Ty value_type;

	_Complex_base(const _Ty& _Realval, const _Ty& _Imagval)
		{	
		this->_Val[0] = _Realval;
		this->_Val[1] = _Imagval;
		}

	_Ty real(const _Ty& _Right)
		{	
		return (this->_Val[0] = _Right);
		}

	_Ty imag(const _Ty& _Right)
		{	
		return (this->_Val[1] = _Right);
		}

	_Ty real() const
		{	
		return (this->_Val[0]);
		}

	_Ty imag() const
		{	
		return (this->_Val[1]);
		}

protected:
	template<class _Other> inline
		void _Add(const complex<_Other>& _Right)
		{	
		this->_Val[0] = this->_Val[0] + (_Ty)_Right.real();
		this->_Val[1] = this->_Val[1] + (_Ty)_Right.imag();
		}

	template<class _Other> inline
		void _Sub(const complex<_Other>& _Right)
		{	
		this->_Val[0] = this->_Val[0] - (_Ty)_Right.real();
		this->_Val[1] = this->_Val[1] - (_Ty)_Right.imag();
		}

	template<class _Other> inline
		void _Mul(const complex<_Other>& _Right)
		{	
		_Ty _Rightreal = (_Ty)_Right.real();
		_Ty _Rightimag = (_Ty)_Right.imag();

		_Ty _Tmp = this->_Val[0] * _Rightreal
			- this->_Val[1] * _Rightimag;
		this->_Val[1] = this->_Val[0] * _Rightimag
			+ this->_Val[1] * _Rightreal;
		this->_Val[0] = _Tmp;
		}

	template<class _Other> inline
		void _Div(const complex<_Other>& _Right)
		{	
		typedef _Ctraits<_Ty> _Myctraits;
		_Ty _Rightreal = (_Ty)_Right.real();
		_Ty _Rightimag = (_Ty)_Right.imag();

		if (_Myctraits::_Isnan(_Rightreal) || _Myctraits::_Isnan(_Rightimag))
			{	
			this->_Val[0] = _Myctraits::_Nanv(_Rightreal);
			this->_Val[1] = this->_Val[0];
			}
		else if ((_Rightimag < 0 ? -_Rightimag : +_Rightimag)
			< (_Rightreal < 0 ? -_Rightreal : +_Rightreal))
			{	
			_Ty _Wr = _Rightimag / _Rightreal;
			_Ty _Wd = _Rightreal + _Wr * _Rightimag;

			if (_Myctraits::_Isnan(_Wd) || _Wd == 0)
				{	
				this->_Val[0] = _Myctraits::_Nanv(_Rightreal);
				this->_Val[1] = this->_Val[0];
				}
			else
				{	
				_Ty _Tmp = (this->_Val[0]
					+ this->_Val[1] * _Wr) / _Wd;
				this->_Val[1] = (this->_Val[1]
					- this->_Val[0] * _Wr) / _Wd;
				this->_Val[0] = _Tmp;
				}
			}
		else if (_Rightimag == 0)
			{	
			this->_Val[0] = _Myctraits::_Nanv(_Rightreal);
			this->_Val[1] = this->_Val[0];
			}
		else
			{	
			_Ty _Wr = _Rightreal / _Rightimag;
			_Ty _Wd = _Rightimag + _Wr * _Rightreal;

			if (_Myctraits::_Isnan(_Wd) || _Wd == 0)
				{	
				this->_Val[0] = _Myctraits::_Nanv(_Rightreal);
				this->_Val[1] = this->_Val[0];
				}
			else
				{	
				_Ty _Tmp = (this->_Val[0] * _Wr + this->_Val[1]) / _Wd;
				this->_Val[1] = (this->_Val[1] * _Wr
					- this->_Val[0]) / _Wd;
				this->_Val[0] = _Tmp;
				}
			}
		}
	};

		
template<>
	class complex<float>
	: public _Complex_base<float, _Fcomplex_value>
	{	
public:
	typedef float _Ty;
	typedef complex<_Ty> _Myt;

	explicit complex(
		const complex<double>&);	
	explicit complex(
		const complex<long double>&);	

	complex(const _Ty& _Realval = 0,
		const _Ty& _Imagval = 0)
		: _Complex_base<float, _Fcomplex_value>(_Realval, _Imagval)
		{	
		}

	complex(const _Fcomplex_value& _Right)
		: _Complex_base<float, _Fcomplex_value>(_Right._Val[0],
			_Right._Val[1])
		{	
		}

	complex(const _Dcomplex_value& _Right)
		: _Complex_base<float, _Fcomplex_value>(_Right._Val[0],
			_Right._Val[1])
		{	
		}

	complex(const _Lcomplex_value& _Right)
		: _Complex_base<float, _Fcomplex_value>(_Right._Val[0],
			_Right._Val[1])
		{	
		}

	complex<_Ty>& operator=(const _Ty& _Right)
		{	
		_Val[0] = _Right;
		_Val[1] = 0;
		return (*this);
		}

	_Myt& operator+=(const _Ty& _Right)
		{	
		_Val[0] = _Val[0] + _Right;
		return (*this);
		}

	_Myt& operator-=(const _Ty& _Right)
		{	
		_Val[0] = _Val[0] - _Right;
		return (*this);
		}

	_Myt& operator*=(const _Ty& _Right)
		{	
		_Val[0] = _Val[0] * _Right;
		_Val[1] = _Val[1] * _Right;
		return (*this);
		}

	_Myt& operator/=(const _Ty& _Right)
		{	
		_Val[0] = _Val[0] / _Right;
		_Val[1] = _Val[1] / _Right;
		return (*this);
		}

	_Myt& operator+=(const _Myt& _Right)
		{	
		this->_Add(_Right);
		return (*this);
		}

	_Myt& operator-=(const _Myt& _Right)
		{	
		this->_Sub(_Right);
		return (*this);
		}

	_Myt& operator*=(const _Myt& _Right)
		{	
		this->_Mul(_Right);
		return (*this);
		}

	_Myt& operator/=(const _Myt& _Right)
		{	
		this->_Div(_Right);
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator=(const complex<_Other>& _Right)
		{	
		_Val[0] = (_Ty)_Right._Val[0];
		_Val[1] = (_Ty)_Right._Val[1];
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator+=(const complex<_Other>& _Right)
		{	
		this->_Add(_Right);
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator-=(const complex<_Other>& _Right)
		{	
		this->_Sub(_Right);
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator*=(const complex<_Other>& _Right)
		{	
		this->_Mul(_Right);
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator/=(const complex<_Other>& _Right)
		{	
		this->_Div(_Right);
		return (*this);
		}
	};

		
template<>
	class complex<double>
	: public _Complex_base<double, _Dcomplex_value>
	{	
public:
	typedef double _Ty;
	typedef complex<_Ty> _Myt;

	complex(
		const complex<float>&);	
	explicit complex(
		const complex<long double>&);	

	complex(const _Ty& _Realval = 0,
		const _Ty& _Imagval = 0)
		: _Complex_base<double, _Dcomplex_value>(_Realval, _Imagval)
		{	
		}

	complex(const _Dcomplex_value& _Right)
		: _Complex_base<double, _Dcomplex_value>(_Right._Val[0],
			_Right._Val[1])
		{	
		}

	complex(const _Lcomplex_value& _Right)
		: _Complex_base<double, _Dcomplex_value>(_Right._Val[0],
			_Right._Val[1])
		{	
		}

	complex<_Ty>& operator=(const _Ty& _Right)
		{	
		_Val[0] = _Right;
		_Val[1] = 0;
		return (*this);
		}

	_Myt& operator+=(const _Ty& _Right)
		{	
		_Val[0] = _Val[0] + _Right;
		return (*this);
		}

	_Myt& operator-=(const _Ty& _Right)
		{	
		_Val[0] = _Val[0] - _Right;
		return (*this);
		}

	_Myt& operator*=(const _Ty& _Right)
		{	
		_Val[0] = _Val[0] * _Right;
		_Val[1] = _Val[1] * _Right;
		return (*this);
		}

	_Myt& operator/=(const _Ty& _Right)
		{	
		_Val[0] = _Val[0] / _Right;
		_Val[1] = _Val[1] / _Right;
		return (*this);
		}

	_Myt& operator+=(const _Myt& _Right)
		{	
		this->_Add(_Right);
		return (*this);
		}

	_Myt& operator-=(const _Myt& _Right)
		{	
		this->_Sub(_Right);
		return (*this);
		}

	_Myt& operator*=(const _Myt& _Right)
		{	
		this->_Mul(_Right);
		return (*this);
		}

	_Myt& operator/=(const _Myt& _Right)
		{	
		this->_Div(_Right);
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator=(const complex<_Other>& _Right)
		{	
		_Val[0] = (_Ty)_Right._Val[0];
		_Val[1] = (_Ty)_Right._Val[1];
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator+=(const complex<_Other>& _Right)
		{	
		this->_Add(_Right);
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator-=(const complex<_Other>& _Right)
		{	
		this->_Sub(_Right);
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator*=(const complex<_Other>& _Right)
		{	
		this->_Mul(_Right);
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator/=(const complex<_Other>& _Right)
		{	
		this->_Div(_Right);
		return (*this);
		}
	};

		
template<>
	class complex<long double>
	: public _Complex_base<long double, _Lcomplex_value>
	{	
public:
	typedef long double _Ty;
	typedef complex<_Ty> _Myt;

	complex(
		const complex<float>&);	
	complex(
		const complex<double>&);	

	complex(const _Ty& _Realval = 0,
		const _Ty& _Imagval = 0)
		: _Complex_base<long double, _Lcomplex_value>(_Realval, _Imagval)
		{	
		}

	complex(const _Lcomplex_value& _Right)
		: _Complex_base<long double, _Lcomplex_value>(_Right._Val[0],
			_Right._Val[1])
		{	
		}

	complex<_Ty>& operator=(const _Ty& _Right)
		{	
		_Val[0] = _Right;
		_Val[1] = 0;
		return (*this);
		}

	_Myt& operator+=(const _Ty& _Right)
		{	
		_Val[0] = _Val[0] + _Right;
		return (*this);
		}

	_Myt& operator-=(const _Ty& _Right)
		{	
		_Val[0] = _Val[0] - _Right;
		return (*this);
		}

	_Myt& operator*=(const _Ty& _Right)
		{	
		_Val[0] = _Val[0] * _Right;
		_Val[1] = _Val[1] * _Right;
		return (*this);
		}

	_Myt& operator/=(const _Ty& _Right)
		{	
		_Val[0] = _Val[0] / _Right;
		_Val[1] = _Val[1] / _Right;
		return (*this);
		}

	_Myt& operator+=(const _Myt& _Right)
		{	
		this->_Add(_Right);
		return (*this);
		}

	_Myt& operator-=(const _Myt& _Right)
		{	
		this->_Sub(_Right);
		return (*this);
		}

	_Myt& operator*=(const _Myt& _Right)
		{	
		this->_Mul(_Right);
		return (*this);
		}

	_Myt& operator/=(const _Myt& _Right)
		{	
		this->_Div(_Right);
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator=(const complex<_Other>& _Right)
		{	
		_Val[0] = (_Ty)_Right._Val[0];
		_Val[1] = (_Ty)_Right._Val[1];
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator+=(const complex<_Other>& _Right)
		{	
		this->_Add(_Right);
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator-=(const complex<_Other>& _Right)
		{	
		this->_Sub(_Right);
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator*=(const complex<_Other>& _Right)
		{	
		this->_Mul(_Right);
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator/=(const complex<_Other>& _Right)
		{	
		this->_Div(_Right);
		return (*this);
		}
	};

		
inline complex<float>::complex(
	const complex<double>& _Right)
		: _Complex_base<float, _Fcomplex_value>(
			(_Ty)_Right.real(), (_Ty)_Right.imag())
	{	
	}

inline complex<float>::complex(
	const complex<long double>& _Right)
		: _Complex_base<float, _Fcomplex_value>(
			(_Ty)_Right.real(), (_Ty)_Right.imag())
	{	
	}

inline complex<double>::complex(
	const complex<float>& _Right)
		: _Complex_base<double, _Dcomplex_value>(
			(_Ty)_Right.real(), (_Ty)_Right.imag())
	{	
	}

inline complex<double>::complex(
	const complex<long double>& _Right)
		: _Complex_base<double, _Dcomplex_value>(
			(_Ty)_Right.real(), (_Ty)_Right.imag())
	{	
	}

inline complex<long double>::complex(
	const complex<float>& _Right)
		: _Complex_base<long double, _Lcomplex_value>(
			(_Ty)_Right.real(), (_Ty)_Right.imag())
	{	
	}

inline complex<long double>::complex(
	const complex<double>& _Right)
		: _Complex_base<long double, _Lcomplex_value>(
			(_Ty)_Right.real(), (_Ty)_Right.imag())
	{	
	}

		
template<class _Ty>
	class complex
		: public _Complex_base<_Ty, _Complex_value<_Ty> >
	{	
public:
	typedef complex<_Ty> _Myt;
	typedef _Complex_base<_Ty, _Complex_value<_Ty> > _Mybase;

	complex(const _Ty& _Realval = _Ty(), const _Ty& _Imagval = _Ty())
		: _Mybase(_Realval, _Imagval)
		{	
		}

	_Myt& operator=(const _Ty& _Right)
		{	
		this->_Val[0] = _Right;
		this->_Val[1] = _Ty();
		return (*this);
		}

	template<class _Other>
		complex(const complex<_Other>& _Right)
		: _Mybase((_Ty)_Right.real(), (_Ty)_Right.imag())
		{	
		}

	template<class _Other>
		_Myt& operator=(const complex<_Other>& _Right)
		{	
		this->_Val[0] = (_Ty)_Right.real();
		this->_Val[1] = (_Ty)_Right.imag();
		return (*this);
		}

	_Myt& operator+=(const _Ty& _Right)
		{	
		this->_Val[0] = this->_Val[0] + _Right;
		return (*this);
		}

	_Myt& operator-=(const _Ty& _Right)
		{	
		this->_Val[0] = this->_Val[0] - _Right;
		return (*this);
		}

	_Myt& operator*=(const _Ty& _Right)
		{	
		this->_Val[0] = this->_Val[0] * _Right;
		this->_Val[1] = this->_Val[1] * _Right;
		return (*this);
		}

	_Myt& operator/=(const _Ty& _Right)
		{	
		this->_Val[0] = this->_Val[0] / _Right;
		this->_Val[1] = this->_Val[1] / _Right;
		return (*this);
		}

	_Myt& operator+=(const _Myt& _Right)
		{	
		this->_Add(_Right);
		return (*this);
		}

	_Myt& operator-=(const _Myt& _Right)
		{	
		this->_Sub(_Right);
		return (*this);
		}

	_Myt& operator*=(const _Myt& _Right)
		{	
		this->_Mul(_Right);
		return (*this);
		}

	_Myt& operator/=(const _Myt& _Right)
		{	
		this->_Div(_Right);
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator+=(const complex<_Other>& _Right)
		{	
		this->_Add(_Right);
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator-=(const complex<_Other>& _Right)
		{	
		this->_Sub(_Right);
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator*=(const complex<_Other>& _Right)
		{	
		this->_Mul(_Right);
		return (*this);
		}

	template<class _Other> inline
		_Myt& operator/=(const complex<_Other>& _Right)
		{	
		this->_Div(_Right);
		return (*this);
		}
	};

 
 
 
 #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xcomplex"



		
template<class _Ty > inline
	complex<_Ty > operator+(const complex<_Ty >& _Left,
		const complex<_Ty >& _Right)
	{	
	complex<_Ty > _Tmp(_Left);
	return (_Tmp += _Right);
	}

template<class _Ty > inline
	complex<_Ty > operator+(const complex<_Ty >& _Left,
		const _Ty& _Right)
	{	
	complex<_Ty > _Tmp(_Left);
	_Tmp.real(_Tmp.real() + _Right);
	return (_Tmp);
	}

template<class _Ty > inline
	complex<_Ty > operator+(const _Ty& _Left,
		const complex<_Ty >& _Right)
	{	
	complex<_Ty > _Tmp(_Left);
	return (_Tmp += _Right);
	}

		
template<class _Ty > inline
	complex<_Ty > operator-(const complex<_Ty >& _Left,
		const complex<_Ty >& _Right)
	{	
	complex<_Ty > _Tmp(_Left);
	return (_Tmp -= _Right);
	}

template<class _Ty > inline
	complex<_Ty > operator-(const complex<_Ty >& _Left,
		const _Ty& _Right)
	{	
	complex<_Ty > _Tmp(_Left);
	_Tmp.real(_Tmp.real() - _Right);
	return (_Tmp);
	}

template<class _Ty > inline
	complex<_Ty > operator-(const _Ty& _Left,
		const complex<_Ty >& _Right)
	{	
	complex<_Ty > _Tmp(_Left);
	return (_Tmp -= _Right);
	}

		
template<class _Ty > inline
	complex<_Ty > operator*(const complex<_Ty >& _Left,
		const complex<_Ty >& _Right)
	{	
	complex<_Ty > _Tmp(_Left);
	return (_Tmp *= _Right);
	}

template<class _Ty > inline
	complex<_Ty > operator*(const complex<_Ty >& _Left,
		const _Ty& _Right)
	{	
	complex<_Ty > _Tmp(_Left);
	_Tmp.real(_Tmp.real() * _Right);
	_Tmp.imag(_Tmp.imag() * _Right);
	return (_Tmp);
	}

template<class _Ty > inline
	complex<_Ty > operator*(const _Ty& _Left,
		const complex<_Ty >& _Right)
	{	
	complex<_Ty > _Tmp(_Left);
	return (_Tmp *= _Right);
	}

		
template<class _Ty > inline
	complex<_Ty > operator/(const complex<_Ty >& _Left,
		const complex<_Ty >& _Right)
	{	
	complex<_Ty > _Tmp(_Left);
	return (_Tmp /= _Right);
	}

template<class _Ty > inline
	complex<_Ty > operator/(const complex<_Ty >& _Left,
		const _Ty& _Right)
	{	
	complex<_Ty > _Tmp(_Left);
	_Tmp.real(_Tmp.real() / _Right);
	_Tmp.imag(_Tmp.imag() / _Right);
	return (_Tmp);
	}

template<class _Ty > inline
	complex<_Ty > operator/(const _Ty& _Left,
		const complex<_Ty >& _Right)
	{	
	complex<_Ty > _Tmp(_Left);
	return (_Tmp /= _Right);
	}

		
template<class _Ty > inline
	complex<_Ty > operator+(const complex<_Ty >& _Left)
	{	
	return (complex<_Ty >(_Left));
	}

		
template<class _Ty > inline
	complex<_Ty > operator-(const complex<_Ty >& _Left)
	{	
	return (complex<_Ty >(-_Left.real(), -_Left.imag()));
	}

		
template<class _Ty > inline
	bool operator==(const complex<_Ty >& _Left,
		const complex<_Ty >& _Right)
	{	
	return (_Left.real() == _Right.real()
		&& _Left.imag() == _Right.imag());
	}

template<class _Ty > inline
	bool operator==(const complex<_Ty >& _Left,
		const _Ty& _Right)
	{	
	return (_Left.real() == _Right
		&& _Left.imag() == 0);
	}

template<class _Ty > inline
	bool operator==(const _Ty& _Left,
		const complex<_Ty >& _Right)
	{	
	return (_Left == _Right.real()
		&& 0 == _Right.imag());
	}

		
template<class _Ty > inline
	bool operator!=(const complex<_Ty >& _Left,
		const complex<_Ty >& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty > inline
	bool operator!=(const complex<_Ty >& _Left,
		const _Ty& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty > inline
	bool operator!=(const _Ty& _Left,
		const complex<_Ty >& _Right)
	{	
	return (!(_Left == _Right));
	}

		
template<class _Ty > inline
	_Ty imag(const complex<_Ty >& _Left)
	{	
	return (_Left.imag());
	}

		
template<class _Ty > inline
	_Ty real(const complex<_Ty >& _Left)
	{	
	return (_Left.real());
	}

		
template<class _Ty > inline
	_Ty _Fabs(const complex<_Ty >& _Left, int *_Pexp)
	{	
	*_Pexp = 0;
	_Ty _Av = real(_Left);
	_Ty _Bv = imag(_Left);

	if (_Ctraits<_Ty >::_Isinf(_Av) || _Ctraits<_Ty >::_Isinf(_Bv))
		return (_Ctraits<_Ty >::_Infv(_Bv));	
	else if (_Ctraits<_Ty >::_Isnan(_Av))
		return (_Av);	
	else if (_Ctraits<_Ty >::_Isnan(_Bv))
		return (_Bv);	
	else
		{	
		if (_Av < 0)
			_Av = -_Av;
		if (_Bv < 0)
			_Bv = -_Bv;
		if (_Av < _Bv)
			{	
			_Ty _Tmp = _Av;
			_Av = _Bv;
			_Bv = _Tmp;
			}

		if (_Av == 0)
			return (_Av);	
		if (1 <= _Av)
			*_Pexp = 2, _Av = _Av * (_Ty)0.25, _Bv = _Bv * (_Ty)0.25;
		else
			*_Pexp = -2, _Av = _Av * 4, _Bv = _Bv * 4;

		_Ty _Tmp = _Av - _Bv;
		if (_Tmp == _Av)
			return (_Av);	
		else if (_Bv < _Tmp)
			{	
			const _Ty _Qv = _Av / _Bv;
			return (_Av + _Bv / (_Qv + _Ctraits<_Ty >::sqrt(_Qv * _Qv + 1)));
			}
		else
			{	
			static const _Ty _Root2 =
				(_Ty)1.4142135623730950488016887242096981L;
			static const _Ty _Oneplusroot2high =
				(_Ty)(10125945.0 / 4194304.0);	
			static const _Ty _Oneplusroot2low =
				(_Ty)1.4341252375973918872420969807856967e-7L;

			const _Ty _Qv = _Tmp / _Bv;
			const _Ty _Rv = (_Qv + 2) * _Qv;
			const _Ty _Sv = _Rv / (_Root2 + _Ctraits<_Ty >::sqrt(_Rv + 2))
				+ _Oneplusroot2low + _Qv + _Oneplusroot2high;
			return (_Av + _Bv / _Sv);
			}
		}
	}

		
template<class _Ty > inline
	_Ty abs(const complex<_Ty >& _Left)
	{	
	int _Leftexp;
	_Ty _Rho = _Fabs(_Left, &_Leftexp);	

	if (_Leftexp == 0)
		return (_Rho);	
	else
		return (_Ctraits<_Ty >::ldexp(_Rho, _Leftexp));	
	}

		
template<class _Ty > inline
	complex<_Ty > acos(const complex<_Ty >& _Left)
	{	
	static const _Ty _Arcbig = (_Ty)0.25L
		* _Ctraits<_Ty >::sqrt(_Ctraits<_Ty >::_Flt_max());
	static const _Ty _Pi = (_Ty)3.1415926535897932384626433832795029L;

	const _Ty _Re = real(_Left);
	const _Ty _Im = imag(_Left);
	_Ty _Ux;
	_Ty _Vx;

	if (_Ctraits<_Ty >::_Isnan(_Re) || _Ctraits<_Ty >::_Isnan(_Im))
		{	
		_Ux = _Ctraits<_Ty >::_Nanv(_Re);
		_Vx = _Ux;
		}
	else if (_Ctraits<_Ty >::_Isinf(_Re))
		{	
		if (_Ctraits<_Ty >::_Isinf(_Im))
			if (_Re < 0)
				_Ux = (_Ty)0.75 * _Pi;	
			else
				_Ux = (_Ty)0.25 * _Pi;	
		else
			if (_Re < 0)
				_Ux = _Pi;	
			else
				_Ux = 0;	
		_Vx = -_Ctraits<_Ty >::_Infv(_Re);
		if (_Im < 0)
			_Vx = -_Vx;
		}
	else if (_Ctraits<_Ty >::_Isinf(_Im))
		{	
		_Ux = (_Ty)0.50 * _Pi;	
		_Vx = -_Im;
		}
	else
		{	
		const complex<_Ty > _Wx = sqrt(complex<_Ty >(1 + _Re, -_Im));
		const complex<_Ty > _Zx = sqrt(complex<_Ty >(1 - _Re, -_Im));
		const _Ty _Wr = real(_Wx);
		const _Ty _Wi = imag(_Wx);
		const _Ty _Zr = real(_Zx);
		const _Ty _Zi = imag(_Zx);
		_Ty _Alfa, _Beta;

		_Ux = 2 * _Ctraits<_Ty >::atan2(_Zr, _Wr);

		if (_Arcbig < _Wr)
			{	
			_Alfa = _Wr;
			_Beta = _Zi + _Wi * (_Zr / _Alfa);
			}
		else if (_Arcbig < _Wi)
			{	
			_Alfa = _Wi;
			_Beta = _Wr * (_Zi / _Alfa) + _Zr;
			}
		else if (_Wi < -_Arcbig)
			{	
			_Alfa = -_Wi;
			_Beta = _Wr * (_Zi / _Alfa) + _Zr;
			}
		else
			{	
			_Alfa = 0;
			_Beta = _Wr * _Zi + _Wi * _Zr;	
			}

		_Vx = _Ctraits<_Ty >::asinh(_Beta);
		if (_Alfa == 0)
			;
		else if (0 <= _Ux)
			_Vx += _Ctraits<_Ty >::log(_Alfa);
		else
			_Vx -= _Ctraits<_Ty >::log(_Alfa);	
		}
	return (complex<_Ty >(_Ux, _Vx));
	}

		
template<class _Ty > inline
	complex<_Ty > acosh(const complex<_Ty >& _Left)
	{	
	static const _Ty _Arcbig = (_Ty)0.25L
		* _Ctraits<_Ty >::sqrt(_Ctraits<_Ty >::_Flt_max());
	static const _Ty _Pi = (_Ty)3.1415926535897932384626433832795029L;

	const _Ty _Re = real(_Left);
	_Ty _Im = imag(_Left);
	_Ty _Ux;
	_Ty _Vx;

	if (_Ctraits<_Ty >::_Isnan(_Re) || _Ctraits<_Ty >::_Isnan(_Im))
		{	
		_Ux = _Ctraits<_Ty >::_Nanv(_Re);
		_Vx = _Ux;
		}
	else if (_Ctraits<_Ty >::_Isinf(_Re))
		{	
		_Ux = _Ctraits<_Ty >::_Infv(_Re);

		if (_Ctraits<_Ty >::_Isinf(_Im))
			if (_Re < 0)
				_Vx = (_Ty)0.75 * _Pi;	
			else
				_Vx = (_Ty)0.25 * _Pi;	
		else
			if (_Re < 0)
				_Vx = _Pi;	
			else
				_Vx = 0;	
		if (_Im < 0)
			_Vx = -_Vx;
		}
	else if (_Ctraits<_Ty >::_Isinf(_Im))
		{	
		_Ux = _Ctraits<_Ty >::_Infv(_Re);
		_Vx = _Im < 0 ? -(_Ty)0.50 * _Pi : (_Ty)0.50 * _Pi;
		}
	else
		{	
		const complex<_Ty > _Wx = sqrt(complex<_Ty >(_Re - 1, -_Im));
		const complex<_Ty > _Zx = sqrt(complex<_Ty >(_Re + 1, _Im));
		const _Ty _Wr = real(_Wx);
		const _Ty _Wi = imag(_Wx);
		const _Ty _Zr = real(_Zx);
		const _Ty _Zi = imag(_Zx);
		_Ty _Alfa, _Beta;

		if (_Arcbig < _Wr)
			{	
			_Alfa = _Wr;
			_Beta = _Zr - _Wi * (_Zi / _Alfa);
			}
		else if (_Arcbig < _Wi)
			{	
			_Alfa = _Wi;
			_Beta = _Wr * (_Zr / _Alfa) - _Zi;
			}
		else if (_Wi < -_Arcbig)
			{	
			_Alfa = -_Wi;
			_Beta = _Wr * (_Zr / _Alfa) - _Zi;
			}
		else
			{	
			_Alfa = 0;
			_Beta = _Wr * _Zr - _Wi * _Zi;	
			}

		_Ux = _Ctraits<_Ty >::asinh(_Beta);
		if (_Alfa == 0)
			;
		else if (0 <= _Ux)
			_Ux += _Ctraits<_Ty >::log(_Alfa);
		else
			_Ux -= _Ctraits<_Ty >::log(_Alfa);	

		bool _Neg = true;
		if (_Im < 0)
			_Im = -_Im;
		else
			_Neg = false;
		_Vx = 2 * _Ctraits<_Ty >::atan2(
			imag(sqrt(complex<_Ty >(_Re - 1, _Im))), _Zr);
		if (_Neg)
			_Vx = -_Vx;
		}
	return (complex<_Ty >(_Ux, _Vx));
	}

		
template<class _Ty > inline
	complex<_Ty > asinh(const complex<_Ty >& _Left)
	{	
	static const _Ty _Arcbig = (_Ty)0.25L
		* _Ctraits<_Ty >::sqrt(_Ctraits<_Ty >::_Flt_max());
	static const _Ty _Pi = (_Ty)3.1415926535897932384626433832795029L;

	const _Ty _Re = real(_Left);
	_Ty _Im = imag(_Left);
	_Ty _Ux;
	_Ty _Vx;

	if (_Ctraits<_Ty >::_Isnan(_Re) || _Ctraits<_Ty >::_Isnan(_Im))
		{	
		_Ux = _Ctraits<_Ty >::_Nanv(_Re);
		_Vx = _Ux;
		}
	else if (_Ctraits<_Ty >::_Isinf(_Re))
		{	
		_Ux = _Ctraits<_Ty >::_Infv(_Re);

		if (_Ctraits<_Ty >::_Isinf(_Im))
			{	
			_Ux = _Re;
			_Vx = _Im < 0 ? -(_Ty)0.25 * _Pi : (_Ty)0.25 * _Pi;
			}
		else
			{	
			_Ux = _Re;
			_Vx = _Im < 0 ? -(_Ty)0 : (_Ty)0;
			}
		}
	else if (_Ctraits<_Ty >::_Isinf(_Im))
		{	
		_Ux = _Im;
		_Vx = _Im < 0 ? -(_Ty)0.50 * _Pi : (_Ty)0.50 * _Pi;
		}
	else
		{	
		const complex<_Ty > _Wx = sqrt(complex<_Ty >(1 - _Im, _Re));
		const complex<_Ty > _Zx = sqrt(complex<_Ty >(1 + _Im, -_Re));
		const _Ty _Wr = real(_Wx);
		const _Ty _Wi = imag(_Wx);
		const _Ty _Zr = real(_Zx);
		const _Ty _Zi = imag(_Zx);
		_Ty _Alfa, _Beta;

		if (_Arcbig < _Wr)
			{	
			_Alfa = _Wr;
			_Beta = _Wi * (_Zr / _Alfa) - _Zi;
			}
		else if (_Arcbig < _Wi)
			{	
			_Alfa = _Wi;
			_Beta = _Zr - _Wr * (_Zi / _Alfa);
			}
		else if (_Wi < -_Arcbig)
			{	
			_Alfa = -_Wi;
			_Beta = _Zr - _Wr * (_Zi / _Alfa);
			}
		else
			{	
			_Alfa = 0;
			_Beta = _Wi * _Zr - _Wr * _Zi;	
			}

		_Ux = _Ctraits<_Ty >::asinh(_Beta);
		if (_Alfa == 0)
			;
		else if (0 <= _Ux)
			_Ux += _Ctraits<_Ty >::log(_Alfa);
		else
			_Ux -= _Ctraits<_Ty >::log(_Alfa);	

		_Vx = _Ctraits<_Ty >::atan2(_Im, real(_Wx * _Zx));
		}

	return (complex<_Ty >(_Ux, _Vx));
	}

		
template<class _Ty > inline
	complex<_Ty > asin(const complex<_Ty >& _Left)
	{	
	complex<_Ty > _Asinh = ::std:: asinh(complex<_Ty >(-imag(_Left), real(_Left)));

	return (complex<_Ty >(imag(_Asinh), -real(_Asinh)));
	}

		
template<class _Ty > inline
	complex<_Ty > atanh(const complex<_Ty >& _Left)
	{	
	static const _Ty _Arcbig = (_Ty)0.25L
		* _Ctraits<_Ty >::sqrt(_Ctraits<_Ty >::_Flt_max());
	static const _Ty _Piby2 = (_Ty)1.5707963267948966192313216916397514L;

	_Ty _Re = real(_Left);
	_Ty _Im = imag(_Left);
	_Ty _Ux;
	_Ty _Vx;

	if (_Ctraits<_Ty >::_Isnan(_Re) || _Ctraits<_Ty >::_Isnan(_Im))
		{	
		_Ux = _Ctraits<_Ty >::_Nanv(_Re);
		_Vx = _Ux;
		}
	else if (_Ctraits<_Ty >::_Isinf(_Re))
		{	
		_Ux = _Re < 0 ? -(_Ty)0 : (_Ty)0;
		_Vx = _Im < 0 ? -_Piby2 : _Piby2;
		}
	else
		{	
		_Ty _Magim = _Im < 0 ? -_Im : _Im;
		bool _Neg = _Re < 0;

		if (_Neg)
			_Re = -_Re;
		else
			_Im = -_Im;

		if (_Arcbig < _Re)
			{	
			_Ty _Fx = _Im / _Re;

			_Ux = 1 / _Re / (1 + _Fx * _Fx);
			_Vx = _Im < 0 ?  -_Piby2 : _Piby2;
			}
		else if (_Arcbig < _Magim)
			{	
			_Ty _Fx = _Re / _Im;

			_Ux = _Fx / _Im / (1 + _Fx * _Fx);
			_Vx = _Im < 0 ?  -_Piby2 : _Piby2;
			}
		else if (_Re != 1)
			{	
			_Ty _Refrom1 = 1 - _Re;
			_Ty _Imeps2 = _Magim * _Magim;

			_Ux = (_Ty)0.25 * _Ctraits<_Ty >::log1p(4 * _Re
				/ (_Refrom1 * _Refrom1 + _Imeps2));
			_Vx = (_Ty)0.50 * _Ctraits<_Ty >::atan2(2 * _Im,
				_Refrom1 * (1 + _Re) - _Imeps2);
			}
		else if (_Im == 0)
			{	
			_Ux = _Ctraits<_Ty >::_Infv(_Re);
			_Vx = _Im;
			}
		else
			{	
			_Ux = _Ctraits<_Ty >::log(
				_Ctraits<_Ty >::sqrt(_Ctraits<_Ty >::sqrt(4 + _Im * _Im))
					/ _Ctraits<_Ty >::sqrt(_Magim));
			_Vx = (_Ty)0.50 * (_Piby2 + _Ctraits<_Ty >::atan2(_Magim, 2));
			if (_Im < 0)
				_Vx = -_Vx;
			}

		if (_Neg)
			_Ux = -_Ux;
		else
			_Vx = -_Vx;
		}
	return (complex<_Ty >(_Ux, _Vx));
	}

		
template<class _Ty > inline
	complex<_Ty > atan(const complex<_Ty >& _Left)
	{	
	complex<_Ty > _Atanh = ::std:: atanh(complex<_Ty >(-imag(_Left), real(_Left)));

	return (complex<_Ty >(imag(_Atanh), -real(_Atanh)));
	}

		
template<class _Ty > inline
	complex<_Ty > cosh(const complex<_Ty >& _Left)
	{	
	return (complex<_Ty >(
		_Ctraits<_Ty >::_Cosh(real(_Left), _Ctraits<_Ty >::cos(imag(_Left))),
		_Ctraits<_Ty >::_Sinh(real(_Left), _Ctraits<_Ty >::sin(imag(_Left)))));
	}

		
template<class _Ty > inline
	complex<_Ty > exp(const complex<_Ty >& _Left)
	{	
	_Ty _Real(real(_Left)), _Imag(real(_Left));
	_Ctraits<_Ty >::_Exp(&_Real, _Ctraits<_Ty >::cos(imag(_Left)), 0);
	_Ctraits<_Ty >::_Exp(&_Imag, _Ctraits<_Ty >::sin(imag(_Left)), 0);
	return (complex<_Ty >(_Real, _Imag));
	}

		
template<class _Ty > inline
	complex<_Ty > log(const complex<_Ty >& _Left)
	{	
	_Ty _Theta = _Ctraits<_Ty >::atan2(imag(_Left), real(_Left));	

	if (_Ctraits<_Ty >::_Isnan(_Theta))
		return (complex<_Ty >(_Theta, _Theta));	
	else
		{	
		static const _Ty _Cm = (_Ty)(22713.0L / 32768.0L);
		static const _Ty _Cl =
			(_Ty)1.4286068203094172321214581765680755e-6L;
		int _Leftexp;
		_Ty _Rho = _Fabs(_Left, &_Leftexp);	

		_Ty _Leftn = (_Ty)_Leftexp;
		complex<_Ty > _Tmp(
			_Rho == 0 ? -_Ctraits<_Ty >::_Infv(_Rho)	
			: _Ctraits<_Ty >::_Isinf(_Rho) ? _Rho	
			: _Ctraits<_Ty >::log(_Rho) + _Leftn * _Cl + _Leftn * _Cm,
				_Theta);
		return (_Tmp);
		}
	}

		
template<class _Ty > inline
	complex<_Ty > pow(const complex<_Ty >& _Left, const _Ty& _Right)
	{	
	if (imag(_Left) == 0 && 0 <= real(_Left))
		return (complex<_Ty >(_Ctraits<_Ty >::pow(real(_Left), _Right)));
	else
		return (exp(_Right * log(_Left)));
	}

template<class _Ty > inline
	complex<_Ty > pow(const complex<_Ty >& _Left, int _Right)
	{	
	complex<_Ty > _Tmp = _Left;
	unsigned int _Count = _Right;

	if (_Right < 0)
		_Count = 0 - _Count;	

	for (complex<_Ty > _Zv = complex<_Ty >(1); ; _Tmp *= _Tmp)
		{	
		if ((_Count & 1) != 0)
			_Zv *= _Tmp;
		if ((_Count >>= 1) == 0)
			return (_Right < 0 ? complex<_Ty >(1) / _Zv : _Zv);
		}
	}

template<class _Ty > inline
	complex<_Ty > pow(const _Ty& _Left, const complex<_Ty >& _Right)
	{	
	if (imag(_Right) == 0)
		return (complex<_Ty >(_Ctraits<_Ty >::pow(_Left, real(_Right))));
	else if (0 < _Left)
		return (exp(_Right * _Ctraits<_Ty >::log(_Left)));
	else
		return (exp(_Right * log(complex<_Ty >(_Left))));
	}

template<class _Ty > inline
	complex<_Ty > pow(const complex<_Ty >& _Left,
		const complex<_Ty >& _Right)
	{	
	if (imag(_Right) == 0)
		return (pow(_Left, real(_Right)));
	else if (imag(_Left) == 0)
		return (complex<_Ty >(pow(real(_Left), _Right)));
	else
		return (exp(_Right * log(_Left)));
	}

		
template<class _Ty > inline
	complex<_Ty > sinh(const complex<_Ty >& _Left)
	{	
	return (complex<_Ty >(
		_Ctraits<_Ty >::_Sinh(real(_Left), _Ctraits<_Ty >::cos(imag(_Left))),
		_Ctraits<_Ty >::_Cosh(real(_Left), _Ctraits<_Ty >::sin(imag(_Left)))));
	}

		
template<class _Ty > inline
	complex<_Ty > sqrt(const complex<_Ty >& _Left)
	{	
	int _Leftexp;
	_Ty _Rho = _Fabs(_Left, &_Leftexp);	

	if (_Leftexp == 0)
		return (complex<_Ty >(_Rho, _Rho));	
	else
		{	
		_Ty _Realmag = _Ctraits<_Ty >::ldexp(real(_Left) < 0
			? - real(_Left) : real(_Left), -_Leftexp);
		_Rho = _Ctraits<_Ty >::ldexp(_Ctraits<_Ty >::sqrt(
			2 * (_Realmag + _Rho)), _Leftexp / 2 - 1);

		if (0 <= real(_Left))
			return (complex<_Ty >(_Rho, imag(_Left) / (2 * _Rho)));
		else if (imag(_Left) < 0)
			return (complex<_Ty >(-imag(_Left) / (2 * _Rho), -_Rho));
		else
			return (complex<_Ty >(imag(_Left) / (2 * _Rho), _Rho));
		}
	}

		
template<class _Ty > inline
	complex<_Ty > tanh(const complex<_Ty >& _Left)
	{	
	_Ty _Tv = _Ctraits<_Ty >::tan(imag(_Left));
	_Ty _Sv = _Ctraits<_Ty >::_Sinh(real(_Left), (_Ty)(1));
	_Ty _Bv = _Sv *((_Ty)(1) + _Tv * _Tv);
	_Ty _Dv = (_Ty)(1) + _Bv * _Sv;

	if (_Ctraits<_Ty >::_Isinf(_Dv))
		return (complex<_Ty >(_Sv < (_Ty)0 ? (_Ty)(-1) : (_Ty)(1),
			_Tv * (_Ty)(0)));
	else
		return (complex<_Ty >((_Ctraits<_Ty >::sqrt((_Ty)(1) + _Sv * _Sv))
			* _Bv / _Dv, _Tv / _Dv));
	}

		
template<class _Ty > inline
	_Ty arg(const complex<_Ty >& _Left)
	{	
	return (_Ctraits<_Ty >::atan2(imag(_Left), real(_Left)));
	}

		
template<class _Ty > inline
	complex<_Ty > conj(const complex<_Ty >& _Left)
	{	
	return (complex<_Ty >(real(_Left), -imag(_Left)));
	}

		
template<class _Ty > inline
	complex<_Ty > proj(const complex<_Ty >& _Left)
	{	
	return (complex<_Ty >(
		_Ctraits<_Ty >::_Isinf(real(_Left)) || _Ctraits<_Ty >::_Isinf(real(_Left))
			? _Ctraits<_Ty >::_Infv(real(_Left)) : real(_Left),
		imag(_Left) < 0 ? -(_Ty)0 : (_Ty)0));
	}

		
template<class _Ty > inline
	complex<_Ty > cos(const complex<_Ty >& _Left)
	{	
	return (complex<_Ty >(
		_Ctraits<_Ty >::_Cosh(imag(_Left), _Ctraits<_Ty >::cos(real(_Left))),
		-_Ctraits<_Ty >::_Sinh(imag(_Left),
			_Ctraits<_Ty >::sin(real(_Left)))));
	}

		
template<class _Ty > inline
	complex<_Ty > log10(const complex<_Ty >& _Left)
	{	
	return (log(_Left) * (_Ty)0.43429448190325182765112891891660508L);
	}

		
template<class _Ty > inline
	_Ty norm(const complex<_Ty >& _Left)
	{	
	return (real(_Left) * real(_Left) + imag(_Left) * imag(_Left));
	}

		
template<class _Ty > inline
	complex<_Ty > polar(const _Ty& _Rho, const _Ty& _Theta)
	{	
	return (complex<_Ty >(_Rho * _Ctraits<_Ty >::cos(_Theta),
		_Rho * _Ctraits<_Ty >::sin(_Theta)));
	}

template<class _Ty > inline
	complex<_Ty > polar(const _Ty& _Rho)
	{	
	return (complex<_Ty >(_Rho, (_Ty)0));
	}

		
template<class _Ty > inline
	complex<_Ty > sin(const complex<_Ty >& _Left)
	{	
	return (complex<_Ty >(
		_Ctraits<_Ty >::_Cosh(imag(_Left), _Ctraits<_Ty >::sin(real(_Left))),
		_Ctraits<_Ty >::_Sinh(imag(_Left), _Ctraits<_Ty >::cos(real(_Left)))));
	}

		
template<class _Ty > inline
	complex<_Ty > tan(const complex<_Ty >& _Left)
	{	
	complex<_Ty > _Zv(tanh(complex<_Ty >(-imag(_Left), real(_Left))));
	return (complex<_Ty >(imag(_Zv), -real(_Zv)));
	}

 
		




















template<class _Ty> inline typename enable_if<_Is_numeric<_Ty>::value, typename _Promote_to_float<_Ty>::type>::type arg(_Ty) { typedef typename _Promote_to_float<_Ty>::type type; return ((type)0); }
template<class _Ty> inline typename enable_if<_Is_numeric<_Ty>::value, typename _Promote_to_float<_Ty>::type>::type imag(_Ty) { typedef typename _Promote_to_float<_Ty>::type type; return ((type)0); }
template<class _Ty> inline typename enable_if<_Is_numeric<_Ty>::value, typename _Promote_to_float<_Ty>::type>::type real(_Ty _Left) { typedef typename _Promote_to_float<_Ty>::type type; return ((type)_Left); }

template<class _Ty> inline typename enable_if<_Is_numeric<_Ty>::value, typename _Promote_to_float<_Ty>::type>::type norm(_Ty _Left) { typedef typename _Promote_to_float<_Ty>::type type; return ((type)(_Left * _Left)); }

template<class _Ty> inline typename enable_if<_Is_numeric<_Ty>::value, typename _Promote_to_float<_Ty>::type>::type conj(_Ty _Left) { typedef typename _Promote_to_float<_Ty>::type type; return ((type)_Left); }
template<class _Ty> inline typename enable_if<_Is_numeric<_Ty>::value, typename _Promote_to_float<_Ty>::type>::type proj(_Ty _Left) { typedef typename _Promote_to_float<_Ty>::type type; return ((type)_Left); }

		
template<class _Ty1,
	class _Ty2> inline
	complex<typename _Common_float_type<_Ty1, _Ty2>::type>
	polar(const _Ty1& _Left, const _Ty2& _Right)
	{	
	typedef complex<typename _Common_float_type<_Ty1, _Ty2>::type> type;
	return (::std:: polar((type)_Left, (type)_Right));
	}

		
template<class _Ty1,
	class _Ty2> inline
	complex<typename _Common_float_type<_Ty1, _Ty2>::type>
	pow(const complex<_Ty1>& _Left, const complex<_Ty2>& _Right)
	{	
	typedef complex<typename _Common_float_type<_Ty1, _Ty2>::type> type;
	return (::std:: pow(type(_Left), type(_Right)));
	}

template<class _Ty1,
	class _Ty2> inline
	complex<typename _Common_float_type<_Ty1, _Ty2>::type>
	pow(const complex<_Ty1>& _Left, const _Ty2& _Right)
	{	
	typedef complex<typename _Common_float_type<_Ty1, _Ty2>::type> type;
	return (::std:: pow(type(_Left), type(_Right)));
	}

template<class _Ty1,
	class _Ty2> inline
	complex<typename _Common_float_type<_Ty1, _Ty2>::type>
	pow(const _Ty1& _Left, const complex<_Ty2>& _Right)
	{	
	typedef complex<typename _Common_float_type<_Ty1, _Ty2>::type> type;
	return (::std:: pow(type(_Left), type(_Right)));
	}

template<class _Ty1,
	class _Ty2> inline
	typename enable_if<is_integral<_Ty1>::value && is_integral<_Ty2>::value,
		complex<_Ty1> >::type
	pow(const complex<_Ty1>& _Left, _Ty2& _Right)
	{	
	typedef complex<_Ty1> type;
	type _Ans = type(1, 0);

	if (_Right < 0)
		_Ans = type(0, 0);	
	else if (0 < _Right)
		{	
		for (type _Factor = _Left; ; _Factor *= _Factor)
			{	
			if ((_Right & 1) != 0)
				_Ans *= _Factor;
			if ((_Right >>= 1) == 0)
				break;
			}
		}
	return (_Ans);
	}
 #line 933 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\xcomplex"





#line 1250 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\complex"

		
template<class _Ty,
	class _Elem,
	class _Tr> inline
	basic_istream<_Elem, _Tr>& operator>>(
		basic_istream<_Elem, _Tr>& _Istr, complex<_Ty>& _Right)
	{	
	typedef complex<_Ty> _Myt;
	const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Istr.getloc());
	_Elem _Ch = 0;
	long double _Real = 0;
	long double _Imag = 0;

	if (_Istr >> _Ch && _Ch != _Ctype_fac.widen('('))
		{	
		_Istr.putback(_Ch);
		_Istr >> _Real;
		_Imag = 0;
		}
	else if (_Istr >> _Real >> _Ch && _Ch != _Ctype_fac.widen(','))
		if (_Ch == _Ctype_fac.widen(')'))
			_Imag = 0;	
		else
			{	
			_Istr.putback(_Ch);
			_Istr.setstate(ios_base::failbit);
			}
	else if (_Istr >> _Imag >> _Ch && _Ch != _Ctype_fac.widen(')'))
			{	
			_Istr.putback(_Ch);
			_Istr.setstate(ios_base::failbit);
			}

	if (!_Istr.fail())
		{	
		_Ty _Tyreal((_Ty)_Real), _Tyimag((_Ty)_Imag);
		_Right = _Myt(_Tyreal, _Tyimag);
		}
	return (_Istr);
	}

		
template<class _Ty,
	class _Elem,
	class _Tr> inline
	basic_ostream<_Elem, _Tr>& operator<<(
		basic_ostream<_Elem, _Tr>& _Ostr, const complex<_Ty>& _Right)
	{	
	const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
	basic_ostringstream<_Elem, _Tr, allocator<_Elem> > _Sstr;

	_Sstr.flags(_Ostr.flags());
	_Sstr.imbue(_Ostr.getloc());
	_Sstr.precision(_Ostr.precision());
	_Sstr << _Ctype_fac.widen('(') << real(_Right)
		<< _Ctype_fac.widen(',') << imag(_Right)
		<< _Ctype_fac.widen(')');

	basic_string<_Elem, _Tr, allocator<_Elem> > _Str = _Sstr.str();
	return (_Ostr << _Str.c_str());
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1318 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\complex"
#line 1319 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\complex"






#line 48 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvstd.inl.hpp"





#pragma warning( push )
#pragma warning( disable: 4127 )
#line 56 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvstd.inl.hpp"

namespace cv
{

template<typename _Tp> class DataType< std::complex<_Tp> >
{
public:
    typedef std::complex<_Tp>  value_type;
    typedef value_type         work_type;
    typedef _Tp                channel_type;

    enum { generic_type = 0,
           depth        = DataType<channel_type>::depth,
           channels     = 2,
           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
           type         = (((depth) & ((1 << 3) - 1)) + (((channels)-1) << 3)) };

    typedef Vec<channel_type, channels> vec_type;
};

inline
String::String(const std::string& str)
    : cstr_(0), len_(0)
{
    if (!str.empty())
    {
        size_t len = str.size();
        memcpy(allocate(len), str.c_str(), len);
    }
}

inline
String::String(const std::string& str, size_t pos, size_t len)
    : cstr_(0), len_(0)
{
    size_t strlen = str.size();
    pos = min(pos, strlen);
    len = min(strlen - pos, len);
    if (!len) return;
    memcpy(allocate(len), str.c_str() + pos, len);
}

inline
String& String::operator = (const std::string& str)
{
    deallocate();
    if (!str.empty())
    {
        size_t len = str.size();
        memcpy(allocate(len), str.c_str(), len);
    }
    return *this;
}

inline
String& String::operator += (const std::string& str)
{
    *this = *this + str;
    return *this;
}

inline
String::operator std::string() const
{
    return std::string(cstr_, len_);
}

inline
String operator + (const String& lhs, const std::string& rhs)
{
    String s;
    size_t rhslen = rhs.size();
    s.allocate(lhs.len_ + rhslen);
    memcpy(s.cstr_, lhs.cstr_, lhs.len_);
    memcpy(s.cstr_ + lhs.len_, rhs.c_str(), rhslen);
    return s;
}

inline
String operator + (const std::string& lhs, const String& rhs)
{
    String s;
    size_t lhslen = lhs.size();
    s.allocate(lhslen + rhs.len_);
    memcpy(s.cstr_, lhs.c_str(), lhslen);
    memcpy(s.cstr_ + lhslen, rhs.cstr_, rhs.len_);
    return s;
}

inline
FileNode::operator std::string() const
{
    String value;
    read(*this, value, value);
    return value;
}

template<> inline
void operator >> (const FileNode& n, std::string& value)
{
    read(n, value, std::string());
}

template<> inline
FileStorage& operator << (FileStorage& fs, const std::string& value)
{
    return fs << cv::String(value);
}

static inline
std::ostream& operator << (std::ostream& os, const String& str)
{
    return os << str.c_str();
}

static inline
std::ostream& operator << (std::ostream& out, Ptr<Formatted> fmtd)
{
    fmtd->reset();
    for(const char* str = fmtd->next(); str; str = fmtd->next())
        out << str;
    return out;
}

static inline
std::ostream& operator << (std::ostream& out, const Mat& mtx)
{
    return out << Formatter::get()->format(mtx);
}

static inline
std::ostream& operator << (std::ostream& out, const UMat& m)
{
    return out << m.getMat(ACCESS_READ);
}

template<typename _Tp> static inline
std::ostream& operator << (std::ostream& out, const Complex<_Tp>& c)
{
    return out << "(" << c.re << "," << c.im << ")";
}

template<typename _Tp> static inline
std::ostream& operator << (std::ostream& out, const std::vector<Point_<_Tp> >& vec)
{
    return out << Formatter::get()->format(Mat(vec));
}


template<typename _Tp> static inline
std::ostream& operator << (std::ostream& out, const std::vector<Point3_<_Tp> >& vec)
{
    return out << Formatter::get()->format(Mat(vec));
}


template<typename _Tp, int m, int n> static inline
std::ostream& operator << (std::ostream& out, const Matx<_Tp, m, n>& matx)
{
    return out << Formatter::get()->format(Mat(matx));
}

template<typename _Tp> static inline
std::ostream& operator << (std::ostream& out, const Point_<_Tp>& p)
{
    out << "[" << p.x << ", " << p.y << "]";
    return out;
}

template<typename _Tp> static inline
std::ostream& operator << (std::ostream& out, const Point3_<_Tp>& p)
{
    out << "[" << p.x << ", " << p.y << ", " << p.z << "]";
    return out;
}

template<typename _Tp, int n> static inline
std::ostream& operator << (std::ostream& out, const Vec<_Tp, n>& vec)
{
    out << "[";
    if(Vec<_Tp, n>::depth < 5)
    {
        for (int i = 0; i < n - 1; ++i) {
            out << (int)vec[i] << ", ";
        }
        out << (int)vec[n-1] << "]";
    }
    else
    {
        for (int i = 0; i < n - 1; ++i) {
            out << vec[i] << ", ";
        }
        out << vec[n-1] << "]";
    }

    return out;
}

template<typename _Tp> static inline
std::ostream& operator << (std::ostream& out, const Size_<_Tp>& size)
{
    return out << "[" << size.width << " x " << size.height << "]";
}

template<typename _Tp> static inline
std::ostream& operator << (std::ostream& out, const Rect_<_Tp>& rect)
{
    return out << "[" << rect.width << " x " << rect.height << " from (" << rect.x << ", " << rect.y << ")]";
}

static inline std::ostream& operator << (std::ostream& out, const MatSize& msize)
{
    int i, dims = msize.p[-1];
    for( i = 0; i < dims; i++ )
    {
        out << msize.p[i];
        if( i < dims-1 )
            out << " x ";
    }
    return out;
}

} 


#pragma warning( pop )
#line 283 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvstd.inl.hpp"



#line 287 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvstd.inl.hpp"
#line 3224 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/utility.hpp"





















































#line 55 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/utility.hpp"

#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 57 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/utility.hpp"






namespace cv
{























#line 89 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/utility.hpp"






























template<typename _Tp, size_t fixed_size = 1024/sizeof(_Tp)+8> class AutoBuffer
{
public:
    typedef _Tp value_type;

    
    AutoBuffer();
    
    AutoBuffer(size_t _size);

    
    AutoBuffer(const AutoBuffer<_Tp, fixed_size>& buf);
    
    AutoBuffer<_Tp, fixed_size>& operator = (const AutoBuffer<_Tp, fixed_size>& buf);

    
    ~AutoBuffer();

    
    void allocate(size_t _size);
    
    void deallocate();
    
    void resize(size_t _size);
    
    size_t size() const;
    
    operator _Tp* ();
    
    operator const _Tp* () const;

protected:
    
    _Tp* ptr;
    
    size_t sz;
    
    _Tp buf[(fixed_size > 0) ? fixed_size : 1];
};








 bool setBreakOnError(bool flag);

extern "C" typedef int (*ErrorCallback)( int status, const char* func_name,
                                       const char* err_msg, const char* file_name,
                                       int line, void* userdata );












 ErrorCallback redirectError( ErrorCallback errCallback, void* userdata=0, void** prevUserdata=0);







 String format( const char* fmt, ... );
 String tempfile( const char* suffix = 0);
 void glob(String pattern, std::vector<String>& result, bool recursive = false);



















 void setNumThreads(int nthreads);

















 int getNumThreads();













 int getThreadNum();







 const String& getBuildInformation();








 int64 getTickCount();












 double getTickFrequency();















class  TickMeter
{
public:
    
     TickMeter()
    {
    reset();
    }

    


     void start()
    {
    startTime = cv::getTickCount();
    }

    


     void stop()
    {
    int64 time = cv::getTickCount();
    if (startTime == 0)
    return;
    ++counter;
    sumTime += (time - startTime);
    startTime = 0;
    }

    


     int64 getTimeTicks() const
    {
    return sumTime;
    }

    


     double getTimeMicro() const
    {
    return getTimeMilli()*1e3;
    }

    


     double getTimeMilli() const
    {
    return getTimeSec()*1e3;
    }

    


     double getTimeSec()   const
    {
    return (double)getTimeTicks() / getTickFrequency();
    }

    


     int64 getCounter() const
    {
    return counter;
    }

    


     void reset()
    {
    startTime = 0;
    sumTime = 0;
    counter = 0;
    }

private:
    int64 counter;
    int64 sumTime;
    int64 startTime;
};











static inline
std::ostream& operator << (std::ostream& out, const TickMeter& tm)
{
    return out << tm.getTimeSec() << "sec";
}













 int64 getCPUTickCount();









 bool checkHardwareSupport(int feature);



 int getNumberOfCPUs();









template<typename _Tp> static inline _Tp* alignPtr(_Tp* ptr, int n=(int)sizeof(_Tp))
{
    return (_Tp*)(((size_t)ptr + n-1) & -n);
}








static inline size_t alignSize(size_t sz, int n)
{
    ; 
    return (sz + n-1) & -n;
}







static inline int divUp(int a, unsigned int b)
{
    ;
    return (a + b - 1) / b;
}

static inline size_t divUp(size_t a, unsigned int b)
{
    return (a + b - 1) / b;
}














 void setUseOptimized(bool onoff);





 bool useOptimized();

static inline size_t getElemSize(int type) { return (((((type) & ((512 - 1) << 3)) >> 3) + 1) << ((((sizeof(size_t)/4+1)*16384|0x3a50) >> ((type) & ((1 << 3) - 1))*2) & 3)); }





class  ParallelLoopBody
{
public:
    virtual ~ParallelLoopBody();
    virtual void operator() (const Range& range) const = 0;
};



 void parallel_for_(const Range& range, const ParallelLoopBody& body, double nstripes=-1.);
























template<typename _Tp, typename Functor> inline
void Mat::forEach_impl(const Functor& operation) {
    if (false) {
        operation(*reinterpret_cast<_Tp*>(0), reinterpret_cast<int*>(0));
        
        
        
        
    }

    if(!!(this->total() / this->size[this->dims - 1] <= 2147483647)) ; else cv::error( cv::Error::StsAssert, "this->total() / this->size[this->dims - 1] <= INT_MAX",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/utility.hpp", 535 );
    const int LINES = static_cast<int>(this->total() / this->size[this->dims - 1]);

    class PixelOperationWrapper :public ParallelLoopBody
    {
    public:
        PixelOperationWrapper(Mat_<_Tp>* const frame, const Functor& _operation)
            : mat(frame), op(_operation) {}
        virtual ~PixelOperationWrapper(){}
        
        
        virtual void operator()(const Range &range) const {
            const int DIMS = mat->dims;
            const int COLS = mat->size[DIMS - 1];
            if (DIMS <= 2) {
                for (int row = range.start; row < range.end; ++row) {
                    this->rowCall2(row, COLS);
                }
            } else {
                std::vector<int> idx(DIMS); 
                idx[DIMS - 2] = range.start - 1;

                for (int line_num = range.start; line_num < range.end; ++line_num) {
                    idx[DIMS - 2]++;
                    for (int i = DIMS - 2; i >= 0; --i) {
                        if (idx[i] >= mat->size[i]) {
                            idx[i - 1] += idx[i] / mat->size[i];
                            idx[i] %= mat->size[i];
                            continue; 
                        }
                        else {
                            break;
                        }
                    }
                    this->rowCall(&idx[0], COLS, DIMS);
                }
            }
        }
    private:
        Mat_<_Tp>* const mat;
        const Functor op;
        
        inline void rowCall(int* const idx, const int COLS, const int DIMS) const {
            int &col = idx[DIMS - 1];
            col = 0;
            _Tp* pixel = &(mat->template at<_Tp>(idx));

            while (col < COLS) {
                op(*pixel, const_cast<const int*>(idx));
                pixel++; col++;
            }
            col = 0;
        }
        
        inline void rowCall2(const int row, const int COLS) const {
            union Index{
                int body[2];
                operator const int*() const {
                    return reinterpret_cast<const int*>(this);
                }
                int& operator[](const int i) {
                    return body[i];
                }
            } idx = {{row, 0}};
            
            
            

            _Tp* pixel = &(mat->template at<_Tp>(idx));
            const _Tp* const pixel_end = pixel + COLS;
            while(pixel < pixel_end) {
                op(*pixel++, static_cast<const int*>(idx));
                idx[1]++;
            }
        }
        PixelOperationWrapper& operator=(const PixelOperationWrapper &) {
            if(!!(false)) ; else cv::error( cv::Error::StsAssert, "false",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/utility.hpp", 611 );
            
            return *this;
        }
    };

    parallel_for_(cv::Range(0, LINES), PixelOperationWrapper(reinterpret_cast<Mat_<_Tp>*>(this), operation));
}



class  Mutex
{
public:
    Mutex();
    ~Mutex();
    Mutex(const Mutex& m);
    Mutex& operator = (const Mutex& m);

    void lock();
    bool trylock();
    void unlock();

    struct Impl;
protected:
    Impl* impl;
};

class  AutoLock
{
public:
    AutoLock(Mutex& m) : mutex(&m) { mutex->lock(); }
    ~AutoLock() { mutex->unlock(); }
protected:
    Mutex* mutex;
private:
    AutoLock(const AutoLock&);
    AutoLock& operator = (const AutoLock&);
};


class  TLSDataContainer
{
protected:
    TLSDataContainer();
    virtual ~TLSDataContainer();

    void  gatherData(std::vector<void*> &data) const;





#line 665 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/utility.hpp"
    void  release();

public:
    void* getData() const;
#line 670 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/utility.hpp"
    virtual void* createDataInstance() const = 0;
    virtual void  deleteDataInstance(void* pData) const = 0;

    int key_;

public:
    void cleanup(); 
};


template <typename T>
class TLSData : protected TLSDataContainer
{
public:
    inline TLSData()        {}
    inline ~TLSData()       { release();            } 
    inline T* get() const   { return (T*)getData(); } 
    inline T& getRef() const { T* ptr = (T*)getData(); if(!!(ptr)) ; else cv::error( cv::Error::StsAssert, "ptr",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/utility.hpp", 687 ); return *ptr; } 

    
    inline void gather(std::vector<T*> &data) const
    {
        std::vector<void*> &dataVoid = reinterpret_cast<std::vector<void*>&>(data);
        gatherData(dataVoid);
    }

    inline void cleanup() { TLSDataContainer::cleanup(); }

private:
    virtual void* createDataInstance() const {return new T;}                
    virtual void  deleteDataInstance(void* pData) const {delete (T*)pData;} 

    
    TLSData(TLSData &) {}
    TLSData& operator =(const TLSData &) {return *this;}
};














































































class  CommandLineParser
{
public:

    







    CommandLineParser(int argc, const char* const argv[], const String& keys);

    
    CommandLineParser(const CommandLineParser& parser);

    
    CommandLineParser& operator = (const CommandLineParser& parser);

    
    ~CommandLineParser();

    









    String getPathToApplication() const;

    






























    template <typename T>
    T get(const String& name, bool space_delete = true) const
    {
        T val = T();
        getByName(name, space_delete, ParamType<T>::type, (void*)&val);
        return val;
    }

    























    template <typename T>
    T get(int index, bool space_delete = true) const
    {
        T val = T();
        getByIndex(index, space_delete, ParamType<T>::type, (void*)&val);
        return val;
    }

    



    bool has(const String& name) const;

    




    bool check() const;

    



    void about(const String& message);

    





    void printMessage() const;

    



    void printErrors() const;

protected:
    void getByName(const String& name, bool space_delete, int type, void* dst) const;
    void getByIndex(int index, bool space_delete, int type, void* dst) const;

    struct Impl;
    Impl* impl;
};







template<typename _Tp, size_t fixed_size> inline
AutoBuffer<_Tp, fixed_size>::AutoBuffer()
{
    ptr = buf;
    sz = fixed_size;
}

template<typename _Tp, size_t fixed_size> inline
AutoBuffer<_Tp, fixed_size>::AutoBuffer(size_t _size)
{
    ptr = buf;
    sz = fixed_size;
    allocate(_size);
}

template<typename _Tp, size_t fixed_size> inline
AutoBuffer<_Tp, fixed_size>::AutoBuffer(const AutoBuffer<_Tp, fixed_size>& abuf )
{
    ptr = buf;
    sz = fixed_size;
    allocate(abuf.size());
    for( size_t i = 0; i < sz; i++ )
        ptr[i] = abuf.ptr[i];
}

template<typename _Tp, size_t fixed_size> inline AutoBuffer<_Tp, fixed_size>&
AutoBuffer<_Tp, fixed_size>::operator = (const AutoBuffer<_Tp, fixed_size>& abuf)
{
    if( this != &abuf )
    {
        deallocate();
        allocate(abuf.size());
        for( size_t i = 0; i < sz; i++ )
            ptr[i] = abuf.ptr[i];
    }
    return *this;
}

template<typename _Tp, size_t fixed_size> inline
AutoBuffer<_Tp, fixed_size>::~AutoBuffer()
{ deallocate(); }

template<typename _Tp, size_t fixed_size> inline void
AutoBuffer<_Tp, fixed_size>::allocate(size_t _size)
{
    if(_size <= sz)
    {
        sz = _size;
        return;
    }
    deallocate();
    sz = _size;
    if(_size > fixed_size)
    {
        ptr = new _Tp[_size];
    }
}

template<typename _Tp, size_t fixed_size> inline void
AutoBuffer<_Tp, fixed_size>::deallocate()
{
    if( ptr != buf )
    {
        delete[] ptr;
        ptr = buf;
        sz = fixed_size;
    }
}

template<typename _Tp, size_t fixed_size> inline void
AutoBuffer<_Tp, fixed_size>::resize(size_t _size)
{
    if(_size <= sz)
    {
        sz = _size;
        return;
    }
    size_t i, prevsize = sz, minsize = ((prevsize) > (_size) ? (_size) : (prevsize));
    _Tp* prevptr = ptr;

    ptr = _size > fixed_size ? new _Tp[_size] : buf;
    sz = _size;

    if( ptr != prevptr )
        for( i = 0; i < minsize; i++ )
            ptr[i] = prevptr[i];
    for( i = prevsize; i < _size; i++ )
        ptr[i] = _Tp();

    if( prevptr != buf )
        delete[] prevptr;
}

template<typename _Tp, size_t fixed_size> inline size_t
AutoBuffer<_Tp, fixed_size>::size() const
{ return sz; }

template<typename _Tp, size_t fixed_size> inline
AutoBuffer<_Tp, fixed_size>::operator _Tp* ()
{ return ptr; }

template<typename _Tp, size_t fixed_size> inline
AutoBuffer<_Tp, fixed_size>::operator const _Tp* () const
{ return ptr; }

template<> inline std::string CommandLineParser::get<std::string>(int index, bool space_delete) const
{
    return get<String>(index, space_delete);
}
template<> inline std::string CommandLineParser::get<std::string>(const String& name, bool space_delete) const
{
    return get<String>(name, space_delete);
}





template<class OBJECT>
class  Node
{
public:
    Node()
    {
        m_pParent  = 0;
    }
    Node(OBJECT& payload) : m_payload(payload)
    {
        m_pParent  = 0;
    }
    ~Node()
    {
        removeChilds();
        if (m_pParent)
        {
            int idx = m_pParent->findChild(this);
            if (idx >= 0)
                m_pParent->m_childs.erase(m_pParent->m_childs.begin() + idx);
        }
    }

    Node<OBJECT>* findChild(OBJECT& payload) const
    {
        for(size_t i = 0; i < this->m_childs.size(); i++)
        {
            if(this->m_childs[i]->m_payload == payload)
                return this->m_childs[i];
        }
        return 0;
    }

    int findChild(Node<OBJECT> *pNode) const
    {
        for (size_t i = 0; i < this->m_childs.size(); i++)
        {
            if(this->m_childs[i] == pNode)
                return (int)i;
        }
        return -1;
    }

    void addChild(Node<OBJECT> *pNode)
    {
        if(!pNode)
            return;

        if(!!(pNode->m_pParent == 0)) ; else cv::error( cv::Error::StsAssert, "pNode->m_pParent == 0",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/utility.hpp", 1103 );
        pNode->m_pParent = this;
        this->m_childs.push_back(pNode);
    }

    void removeChilds()
    {
        for(size_t i = 0; i < m_childs.size(); i++)
        {
            m_childs[i]->m_pParent = 0; 
            delete m_childs[i];
        }
        m_childs.clear();
    }

    int getDepth()
    {
        int   count   = 0;
        Node *pParent = m_pParent;
        while(pParent) count++, pParent = pParent->m_pParent;
        return count;
    }

public:
    OBJECT                     m_payload;
    Node<OBJECT>*              m_pParent;
    std::vector<Node<OBJECT>*> m_childs;
};


namespace instr
{



enum TYPE
{
    TYPE_GENERAL = 0,   
    TYPE_MARKER,        
    TYPE_WRAPPER,       
    TYPE_FUN,           
};

enum IMPL
{
    IMPL_PLAIN = 0,
    IMPL_IPP,
    IMPL_OPENCL,
};

struct NodeDataTls
{
    NodeDataTls()
    {
        m_ticksTotal = 0;
    }
    uint64      m_ticksTotal;
};

class  NodeData
{
public:
    NodeData(const char* funName = 0, const char* fileName = 0, int lineNum = 0, void* retAddress = 0, bool alwaysExpand = false, cv::instr::TYPE instrType = TYPE_GENERAL, cv::instr::IMPL implType = IMPL_PLAIN);
    NodeData(NodeData &ref);
    ~NodeData();
    NodeData& operator=(const NodeData&);

    cv::String          m_funName;
    cv::instr::TYPE     m_instrType;
    cv::instr::IMPL     m_implType;
    const char*         m_fileName;
    int                 m_lineNum;
    void*               m_retAddress;
    bool                m_alwaysExpand;
    bool                m_funError;

    volatile int         m_counter;
    volatile uint64      m_ticksTotal;
    TLSData<NodeDataTls> m_tls;
    int                  m_threads;

    
    double getTotalMs()   const { return ((double)m_ticksTotal / cv::getTickFrequency()) * 1000; }
    double getMeanMs()    const { return (((double)m_ticksTotal/m_counter) / cv::getTickFrequency()) * 1000; }
};
bool operator==(const NodeData& lhs, const NodeData& rhs);

typedef Node<NodeData> InstrNode;

 InstrNode* getTrace();

#line 1195 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/utility.hpp"


 bool       useInstrumentation();
 void       setUseInstrumentation(bool flag);
 void       resetTrace();

enum FLAGS
{
    FLAGS_NONE              = 0,
    FLAGS_MAPPING           = 0x01,
    FLAGS_EXPAND_SAME_NAMES = 0x02,
};

 void       setFlags(FLAGS modeFlags);
static inline void    setFlags(int modeFlags) { setFlags((FLAGS)modeFlags); }
 FLAGS      getFlags();
}

namespace utils {

 int getThreadID();

} 

} 


#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/core_c.h"















































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
























































#line 58 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"

#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/cvdef.h"


















































































































































































































































































































































































































































#line 60 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\assert.h"













#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\crtdefs.h"














 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\assert.h"










extern "C" {
#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\assert.h"

__declspec(dllimport) void __cdecl _wassert(  const wchar_t * _Message,   const wchar_t *_File,   unsigned _Line);


}
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\assert.h"



#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\assert.h"
#line 63 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"



#line 67 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"







#line 75 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"






#line 82 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
#line 83 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"






#line 90 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
#line 91 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"



#line 95 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"



#line 99 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"


#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 102 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
#line 103 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"











typedef void CvArr;

typedef int CVStatus;


enum {
 CV_StsOk=                       0,  
 CV_StsBackTrace=               -1,  
 CV_StsError=                   -2,  
 CV_StsInternal=                -3,  
 CV_StsNoMem=                   -4,  
 CV_StsBadArg=                  -5,  
 CV_StsBadFunc=                 -6,  
 CV_StsNoConv=                  -7,  
 CV_StsAutoTrace=               -8,  
 CV_HeaderIsNull=               -9,  
 CV_BadImageSize=              -10,  
 CV_BadOffset=                 -11,  
 CV_BadDataPtr=                -12,  
 CV_BadStep=                   -13,  
 CV_BadModelOrChSeq=           -14,  
 CV_BadNumChannels=            -15,  
 CV_BadNumChannel1U=           -16,  
 CV_BadDepth=                  -17,  
 CV_BadAlphaChannel=           -18,  
 CV_BadOrder=                  -19,  
 CV_BadOrigin=                 -20,  
 CV_BadAlign=                  -21,  
 CV_BadCallBack=               -22,  
 CV_BadTileSize=               -23,  
 CV_BadCOI=                    -24,  
 CV_BadROISize=                -25,  
 CV_MaskIsTiled=               -26,  
 CV_StsNullPtr=                -27,  
 CV_StsVecLengthErr=           -28,  
 CV_StsFilterStructContentErr= -29,  
 CV_StsKernelStructContentErr= -30,  
 CV_StsFilterOffsetErr=        -31,  
 CV_StsBadSize=                -201, 
 CV_StsDivByZero=              -202, 
 CV_StsInplaceNotSupported=    -203, 
 CV_StsObjectNotFound=         -204, 
 CV_StsUnmatchedFormats=       -205, 
 CV_StsBadFlag=                -206, 
 CV_StsBadPoint=               -207, 
 CV_StsBadMask=                -208, 
 CV_StsUnmatchedSizes=         -209, 
 CV_StsUnsupportedFormat=      -210, 
 CV_StsOutOfRange=             -211, 
 CV_StsParseError=             -212, 
 CV_StsNotImplemented=         -213, 
 CV_StsBadMemBlock=            -214, 
 CV_StsAssert=                 -215, 
 CV_GpuNotSupported=           -216, 
 CV_GpuApiCallError=           -217, 
 CV_OpenGlNotSupported=        -218, 
 CV_OpenGlApiCallError=        -219, 
 CV_OpenCLApiCallError=        -220, 
 CV_OpenCLDoubleNotSupported=  -221,
 CV_OpenCLInitError=           -222, 
 CV_OpenCLNoAMDBlasFft=        -223
};

















#line 194 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"









typedef uint64 CvRNG;











static inline CvRNG cvRNG( int64 seed = -1)
{
    CvRNG rng = seed ? (uint64)seed : (uint64)(int64)-1;
    return rng;
}








static inline unsigned cvRandInt( CvRNG* rng )
{
    uint64 temp = *rng;
    temp = (uint64)(unsigned)temp*4164903690U + (temp >> 32);
    *rng = temp;
    return (unsigned)temp;
}







static inline double cvRandReal( CvRNG* rng )
{
    return cvRandInt(rng)*2.3283064365386962890625e-10 ;
}


















































typedef struct

  
#line 300 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
_IplImage
{
    int  nSize;             
    int  ID;                
    int  nChannels;         
    int  alphaChannel;      
    int  depth;             

    char colorModel[4];     
    char channelSeq[4];     
    int  dataOrder;         

    int  origin;            

    int  align;             

    int  width;             
    int  height;            
    struct _IplROI *roi;    
    struct _IplImage *maskROI;      
    void  *imageId;                 
    struct _IplTileInfo *tileInfo;  
    int  imageSize;         


    char *imageData;        
    int  widthStep;         
    int  BorderMode[4];     
    int  BorderConst[4];    
    char *imageDataOrigin;  




    _IplImage() {}
    _IplImage(const cv::Mat& m);
#line 337 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
}
IplImage;

typedef struct _IplTileInfo IplTileInfo;

typedef struct _IplROI
{
    int  coi; 
    int  xOffset;
    int  yOffset;
    int  width;
    int  height;
}
IplROI;

typedef struct _IplConvKernel
{
    int  nCols;
    int  nRows;
    int  anchorX;
    int  anchorY;
    int *values;
    int  nShiftR;
}
IplConvKernel;

typedef struct _IplConvKernelFP
{
    int  nCols;
    int  nRows;
    int  anchorX;
    int  anchorY;
    float *values;
}
IplConvKernelFP;





#line 378 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"













































typedef struct CvMat
{
    int type;
    int step;

    
    int* refcount;
    int hdr_refcount;

    union
    {
        uchar* ptr;
        short* s;
        int* i;
        float* fl;
        double* db;
    } data;


    union
    {
        int rows;
        int height;
    };

    union
    {
        int cols;
        int width;
    };



#line 457 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"



    CvMat() {}
    CvMat(const CvMat& m) { memcpy(this, &m, sizeof(CvMat));}
    CvMat(const cv::Mat& m);
#line 464 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"

}
CvMat;










































static inline CvMat cvMat( int rows, int cols, int type, void* data = 0)
{
    CvMat m;

    (void)( (!!((unsigned)((type) & ((1 << 3) - 1)) <= 6)) || (_wassert(L"(unsigned)CV_MAT_DEPTH(type) <= CV_64F", L"C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h", 513), 0) );
    type = ((type) & ((1 << 3)*512 - 1));
    m.type = 0x42420000 | (1 << 14) | type;
    m.cols = cols;
    m.rows = rows;
    m.step = m.cols*(((((type) & ((512 - 1) << 3)) >> 3) + 1) << ((((sizeof(size_t)/4+1)*16384|0x3a50) >> ((type) & ((1 << 3) - 1))*2) & 3));
    m.data.ptr = (uchar*)data;
    m.refcount = 0;
    m.hdr_refcount = 0;

    return m;
}


inline CvMat::CvMat(const cv::Mat& m)
{
    ;
    *this = cvMat(m.rows, m.dims == 1 ? 1 : m.cols, m.type(), m.data);
    step = (int)m.step[0];
    type = (type & ~cv::Mat::CONTINUOUS_FLAG) | (m.flags & cv::Mat::CONTINUOUS_FLAG);
}
#line 535 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"






















static inline  double  cvmGet( const CvMat* mat, int row, int col )
{
    int type;

    type = ((mat->type) & ((1 << 3)*512 - 1));
    (void)( (!!((unsigned)row < (unsigned)mat->rows && (unsigned)col < (unsigned)mat->cols)) || (_wassert(L"(unsigned)row < (unsigned)mat->rows && (unsigned)col < (unsigned)mat->cols", L"C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h", 563), 0) );
#line 564 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"

    if( type == (((5) & ((1 << 3) - 1)) + (((1)-1) << 3)) )
        return ((float*)(void*)(mat->data.ptr + (size_t)mat->step*row))[col];
    else
    {
        (void)( (!!(type == (((6) & ((1 << 3) - 1)) + (((1)-1) << 3)))) || (_wassert(L"type == CV_64FC1", L"C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h", 569), 0) );
        return ((double*)(void*)(mat->data.ptr + (size_t)mat->step*row))[col];
    }
}











static inline  void  cvmSet( CvMat* mat, int row, int col, double value )
{
    int type;
    type = ((mat->type) & ((1 << 3)*512 - 1));
    (void)( (!!((unsigned)row < (unsigned)mat->rows && (unsigned)col < (unsigned)mat->cols)) || (_wassert(L"(unsigned)row < (unsigned)mat->rows && (unsigned)col < (unsigned)mat->cols", L"C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h", 589), 0) );
#line 590 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"

    if( type == (((5) & ((1 << 3) - 1)) + (((1)-1) << 3)) )
        ((float*)(void*)(mat->data.ptr + (size_t)mat->step*row))[col] = (float)value;
    else
    {
        (void)( (!!(type == (((6) & ((1 << 3) - 1)) + (((1)-1) << 3)))) || (_wassert(L"type == CV_64FC1", L"C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h", 595), 0) );
        ((double*)(void*)(mat->data.ptr + (size_t)mat->step*row))[col] = value;
    }
}


static inline int cvIplDepth( int type )
{
    int depth = ((type) & ((1 << 3) - 1));
    return ((((sizeof(size_t)<<28)|0x8442211) >> ((depth) & ((1 << 3) - 1))*4) & 15)*8 | (depth == 1 || depth == 3 ||
           depth == 4 ? 0x80000000 : 0);
}















typedef struct

  
#line 626 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
CvMatND
{
    int type;
    int dims;

    int* refcount;
    int hdr_refcount;

    union
    {
        uchar* ptr;
        float* fl;
        double* db;
        int* i;
        short* s;
    } data;

    struct
    {
        int size;
        int step;
    }
    dim[32];


    CvMatND() {}
    CvMatND(const cv::Mat& m);
#line 654 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
}
CvMatND;















struct CvSet;

typedef struct

  
#line 677 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
CvSparseMat
{
    int type;
    int dims;
    int* refcount;
    int hdr_refcount;

    struct CvSet* heap;
    void** hashtable;
    int hashsize;
    int valoffset;
    int idxoffset;
    int size[32];


    void copyToSparseMat(cv::SparseMat& m) const;
#line 694 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
}
CvSparseMat;


     CvSparseMat* cvCreateSparseMat(const cv::SparseMat& m);
#line 700 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"










typedef struct CvSparseNode
{
    unsigned hashval;
    struct CvSparseNode* next;
}
CvSparseNode;

typedef struct CvSparseMatIterator
{
    CvSparseMat* mat;
    CvSparseNode* node;
    int curidx;
}
CvSparseMatIterator;








typedef int CvHistType;















typedef struct CvHistogram
{
    int     type;
    CvArr*  bins;
    float   thresh[32][2];  
    float** thresh2;                
    CvMatND mat;                    
}
CvHistogram;





















typedef struct CvRect
{
    int x;
    int y;
    int width;
    int height;


    CvRect(int _x = 0, int _y = 0, int w = 0, int h = 0): x(_x), y(_y), width(w), height(h) {}
    template<typename _Tp>
    CvRect(const cv::Rect_<_Tp>& r): x(cv::saturate_cast<int>(r.x)), y(cv::saturate_cast<int>(r.y)), width(cv::saturate_cast<int>(r.width)), height(cv::saturate_cast<int>(r.height)) {}
    template<typename _Tp>
    operator cv::Rect_<_Tp>() const { return cv::Rect_<_Tp>((_Tp)x, (_Tp)y, (_Tp)width, (_Tp)height); }
#line 792 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
}
CvRect;


static inline  CvRect  cvRect( int x, int y, int width, int height )
{
    CvRect r;

    r.x = x;
    r.y = y;
    r.width = width;
    r.height = height;

    return r;
}


static inline  IplROI  cvRectToROI( CvRect rect, int coi )
{
    IplROI roi;
    roi.xOffset = rect.x;
    roi.yOffset = rect.y;
    roi.width = rect.width;
    roi.height = rect.height;
    roi.coi = coi;

    return roi;
}


static inline  CvRect  cvROIToRect( IplROI roi )
{
    return cvRect( roi.xOffset, roi.yOffset, roi.width, roi.height );
}









typedef struct CvTermCriteria
{
    int    type;  


    int    max_iter;
    double epsilon;


    CvTermCriteria(int _type = 0, int _iter = 0, double _eps = 0) : type(_type), max_iter(_iter), epsilon(_eps)  {}
    CvTermCriteria(const cv::TermCriteria& t) : type(t.type), max_iter(t.maxCount), epsilon(t.epsilon)  {}
    operator cv::TermCriteria() const { return cv::TermCriteria(type, max_iter, epsilon); }
#line 848 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"

}
CvTermCriteria;

static inline  CvTermCriteria  cvTermCriteria( int type, int max_iter, double epsilon )
{
    CvTermCriteria t;

    t.type = type;
    t.max_iter = max_iter;
    t.epsilon = (float)epsilon;

    return t;
}




typedef struct CvPoint
{
    int x;
    int y;


    CvPoint(int _x = 0, int _y = 0): x(_x), y(_y) {}
    template<typename _Tp>
    CvPoint(const cv::Point_<_Tp>& pt): x((int)pt.x), y((int)pt.y) {}
    template<typename _Tp>
    operator cv::Point_<_Tp>() const { return cv::Point_<_Tp>(cv::saturate_cast<_Tp>(x), cv::saturate_cast<_Tp>(y)); }
#line 878 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
}
CvPoint;


static inline  CvPoint  cvPoint( int x, int y )
{
    CvPoint p;

    p.x = x;
    p.y = y;

    return p;
}


typedef struct CvPoint2D32f
{
    float x;
    float y;


    CvPoint2D32f(float _x = 0, float _y = 0): x(_x), y(_y) {}
    template<typename _Tp>
    CvPoint2D32f(const cv::Point_<_Tp>& pt): x((float)pt.x), y((float)pt.y) {}
    template<typename _Tp>
    operator cv::Point_<_Tp>() const { return cv::Point_<_Tp>(cv::saturate_cast<_Tp>(x), cv::saturate_cast<_Tp>(y)); }
#line 905 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
}
CvPoint2D32f;


static inline  CvPoint2D32f  cvPoint2D32f( double x, double y )
{
    CvPoint2D32f p;

    p.x = (float)x;
    p.y = (float)y;

    return p;
}


static inline  CvPoint2D32f  cvPointTo32f( CvPoint point )
{
    return cvPoint2D32f( (float)point.x, (float)point.y );
}


static inline  CvPoint  cvPointFrom32f( CvPoint2D32f point )
{
    CvPoint ipt;
    ipt.x = cvRound(point.x);
    ipt.y = cvRound(point.y);

    return ipt;
}


typedef struct CvPoint3D32f
{
    float x;
    float y;
    float z;


    CvPoint3D32f(float _x = 0, float _y = 0, float _z = 0): x(_x), y(_y), z(_z) {}
    template<typename _Tp>
    CvPoint3D32f(const cv::Point3_<_Tp>& pt): x((float)pt.x), y((float)pt.y), z((float)pt.z) {}
    template<typename _Tp>
    operator cv::Point3_<_Tp>() const { return cv::Point3_<_Tp>(cv::saturate_cast<_Tp>(x), cv::saturate_cast<_Tp>(y), cv::saturate_cast<_Tp>(z)); }
#line 949 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
}
CvPoint3D32f;


static inline  CvPoint3D32f  cvPoint3D32f( double x, double y, double z )
{
    CvPoint3D32f p;

    p.x = (float)x;
    p.y = (float)y;
    p.z = (float)z;

    return p;
}


typedef struct CvPoint2D64f
{
    double x;
    double y;
}
CvPoint2D64f;


static inline  CvPoint2D64f  cvPoint2D64f( double x, double y )
{
    CvPoint2D64f p;

    p.x = x;
    p.y = y;

    return p;
}


typedef struct CvPoint3D64f
{
    double x;
    double y;
    double z;
}
CvPoint3D64f;


static inline  CvPoint3D64f  cvPoint3D64f( double x, double y, double z )
{
    CvPoint3D64f p;

    p.x = x;
    p.y = y;
    p.z = z;

    return p;
}




typedef struct CvSize
{
    int width;
    int height;


    CvSize(int w = 0, int h = 0): width(w), height(h) {}
    template<typename _Tp>
    CvSize(const cv::Size_<_Tp>& sz): width(cv::saturate_cast<int>(sz.width)), height(cv::saturate_cast<int>(sz.height)) {}
    template<typename _Tp>
    operator cv::Size_<_Tp>() const { return cv::Size_<_Tp>(cv::saturate_cast<_Tp>(width), cv::saturate_cast<_Tp>(height)); }
#line 1019 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
}
CvSize;


static inline  CvSize  cvSize( int width, int height )
{
    CvSize s;

    s.width = width;
    s.height = height;

    return s;
}

typedef struct CvSize2D32f
{
    float width;
    float height;


    CvSize2D32f(float w = 0, float h = 0): width(w), height(h) {}
    template<typename _Tp>
    CvSize2D32f(const cv::Size_<_Tp>& sz): width(cv::saturate_cast<float>(sz.width)), height(cv::saturate_cast<float>(sz.height)) {}
    template<typename _Tp>
    operator cv::Size_<_Tp>() const { return cv::Size_<_Tp>(cv::saturate_cast<_Tp>(width), cv::saturate_cast<_Tp>(height)); }
#line 1045 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
}
CvSize2D32f;


static inline  CvSize2D32f  cvSize2D32f( double width, double height )
{
    CvSize2D32f s;

    s.width = (float)width;
    s.height = (float)height;

    return s;
}



typedef struct CvBox2D
{
    CvPoint2D32f center;  
    CvSize2D32f  size;    
    float angle;          
                          


    CvBox2D(CvPoint2D32f c = CvPoint2D32f(), CvSize2D32f s = CvSize2D32f(), float a = 0) : center(c), size(s), angle(a) {}
    CvBox2D(const cv::RotatedRect& rr) : center(rr.center), size(rr.size), angle(rr.angle) {}
    operator cv::RotatedRect() const { return cv::RotatedRect(center, size, angle); }
#line 1073 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
}
CvBox2D;



typedef struct CvLineIterator
{
    
    uchar* ptr;

    
    int  err;
    int  plus_delta;
    int  minus_delta;
    int  plus_step;
    int  minus_step;
}
CvLineIterator;







typedef struct CvSlice
{
    int  start_index, end_index;


    CvSlice(int start = 0, int end = 0) : start_index(start), end_index(end) {}
    CvSlice(const cv::Range& r) { *this = (r.start != (-2147483647 - 1) && r.end != 2147483647) ? CvSlice(r.start, r.end) : CvSlice(0, 0x3fffffff); }
    operator cv::Range() const { return (start_index == 0 && end_index == 0x3fffffff ) ? cv::Range::all() : cv::Range(start_index, end_index); }
#line 1107 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
}
CvSlice;

static inline  CvSlice  cvSlice( int start, int end )
{
    CvSlice slice;
    slice.start_index = start;
    slice.end_index = end;

    return slice;
}






typedef struct CvScalar
{
    double val[4];


    CvScalar() {}
    CvScalar(double d0, double d1 = 0, double d2 = 0, double d3 = 0) { val[0] = d0; val[1] = d1; val[2] = d2; val[3] = d3; }
    template<typename _Tp>
    CvScalar(const cv::Scalar_<_Tp>& s) { val[0] = s.val[0]; val[1] = s.val[1]; val[2] = s.val[2]; val[3] = s.val[3]; }
    template<typename _Tp>
    operator cv::Scalar_<_Tp>() const { return cv::Scalar_<_Tp>(cv::saturate_cast<_Tp>(val[0]), cv::saturate_cast<_Tp>(val[1]), cv::saturate_cast<_Tp>(val[2]), cv::saturate_cast<_Tp>(val[3])); }
    template<typename _Tp, int cn>
    CvScalar(const cv::Vec<_Tp, cn>& v)
    {
        int i;
        for( i = 0; i < (cn < 4 ? cn : 4); i++ ) val[i] = v.val[i];
        for( ; i < 4; i++ ) val[i] = 0;
    }
#line 1143 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
}
CvScalar;

static inline  CvScalar  cvScalar( double val0, double val1 = 0,
                               double val2 = 0, double val3 = 0)
{
    CvScalar scalar;
    scalar.val[0] = val0; scalar.val[1] = val1;
    scalar.val[2] = val2; scalar.val[3] = val3;
    return scalar;
}


static inline  CvScalar  cvRealScalar( double val0 )
{
    CvScalar scalar;
    scalar.val[0] = val0;
    scalar.val[1] = scalar.val[2] = scalar.val[3] = 0;
    return scalar;
}

static inline  CvScalar  cvScalarAll( double val0123 )
{
    CvScalar scalar;
    scalar.val[0] = val0123;
    scalar.val[1] = val0123;
    scalar.val[2] = val0123;
    scalar.val[3] = val0123;
    return scalar;
}







typedef struct CvMemBlock
{
    struct CvMemBlock*  prev;
    struct CvMemBlock*  next;
}
CvMemBlock;



typedef struct CvMemStorage
{
    int signature;
    CvMemBlock* bottom;           
    CvMemBlock* top;              
    struct  CvMemStorage* parent; 
    int block_size;               
    int free_space;               
}
CvMemStorage;






typedef struct CvMemStoragePos
{
    CvMemBlock* top;
    int free_space;
}
CvMemStoragePos;




typedef struct CvSeqBlock
{
    struct CvSeqBlock*  prev; 
    struct CvSeqBlock*  next; 
  int    start_index;         
                              
    int    count;             
    schar* data;              
}
CvSeqBlock;

























typedef struct CvSeq
{
    int flags; int header_size; struct CvSeq* h_prev; struct CvSeq* h_next; struct CvSeq* v_prev; struct CvSeq* v_next; int total; int elem_size; schar* block_max; schar* ptr; int delta_elems; CvMemStorage* storage; CvSeqBlock* free_blocks; CvSeqBlock* first;
}
CvSeq;














typedef struct CvSetElem
{
    int flags; struct CvSetElem* next_free;
}
CvSetElem;






typedef struct CvSet
{
    int flags; int header_size; struct CvSeq* h_prev; struct CvSeq* h_next; struct CvSeq* v_prev; struct CvSeq* v_next; int total; int elem_size; schar* block_max; schar* ptr; int delta_elems; CvMemStorage* storage; CvSeqBlock* free_blocks; CvSeqBlock* first; CvSetElem* free_elems; int active_count;
}
CvSet;










































typedef struct CvGraphEdge
{
    int flags; float weight; struct CvGraphEdge* next[2]; struct CvGraphVtx* vtx[2];
}
CvGraphEdge;

typedef struct CvGraphVtx
{
    int flags; struct CvGraphEdge* first;
}
CvGraphVtx;

typedef struct CvGraphVtx2D
{
    int flags; struct CvGraphEdge* first;
    CvPoint2D32f* ptr;
}
CvGraphVtx2D;









typedef struct CvGraph
{
    int flags; int header_size; struct CvSeq* h_prev; struct CvSeq* h_next; struct CvSeq* v_prev; struct CvSeq* v_next; int total; int elem_size; schar* block_max; schar* ptr; int delta_elems; CvMemStorage* storage; CvSeqBlock* free_blocks; CvSeqBlock* first; CvSetElem* free_elems; int active_count; CvSet* edges;
}
CvGraph;







typedef struct CvChain
{
    int flags; int header_size; struct CvSeq* h_prev; struct CvSeq* h_next; struct CvSeq* v_prev; struct CvSeq* v_next; int total; int elem_size; schar* block_max; schar* ptr; int delta_elems; CvMemStorage* storage; CvSeqBlock* free_blocks; CvSeqBlock* first;
    CvPoint  origin;
}
CvChain;







typedef struct CvContour
{
    int flags; int header_size; struct CvSeq* h_prev; struct CvSeq* h_next; struct CvSeq* v_prev; struct CvSeq* v_next; int total; int elem_size; schar* block_max; schar* ptr; int delta_elems; CvMemStorage* storage; CvSeqBlock* free_blocks; CvSeqBlock* first; CvRect rect; int color; int reserved[3];
}
CvContour;

typedef CvContour CvPoint2DSeq;








































































































































typedef struct CvSeqWriter
{
    int header_size; CvSeq* seq; CvSeqBlock* block; schar* ptr; schar* block_min; schar* block_max;
}
CvSeqWriter;












typedef struct CvSeqReader
{
    int header_size; CvSeq* seq; CvSeqBlock* block; schar* ptr; schar* block_min; schar* block_max; int delta_index; schar* prev_elem;
}
CvSeqReader;



















































































































typedef struct CvFileStorage CvFileStorage;























typedef struct CvAttrList
{
    const char** attr;         
    struct CvAttrList* next;   
}
CvAttrList;


static inline CvAttrList cvAttrList( const char** attr = 0,
                                 CvAttrList* next = 0 )
{
    CvAttrList l;
    l.attr = attr;
    l.next = next;

    return l;
}

struct CvTypeInfo;



































typedef struct CvString
{
    int len;
    char* ptr;
}
CvString;



typedef struct CvStringHashNode
{
    unsigned hashval;
    CvString str;
    struct CvStringHashNode* next;
}
CvStringHashNode;

typedef struct CvGenericHash CvFileNodeHash;


typedef struct CvFileNode
{
    int tag;
    struct CvTypeInfo* info; 

    union
    {
        double f; 
        int i;    
        CvString str; 
        CvSeq* seq; 
        CvFileNodeHash* map; 
    } data;
}
CvFileNode;


extern "C" {
#line 1776 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"
typedef int (__cdecl *CvIsInstanceFunc)( const void* struct_ptr );
typedef void (__cdecl *CvReleaseFunc)( void** struct_dblptr );
typedef void* (__cdecl *CvReadFunc)( CvFileStorage* storage, CvFileNode* node );
typedef void (__cdecl *CvWriteFunc)( CvFileStorage* storage, const char* name,
                                      const void* struct_ptr, CvAttrList attributes );
typedef void* (__cdecl *CvCloneFunc)( const void* struct_ptr );

}
#line 1785 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"











typedef struct CvTypeInfo
{
    int flags; 
    int header_size; 
    struct CvTypeInfo* prev; 
    struct CvTypeInfo* next; 
    const char* type_name; 
    CvIsInstanceFunc is_instance; 
    CvReleaseFunc release; 
    CvReadFunc read; 
    CvWriteFunc write; 
    CvCloneFunc clone; 
}
CvTypeInfo;




typedef struct CvPluginFuncInfo
{
    void** func_addr;
    void* default_func_addr;
    const char* func_names;
    int search_modules;
    int loaded_from;
}
CvPluginFuncInfo;

typedef struct CvModuleInfo
{
    struct CvModuleInfo* next;
    const char* name;
    const char* version;
    CvPluginFuncInfo* func_tab;
}
CvModuleInfo;



#line 1836 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/types_c.h"



#line 49 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/core_c.h"









#pragma warning(disable:4190)


#line 62 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/core_c.h"
#line 63 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/core_c.h"


extern "C" {
#line 67 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/core_c.h"













extern "C"  void* __cdecl  cvAlloc( size_t size );







extern "C"  void __cdecl   cvFree_( void* ptr );








extern "C"  IplImage* __cdecl  cvCreateImageHeader( CvSize size, int depth, int channels );











extern "C"  IplImage* __cdecl cvInitImageHeader( IplImage* image, CvSize size, int depth,
                                   int channels, int origin = 0,
                                   int align = 4);













extern "C"  IplImage* __cdecl  cvCreateImage( CvSize size, int depth, int channels );














extern "C"  void __cdecl  cvReleaseImageHeader( IplImage** image );













extern "C"  void __cdecl  cvReleaseImage( IplImage** image );


extern "C"  IplImage* __cdecl cvCloneImage( const IplImage* image );











extern "C"  void __cdecl  cvSetImageCOI( IplImage* image, int coi );







extern "C"  int __cdecl  cvGetImageCOI( const IplImage* image );












extern "C"  void __cdecl  cvSetImageROI( IplImage* image, CvRect rect );










extern "C"  void __cdecl  cvResetImageROI( IplImage* image );






extern "C"  CvRect __cdecl cvGetImageROI( const IplImage* image );









extern "C"  CvMat* __cdecl  cvCreateMatHeader( int rows, int cols, int type );



































extern "C"  CvMat* __cdecl cvInitMatHeader( CvMat* mat, int rows, int cols,
                              int type, void* data = 0,
                              int step = 0x7fffffff );















extern "C"  CvMat* __cdecl  cvCreateMat( int rows, int cols, int type );












extern "C"  void __cdecl  cvReleaseMat( CvMat** mat );












static inline  void  cvDecRefData( CvArr* arr )
{
    if( (((arr) != 0 && (((const CvMat*)(arr))->type & 0xFFFF0000) == 0x42420000 && ((const CvMat*)(arr))->cols > 0 && ((const CvMat*)(arr))->rows > 0) && ((const CvMat*)(arr))->data.ptr != 0))
    {
        CvMat* mat = (CvMat*)arr;
        mat->data.ptr = 0;
        if( mat->refcount != 0 && --*mat->refcount == 0 )
            (cvFree_(*(&mat->refcount)), *(&mat->refcount)=0);
        mat->refcount = 0;
    }
    else if( (((arr) != 0 && (((const CvMatND*)(arr))->type & 0xFFFF0000) == 0x42430000) && ((const CvMatND*)(arr))->data.ptr != 0))
    {
        CvMatND* mat = (CvMatND*)arr;
        mat->data.ptr = 0;
        if( mat->refcount != 0 && --*mat->refcount == 0 )
            (cvFree_(*(&mat->refcount)), *(&mat->refcount)=0);
        mat->refcount = 0;
    }
}







static inline  int  cvIncRefData( CvArr* arr )
{
    int refcount = 0;
    if( (((arr) != 0 && (((const CvMat*)(arr))->type & 0xFFFF0000) == 0x42420000 && ((const CvMat*)(arr))->cols > 0 && ((const CvMat*)(arr))->rows > 0) && ((const CvMat*)(arr))->data.ptr != 0))
    {
        CvMat* mat = (CvMat*)arr;
        if( mat->refcount != 0 )
            refcount = ++*mat->refcount;
    }
    else if( (((arr) != 0 && (((const CvMatND*)(arr))->type & 0xFFFF0000) == 0x42430000) && ((const CvMatND*)(arr))->data.ptr != 0))
    {
        CvMatND* mat = (CvMatND*)arr;
        if( mat->refcount != 0 )
            refcount = ++*mat->refcount;
    }
    return refcount;
}



extern "C"  CvMat* __cdecl cvCloneMat( const CvMat* mat );












extern "C"  CvMat* __cdecl cvGetSubRect( const CvArr* arr, CvMat* submat, CvRect rect );













extern "C"  CvMat* __cdecl cvGetRows( const CvArr* arr, CvMat* submat,
                        int start_row, int end_row,
                        int delta_row = 1);






static inline  CvMat*  cvGetRow( const CvArr* arr, CvMat* submat, int row )
{
    return cvGetRows( arr, submat, row, row + 1, 1 );
}














extern "C"  CvMat* __cdecl cvGetCols( const CvArr* arr, CvMat* submat,
                        int start_col, int end_col );






static inline  CvMat*  cvGetCol( const CvArr* arr, CvMat* submat, int col )
{
    return cvGetCols( arr, submat, col, col + 1 );
}










extern "C"  CvMat* __cdecl cvGetDiag( const CvArr* arr, CvMat* submat,
                            int diag = 0);


extern "C"  void __cdecl cvScalarToRawData( const CvScalar* scalar, void* data, int type,
                              int extend_to_12 = 0 );

extern "C"  void __cdecl cvRawDataToScalar( const void* data, int type, CvScalar* scalar );









extern "C"  CvMatND* __cdecl  cvCreateMatNDHeader( int dims, const int* sizes, int type );













extern "C"  CvMatND* __cdecl  cvCreateMatND( int dims, const int* sizes, int type );









extern "C"  CvMatND* __cdecl  cvInitMatNDHeader( CvMatND* mat, int dims, const int* sizes,
                                    int type, void* data = 0 );












static inline  void  cvReleaseMatND( CvMatND** mat )
{
    cvReleaseMat( (CvMat**)mat );
}


extern "C"  CvMatND* __cdecl cvCloneMatND( const CvMatND* mat );










extern "C"  CvSparseMat* __cdecl  cvCreateSparseMat( int dims, const int* sizes, int type );






extern "C"  void __cdecl  cvReleaseSparseMat( CvSparseMat** mat );


extern "C"  CvSparseMat* __cdecl cvCloneSparseMat( const CvSparseMat* mat );








extern "C"  CvSparseNode* __cdecl cvInitSparseMatIterator( const CvSparseMat* mat,
                                              CvSparseMatIterator* mat_iterator );





























static inline CvSparseNode* cvGetNextSparseNode( CvSparseMatIterator* mat_iterator )
{
    if( mat_iterator->node->next )
        return mat_iterator->node = mat_iterator->node->next;
    else
    {
        int idx;
        for( idx = ++mat_iterator->curidx; idx < mat_iterator->mat->hashsize; idx++ )
        {
            CvSparseNode* node = (CvSparseNode*)mat_iterator->mat->hashtable[idx];
            if( node )
            {
                mat_iterator->curidx = idx;
                return mat_iterator->node = node;
            }
        }
        return 0;
    }
}





typedef struct CvNArrayIterator
{
    int count; 
    int dims; 
    CvSize size; 
    uchar* ptr[10]; 
    int stack[32]; 
    CvMatND* hdr[10]; 

}
CvNArrayIterator;








extern "C"  int __cdecl cvInitNArrayIterator( int count, CvArr** arrs,
                                 const CvArr* mask, CvMatND* stubs,
                                 CvNArrayIterator* array_iterator,
                                 int flags = 0 );


extern "C"  int __cdecl cvNextNArraySlice( CvNArrayIterator* array_iterator );












extern "C"  int __cdecl cvGetElemType( const CvArr* arr );

















extern "C"  int __cdecl cvGetDims( const CvArr* arr, int* sizes = 0 );








extern "C"  int __cdecl cvGetDimSize( const CvArr* arr, int index );

















extern "C"  uchar* __cdecl cvPtr1D( const CvArr* arr, int idx0, int* type = 0);

extern "C"  uchar* __cdecl cvPtr2D( const CvArr* arr, int idx0, int idx1, int* type = 0 );

extern "C"  uchar* __cdecl cvPtr3D( const CvArr* arr, int idx0, int idx1, int idx2,
                      int* type = 0);










extern "C"  uchar* __cdecl cvPtrND( const CvArr* arr, const int* idx, int* type = 0,
                      int create_node = 1,
                      unsigned* precalc_hashval = 0);








extern "C"  CvScalar __cdecl cvGet1D( const CvArr* arr, int idx0 );

extern "C"  CvScalar __cdecl cvGet2D( const CvArr* arr, int idx0, int idx1 );

extern "C"  CvScalar __cdecl cvGet3D( const CvArr* arr, int idx0, int idx1, int idx2 );




extern "C"  CvScalar __cdecl cvGetND( const CvArr* arr, const int* idx );












extern "C"  double __cdecl cvGetReal1D( const CvArr* arr, int idx0 );

extern "C"  double __cdecl cvGetReal2D( const CvArr* arr, int idx0, int idx1 );

extern "C"  double __cdecl cvGetReal3D( const CvArr* arr, int idx0, int idx1, int idx2 );




extern "C"  double __cdecl cvGetRealND( const CvArr* arr, const int* idx );









extern "C"  void __cdecl cvSet1D( CvArr* arr, int idx0, CvScalar value );

extern "C"  void __cdecl cvSet2D( CvArr* arr, int idx0, int idx1, CvScalar value );

extern "C"  void __cdecl cvSet3D( CvArr* arr, int idx0, int idx1, int idx2, CvScalar value );





extern "C"  void __cdecl cvSetND( CvArr* arr, const int* idx, CvScalar value );












extern "C"  void __cdecl cvSetReal1D( CvArr* arr, int idx0, double value );

extern "C"  void __cdecl cvSetReal2D( CvArr* arr, int idx0, int idx1, double value );

extern "C"  void __cdecl cvSetReal3D( CvArr* arr, int idx0,
                        int idx1, int idx2, double value );





extern "C"  void __cdecl cvSetRealND( CvArr* arr, const int* idx, double value );



extern "C"  void __cdecl cvClearND( CvArr* arr, const int* idx );























extern "C"  CvMat* __cdecl cvGetMat( const CvArr* arr, CvMat* header,
                       int* coi = 0,
                       int allowND = 0);











extern "C"  IplImage* __cdecl cvGetImage( const CvArr* arr, IplImage* image_header );






































extern "C"  CvArr* __cdecl cvReshapeMatND( const CvArr* arr,
                             int sizeof_header, CvArr* header,
                             int new_cn, int new_dims, int* new_sizes );
































extern "C"  CvMat* __cdecl cvReshape( const CvArr* arr, CvMat* header,
                        int new_cn, int new_rows = 0 );



extern "C"  void __cdecl cvRepeat( const CvArr* src, CvArr* dst );









extern "C"  void __cdecl  cvCreateData( CvArr* arr );








extern "C"  void __cdecl  cvReleaseData( CvArr* arr );










extern "C"  void __cdecl  cvSetData( CvArr* arr, void* data, int step );



























extern "C"  void __cdecl cvGetRawData( const CvArr* arr, uchar** data,
                         int* step = 0,
                         CvSize* roi_size = 0);







extern "C"  CvSize __cdecl cvGetSize( const CvArr* arr );















extern "C"  void __cdecl  cvCopy( const CvArr* src, CvArr* dst,
                     const CvArr* mask = 0 );











extern "C"  void __cdecl  cvSet( CvArr* arr, CvScalar value,
                    const CvArr* mask = 0 );








extern "C"  void __cdecl  cvSetZero( CvArr* arr );





extern "C"  void __cdecl  cvSplit( const CvArr* src, CvArr* dst0, CvArr* dst1,
                      CvArr* dst2, CvArr* dst3 );



extern "C"  void __cdecl  cvMerge( const CvArr* src0, const CvArr* src1,
                      const CvArr* src2, const CvArr* src3,
                      CvArr* dst );



extern "C"  void __cdecl  cvMixChannels( const CvArr** src, int src_count,
                            CvArr** dst, int dst_count,
                            const int* from_to, int pair_count );



















extern "C"  void __cdecl  cvConvertScale( const CvArr* src, CvArr* dst,
                             double scale = 1,
                             double shift = 0 );










extern "C"  void __cdecl  cvConvertScaleAbs( const CvArr* src, CvArr* dst,
                                double scale = 1,
                                double shift = 0 );







extern "C"  CvTermCriteria __cdecl cvCheckTermCriteria( CvTermCriteria criteria,
                                           double default_eps,
                                           int default_max_iters );






extern "C"  void __cdecl  cvAdd( const CvArr* src1, const CvArr* src2, CvArr* dst,
                    const CvArr* mask = 0);


extern "C"  void __cdecl  cvAddS( const CvArr* src, CvScalar value, CvArr* dst,
                     const CvArr* mask = 0);


extern "C"  void __cdecl  cvSub( const CvArr* src1, const CvArr* src2, CvArr* dst,
                    const CvArr* mask = 0);


static inline  void  cvSubS( const CvArr* src, CvScalar value, CvArr* dst,
                         const CvArr* mask = 0)
{
    cvAddS( src, cvScalar( -value.val[0], -value.val[1], -value.val[2], -value.val[3]),
            dst, mask );
}


extern "C"  void __cdecl  cvSubRS( const CvArr* src, CvScalar value, CvArr* dst,
                      const CvArr* mask = 0);



extern "C"  void __cdecl  cvMul( const CvArr* src1, const CvArr* src2,
                    CvArr* dst, double scale = 1 );




extern "C"  void __cdecl  cvDiv( const CvArr* src1, const CvArr* src2,
                    CvArr* dst, double scale = 1);


extern "C"  void __cdecl  cvScaleAdd( const CvArr* src1, CvScalar scale,
                         const CvArr* src2, CvArr* dst );



extern "C"  void __cdecl  cvAddWeighted( const CvArr* src1, double alpha,
                            const CvArr* src2, double beta,
                            double gamma, CvArr* dst );













extern "C"  double __cdecl  cvDotProduct( const CvArr* src1, const CvArr* src2 );


extern "C"  void __cdecl cvAnd( const CvArr* src1, const CvArr* src2,
                  CvArr* dst, const CvArr* mask = 0);


extern "C"  void __cdecl cvAndS( const CvArr* src, CvScalar value,
                   CvArr* dst, const CvArr* mask = 0);


extern "C"  void __cdecl cvOr( const CvArr* src1, const CvArr* src2,
                 CvArr* dst, const CvArr* mask = 0);


extern "C"  void __cdecl cvOrS( const CvArr* src, CvScalar value,
                  CvArr* dst, const CvArr* mask = 0);


extern "C"  void __cdecl cvXor( const CvArr* src1, const CvArr* src2,
                  CvArr* dst, const CvArr* mask = 0);


extern "C"  void __cdecl cvXorS( const CvArr* src, CvScalar value,
                   CvArr* dst, const CvArr* mask = 0);


extern "C"  void __cdecl cvNot( const CvArr* src, CvArr* dst );


extern "C"  void __cdecl cvInRange( const CvArr* src, const CvArr* lower,
                      const CvArr* upper, CvArr* dst );


extern "C"  void __cdecl cvInRangeS( const CvArr* src, CvScalar lower,
                       CvScalar upper, CvArr* dst );












extern "C"  void __cdecl cvCmp( const CvArr* src1, const CvArr* src2, CvArr* dst, int cmp_op );


extern "C"  void __cdecl cvCmpS( const CvArr* src, double value, CvArr* dst, int cmp_op );


extern "C"  void __cdecl cvMin( const CvArr* src1, const CvArr* src2, CvArr* dst );


extern "C"  void __cdecl cvMax( const CvArr* src1, const CvArr* src2, CvArr* dst );


extern "C"  void __cdecl cvMinS( const CvArr* src, double value, CvArr* dst );


extern "C"  void __cdecl cvMaxS( const CvArr* src, double value, CvArr* dst );


extern "C"  void __cdecl cvAbsDiff( const CvArr* src1, const CvArr* src2, CvArr* dst );


extern "C"  void __cdecl cvAbsDiffS( const CvArr* src, CvArr* dst, CvScalar value );








extern "C"  void __cdecl  cvCartToPolar( const CvArr* x, const CvArr* y,
                            CvArr* magnitude, CvArr* angle = 0,
                            int angle_in_degrees = 0);




extern "C"  void __cdecl  cvPolarToCart( const CvArr* magnitude, const CvArr* angle,
                            CvArr* x, CvArr* y,
                            int angle_in_degrees = 0);


extern "C"  void __cdecl  cvPow( const CvArr* src, CvArr* dst, double power );




extern "C"  void __cdecl  cvExp( const CvArr* src, CvArr* dst );





extern "C"  void __cdecl  cvLog( const CvArr* src, CvArr* dst );


extern "C"  float __cdecl cvFastArctan( float y, float x );


extern "C"  float __cdecl  cvCbrt( float value );







extern "C"  int __cdecl  cvCheckArr( const CvArr* arr, int flags = 0,
                        double min_val = 0, double max_val = 0);





















extern "C"  void __cdecl cvRandArr( CvRNG* rng, CvArr* arr, int dist_type,
                      CvScalar param1, CvScalar param2 );

extern "C"  void __cdecl cvRandShuffle( CvArr* mat, CvRNG* rng,
                           double iter_factor = 1.);






extern "C"  void __cdecl cvSort( const CvArr* src, CvArr* dst = 0,
                    CvArr* idxmat = 0,
                    int flags = 0);


extern "C"  int __cdecl cvSolveCubic( const CvMat* coeffs, CvMat* roots );


extern "C"  void __cdecl cvSolvePoly(const CvMat* coeffs, CvMat *roots2,
      int maxiter = 20, int fig = 100);















extern "C"  void __cdecl  cvCrossProduct( const CvArr* src1, const CvArr* src2, CvArr* dst );










extern "C"  void __cdecl  cvGEMM( const CvArr* src1, const CvArr* src2, double alpha,
                     const CvArr* src3, double beta, CvArr* dst,
                     int tABC = 0);




extern "C"  void __cdecl  cvTransform( const CvArr* src, CvArr* dst,
                          const CvMat* transmat,
                          const CvMat* shiftvec = 0);



extern "C"  void __cdecl  cvPerspectiveTransform( const CvArr* src, CvArr* dst,
                                     const CvMat* mat );


extern "C"  void __cdecl cvMulTransposed( const CvArr* src, CvArr* dst, int order,
                             const CvArr* delta = 0,
                             double scale = 1. );


extern "C"  void __cdecl  cvTranspose( const CvArr* src, CvArr* dst );



extern "C"  void __cdecl  cvCompleteSymm( CvMat* matrix, int LtoR = 0 );




extern "C"  void __cdecl  cvFlip( const CvArr* src, CvArr* dst = 0,
                     int flip_mode = 0);








extern "C"  void __cdecl   cvSVD( CvArr* A, CvArr* W, CvArr* U = 0,
                     CvArr* V = 0, int flags = 0);



extern "C"  void __cdecl   cvSVBkSb( const CvArr* W, const CvArr* U,
                        const CvArr* V, const CvArr* B,
                        CvArr* X, int flags );









extern "C"  double __cdecl  cvInvert( const CvArr* src, CvArr* dst,
                         int method = 0);




extern "C"  int __cdecl  cvSolve( const CvArr* src1, const CvArr* src2, CvArr* dst,
                     int method = 0);


extern "C"  double __cdecl cvDet( const CvArr* mat );


extern "C"  CvScalar __cdecl cvTrace( const CvArr* mat );


extern "C"  void __cdecl  cvEigenVV( CvArr* mat, CvArr* evects, CvArr* evals,
                        double eps = 0,
                        int lowindex = -1,
                        int highindex = -1);






extern "C"  void __cdecl  cvSetIdentity( CvArr* mat, CvScalar value = cvRealScalar(1) );


extern "C"  CvArr* __cdecl  cvRange( CvArr* mat, double start, double end );































extern "C"  void __cdecl  cvCalcCovarMatrix( const CvArr** vects, int count,
                                CvArr* cov_mat, CvArr* avg, int flags );




extern "C"  void __cdecl  cvCalcPCA( const CvArr* data, CvArr* mean,
                        CvArr* eigenvals, CvArr* eigenvects, int flags );

extern "C"  void __cdecl  cvProjectPCA( const CvArr* data, const CvArr* mean,
                           const CvArr* eigenvects, CvArr* result );

extern "C"  void __cdecl  cvBackProjectPCA( const CvArr* proj, const CvArr* mean,
                               const CvArr* eigenvects, CvArr* result );


extern "C"  double __cdecl  cvMahalanobis( const CvArr* vec1, const CvArr* vec2, const CvArr* mat );







extern "C"  CvScalar __cdecl  cvSum( const CvArr* arr );


extern "C"  int __cdecl  cvCountNonZero( const CvArr* arr );


extern "C"  CvScalar __cdecl  cvAvg( const CvArr* arr, const CvArr* mask = 0 );


extern "C"  void __cdecl  cvAvgSdv( const CvArr* arr, CvScalar* mean, CvScalar* std_dev,
                       const CvArr* mask = 0 );


extern "C"  void __cdecl  cvMinMaxLoc( const CvArr* arr, double* min_val, double* max_val,
                          CvPoint* min_loc = 0,
                          CvPoint* max_loc = 0,
                          const CvArr* mask = 0 );
























extern "C"  double __cdecl  cvNorm( const CvArr* arr1, const CvArr* arr2 = 0,
                       int norm_type = 4,
                       const CvArr* mask = 0 );


extern "C"  void __cdecl  cvNormalize( const CvArr* src, CvArr* dst,
                          double a = 1., double b = 0.,
                          int norm_type = 4,
                          const CvArr* mask = 0 );












extern "C"  void __cdecl  cvReduce( const CvArr* src, CvArr* dst, int dim = -1,
                       int op = 0 );
























extern "C"  void __cdecl  cvDFT( const CvArr* src, CvArr* dst, int flags,
                    int nonzero_rows = 0 );





extern "C"  void __cdecl  cvMulSpectrums( const CvArr* src1, const CvArr* src2,
                             CvArr* dst, int flags );


extern "C"  int __cdecl  cvGetOptimalDFTSize( int size0 );




extern "C"  void __cdecl  cvDCT( const CvArr* src, CvArr* dst, int flags );






extern "C"  int __cdecl cvSliceLength( CvSlice slice, const CvSeq* seq );





extern "C"  CvMemStorage* __cdecl  cvCreateMemStorage( int block_size = 0);



extern "C"  CvMemStorage* __cdecl  cvCreateChildMemStorage( CvMemStorage* parent );




extern "C"  void __cdecl  cvReleaseMemStorage( CvMemStorage** storage );






extern "C"  void __cdecl  cvClearMemStorage( CvMemStorage* storage );


extern "C"  void __cdecl  cvSaveMemStoragePos( const CvMemStorage* storage, CvMemStoragePos* pos );


extern "C"  void __cdecl  cvRestoreMemStoragePos( CvMemStorage* storage, CvMemStoragePos* pos );


extern "C"  void* __cdecl cvMemStorageAlloc( CvMemStorage* storage, size_t size );


extern "C"  CvString __cdecl cvMemStorageAllocString( CvMemStorage* storage, const char* ptr,
                                         int len = -1 );


extern "C"  CvSeq* __cdecl  cvCreateSeq( int seq_flags, size_t header_size,
                            size_t elem_size, CvMemStorage* storage );



extern "C"  void __cdecl  cvSetSeqBlockSize( CvSeq* seq, int delta_elems );



extern "C"  schar* __cdecl  cvSeqPush( CvSeq* seq, const void* element = 0);



extern "C"  schar* __cdecl  cvSeqPushFront( CvSeq* seq, const void* element = 0);



extern "C"  void __cdecl  cvSeqPop( CvSeq* seq, void* element = 0);



extern "C"  void __cdecl  cvSeqPopFront( CvSeq* seq, void* element = 0);





extern "C"  void __cdecl  cvSeqPushMulti( CvSeq* seq, const void* elements,
                             int count, int in_front = 0 );


extern "C"  void __cdecl  cvSeqPopMulti( CvSeq* seq, void* elements,
                            int count, int in_front = 0 );



extern "C"  schar* __cdecl  cvSeqInsert( CvSeq* seq, int before_index,
                            const void* element = 0);


extern "C"  void __cdecl  cvSeqRemove( CvSeq* seq, int index );





extern "C"  void __cdecl  cvClearSeq( CvSeq* seq );





extern "C"  schar* __cdecl  cvGetSeqElem( const CvSeq* seq, int index );



extern "C"  int __cdecl  cvSeqElemIdx( const CvSeq* seq, const void* element,
                         CvSeqBlock** block = 0 );


extern "C"  void __cdecl  cvStartAppendToSeq( CvSeq* seq, CvSeqWriter* writer );



extern "C"  void __cdecl  cvStartWriteSeq( int seq_flags, int header_size,
                              int elem_size, CvMemStorage* storage,
                              CvSeqWriter* writer );





extern "C"  CvSeq* __cdecl  cvEndWriteSeq( CvSeqWriter* writer );




extern "C"  void __cdecl   cvFlushSeqWriter( CvSeqWriter* writer );




extern "C"  void __cdecl cvStartReadSeq( const CvSeq* seq, CvSeqReader* reader,
                           int reverse = 0 );



extern "C"  int __cdecl  cvGetSeqReaderPos( CvSeqReader* reader );




extern "C"  void __cdecl   cvSetSeqReaderPos( CvSeqReader* reader, int index,
                                 int is_relative = 0);


extern "C"  void* __cdecl  cvCvtSeqToArray( const CvSeq* seq, void* elements,
                               CvSlice slice = cvSlice(0, 0x3fffffff) );




extern "C"  CvSeq* __cdecl cvMakeSeqHeaderForArray( int seq_type, int header_size,
                                       int elem_size, void* elements, int total,
                                       CvSeq* seq, CvSeqBlock* block );


extern "C"  CvSeq* __cdecl cvSeqSlice( const CvSeq* seq, CvSlice slice,
                         CvMemStorage* storage = 0,
                         int copy_data = 0);

static inline CvSeq* cvCloneSeq( const CvSeq* seq, CvMemStorage* storage = 0)
{
    return cvSeqSlice( seq, cvSlice(0, 0x3fffffff), storage, 1 );
}


extern "C"  void __cdecl  cvSeqRemoveSlice( CvSeq* seq, CvSlice slice );


extern "C"  void __cdecl  cvSeqInsertSlice( CvSeq* seq, int before_index, const CvArr* from_arr );


typedef int (__cdecl* CvCmpFunc)(const void* a, const void* b, void* userdata );


extern "C"  void __cdecl cvSeqSort( CvSeq* seq, CvCmpFunc func, void* userdata = 0 );


extern "C"  schar* __cdecl cvSeqSearch( CvSeq* seq, const void* elem, CvCmpFunc func,
                           int is_sorted, int* elem_idx,
                           void* userdata = 0 );


extern "C"  void __cdecl cvSeqInvert( CvSeq* seq );


extern "C"  int __cdecl  cvSeqPartition( const CvSeq* seq, CvMemStorage* storage,
                            CvSeq** labels, CvCmpFunc is_equal, void* userdata );


extern "C"  void __cdecl  cvChangeSeqBlock( void* reader, int direction );
extern "C"  void __cdecl  cvCreateSeqBlock( CvSeqWriter* writer );



extern "C"  CvSet* __cdecl  cvCreateSet( int set_flags, int header_size,
                            int elem_size, CvMemStorage* storage );


extern "C"  int __cdecl  cvSetAdd( CvSet* set_header, CvSetElem* elem = 0,
                      CvSetElem** inserted_elem = 0 );


static inline  CvSetElem* cvSetNew( CvSet* set_header )
{
    CvSetElem* elem = set_header->free_elems;
    if( elem )
    {
        set_header->free_elems = elem->next_free;
        elem->flags = elem->flags & ((1 << 26) - 1);
        set_header->active_count++;
    }
    else
        cvSetAdd( set_header, 0, &elem );
    return elem;
}


static inline  void cvSetRemoveByPtr( CvSet* set_header, void* elem )
{
    CvSetElem* _elem = (CvSetElem*)elem;
    (void)( (!!(_elem->flags >= 0)) || (_wassert(L"_elem->flags >= 0", L"C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/core_c.h", 1755), 0) );
    _elem->next_free = set_header->free_elems;
    _elem->flags = (_elem->flags & ((1 << 26) - 1)) | (1 << (sizeof(int)*8-1));
    set_header->free_elems = _elem;
    set_header->active_count--;
}


extern "C"  void __cdecl   cvSetRemove( CvSet* set_header, int index );



static inline CvSetElem* cvGetSetElem( const CvSet* set_header, int idx )
{
    CvSetElem* elem = (CvSetElem*)(void *)cvGetSeqElem( (CvSeq*)set_header, idx );
    return elem && (((CvSetElem*)(elem))->flags >= 0) ? elem : 0;
}


extern "C"  void __cdecl  cvClearSet( CvSet* set_header );


extern "C"  CvGraph* __cdecl  cvCreateGraph( int graph_flags, int header_size,
                                int vtx_size, int edge_size,
                                CvMemStorage* storage );


extern "C"  int __cdecl  cvGraphAddVtx( CvGraph* graph, const CvGraphVtx* vtx = 0,
                           CvGraphVtx** inserted_vtx = 0 );



extern "C"  int __cdecl  cvGraphRemoveVtx( CvGraph* graph, int index );
extern "C"  int __cdecl  cvGraphRemoveVtxByPtr( CvGraph* graph, CvGraphVtx* vtx );






extern "C"  int __cdecl  cvGraphAddEdge( CvGraph* graph,
                            int start_idx, int end_idx,
                            const CvGraphEdge* edge = 0,
                            CvGraphEdge** inserted_edge = 0 );

extern "C"  int __cdecl  cvGraphAddEdgeByPtr( CvGraph* graph,
                               CvGraphVtx* start_vtx, CvGraphVtx* end_vtx,
                               const CvGraphEdge* edge = 0,
                               CvGraphEdge** inserted_edge = 0 );


extern "C"  void __cdecl  cvGraphRemoveEdge( CvGraph* graph, int start_idx, int end_idx );
extern "C"  void __cdecl  cvGraphRemoveEdgeByPtr( CvGraph* graph, CvGraphVtx* start_vtx,
                                     CvGraphVtx* end_vtx );


extern "C"  CvGraphEdge* __cdecl  cvFindGraphEdge( const CvGraph* graph, int start_idx, int end_idx );
extern "C"  CvGraphEdge* __cdecl  cvFindGraphEdgeByPtr( const CvGraph* graph,
                                           const CvGraphVtx* start_vtx,
                                           const CvGraphVtx* end_vtx );




extern "C"  void __cdecl  cvClearGraph( CvGraph* graph );



extern "C"  int __cdecl  cvGraphVtxDegree( const CvGraph* graph, int vtx_idx );
extern "C"  int __cdecl  cvGraphVtxDegreeByPtr( const CvGraph* graph, const CvGraphVtx* vtx );



































typedef struct CvGraphScanner
{
    CvGraphVtx* vtx;       
    CvGraphVtx* dst;       
    CvGraphEdge* edge;     

    CvGraph* graph;        
    CvSeq*   stack;        
    int      index;        
    int      mask;         
}
CvGraphScanner;


extern "C"  CvGraphScanner* __cdecl  cvCreateGraphScanner( CvGraph* graph,
                                             CvGraphVtx* vtx = 0,
                                             int mask = -1);


extern "C"  void __cdecl cvReleaseGraphScanner( CvGraphScanner** scanner );


extern "C"  int __cdecl  cvNextGraphItem( CvGraphScanner* scanner );


extern "C"  CvGraph* __cdecl cvCloneGraph( const CvGraph* graph, CvMemStorage* storage );




extern "C"  void __cdecl cvLUT( const CvArr* src, CvArr* dst, const CvArr* lut );



typedef struct CvTreeNodeIterator
{
    const void* node;
    int level;
    int max_level;
}
CvTreeNodeIterator;

extern "C"  void __cdecl cvInitTreeNodeIterator( CvTreeNodeIterator* tree_iterator,
                                   const void* first, int max_level );
extern "C"  void* __cdecl cvNextTreeNode( CvTreeNodeIterator* tree_iterator );
extern "C"  void* __cdecl cvPrevTreeNode( CvTreeNodeIterator* tree_iterator );




extern "C"  void __cdecl cvInsertNodeIntoTree( void* node, void* parent, void* frame );


extern "C"  void __cdecl cvRemoveNodeFromTree( void* node, void* frame );



extern "C"  CvSeq* __cdecl cvTreeToNodeSeq( const void* first, int header_size,
                              CvMemStorage* storage );




extern "C"  int __cdecl cvKMeans2( const CvArr* samples, int cluster_count, CvArr* labels,
                      CvTermCriteria termcrit, int attempts = 1,
                      CvRNG* rng = 0, int flags = 0,
                      CvArr* _centers = 0, double* compactness = 0 );






extern "C"  int __cdecl  cvUseOptimized( int on_off );

typedef IplImage* (__stdcall* Cv_iplCreateImageHeader)
                            (int,int,int,char*,char*,int,int,int,int,int,
                            IplROI*,IplImage*,void*,IplTileInfo*);
typedef void (__stdcall* Cv_iplAllocateImageData)(IplImage*,int,int);
typedef void (__stdcall* Cv_iplDeallocate)(IplImage*,int);
typedef IplROI* (__stdcall* Cv_iplCreateROI)(int,int,int,int,int);
typedef IplImage* (__stdcall* Cv_iplCloneImage)(const IplImage*);

















extern "C"  void __cdecl cvSetIPLAllocators( Cv_iplCreateImageHeader create_header,
                               Cv_iplAllocateImageData allocate_data,
                               Cv_iplDeallocate deallocate,
                               Cv_iplCreateROI create_roi,
                               Cv_iplCloneImage clone_image );



































extern "C"  CvFileStorage* __cdecl  cvOpenFileStorage( const char* filename, CvMemStorage* memstorage,
                                          int flags, const char* encoding = 0 );







extern "C"  void __cdecl cvReleaseFileStorage( CvFileStorage** fs );


extern "C"  const char* __cdecl cvAttrValue( const CvAttrList* attr, const char* attr_name );



























extern "C"  void __cdecl cvStartWriteStruct( CvFileStorage* fs, const char* name,
                                int struct_flags, const char* type_name = 0,
                                CvAttrList attributes = cvAttrList());





extern "C"  void __cdecl cvEndWriteStruct( CvFileStorage* fs );









extern "C"  void __cdecl cvWriteInt( CvFileStorage* fs, const char* name, int value );


























extern "C"  void __cdecl cvWriteReal( CvFileStorage* fs, const char* name, double value );












extern "C"  void __cdecl cvWriteString( CvFileStorage* fs, const char* name,
                           const char* str, int quote = 0 );










extern "C"  void __cdecl cvWriteComment( CvFileStorage* fs, const char* comment,
                            int eol_comment );














































extern "C"  void __cdecl cvWrite( CvFileStorage* fs, const char* name, const void* ptr,
                         CvAttrList attributes = cvAttrList());

























extern "C"  void __cdecl cvStartNextStream( CvFileStorage* fs );












extern "C"  void __cdecl cvWriteRawData( CvFileStorage* fs, const void* src,
                                int len, const char* dt );




















extern "C"  void __cdecl cvWriteRawDataBase64( CvFileStorage* fs, const void* src,
                                 int len, const char* dt );





































































extern "C"  CvStringHashNode* __cdecl cvGetHashedKey( CvFileStorage* fs, const char* name,
                                        int len = -1,
                                        int create_missing = 0);












extern "C"  CvFileNode* __cdecl cvGetRootFileNode( const CvFileStorage* fs,
                                     int stream_index = 0 );











extern "C"  CvFileNode* __cdecl cvGetFileNode( CvFileStorage* fs, CvFileNode* map,
                                 const CvStringHashNode* key,
                                 int create_missing = 0 );













extern "C"  CvFileNode* __cdecl cvGetFileNodeByName( const CvFileStorage* fs,
                                       const CvFileNode* map,
                                       const char* name );











static inline int cvReadInt( const CvFileNode* node, int default_value = 0 )
{
    return !node ? default_value :
        (((node->tag) & 7) == 1) ? node->data.i :
        (((node->tag) & 7) == 2) ? cvRound(node->data.f) : 0x7fffffff;
}









static inline int cvReadIntByName( const CvFileStorage* fs, const CvFileNode* map,
                         const char* name, int default_value = 0 )
{
    return cvReadInt( cvGetFileNodeByName( fs, map, name ), default_value );
}











static inline double cvReadReal( const CvFileNode* node, double default_value = 0. )
{
    return !node ? default_value :
        (((node->tag) & 7) == 1) ? (double)node->data.i :
        (((node->tag) & 7) == 2) ? node->data.f : 1e300;
}









static inline double cvReadRealByName( const CvFileStorage* fs, const CvFileNode* map,
                        const char* name, double default_value = 0. )
{
    return cvReadReal( cvGetFileNodeByName( fs, map, name ), default_value );
}










static inline const char* cvReadString( const CvFileNode* node,
                        const char* default_value = 0 )
{
    return !node ? default_value : (((node->tag) & 7) == 3) ? node->data.str.ptr : 0;
}









static inline const char* cvReadStringByName( const CvFileStorage* fs, const CvFileNode* map,
                        const char* name, const char* default_value = 0 )
{
    return cvReadString( cvGetFileNodeByName( fs, map, name ), default_value );
}
















extern "C"  void* __cdecl cvRead( CvFileStorage* fs, CvFileNode* node,
                        CvAttrList* attributes = 0);









static inline void* cvReadByName( CvFileStorage* fs, const CvFileNode* map,
                              const char* name, CvAttrList* attributes = 0 )
{
    return cvRead( fs, cvGetFileNodeByName( fs, map, name ), attributes );
}










extern "C"  void __cdecl cvStartReadRawData( const CvFileStorage* fs, const CvFileNode* src,
                               CvSeqReader* reader );














extern "C"  void __cdecl cvReadRawDataSlice( const CvFileStorage* fs, CvSeqReader* reader,
                               int count, void* dst, const char* dt );









extern "C"  void __cdecl cvReadRawData( const CvFileStorage* fs, const CvFileNode* src,
                          void* dst, const char* dt );














extern "C"  void __cdecl cvWriteFileNode( CvFileStorage* fs, const char* new_node_name,
                            const CvFileNode* node, int embed );







extern "C"  const char* __cdecl cvGetFileNodeName( const CvFileNode* node );









extern "C"  void __cdecl cvRegisterType( const CvTypeInfo* info );








extern "C"  void __cdecl cvUnregisterType( const char* type_name );






extern "C"  CvTypeInfo* __cdecl cvFirstType(void);







extern "C"  CvTypeInfo* __cdecl cvFindType( const char* type_name );









extern "C"  CvTypeInfo* __cdecl cvTypeOf( const void* struct_ptr );






extern "C"  void __cdecl cvRelease( void** struct_ptr );








extern "C"  void* __cdecl cvClone( const void* struct_ptr );










extern "C"  void __cdecl cvSave( const char* filename, const void* struct_ptr,
                    const char* name = 0,
                    const char* comment = 0,
                    CvAttrList attributes = cvAttrList());

















extern "C"  void* __cdecl cvLoad( const char* filename,
                     CvMemStorage* memstorage = 0,
                     const char* name = 0,
                     const char** real_name = 0 );





extern "C"  int64 __cdecl  cvGetTickCount( void );
extern "C"  double __cdecl cvGetTickFrequency( void );



extern "C"  int __cdecl cvCheckHardwareSupport(int feature);




extern "C"  int __cdecl  cvGetNumThreads( void );
extern "C"  void __cdecl cvSetNumThreads( int threads = 0 );

extern "C"  int __cdecl  cvGetThreadNum( void );





extern "C"  int __cdecl cvGetErrStatus( void );


extern "C"  void __cdecl cvSetErrStatus( int status );






extern "C"  int __cdecl  cvGetErrMode( void );


extern "C"  int __cdecl cvSetErrMode( int mode );




extern "C"  void __cdecl cvError( int status, const char* func_name,
                    const char* err_msg, const char* file_name, int line );


extern "C"  const char* __cdecl cvErrorStr( int status );


extern "C"  int __cdecl cvGetErrInfo( const char** errcode_desc, const char** description,
                        const char** filename, int* line );


extern "C"  int __cdecl cvErrorFromIppStatus( int ipp_status );

typedef int (__cdecl *CvErrorCallback)( int status, const char* func_name,
                                        const char* err_msg, const char* file_name, int line, void* userdata );


extern "C"  CvErrorCallback __cdecl cvRedirectError( CvErrorCallback error_handler,
                                       void* userdata = 0,
                                       void** prev_userdata = 0 );


extern "C"  int __cdecl cvNulDevReport( int status, const char* func_name, const char* err_msg,
                          const char* file_name, int line, void* userdata );


extern "C"  int __cdecl cvStdErrReport( int status, const char* func_name, const char* err_msg,
                          const char* file_name, int line, void* userdata );


extern "C"  int __cdecl cvGuiBoxReport( int status, const char* func_name, const char* err_msg,
                          const char* file_name, int line, void* userdata );





















#line 2714 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/core_c.h"


















































} 
#line 2766 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/core_c.h"







struct  CvType
{
    CvType( const char* type_name,
            CvIsInstanceFunc is_instance, CvReleaseFunc release=0,
            CvReadFunc read=0, CvWriteFunc write=0, CvCloneFunc clone=0 );
    ~CvType();
    CvTypeInfo* info;

    static CvTypeInfo* first;
    static CvTypeInfo* last;
};



#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/utility.hpp"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 2788 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/core_c.h"

namespace cv
{







 Mat cvarrToMat(const CvArr* arr, bool copyData=false,
                          bool allowND=true, int coiMode=0,
                          AutoBuffer<double>* buf=0);

static inline Mat cvarrToMatND(const CvArr* arr, bool copyData=false, int coiMode=0)
{
    return cvarrToMat(arr, copyData, true, coiMode);
}



 void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi=-1);

 void insertImageCOI(InputArray coiimg, CvArr* arr, int coi=-1);





template<>  void DefaultDeleter<CvMat>::operator ()(CvMat* obj) const;
template<>  void DefaultDeleter<IplImage>::operator ()(IplImage* obj) const;
template<>  void DefaultDeleter<CvMatND>::operator ()(CvMatND* obj) const;
template<>  void DefaultDeleter<CvSparseMat>::operator ()(CvSparseMat* obj) const;
template<>  void DefaultDeleter<CvMemStorage>::operator ()(CvMemStorage* obj) const;



template<typename _Tp> class SeqIterator;

typedef Ptr<CvMemStorage> MemStorage;











template<typename _Tp> class Seq
{
public:
    typedef SeqIterator<_Tp> iterator;
    typedef SeqIterator<_Tp> const_iterator;

    
    Seq();
    
    Seq(const CvSeq* seq);
    
    Seq(MemStorage& storage, int headerSize = sizeof(CvSeq));
    
    _Tp& operator [](int idx);
    
    const _Tp& operator[](int idx) const;
    
    SeqIterator<_Tp> begin() const;
    
    SeqIterator<_Tp> end() const;
    
    size_t size() const;
    
    int type() const;
    
    int depth() const;
    
    int channels() const;
    
    size_t elemSize() const;
    
    size_t index(const _Tp& elem) const;
    
    void push_back(const _Tp& elem);
    
    void push_front(const _Tp& elem);
    
    void push_back(const _Tp* elems, size_t count);
    
    void push_front(const _Tp* elems, size_t count);
    
    void insert(int idx, const _Tp& elem);
    
    void insert(int idx, const _Tp* elems, size_t count);
    
    void remove(int idx);
    
    void remove(const Range& r);

    
    _Tp& front();
    
    const _Tp& front() const;
    
    _Tp& back();
    
    const _Tp& back() const;
    
    bool empty() const;

    
    void clear();
    
    void pop_front();
    
    void pop_back();
    
    void pop_front(_Tp* elems, size_t count);
    
    void pop_back(_Tp* elems, size_t count);

    
    void copyTo(std::vector<_Tp>& vec, const Range& range=Range::all()) const;
    
    operator std::vector<_Tp>() const;

    CvSeq* seq;
};





template<typename _Tp> class SeqIterator : public CvSeqReader
{
public:
    
    SeqIterator();
    
    SeqIterator(const Seq<_Tp>& seq, bool seekEnd=false);
    
    void seek(size_t pos);
    
    size_t tell() const;
    
    _Tp& operator *();
    
    const _Tp& operator *() const;
    
    SeqIterator& operator ++();
    
    SeqIterator operator ++(int) const;
    
    SeqIterator& operator --();
    
    SeqIterator operator --(int) const;

    
    SeqIterator& operator +=(int);
    
    SeqIterator& operator -=(int);

    
    
    int index;
};




 schar*  seqPush( CvSeq* seq, const void* element=0);
 schar*  seqPushFront( CvSeq* seq, const void* element=0);
 void  seqPop( CvSeq* seq, void* element=0);
 void  seqPopFront( CvSeq* seq, void* element=0);
 void  seqPopMulti( CvSeq* seq, void* elements,
                              int count, int in_front=0 );
 void  seqRemove( CvSeq* seq, int index );
 void  clearSeq( CvSeq* seq );
 schar*  getSeqElem( const CvSeq* seq, int index );
 void  seqRemoveSlice( CvSeq* seq, CvSlice slice );
 void  seqInsertSlice( CvSeq* seq, int before_index, const CvArr* from_arr );

template<typename _Tp> inline Seq<_Tp>::Seq() : seq(0) {}
template<typename _Tp> inline Seq<_Tp>::Seq( const CvSeq* _seq ) : seq((CvSeq*)_seq)
{
    if(!!(!_seq || _seq->elem_size == sizeof(_Tp))) ; else cv::error( cv::Error::StsAssert, "!_seq || _seq->elem_size == sizeof(_Tp)",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/core_c.h", 2974 );
}

template<typename _Tp> inline Seq<_Tp>::Seq( MemStorage& storage,
                                             int headerSize )
{
    if(!!(headerSize >= (int)sizeof(CvSeq))) ; else cv::error( cv::Error::StsAssert, "headerSize >= (int)sizeof(CvSeq)",  __FUNCTION__  , "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/core_c.h", 2980 );
    seq = cvCreateSeq(DataType<_Tp>::type, headerSize, sizeof(_Tp), storage);
}

template<typename _Tp> inline _Tp& Seq<_Tp>::operator [](int idx)
{ return *(_Tp*)getSeqElem(seq, idx); }

template<typename _Tp> inline const _Tp& Seq<_Tp>::operator [](int idx) const
{ return *(_Tp*)getSeqElem(seq, idx); }

template<typename _Tp> inline SeqIterator<_Tp> Seq<_Tp>::begin() const
{ return SeqIterator<_Tp>(*this); }

template<typename _Tp> inline SeqIterator<_Tp> Seq<_Tp>::end() const
{ return SeqIterator<_Tp>(*this, true); }

template<typename _Tp> inline size_t Seq<_Tp>::size() const
{ return seq ? seq->total : 0; }

template<typename _Tp> inline int Seq<_Tp>::type() const
{ return seq ? ((seq->flags) & ((1 << 3)*512 - 1)) : 0; }

template<typename _Tp> inline int Seq<_Tp>::depth() const
{ return seq ? ((seq->flags) & ((1 << 3) - 1)) : 0; }

template<typename _Tp> inline int Seq<_Tp>::channels() const
{ return seq ? ((((seq->flags) & ((512 - 1) << 3)) >> 3) + 1) : 0; }

template<typename _Tp> inline size_t Seq<_Tp>::elemSize() const
{ return seq ? seq->elem_size : 0; }

template<typename _Tp> inline size_t Seq<_Tp>::index(const _Tp& elem) const
{ return cvSeqElemIdx(seq, &elem); }

template<typename _Tp> inline void Seq<_Tp>::push_back(const _Tp& elem)
{ cvSeqPush(seq, &elem); }

template<typename _Tp> inline void Seq<_Tp>::push_front(const _Tp& elem)
{ cvSeqPushFront(seq, &elem); }

template<typename _Tp> inline void Seq<_Tp>::push_back(const _Tp* elem, size_t count)
{ cvSeqPushMulti(seq, elem, (int)count, 0); }

template<typename _Tp> inline void Seq<_Tp>::push_front(const _Tp* elem, size_t count)
{ cvSeqPushMulti(seq, elem, (int)count, 1); }

template<typename _Tp> inline _Tp& Seq<_Tp>::back()
{ return *(_Tp*)getSeqElem(seq, -1); }

template<typename _Tp> inline const _Tp& Seq<_Tp>::back() const
{ return *(const _Tp*)getSeqElem(seq, -1); }

template<typename _Tp> inline _Tp& Seq<_Tp>::front()
{ return *(_Tp*)getSeqElem(seq, 0); }

template<typename _Tp> inline const _Tp& Seq<_Tp>::front() const
{ return *(const _Tp*)getSeqElem(seq, 0); }

template<typename _Tp> inline bool Seq<_Tp>::empty() const
{ return !seq || seq->total == 0; }

template<typename _Tp> inline void Seq<_Tp>::clear()
{ if(seq) clearSeq(seq); }

template<typename _Tp> inline void Seq<_Tp>::pop_back()
{ seqPop(seq); }

template<typename _Tp> inline void Seq<_Tp>::pop_front()
{ seqPopFront(seq); }

template<typename _Tp> inline void Seq<_Tp>::pop_back(_Tp* elem, size_t count)
{ seqPopMulti(seq, elem, (int)count, 0); }

template<typename _Tp> inline void Seq<_Tp>::pop_front(_Tp* elem, size_t count)
{ seqPopMulti(seq, elem, (int)count, 1); }

template<typename _Tp> inline void Seq<_Tp>::insert(int idx, const _Tp& elem)
{ seqInsert(seq, idx, &elem); }

template<typename _Tp> inline void Seq<_Tp>::insert(int idx, const _Tp* elems, size_t count)
{
    CvMat m = cvMat(1, count, DataType<_Tp>::type, elems);
    seqInsertSlice(seq, idx, &m);
}

template<typename _Tp> inline void Seq<_Tp>::remove(int idx)
{ seqRemove(seq, idx); }

template<typename _Tp> inline void Seq<_Tp>::remove(const Range& r)
{ seqRemoveSlice(seq, cvSlice(r.start, r.end)); }

template<typename _Tp> inline void Seq<_Tp>::copyTo(std::vector<_Tp>& vec, const Range& range) const
{
    size_t len = !seq ? 0 : range == Range::all() ? seq->total : range.end - range.start;
    vec.resize(len);
    if( seq && len )
        cvCvtSeqToArray(seq, &vec[0], range);
}

template<typename _Tp> inline Seq<_Tp>::operator std::vector<_Tp>() const
{
    std::vector<_Tp> vec;
    copyTo(vec);
    return vec;
}

template<typename _Tp> inline SeqIterator<_Tp>::SeqIterator()
{ memset(this, 0, sizeof(*this)); }

template<typename _Tp> inline SeqIterator<_Tp>::SeqIterator(const Seq<_Tp>& _seq, bool seekEnd)
{
    cvStartReadSeq(_seq.seq, this);
    index = seekEnd ? _seq.seq->total : 0;
}

template<typename _Tp> inline void SeqIterator<_Tp>::seek(size_t pos)
{
    cvSetSeqReaderPos(this, (int)pos, false);
    index = pos;
}

template<typename _Tp> inline size_t SeqIterator<_Tp>::tell() const
{ return index; }

template<typename _Tp> inline _Tp& SeqIterator<_Tp>::operator *()
{ return *(_Tp*)ptr; }

template<typename _Tp> inline const _Tp& SeqIterator<_Tp>::operator *() const
{ return *(const _Tp*)ptr; }

template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator ++()
{
    { if( ((*this).ptr += (sizeof(_Tp))) >= (*this).block_max ) { cvChangeSeqBlock( &(*this), 1 ); } };
    if( ++index >= seq->total*2 )
        index = 0;
    return *this;
}

template<typename _Tp> inline SeqIterator<_Tp> SeqIterator<_Tp>::operator ++(int) const
{
    SeqIterator<_Tp> it = *this;
    ++*this;
    return it;
}

template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator --()
{
    { if( ((*this).ptr -= (sizeof(_Tp))) < (*this).block_min ) { cvChangeSeqBlock( &(*this), -1 ); } };
    if( --index < 0 )
        index = seq->total*2-1;
    return *this;
}

template<typename _Tp> inline SeqIterator<_Tp> SeqIterator<_Tp>::operator --(int) const
{
    SeqIterator<_Tp> it = *this;
    --*this;
    return it;
}

template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator +=(int delta)
{
    cvSetSeqReaderPos(this, delta, 1);
    index += delta;
    int n = seq->total*2;
    if( index < 0 )
        index += n;
    if( index >= n )
        index -= n;
    return *this;
}

template<typename _Tp> inline SeqIterator<_Tp>& SeqIterator<_Tp>::operator -=(int delta)
{
    return (*this += -delta);
}

template<typename _Tp> inline ptrdiff_t operator - (const SeqIterator<_Tp>& a,
                                                    const SeqIterator<_Tp>& b)
{
    ptrdiff_t delta = a.index - b.index, n = a.seq->total;
    if( delta > n || delta < -n )
        delta += delta < 0 ? n : -n;
    return delta;
}

template<typename _Tp> inline bool operator == (const SeqIterator<_Tp>& a,
                                                const SeqIterator<_Tp>& b)
{
    return a.seq == b.seq && a.index == b.index;
}

template<typename _Tp> inline bool operator != (const SeqIterator<_Tp>& a,
                                                const SeqIterator<_Tp>& b)
{
    return !(a == b);
}



} 

#line 3183 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/core_c.h"

#line 3185 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/core_c.h"

#line 1223 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/utility.hpp"
#line 1224 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/utility.hpp"

#line 1226 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/utility.hpp"

#line 3225 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/optim.hpp"












































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 46 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/optim.hpp"

namespace cv
{









class  MinProblemSolver : public Algorithm
{
public:
    

    class  Function
    {
    public:
        virtual ~Function() {}
        virtual int getDims() const = 0;
        virtual double getGradientEps() const;
        virtual double calc(const double* x) const = 0;
        virtual void getGradient(const double* x,double* grad);
    };

    







    virtual Ptr<Function> getFunction() const = 0;

    





    virtual void setFunction(const Ptr<Function>& f) = 0;

    



    virtual TermCriteria getTermCriteria() const = 0;

    










    virtual void setTermCriteria(const TermCriteria& termcrit) = 0;

    











    virtual double minimize(InputOutputArray x) = 0;
};































class  DownhillSolver : public MinProblemSolver
{
public:
    





    virtual void getInitStep(OutputArray step) const=0;

    













    virtual void setInitStep(InputArray step)=0;

    















    static Ptr<DownhillSolver> create(const Ptr<MinProblemSolver::Function>& f=Ptr<MinProblemSolver::Function>(),
                                      InputArray initStep=Mat_<double>(1,1,0.0),
                                      TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5000,0.000001));
};


































class  ConjGradSolver : public MinProblemSolver
{
public:
    












    static Ptr<ConjGradSolver> create(const Ptr<MinProblemSolver::Function>& f=Ptr<ConjGradSolver::Function>(),
                                      TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5000,0.000001));
};


enum SolveLPResult
{
    SOLVELP_UNBOUNDED    = -2, 
    SOLVELP_UNFEASIBLE    = -1, 
    SOLVELP_SINGLE    = 0, 
    SOLVELP_MULTI    = 1 
};
































 int solveLP(const Mat& Func, const Mat& Constr, Mat& z);



}

#line 303 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/optim.hpp"
#line 3226 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/ovx.hpp"









#pragma once



#line 1 "c:\\c++_lib\\opencv\\build\\include\\opencv2\\core\\cvdef.h"


















































































































































































































































































































































































































































#line 15 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/ovx.hpp"

namespace cv
{

 bool haveOpenVX();


 bool useOpenVX();


 void setUseOpenVX(bool flag);
} 

#line 29 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/ovx.hpp"
#line 3227 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"

#line 3229 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"

#line 47 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgproc.hpp"

















































































































































































namespace cv
{









enum MorphTypes{
    MORPH_ERODE    = 0, 
    MORPH_DILATE   = 1, 
    MORPH_OPEN     = 2, 
                        
    MORPH_CLOSE    = 3, 
                        
    MORPH_GRADIENT = 4, 
                        
    MORPH_TOPHAT   = 5, 
                        
    MORPH_BLACKHAT = 6, 
                        
    MORPH_HITMISS  = 7  
                        
};


enum MorphShapes {
    MORPH_RECT    = 0, 
    MORPH_CROSS   = 1, 
                       
    MORPH_ELLIPSE = 2 
                      
};







enum InterpolationFlags{
    
    INTER_NEAREST        = 0,
    
    INTER_LINEAR         = 1,
    
    INTER_CUBIC          = 2,
    


    INTER_AREA           = 3,
    
    INTER_LANCZOS4       = 4,
    
    INTER_MAX            = 7,
    

    WARP_FILL_OUTLIERS   = 8,
    





    WARP_INVERSE_MAP     = 16
};

enum InterpolationMasks {
       INTER_BITS      = 5,
       INTER_BITS2     = INTER_BITS * 2,
       INTER_TAB_SIZE  = 1 << INTER_BITS,
       INTER_TAB_SIZE2 = INTER_TAB_SIZE * INTER_TAB_SIZE
     };








enum DistanceTypes {
    DIST_USER    = -1,  
    DIST_L1      = 1,   
    DIST_L2      = 2,   
    DIST_C       = 3,   
    DIST_L12     = 4,   
    DIST_FAIR    = 5,   
    DIST_WELSCH  = 6,   
    DIST_HUBER   = 7    
};


enum DistanceTransformMasks {
    DIST_MASK_3       = 3, 
    DIST_MASK_5       = 5, 
    DIST_MASK_PRECISE = 0  
};



enum ThresholdTypes {
    THRESH_BINARY     = 0, 
    THRESH_BINARY_INV = 1, 
    THRESH_TRUNC      = 2, 
    THRESH_TOZERO     = 3, 
    THRESH_TOZERO_INV = 4, 
    THRESH_MASK       = 7,
    THRESH_OTSU       = 8, 
    THRESH_TRIANGLE   = 16 
};



enum AdaptiveThresholdTypes {
    

    ADAPTIVE_THRESH_MEAN_C     = 0,
    



    ADAPTIVE_THRESH_GAUSSIAN_C = 1
};


enum UndistortTypes {
       PROJ_SPHERICAL_ORTHO  = 0,
       PROJ_SPHERICAL_EQRECT = 1
     };


enum GrabCutClasses {
    GC_BGD    = 0,  
    GC_FGD    = 1,  
    GC_PR_BGD = 2,  
    GC_PR_FGD = 3   
};


enum GrabCutModes {
    

    GC_INIT_WITH_RECT  = 0,
    


    GC_INIT_WITH_MASK  = 1,
    
    GC_EVAL            = 2
};


enum DistanceTransformLabelTypes {
    

    DIST_LABEL_CCOMP = 0,
    
    DIST_LABEL_PIXEL = 1
};


enum FloodFillFlags {
    

    FLOODFILL_FIXED_RANGE = 1 << 16,
    


    FLOODFILL_MASK_ONLY   = 1 << 17
};







enum ConnectedComponentsTypes {
    CC_STAT_LEFT   = 0, 
                        
    CC_STAT_TOP    = 1, 
                        
    CC_STAT_WIDTH  = 2, 
    CC_STAT_HEIGHT = 3, 
    CC_STAT_AREA   = 4, 
    CC_STAT_MAX    = 5
};


enum ConnectedComponentsAlgorithmsTypes {
    CCL_WU      = 0,  
    CCL_DEFAULT = -1, 
    CCL_GRANA   = 1   
};


enum RetrievalModes {
    

    RETR_EXTERNAL  = 0,
    
    RETR_LIST      = 1,
    



    RETR_CCOMP     = 2,
    
    RETR_TREE      = 3,
    RETR_FLOODFILL = 4 
};


enum ContourApproximationModes {
    


    CHAIN_APPROX_NONE      = 1,
    

    CHAIN_APPROX_SIMPLE    = 2,
    
    CHAIN_APPROX_TC89_L1   = 3,
    
    CHAIN_APPROX_TC89_KCOS = 4
};









enum ShapeMatchModes {
    CONTOURS_MATCH_I1  =1, 
    CONTOURS_MATCH_I2  =2, 
    CONTOURS_MATCH_I3  =3  
};




enum HoughModes {

    



    HOUGH_STANDARD      = 0,
    



    HOUGH_PROBABILISTIC = 1,
    

    HOUGH_MULTI_SCALE   = 2,
    HOUGH_GRADIENT      = 3 
};



enum LineSegmentDetectorModes {
    LSD_REFINE_NONE = 0, 
    LSD_REFINE_STD  = 1, 
    LSD_REFINE_ADV  = 2  
                         
};




enum HistCompMethods {
    




    HISTCMP_CORREL        = 0,
    

    HISTCMP_CHISQR        = 1,
    

    HISTCMP_INTERSECT     = 2,
    


    HISTCMP_BHATTACHARYYA = 3,
    HISTCMP_HELLINGER     = HISTCMP_BHATTACHARYYA, 
    


    HISTCMP_CHISQR_ALT    = 4,
    

    HISTCMP_KL_DIV        = 5
};





enum ColorConversionCodes {
    COLOR_BGR2BGRA     = 0, 
    COLOR_RGB2RGBA     = COLOR_BGR2BGRA,

    COLOR_BGRA2BGR     = 1, 
    COLOR_RGBA2RGB     = COLOR_BGRA2BGR,

    COLOR_BGR2RGBA     = 2, 
    COLOR_RGB2BGRA     = COLOR_BGR2RGBA,

    COLOR_RGBA2BGR     = 3,
    COLOR_BGRA2RGB     = COLOR_RGBA2BGR,

    COLOR_BGR2RGB      = 4,
    COLOR_RGB2BGR      = COLOR_BGR2RGB,

    COLOR_BGRA2RGBA    = 5,
    COLOR_RGBA2BGRA    = COLOR_BGRA2RGBA,

    COLOR_BGR2GRAY     = 6, 
    COLOR_RGB2GRAY     = 7,
    COLOR_GRAY2BGR     = 8,
    COLOR_GRAY2RGB     = COLOR_GRAY2BGR,
    COLOR_GRAY2BGRA    = 9,
    COLOR_GRAY2RGBA    = COLOR_GRAY2BGRA,
    COLOR_BGRA2GRAY    = 10,
    COLOR_RGBA2GRAY    = 11,

    COLOR_BGR2BGR565   = 12, 
    COLOR_RGB2BGR565   = 13,
    COLOR_BGR5652BGR   = 14,
    COLOR_BGR5652RGB   = 15,
    COLOR_BGRA2BGR565  = 16,
    COLOR_RGBA2BGR565  = 17,
    COLOR_BGR5652BGRA  = 18,
    COLOR_BGR5652RGBA  = 19,

    COLOR_GRAY2BGR565  = 20, 
    COLOR_BGR5652GRAY  = 21,

    COLOR_BGR2BGR555   = 22,  
    COLOR_RGB2BGR555   = 23,
    COLOR_BGR5552BGR   = 24,
    COLOR_BGR5552RGB   = 25,
    COLOR_BGRA2BGR555  = 26,
    COLOR_RGBA2BGR555  = 27,
    COLOR_BGR5552BGRA  = 28,
    COLOR_BGR5552RGBA  = 29,

    COLOR_GRAY2BGR555  = 30, 
    COLOR_BGR5552GRAY  = 31,

    COLOR_BGR2XYZ      = 32, 
    COLOR_RGB2XYZ      = 33,
    COLOR_XYZ2BGR      = 34,
    COLOR_XYZ2RGB      = 35,

    COLOR_BGR2YCrCb    = 36, 
    COLOR_RGB2YCrCb    = 37,
    COLOR_YCrCb2BGR    = 38,
    COLOR_YCrCb2RGB    = 39,

    COLOR_BGR2HSV      = 40, 
    COLOR_RGB2HSV      = 41,

    COLOR_BGR2Lab      = 44, 
    COLOR_RGB2Lab      = 45,

    COLOR_BGR2Luv      = 50, 
    COLOR_RGB2Luv      = 51,
    COLOR_BGR2HLS      = 52, 
    COLOR_RGB2HLS      = 53,

    COLOR_HSV2BGR      = 54, 
    COLOR_HSV2RGB      = 55,

    COLOR_Lab2BGR      = 56,
    COLOR_Lab2RGB      = 57,
    COLOR_Luv2BGR      = 58,
    COLOR_Luv2RGB      = 59,
    COLOR_HLS2BGR      = 60,
    COLOR_HLS2RGB      = 61,

    COLOR_BGR2HSV_FULL = 66, 
    COLOR_RGB2HSV_FULL = 67,
    COLOR_BGR2HLS_FULL = 68,
    COLOR_RGB2HLS_FULL = 69,

    COLOR_HSV2BGR_FULL = 70,
    COLOR_HSV2RGB_FULL = 71,
    COLOR_HLS2BGR_FULL = 72,
    COLOR_HLS2RGB_FULL = 73,

    COLOR_LBGR2Lab     = 74,
    COLOR_LRGB2Lab     = 75,
    COLOR_LBGR2Luv     = 76,
    COLOR_LRGB2Luv     = 77,

    COLOR_Lab2LBGR     = 78,
    COLOR_Lab2LRGB     = 79,
    COLOR_Luv2LBGR     = 80,
    COLOR_Luv2LRGB     = 81,

    COLOR_BGR2YUV      = 82, 
    COLOR_RGB2YUV      = 83,
    COLOR_YUV2BGR      = 84,
    COLOR_YUV2RGB      = 85,

    
    COLOR_YUV2RGB_NV12  = 90,
    COLOR_YUV2BGR_NV12  = 91,
    COLOR_YUV2RGB_NV21  = 92,
    COLOR_YUV2BGR_NV21  = 93,
    COLOR_YUV420sp2RGB  = COLOR_YUV2RGB_NV21,
    COLOR_YUV420sp2BGR  = COLOR_YUV2BGR_NV21,

    COLOR_YUV2RGBA_NV12 = 94,
    COLOR_YUV2BGRA_NV12 = 95,
    COLOR_YUV2RGBA_NV21 = 96,
    COLOR_YUV2BGRA_NV21 = 97,
    COLOR_YUV420sp2RGBA = COLOR_YUV2RGBA_NV21,
    COLOR_YUV420sp2BGRA = COLOR_YUV2BGRA_NV21,

    COLOR_YUV2RGB_YV12  = 98,
    COLOR_YUV2BGR_YV12  = 99,
    COLOR_YUV2RGB_IYUV  = 100,
    COLOR_YUV2BGR_IYUV  = 101,
    COLOR_YUV2RGB_I420  = COLOR_YUV2RGB_IYUV,
    COLOR_YUV2BGR_I420  = COLOR_YUV2BGR_IYUV,
    COLOR_YUV420p2RGB   = COLOR_YUV2RGB_YV12,
    COLOR_YUV420p2BGR   = COLOR_YUV2BGR_YV12,

    COLOR_YUV2RGBA_YV12 = 102,
    COLOR_YUV2BGRA_YV12 = 103,
    COLOR_YUV2RGBA_IYUV = 104,
    COLOR_YUV2BGRA_IYUV = 105,
    COLOR_YUV2RGBA_I420 = COLOR_YUV2RGBA_IYUV,
    COLOR_YUV2BGRA_I420 = COLOR_YUV2BGRA_IYUV,
    COLOR_YUV420p2RGBA  = COLOR_YUV2RGBA_YV12,
    COLOR_YUV420p2BGRA  = COLOR_YUV2BGRA_YV12,

    COLOR_YUV2GRAY_420  = 106,
    COLOR_YUV2GRAY_NV21 = COLOR_YUV2GRAY_420,
    COLOR_YUV2GRAY_NV12 = COLOR_YUV2GRAY_420,
    COLOR_YUV2GRAY_YV12 = COLOR_YUV2GRAY_420,
    COLOR_YUV2GRAY_IYUV = COLOR_YUV2GRAY_420,
    COLOR_YUV2GRAY_I420 = COLOR_YUV2GRAY_420,
    COLOR_YUV420sp2GRAY = COLOR_YUV2GRAY_420,
    COLOR_YUV420p2GRAY  = COLOR_YUV2GRAY_420,

    
    COLOR_YUV2RGB_UYVY = 107,
    COLOR_YUV2BGR_UYVY = 108,
    
    
    COLOR_YUV2RGB_Y422 = COLOR_YUV2RGB_UYVY,
    COLOR_YUV2BGR_Y422 = COLOR_YUV2BGR_UYVY,
    COLOR_YUV2RGB_UYNV = COLOR_YUV2RGB_UYVY,
    COLOR_YUV2BGR_UYNV = COLOR_YUV2BGR_UYVY,

    COLOR_YUV2RGBA_UYVY = 111,
    COLOR_YUV2BGRA_UYVY = 112,
    
    
    COLOR_YUV2RGBA_Y422 = COLOR_YUV2RGBA_UYVY,
    COLOR_YUV2BGRA_Y422 = COLOR_YUV2BGRA_UYVY,
    COLOR_YUV2RGBA_UYNV = COLOR_YUV2RGBA_UYVY,
    COLOR_YUV2BGRA_UYNV = COLOR_YUV2BGRA_UYVY,

    COLOR_YUV2RGB_YUY2 = 115,
    COLOR_YUV2BGR_YUY2 = 116,
    COLOR_YUV2RGB_YVYU = 117,
    COLOR_YUV2BGR_YVYU = 118,
    COLOR_YUV2RGB_YUYV = COLOR_YUV2RGB_YUY2,
    COLOR_YUV2BGR_YUYV = COLOR_YUV2BGR_YUY2,
    COLOR_YUV2RGB_YUNV = COLOR_YUV2RGB_YUY2,
    COLOR_YUV2BGR_YUNV = COLOR_YUV2BGR_YUY2,

    COLOR_YUV2RGBA_YUY2 = 119,
    COLOR_YUV2BGRA_YUY2 = 120,
    COLOR_YUV2RGBA_YVYU = 121,
    COLOR_YUV2BGRA_YVYU = 122,
    COLOR_YUV2RGBA_YUYV = COLOR_YUV2RGBA_YUY2,
    COLOR_YUV2BGRA_YUYV = COLOR_YUV2BGRA_YUY2,
    COLOR_YUV2RGBA_YUNV = COLOR_YUV2RGBA_YUY2,
    COLOR_YUV2BGRA_YUNV = COLOR_YUV2BGRA_YUY2,

    COLOR_YUV2GRAY_UYVY = 123,
    COLOR_YUV2GRAY_YUY2 = 124,
    
    COLOR_YUV2GRAY_Y422 = COLOR_YUV2GRAY_UYVY,
    COLOR_YUV2GRAY_UYNV = COLOR_YUV2GRAY_UYVY,
    COLOR_YUV2GRAY_YVYU = COLOR_YUV2GRAY_YUY2,
    COLOR_YUV2GRAY_YUYV = COLOR_YUV2GRAY_YUY2,
    COLOR_YUV2GRAY_YUNV = COLOR_YUV2GRAY_YUY2,

    
    COLOR_RGBA2mRGBA    = 125,
    COLOR_mRGBA2RGBA    = 126,

    
    COLOR_RGB2YUV_I420  = 127,
    COLOR_BGR2YUV_I420  = 128,
    COLOR_RGB2YUV_IYUV  = COLOR_RGB2YUV_I420,
    COLOR_BGR2YUV_IYUV  = COLOR_BGR2YUV_I420,

    COLOR_RGBA2YUV_I420 = 129,
    COLOR_BGRA2YUV_I420 = 130,
    COLOR_RGBA2YUV_IYUV = COLOR_RGBA2YUV_I420,
    COLOR_BGRA2YUV_IYUV = COLOR_BGRA2YUV_I420,
    COLOR_RGB2YUV_YV12  = 131,
    COLOR_BGR2YUV_YV12  = 132,
    COLOR_RGBA2YUV_YV12 = 133,
    COLOR_BGRA2YUV_YV12 = 134,

    
    COLOR_BayerBG2BGR = 46,
    COLOR_BayerGB2BGR = 47,
    COLOR_BayerRG2BGR = 48,
    COLOR_BayerGR2BGR = 49,

    COLOR_BayerBG2RGB = COLOR_BayerRG2BGR,
    COLOR_BayerGB2RGB = COLOR_BayerGR2BGR,
    COLOR_BayerRG2RGB = COLOR_BayerBG2BGR,
    COLOR_BayerGR2RGB = COLOR_BayerGB2BGR,

    COLOR_BayerBG2GRAY = 86,
    COLOR_BayerGB2GRAY = 87,
    COLOR_BayerRG2GRAY = 88,
    COLOR_BayerGR2GRAY = 89,

    
    COLOR_BayerBG2BGR_VNG = 62,
    COLOR_BayerGB2BGR_VNG = 63,
    COLOR_BayerRG2BGR_VNG = 64,
    COLOR_BayerGR2BGR_VNG = 65,

    COLOR_BayerBG2RGB_VNG = COLOR_BayerRG2BGR_VNG,
    COLOR_BayerGB2RGB_VNG = COLOR_BayerGR2BGR_VNG,
    COLOR_BayerRG2RGB_VNG = COLOR_BayerBG2BGR_VNG,
    COLOR_BayerGR2RGB_VNG = COLOR_BayerGB2BGR_VNG,

    
    COLOR_BayerBG2BGR_EA  = 135,
    COLOR_BayerGB2BGR_EA  = 136,
    COLOR_BayerRG2BGR_EA  = 137,
    COLOR_BayerGR2BGR_EA  = 138,

    COLOR_BayerBG2RGB_EA  = COLOR_BayerRG2BGR_EA,
    COLOR_BayerGB2RGB_EA  = COLOR_BayerGR2BGR_EA,
    COLOR_BayerRG2RGB_EA  = COLOR_BayerBG2BGR_EA,
    COLOR_BayerGR2RGB_EA  = COLOR_BayerGB2BGR_EA,

    
    COLOR_BayerBG2BGRA = 139,
    COLOR_BayerGB2BGRA = 140,
    COLOR_BayerRG2BGRA = 141,
    COLOR_BayerGR2BGRA = 142,

    COLOR_BayerBG2RGBA = COLOR_BayerRG2BGRA,
    COLOR_BayerGB2RGBA = COLOR_BayerGR2BGRA,
    COLOR_BayerRG2RGBA = COLOR_BayerBG2BGRA,
    COLOR_BayerGR2RGBA = COLOR_BayerGB2BGRA,

    COLOR_COLORCVT_MAX  = 143
};




enum RectanglesIntersectTypes {
    INTERSECT_NONE = 0, 
    INTERSECT_PARTIAL  = 1, 
    INTERSECT_FULL  = 2 
};


class  GeneralizedHough : public Algorithm
{
public:
    
    virtual void setTemplate(InputArray templ, Point templCenter = Point(-1, -1)) = 0;
    virtual void setTemplate(InputArray edges, InputArray dx, InputArray dy, Point templCenter = Point(-1, -1)) = 0;

    
    virtual void detect(InputArray image, OutputArray positions, OutputArray votes = noArray()) = 0;
    virtual void detect(InputArray edges, InputArray dx, InputArray dy, OutputArray positions, OutputArray votes = noArray()) = 0;

    
    virtual void setCannyLowThresh(int cannyLowThresh) = 0;
    virtual int getCannyLowThresh() const = 0;

    
    virtual void setCannyHighThresh(int cannyHighThresh) = 0;
    virtual int getCannyHighThresh() const = 0;

    
    virtual void setMinDist(double minDist) = 0;
    virtual double getMinDist() const = 0;

    
    virtual void setDp(double dp) = 0;
    virtual double getDp() const = 0;

    
    virtual void setMaxBufferSize(int maxBufferSize) = 0;
    virtual int getMaxBufferSize() const = 0;
};



class  GeneralizedHoughBallard : public GeneralizedHough
{
public:
    
    virtual void setLevels(int levels) = 0;
    virtual int getLevels() const = 0;

    
    virtual void setVotesThreshold(int votesThreshold) = 0;
    virtual int getVotesThreshold() const = 0;
};



class  GeneralizedHoughGuil : public GeneralizedHough
{
public:
    
    virtual void setXi(double xi) = 0;
    virtual double getXi() const = 0;

    
    virtual void setLevels(int levels) = 0;
    virtual int getLevels() const = 0;

    
    virtual void setAngleEpsilon(double angleEpsilon) = 0;
    virtual double getAngleEpsilon() const = 0;

    
    virtual void setMinAngle(double minAngle) = 0;
    virtual double getMinAngle() const = 0;

    
    virtual void setMaxAngle(double maxAngle) = 0;
    virtual double getMaxAngle() const = 0;

    
    virtual void setAngleStep(double angleStep) = 0;
    virtual double getAngleStep() const = 0;

    
    virtual void setAngleThresh(int angleThresh) = 0;
    virtual int getAngleThresh() const = 0;

    
    virtual void setMinScale(double minScale) = 0;
    virtual double getMinScale() const = 0;

    
    virtual void setMaxScale(double maxScale) = 0;
    virtual double getMaxScale() const = 0;

    
    virtual void setScaleStep(double scaleStep) = 0;
    virtual double getScaleStep() const = 0;

    
    virtual void setScaleThresh(int scaleThresh) = 0;
    virtual int getScaleThresh() const = 0;

    
    virtual void setPosThresh(int posThresh) = 0;
    virtual int getPosThresh() const = 0;
};


class  CLAHE : public Algorithm
{
public:
     virtual void apply(InputArray src, OutputArray dst) = 0;

     virtual void setClipLimit(double clipLimit) = 0;
     virtual double getClipLimit() const = 0;

     virtual void setTilesGridSize(Size tileGridSize) = 0;
     virtual Size getTilesGridSize() const = 0;

     virtual void collectGarbage() = 0;
};





class  Subdiv2D
{
public:
    
    enum { PTLOC_ERROR        = -2, 
           PTLOC_OUTSIDE_RECT = -1, 
           PTLOC_INSIDE       = 0, 
           PTLOC_VERTEX       = 1, 
           PTLOC_ON_EDGE      = 2  
         };

    
    enum { NEXT_AROUND_ORG   = 0x00,
           NEXT_AROUND_DST   = 0x22,
           PREV_AROUND_ORG   = 0x11,
           PREV_AROUND_DST   = 0x33,
           NEXT_AROUND_LEFT  = 0x13,
           NEXT_AROUND_RIGHT = 0x31,
           PREV_AROUND_LEFT  = 0x20,
           PREV_AROUND_RIGHT = 0x02
         };

    


     Subdiv2D();

    







     Subdiv2D(Rect rect);

    




     void initDelaunay(Rect rect);

    









     int insert(Point2f pt);

    






     void insert(const std::vector<Point2f>& ptvec);

    



















     int locate(Point2f pt,  int& edge,  int& vertex);

    











     int findNearest(Point2f pt,  Point2f* nearestPt = 0);

    






     void getEdgeList( std::vector<Vec4f>& edgeList) const;

    





     void getLeadingEdgeList( std::vector<int>& leadingEdgeList) const;

    






     void getTriangleList( std::vector<Vec6f>& triangleList) const;

    






     void getVoronoiFacetList(const std::vector<int>& idx,  std::vector<std::vector<Point2f> >& facetList,
                                      std::vector<Point2f>& facetCenters);

    






     Point2f getVertex(int vertex,  int* firstEdge = 0) const;

    

















     int getEdge( int edge, int nextEdgeType ) const;

    






     int nextEdge(int edge) const;

    











     int rotateEdge(int edge, int rotate) const;
     int symEdge(int edge) const;

    






     int edgeOrg(int edge,  Point2f* orgpt = 0) const;

    






     int edgeDst(int edge,  Point2f* dstpt = 0) const;

protected:
    int newEdge();
    void deleteEdge(int edge);
    int newPoint(Point2f pt, bool isvirtual, int firstEdge = 0);
    void deletePoint(int vtx);
    void setEdgePoints( int edge, int orgPt, int dstPt );
    void splice( int edgeA, int edgeB );
    int connectEdges( int edgeA, int edgeB );
    void swapEdges( int edge );
    int isRightOf(Point2f pt, int edge) const;
    void calcVoronoi();
    void clearVoronoi();
    void checkSubdiv() const;

    struct  Vertex
    {
        Vertex();
        Vertex(Point2f pt, bool _isvirtual, int _firstEdge=0);
        bool isvirtual() const;
        bool isfree() const;

        int firstEdge;
        int type;
        Point2f pt;
    };

    struct  QuadEdge
    {
        QuadEdge();
        QuadEdge(int edgeidx);
        bool isfree() const;

        int next[4];
        int pt[4];
    };

    
    std::vector<Vertex> vtx;
    
    std::vector<QuadEdge> qedges;
    int freeQEdge;
    int freePoint;
    bool validGeometry;

    int recentEdge;
    
    Point2f topLeft;
    
    Point2f bottomRight;
};














class  LineSegmentDetector : public Algorithm
{
public:

    



















     virtual void detect(InputArray _image, OutputArray _lines,
                        OutputArray width = noArray(), OutputArray prec = noArray(),
                        OutputArray nfa = noArray()) = 0;

    




     virtual void drawSegments(InputOutputArray _image, InputArray lines) = 0;

    







     virtual int compareSegments(const Size& size, InputArray lines1, InputArray lines2, InputOutputArray _image = noArray()) = 0;

    virtual ~LineSegmentDetector() { }
};
















 Ptr<LineSegmentDetector> createLineSegmentDetector(
    int _refine = LSD_REFINE_STD, double _scale = 0.8,
    double _sigma_scale = 0.6, double _quant = 2.0, double _ang_th = 22.5,
    double _log_eps = 0, double _density_th = 0.7, int _n_bins = 1024);
























 Mat getGaussianKernel( int ksize, double sigma, int ktype = 6 );



















 void getDerivKernels( OutputArray kx, OutputArray ky,
                                   int dx, int dy, int ksize,
                                   bool normalize = false, int ktype = 5 );














 Mat getGaborKernel( Size ksize, double sigma, double theta, double lambd,
                                 double gamma, double psi = 3.1415926535897932384626433832795*0.5, int ktype = 6 );


static inline Scalar morphologyDefaultBorderValue() { return Scalar::all(1.7976931348623158e+308); }














 Mat getStructuringElement(int shape, Size ksize, Point anchor = Point(-1,-1));















 void medianBlur( InputArray src, OutputArray dst, int ksize );





















 void GaussianBlur( InputArray src, OutputArray dst, Size ksize,
                                double sigmaX, double sigmaY = 0,
                                int borderType = BORDER_DEFAULT );





























 void bilateralFilter( InputArray src, OutputArray dst, int d,
                                   double sigmaColor, double sigmaSpace,
                                   int borderType = BORDER_DEFAULT );

























 void boxFilter( InputArray src, OutputArray dst, int ddepth,
                             Size ksize, Point anchor = Point(-1,-1),
                             bool normalize = true,
                             int borderType = BORDER_DEFAULT );



















 void sqrBoxFilter( InputArray _src, OutputArray _dst, int ddepth,
                                Size ksize, Point anchor = Point(-1, -1),
                                bool normalize = true,
                                int borderType = BORDER_DEFAULT );



















 void blur( InputArray src, OutputArray dst,
                        Size ksize, Point anchor = Point(-1,-1),
                        int borderType = BORDER_DEFAULT );































 void filter2D( InputArray src, OutputArray dst, int ddepth,
                            InputArray kernel, Point anchor = Point(-1,-1),
                            double delta = 0, int borderType = BORDER_DEFAULT );


















 void sepFilter2D( InputArray src, OutputArray dst, int ddepth,
                               InputArray kernelX, InputArray kernelY,
                               Point anchor = Point(-1,-1),
                               double delta = 0, int borderType = BORDER_DEFAULT );











































 void Sobel( InputArray src, OutputArray dst, int ddepth,
                         int dx, int dy, int ksize = 3,
                         double scale = 1, double delta = 0,
                         int borderType = BORDER_DEFAULT );



















 void spatialGradient( InputArray src, OutputArray dx,
                                   OutputArray dy, int ksize = 3,
                                   int borderType = BORDER_DEFAULT );























 void Scharr( InputArray src, OutputArray dst, int ddepth,
                          int dx, int dy, double scale = 1, double delta = 0,
                          int borderType = BORDER_DEFAULT );




























 void Laplacian( InputArray src, OutputArray dst, int ddepth,
                             int ksize = 1, double scale = 1, double delta = 0,
                             int borderType = BORDER_DEFAULT );



























 void Canny( InputArray image, OutputArray edges,
                         double threshold1, double threshold2,
                         int apertureSize = 3, bool L2gradient = false );









 void Canny( InputArray dx, InputArray dy,
                         OutputArray edges,
                         double threshold1, double threshold2,
                         bool L2gradient = false );














 void cornerMinEigenVal( InputArray src, OutputArray dst,
                                     int blockSize, int ksize = 3,
                                     int borderType = BORDER_DEFAULT );




















 void cornerHarris( InputArray src, OutputArray dst, int blockSize,
                                int ksize, double k,
                                int borderType = BORDER_DEFAULT );



























 void cornerEigenValsAndVecs( InputArray src, OutputArray dst,
                                          int blockSize, int ksize,
                                          int borderType = BORDER_DEFAULT );
























 void preCornerDetect( InputArray src, OutputArray dst, int ksize,
                                   int borderType = BORDER_DEFAULT );









































 void cornerSubPix( InputArray image, InputOutputArray corners,
                                Size winSize, Size zeroZone,
                                TermCriteria criteria );












































 void goodFeaturesToTrack( InputArray image, OutputArray corners,
                                     int maxCorners, double qualityLevel, double minDistance,
                                     InputArray mask = noArray(), int blockSize = 3,
                                     bool useHarrisDetector = false, double k = 0.04 );






























 void HoughLines( InputArray image, OutputArray lines,
                              double rho, double theta, int threshold,
                              double srn = 0, double stn = 0,
                              double min_theta = 0, double max_theta = 3.1415926535897932384626433832795 );
















































































 void HoughLinesP( InputArray image, OutputArray lines,
                               double rho, double theta, int threshold,
                               double minLineLength = 0, double maxLineGap = 0 );








































































 void HoughCircles( InputArray image, OutputArray circles,
                               int method, double dp, double minDist,
                               double param1 = 100, double param2 = 100,
                               int minRadius = 0, int maxRadius = 0 );
































 void erode( InputArray src, OutputArray dst, InputArray kernel,
                         Point anchor = Point(-1,-1), int iterations = 1,
                         int borderType = BORDER_CONSTANT,
                         const Scalar& borderValue = morphologyDefaultBorderValue() );






















 void dilate( InputArray src, OutputArray dst, InputArray kernel,
                          Point anchor = Point(-1,-1), int iterations = 1,
                          int borderType = BORDER_CONSTANT,
                          const Scalar& borderValue = morphologyDefaultBorderValue() );

























 void morphologyEx( InputArray src, OutputArray dst,
                                int op, InputArray kernel,
                                Point anchor = Point(-1,-1), int iterations = 1,
                                int borderType = BORDER_CONSTANT,
                                const Scalar& borderValue = morphologyDefaultBorderValue() );








































 void resize( InputArray src, OutputArray dst,
                          Size dsize, double fx = 0, double fy = 0,
                          int interpolation = INTER_LINEAR );

























 void warpAffine( InputArray src, OutputArray dst,
                              InputArray M, Size dsize,
                              int flags = INTER_LINEAR,
                              int borderMode = BORDER_CONSTANT,
                              const Scalar& borderValue = Scalar());























 void warpPerspective( InputArray src, OutputArray dst,
                                   InputArray M, Size dsize,
                                   int flags = INTER_LINEAR,
                                   int borderMode = BORDER_CONSTANT,
                                   const Scalar& borderValue = Scalar());

































 void remap( InputArray src, OutputArray dst,
                         InputArray map1, InputArray map2,
                         int interpolation, int borderMode = BORDER_CONSTANT,
                         const Scalar& borderValue = Scalar());































 void convertMaps( InputArray map1, InputArray map2,
                               OutputArray dstmap1, OutputArray dstmap2,
                               int dstmap1type, bool nninterpolation = false );




















 Mat getRotationMatrix2D( Point2f center, double angle, double scale );


 Mat getPerspectiveTransform( const Point2f src[], const Point2f dst[] );
















 Mat getAffineTransform( const Point2f src[], const Point2f dst[] );












 void invertAffineTransform( InputArray M, OutputArray iM );
















 Mat getPerspectiveTransform( InputArray src, InputArray dst );

 Mat getAffineTransform( InputArray src, InputArray dst );






















 void getRectSubPix( InputArray image, Size patchSize,
                                 Point2f center, OutputArray patch, int patchType = -1 );






































 void logPolar( InputArray src, OutputArray dst,
                            Point2f center, double M, int flags );





































 void linearPolar( InputArray src, OutputArray dst,
                               Point2f center, double maxRadius, int flags );







 void integral( InputArray src, OutputArray sum, int sdepth = -1 );


 void integral( InputArray src, OutputArray sum,
                                        OutputArray sqsum, int sdepth = -1, int sqdepth = -1 );



































 void integral( InputArray src, OutputArray sum,
                                        OutputArray sqsum, OutputArray tilted,
                                        int sdepth = -1, int sqdepth = -1 );























 void accumulate( InputArray src, InputOutputArray dst,
                              InputArray mask = noArray() );

















 void accumulateSquare( InputArray src, InputOutputArray dst,
                                    InputArray mask = noArray() );

















 void accumulateProduct( InputArray src1, InputArray src2,
                                     InputOutputArray dst, InputArray mask=noArray() );



















 void accumulateWeighted( InputArray src, InputOutputArray dst,
                                      double alpha, InputArray mask = noArray() );




































 Point2d phaseCorrelate(InputArray src1, InputArray src2,
                                    InputArray window = noArray(),  double* response = 0);
















 void createHanningWindow(OutputArray dst, Size winSize, int type);































 double threshold( InputArray src, OutputArray dst,
                               double thresh, double maxval, int type );


























 void adaptiveThreshold( InputArray src, OutputArray dst,
                                     double maxValue, int adaptiveMethod,
                                     int thresholdType, int blockSize, double C );




























 void pyrDown( InputArray src, OutputArray dst,
                           const Size& dstsize = Size(), int borderType = BORDER_DEFAULT );


















 void pyrUp( InputArray src, OutputArray dst,
                         const Size& dstsize = Size(), int borderType = BORDER_DEFAULT );












 void buildPyramid( InputArray src, OutputArrayOfArrays dst,
                              int maxlevel, int borderType = BORDER_DEFAULT );



































 void undistort( InputArray src, OutputArray dst,
                             InputArray cameraMatrix,
                             InputArray distCoeffs,
                             InputArray newCameraMatrix = noArray() );































































 void initUndistortRectifyMap( InputArray cameraMatrix, InputArray distCoeffs,
                           InputArray R, InputArray newCameraMatrix,
                           Size size, int m1type, OutputArray map1, OutputArray map2 );


 float initWideAngleProjMap( InputArray cameraMatrix, InputArray distCoeffs,
                                         Size imageSize, int destImageWidth,
                                         int m1type, OutputArray map1, OutputArray map2,
                                         int projType = PROJ_SPHERICAL_EQRECT, double alpha = 0);























 Mat getDefaultNewCameraMatrix( InputArray cameraMatrix, Size imgsize = Size(),
                                            bool centerPrincipalPoint = false );









































 void undistortPoints( InputArray src, OutputArray dst,
                                   InputArray cameraMatrix, InputArray distCoeffs,
                                   InputArray R = noArray(), InputArray P = noArray());



































































































 void calcHist( const Mat* images, int nimages,
                          const int* channels, InputArray mask,
                          OutputArray hist, int dims, const int* histSize,
                          const float** ranges, bool uniform = true, bool accumulate = false );





 void calcHist( const Mat* images, int nimages,
                          const int* channels, InputArray mask,
                          SparseMat& hist, int dims,
                          const int* histSize, const float** ranges,
                          bool uniform = true, bool accumulate = false );


 void calcHist( InputArrayOfArrays images,
                            const std::vector<int>& channels,
                            InputArray mask, OutputArray hist,
                            const std::vector<int>& histSize,
                            const std::vector<float>& ranges,
                            bool accumulate = false );








































 void calcBackProject( const Mat* images, int nimages,
                                 const int* channels, InputArray hist,
                                 OutputArray backProject, const float** ranges,
                                 double scale = 1, bool uniform = true );


 void calcBackProject( const Mat* images, int nimages,
                                 const int* channels, const SparseMat& hist,
                                 OutputArray backProject, const float** ranges,
                                 double scale = 1, bool uniform = true );


 void calcBackProject( InputArrayOfArrays images, const std::vector<int>& channels,
                                   InputArray hist, OutputArray dst,
                                   const std::vector<float>& ranges,
                                   double scale );
















 double compareHist( InputArray H1, InputArray H2, int method );


 double compareHist( const SparseMat& H1, const SparseMat& H2, int method );
















 void equalizeHist( InputArray src, OutputArray dst );



































 float EMD( InputArray signature1, InputArray signature2,
                      int distType, InputArray cost=noArray(),
                      float* lowerBound = 0, OutputArray flow = noArray() );

 float wrapperEMD( InputArray signature1, InputArray signature2,
                      int distType, InputArray cost=noArray(),
                       Ptr<float> lowerBound = Ptr<float>(), OutputArray flow = noArray() );

































 void watershed( InputArray image, InputOutputArray markers );








































 void pyrMeanShiftFiltering( InputArray src, OutputArray dst,
                                         double sp, double sr, int maxLevel = 1,
                                         TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1) );




























 void grabCut( InputArray img, InputOutputArray mask, Rect rect,
                           InputOutputArray bgdModel, InputOutputArray fgdModel,
                           int iterCount, int mode = GC_EVAL );



























































 void distanceTransform( InputArray src, OutputArray dst,
                                     OutputArray labels, int distanceType, int maskSize,
                                     int labelType = DIST_LABEL_CCOMP );












 void distanceTransform( InputArray src, OutputArray dst,
                                     int distanceType, int maskSize, int dstType=5);









 int floodFill( InputOutputArray image,
                          Point seedPoint, Scalar newVal,  Rect* rect = 0,
                          Scalar loDiff = Scalar(), Scalar upDiff = Scalar(),
                          int flags = 4 );







































































 int floodFill( InputOutputArray image, InputOutputArray mask,
                            Point seedPoint, Scalar newVal,  Rect* rect=0,
                            Scalar loDiff = Scalar(), Scalar upDiff = Scalar(),
                            int flags = 4 );










































 void cvtColor( InputArray src, OutputArray dst, int code, int dstCn = 0 );




 void demosaicing(InputArray _src, OutputArray _dst, int code, int dcn = 0);




















 Moments moments( InputArray array, bool binaryImage = false );




















 void HuMoments( const Moments& moments, double hu[7] );


 void HuMoments( const Moments& m, OutputArray hu );







enum TemplateMatchModes {
    TM_SQDIFF        = 0, 
    TM_SQDIFF_NORMED = 1, 
    TM_CCORR         = 2, 
    TM_CCORR_NORMED  = 3, 
    TM_CCOEFF        = 4, 
                          
                          
    TM_CCOEFF_NORMED = 5  
};



























 void matchTemplate( InputArray image, InputArray templ,
                                 OutputArray result, int method, InputArray mask = noArray() );























 int connectedComponents(InputArray image, OutputArray labels,
                                                                        int connectivity, int ltype, int ccltype);









 int connectedComponents(InputArray image, OutputArray labels,
                                     int connectivity = 8, int ltype = 4);
























 int connectedComponentsWithStats(InputArray image, OutputArray labels,
                                                                                          OutputArray stats, OutputArray centroids,
                                                                                          int connectivity, int ltype, int ccltype);












 int connectedComponentsWithStats(InputArray image, OutputArray labels,
                                              OutputArray stats, OutputArray centroids,
                                              int connectivity = 8, int ltype = 4);



























 void findContours( InputOutputArray image, OutputArrayOfArrays contours,
                              OutputArray hierarchy, int mode,
                              int method, Point offset = Point());


 void findContours( InputOutputArray image, OutputArrayOfArrays contours,
                              int mode, int method, Point offset = Point());














 void approxPolyDP( InputArray curve,
                                OutputArray approxCurve,
                                double epsilon, bool closed );








 double arcLength( InputArray curve, bool closed );







 Rect boundingRect( InputArray points );































 double contourArea( InputArray contour, bool oriented = false );










 RotatedRect minAreaRect( InputArray points );












 void boxPoints(RotatedRect box, OutputArray points);










 void minEnclosingCircle( InputArray points,
                                       Point2f& center,  float& radius );























 double minEnclosingTriangle( InputArray points,  OutputArray triangle );










 double matchShapes( InputArray contour1, InputArray contour2,
                                 int method, double parameter );

























 void convexHull( InputArray points, OutputArray hull,
                              bool clockwise = false, bool returnPoints = true );


















 void convexityDefects( InputArray contour, InputArray convexhull, OutputArray convexityDefects );








 bool isContourConvex( InputArray contour );


 float intersectConvexConvex( InputArray _p1, InputArray _p2,
                                          OutputArray _p12, bool handleNested = true );















 RotatedRect fitEllipse( InputArray points );



































 void fitLine( InputArray points, OutputArray line, int distType,
                           double param, double reps, double aeps );

















 double pointPolygonTest( InputArray contour, Point2f pt, bool measureDist );
















 int rotatedRectangleIntersection( const RotatedRect& rect1, const RotatedRect& rect2, OutputArray intersectingRegion  );



 Ptr<CLAHE> createCLAHE(double clipLimit = 40.0, Size tileGridSize = Size(8, 8));



 Ptr<GeneralizedHoughBallard> createGeneralizedHoughBallard();



 Ptr<GeneralizedHoughGuil> createGeneralizedHoughGuil();








 void blendLinear(InputArray src1, InputArray src2, InputArray weights1, InputArray weights2, OutputArray dst);





enum ColormapTypes
{
    COLORMAP_AUTUMN = 0, 
    COLORMAP_BONE = 1, 
    COLORMAP_JET = 2, 
    COLORMAP_WINTER = 3, 
    COLORMAP_RAINBOW = 4, 
    COLORMAP_OCEAN = 5, 
    COLORMAP_SUMMER = 6, 
    COLORMAP_SPRING = 7, 
    COLORMAP_COOL = 8, 
    COLORMAP_HSV = 9, 
    COLORMAP_PINK = 10, 
    COLORMAP_HOT = 11, 
    COLORMAP_PARULA = 12 
};










 void applyColorMap(InputArray src, OutputArray dst, int colormap);







 void applyColorMap(InputArray src, OutputArray dst, InputArray userColor);





















 void line(InputOutputArray img, Point pt1, Point pt2, const Scalar& color,
                     int thickness = 1, int lineType = LINE_8, int shift = 0);














 void arrowedLine(InputOutputArray img, Point pt1, Point pt2, const Scalar& color,
                     int thickness=1, int line_type=8, int shift=0, double tipLength=0.1);















 void rectangle(InputOutputArray img, Point pt1, Point pt2,
                          const Scalar& color, int thickness = 1,
                          int lineType = LINE_8, int shift = 0);






 void rectangle( Mat& img, Rect rec,
                          const Scalar& color, int thickness = 1,
                          int lineType = LINE_8, int shift = 0);
















 void circle(InputOutputArray img, Point center, int radius,
                       const Scalar& color, int thickness = 1,
                       int lineType = LINE_8, int shift = 0);


























 void ellipse(InputOutputArray img, Point center, Size axes,
                        double angle, double startAngle, double endAngle,
                        const Scalar& color, int thickness = 1,
                        int lineType = LINE_8, int shift = 0);










 void ellipse(InputOutputArray img, const RotatedRect& box, const Scalar& color,
                        int thickness = 1, int lineType = LINE_8);






enum MarkerTypes
{
    MARKER_CROSS = 0,           
    MARKER_TILTED_CROSS = 1,    
    MARKER_STAR = 2,            
    MARKER_DIAMOND = 3,         
    MARKER_SQUARE = 4,          
    MARKER_TRIANGLE_UP = 5,     
    MARKER_TRIANGLE_DOWN = 6    
};














 void drawMarker( Mat& img, Point position, const Scalar& color,
                             int markerType = MARKER_CROSS, int markerSize=20, int thickness=1,
                             int line_type=8);






 void fillConvexPoly(Mat& img, const Point* pts, int npts,
                               const Scalar& color, int lineType = LINE_8,
                               int shift = 0);














 void fillConvexPoly(InputOutputArray img, InputArray points,
                                 const Scalar& color, int lineType = LINE_8,
                                 int shift = 0);


 void fillPoly(Mat& img, const Point** pts,
                         const int* npts, int ncontours,
                         const Scalar& color, int lineType = LINE_8, int shift = 0,
                         Point offset = Point() );

















 void fillPoly(InputOutputArray img, InputArrayOfArrays pts,
                           const Scalar& color, int lineType = LINE_8, int shift = 0,
                           Point offset = Point() );


 void polylines(Mat& img, const Point* const* pts, const int* npts,
                          int ncontours, bool isClosed, const Scalar& color,
                          int thickness = 1, int lineType = LINE_8, int shift = 0 );














 void polylines(InputOutputArray img, InputArrayOfArrays pts,
                            bool isClosed, const Scalar& color,
                            int thickness = 1, int lineType = LINE_8, int shift = 0 );








































































 void drawContours( InputOutputArray image, InputArrayOfArrays contours,
                              int contourIdx, const Scalar& color,
                              int thickness = 1, int lineType = LINE_8,
                              InputArray hierarchy = noArray(),
                              int maxLevel = 2147483647, Point offset = Point() );










 bool clipLine(Size imgSize,  Point& pt1,  Point& pt2);






 bool clipLine(Size2l imgSize,  Point2l& pt1,  Point2l& pt2);






 bool clipLine(Rect imgRect,   Point& pt1,   Point& pt2);















 void ellipse2Poly( Point center, Size axes, int angle,
                                int arcStart, int arcEnd, int delta,
                                 std::vector<Point>& pts );











 void ellipse2Poly(Point2d center, Size2d axes, int angle,
                             int arcStart, int arcEnd, int delta,
                              std::vector<Point2d>& pts);


















 void putText( InputOutputArray img, const String& text, Point org,
                         int fontFace, double fontScale, Scalar color,
                         int thickness = 1, int lineType = LINE_8,
                         bool bottomLeftOrigin = false );














































 Size getTextSize(const String& text, int fontFace,
                            double fontScale, int thickness,
                             int* baseLine);

































class  LineIterator
{
public:
    








    LineIterator( const Mat& img, Point pt1, Point pt2,
                  int connectivity = 8, bool leftToRight = false );
    

    uchar* operator *();
    

    LineIterator& operator ++();
    

    LineIterator operator ++(int);
    

    Point pos() const;

    uchar* ptr;
    const uchar* ptr0;
    int step, elemSize;
    int err, count;
    int minusDelta, plusDelta;
    int minusStep, plusStep;
};





inline
uchar* LineIterator::operator *()
{
    return ptr;
}

inline
LineIterator& LineIterator::operator ++()
{
    int mask = err < 0 ? -1 : 0;
    err += minusDelta + (plusDelta & mask);
    ptr += minusStep + (plusStep & mask);
    return *this;
}

inline
LineIterator LineIterator::operator ++(int)
{
    LineIterator it = *this;
    ++(*this);
    return it;
}

inline
Point LineIterator::pos() const
{
    Point p;
    p.y = (int)((ptr - ptr0)/step);
    p.x = (int)(((ptr - ptr0) - p.y*step)/elemSize);
    return p;
}







} 


#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgproc/imgproc_c.h"













































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgproc/types_c.h"













































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/core_c.h"

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 47 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgproc/types_c.h"


extern "C" {
#line 51 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgproc/types_c.h"






typedef struct CvConnectedComp
{
    double area;    
    CvScalar value; 
    CvRect rect;    
    CvSeq* contour; 

}
CvConnectedComp;


enum SmoothMethod_c
{
    


    CV_BLUR_NO_SCALE =0,
    

    CV_BLUR  =1,
    
    CV_GAUSSIAN  =2,
    
    CV_MEDIAN =3,
    


    CV_BILATERAL =4
};


enum
{
    CV_GAUSSIAN_5x5 = 7
};


enum
{
    CV_SCHARR =-1,
    CV_MAX_SOBEL_KSIZE =7
};


enum
{
    CV_BGR2BGRA    =0,
    CV_RGB2RGBA    =CV_BGR2BGRA,

    CV_BGRA2BGR    =1,
    CV_RGBA2RGB    =CV_BGRA2BGR,

    CV_BGR2RGBA    =2,
    CV_RGB2BGRA    =CV_BGR2RGBA,

    CV_RGBA2BGR    =3,
    CV_BGRA2RGB    =CV_RGBA2BGR,

    CV_BGR2RGB     =4,
    CV_RGB2BGR     =CV_BGR2RGB,

    CV_BGRA2RGBA   =5,
    CV_RGBA2BGRA   =CV_BGRA2RGBA,

    CV_BGR2GRAY    =6,
    CV_RGB2GRAY    =7,
    CV_GRAY2BGR    =8,
    CV_GRAY2RGB    =CV_GRAY2BGR,
    CV_GRAY2BGRA   =9,
    CV_GRAY2RGBA   =CV_GRAY2BGRA,
    CV_BGRA2GRAY   =10,
    CV_RGBA2GRAY   =11,

    CV_BGR2BGR565  =12,
    CV_RGB2BGR565  =13,
    CV_BGR5652BGR  =14,
    CV_BGR5652RGB  =15,
    CV_BGRA2BGR565 =16,
    CV_RGBA2BGR565 =17,
    CV_BGR5652BGRA =18,
    CV_BGR5652RGBA =19,

    CV_GRAY2BGR565 =20,
    CV_BGR5652GRAY =21,

    CV_BGR2BGR555  =22,
    CV_RGB2BGR555  =23,
    CV_BGR5552BGR  =24,
    CV_BGR5552RGB  =25,
    CV_BGRA2BGR555 =26,
    CV_RGBA2BGR555 =27,
    CV_BGR5552BGRA =28,
    CV_BGR5552RGBA =29,

    CV_GRAY2BGR555 =30,
    CV_BGR5552GRAY =31,

    CV_BGR2XYZ     =32,
    CV_RGB2XYZ     =33,
    CV_XYZ2BGR     =34,
    CV_XYZ2RGB     =35,

    CV_BGR2YCrCb   =36,
    CV_RGB2YCrCb   =37,
    CV_YCrCb2BGR   =38,
    CV_YCrCb2RGB   =39,

    CV_BGR2HSV     =40,
    CV_RGB2HSV     =41,

    CV_BGR2Lab     =44,
    CV_RGB2Lab     =45,

    CV_BayerBG2BGR =46,
    CV_BayerGB2BGR =47,
    CV_BayerRG2BGR =48,
    CV_BayerGR2BGR =49,

    CV_BayerBG2RGB =CV_BayerRG2BGR,
    CV_BayerGB2RGB =CV_BayerGR2BGR,
    CV_BayerRG2RGB =CV_BayerBG2BGR,
    CV_BayerGR2RGB =CV_BayerGB2BGR,

    CV_BGR2Luv     =50,
    CV_RGB2Luv     =51,
    CV_BGR2HLS     =52,
    CV_RGB2HLS     =53,

    CV_HSV2BGR     =54,
    CV_HSV2RGB     =55,

    CV_Lab2BGR     =56,
    CV_Lab2RGB     =57,
    CV_Luv2BGR     =58,
    CV_Luv2RGB     =59,
    CV_HLS2BGR     =60,
    CV_HLS2RGB     =61,

    CV_BayerBG2BGR_VNG =62,
    CV_BayerGB2BGR_VNG =63,
    CV_BayerRG2BGR_VNG =64,
    CV_BayerGR2BGR_VNG =65,

    CV_BayerBG2RGB_VNG =CV_BayerRG2BGR_VNG,
    CV_BayerGB2RGB_VNG =CV_BayerGR2BGR_VNG,
    CV_BayerRG2RGB_VNG =CV_BayerBG2BGR_VNG,
    CV_BayerGR2RGB_VNG =CV_BayerGB2BGR_VNG,

    CV_BGR2HSV_FULL = 66,
    CV_RGB2HSV_FULL = 67,
    CV_BGR2HLS_FULL = 68,
    CV_RGB2HLS_FULL = 69,

    CV_HSV2BGR_FULL = 70,
    CV_HSV2RGB_FULL = 71,
    CV_HLS2BGR_FULL = 72,
    CV_HLS2RGB_FULL = 73,

    CV_LBGR2Lab     = 74,
    CV_LRGB2Lab     = 75,
    CV_LBGR2Luv     = 76,
    CV_LRGB2Luv     = 77,

    CV_Lab2LBGR     = 78,
    CV_Lab2LRGB     = 79,
    CV_Luv2LBGR     = 80,
    CV_Luv2LRGB     = 81,

    CV_BGR2YUV      = 82,
    CV_RGB2YUV      = 83,
    CV_YUV2BGR      = 84,
    CV_YUV2RGB      = 85,

    CV_BayerBG2GRAY = 86,
    CV_BayerGB2GRAY = 87,
    CV_BayerRG2GRAY = 88,
    CV_BayerGR2GRAY = 89,

    
    CV_YUV2RGB_NV12 = 90,
    CV_YUV2BGR_NV12 = 91,
    CV_YUV2RGB_NV21 = 92,
    CV_YUV2BGR_NV21 = 93,
    CV_YUV420sp2RGB = CV_YUV2RGB_NV21,
    CV_YUV420sp2BGR = CV_YUV2BGR_NV21,

    CV_YUV2RGBA_NV12 = 94,
    CV_YUV2BGRA_NV12 = 95,
    CV_YUV2RGBA_NV21 = 96,
    CV_YUV2BGRA_NV21 = 97,
    CV_YUV420sp2RGBA = CV_YUV2RGBA_NV21,
    CV_YUV420sp2BGRA = CV_YUV2BGRA_NV21,

    CV_YUV2RGB_YV12 = 98,
    CV_YUV2BGR_YV12 = 99,
    CV_YUV2RGB_IYUV = 100,
    CV_YUV2BGR_IYUV = 101,
    CV_YUV2RGB_I420 = CV_YUV2RGB_IYUV,
    CV_YUV2BGR_I420 = CV_YUV2BGR_IYUV,
    CV_YUV420p2RGB = CV_YUV2RGB_YV12,
    CV_YUV420p2BGR = CV_YUV2BGR_YV12,

    CV_YUV2RGBA_YV12 = 102,
    CV_YUV2BGRA_YV12 = 103,
    CV_YUV2RGBA_IYUV = 104,
    CV_YUV2BGRA_IYUV = 105,
    CV_YUV2RGBA_I420 = CV_YUV2RGBA_IYUV,
    CV_YUV2BGRA_I420 = CV_YUV2BGRA_IYUV,
    CV_YUV420p2RGBA = CV_YUV2RGBA_YV12,
    CV_YUV420p2BGRA = CV_YUV2BGRA_YV12,

    CV_YUV2GRAY_420 = 106,
    CV_YUV2GRAY_NV21 = CV_YUV2GRAY_420,
    CV_YUV2GRAY_NV12 = CV_YUV2GRAY_420,
    CV_YUV2GRAY_YV12 = CV_YUV2GRAY_420,
    CV_YUV2GRAY_IYUV = CV_YUV2GRAY_420,
    CV_YUV2GRAY_I420 = CV_YUV2GRAY_420,
    CV_YUV420sp2GRAY = CV_YUV2GRAY_420,
    CV_YUV420p2GRAY = CV_YUV2GRAY_420,

    
    CV_YUV2RGB_UYVY = 107,
    CV_YUV2BGR_UYVY = 108,
    
    
    CV_YUV2RGB_Y422 = CV_YUV2RGB_UYVY,
    CV_YUV2BGR_Y422 = CV_YUV2BGR_UYVY,
    CV_YUV2RGB_UYNV = CV_YUV2RGB_UYVY,
    CV_YUV2BGR_UYNV = CV_YUV2BGR_UYVY,

    CV_YUV2RGBA_UYVY = 111,
    CV_YUV2BGRA_UYVY = 112,
    
    
    CV_YUV2RGBA_Y422 = CV_YUV2RGBA_UYVY,
    CV_YUV2BGRA_Y422 = CV_YUV2BGRA_UYVY,
    CV_YUV2RGBA_UYNV = CV_YUV2RGBA_UYVY,
    CV_YUV2BGRA_UYNV = CV_YUV2BGRA_UYVY,

    CV_YUV2RGB_YUY2 = 115,
    CV_YUV2BGR_YUY2 = 116,
    CV_YUV2RGB_YVYU = 117,
    CV_YUV2BGR_YVYU = 118,
    CV_YUV2RGB_YUYV = CV_YUV2RGB_YUY2,
    CV_YUV2BGR_YUYV = CV_YUV2BGR_YUY2,
    CV_YUV2RGB_YUNV = CV_YUV2RGB_YUY2,
    CV_YUV2BGR_YUNV = CV_YUV2BGR_YUY2,

    CV_YUV2RGBA_YUY2 = 119,
    CV_YUV2BGRA_YUY2 = 120,
    CV_YUV2RGBA_YVYU = 121,
    CV_YUV2BGRA_YVYU = 122,
    CV_YUV2RGBA_YUYV = CV_YUV2RGBA_YUY2,
    CV_YUV2BGRA_YUYV = CV_YUV2BGRA_YUY2,
    CV_YUV2RGBA_YUNV = CV_YUV2RGBA_YUY2,
    CV_YUV2BGRA_YUNV = CV_YUV2BGRA_YUY2,

    CV_YUV2GRAY_UYVY = 123,
    CV_YUV2GRAY_YUY2 = 124,
    
    CV_YUV2GRAY_Y422 = CV_YUV2GRAY_UYVY,
    CV_YUV2GRAY_UYNV = CV_YUV2GRAY_UYVY,
    CV_YUV2GRAY_YVYU = CV_YUV2GRAY_YUY2,
    CV_YUV2GRAY_YUYV = CV_YUV2GRAY_YUY2,
    CV_YUV2GRAY_YUNV = CV_YUV2GRAY_YUY2,

    
    CV_RGBA2mRGBA = 125,
    CV_mRGBA2RGBA = 126,

    CV_RGB2YUV_I420 = 127,
    CV_BGR2YUV_I420 = 128,
    CV_RGB2YUV_IYUV = CV_RGB2YUV_I420,
    CV_BGR2YUV_IYUV = CV_BGR2YUV_I420,

    CV_RGBA2YUV_I420 = 129,
    CV_BGRA2YUV_I420 = 130,
    CV_RGBA2YUV_IYUV = CV_RGBA2YUV_I420,
    CV_BGRA2YUV_IYUV = CV_BGRA2YUV_I420,
    CV_RGB2YUV_YV12  = 131,
    CV_BGR2YUV_YV12  = 132,
    CV_RGBA2YUV_YV12 = 133,
    CV_BGRA2YUV_YV12 = 134,

    
    CV_BayerBG2BGR_EA = 135,
    CV_BayerGB2BGR_EA = 136,
    CV_BayerRG2BGR_EA = 137,
    CV_BayerGR2BGR_EA = 138,

    CV_BayerBG2RGB_EA = CV_BayerRG2BGR_EA,
    CV_BayerGB2RGB_EA = CV_BayerGR2BGR_EA,
    CV_BayerRG2RGB_EA = CV_BayerBG2BGR_EA,
    CV_BayerGR2RGB_EA = CV_BayerGB2BGR_EA,

    CV_BayerBG2BGRA =139,
    CV_BayerGB2BGRA =140,
    CV_BayerRG2BGRA =141,
    CV_BayerGR2BGRA =142,

    CV_BayerBG2RGBA =CV_BayerRG2BGRA,
    CV_BayerGB2RGBA =CV_BayerGR2BGRA,
    CV_BayerRG2RGBA =CV_BayerBG2BGRA,
    CV_BayerGR2RGBA =CV_BayerGB2BGRA,

    CV_COLORCVT_MAX  = 143
};



enum
{
    CV_INTER_NN        =0,
    CV_INTER_LINEAR    =1,
    CV_INTER_CUBIC     =2,
    CV_INTER_AREA      =3,
    CV_INTER_LANCZOS4  =4
};


enum
{
    CV_WARP_FILL_OUTLIERS =8,
    CV_WARP_INVERSE_MAP  =16
};




enum MorphShapes_c
{
    CV_SHAPE_RECT      =0,
    CV_SHAPE_CROSS     =1,
    CV_SHAPE_ELLIPSE   =2,
    CV_SHAPE_CUSTOM    =100 
};


enum
{
    CV_MOP_ERODE        =0,
    CV_MOP_DILATE       =1,
    CV_MOP_OPEN         =2,
    CV_MOP_CLOSE        =3,
    CV_MOP_GRADIENT     =4,
    CV_MOP_TOPHAT       =5,
    CV_MOP_BLACKHAT     =6
};


typedef struct CvMoments
{
    double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; 
    double  mu20, mu11, mu02, mu30, mu21, mu12, mu03; 
    double  inv_sqrt_m00; 


    CvMoments(){}
    CvMoments(const cv::Moments& m)
    {
        m00 = m.m00; m10 = m.m10; m01 = m.m01;
        m20 = m.m20; m11 = m.m11; m02 = m.m02;
        m30 = m.m30; m21 = m.m21; m12 = m.m12; m03 = m.m03;
        mu20 = m.mu20; mu11 = m.mu11; mu02 = m.mu02;
        mu30 = m.mu30; mu21 = m.mu21; mu12 = m.mu12; mu03 = m.mu03;
        double am00 = std::abs(m.m00);
        inv_sqrt_m00 = am00 > 2.2204460492503131e-016 ? 1./std::sqrt(am00) : 0;
    }
    operator cv::Moments() const
    {
        return cv::Moments(m00, m10, m01, m20, m11, m02, m30, m21, m12, m03);
    }
#line 430 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgproc/types_c.h"
}
CvMoments;


typedef struct CvHuMoments
{
    double hu1, hu2, hu3, hu4, hu5, hu6, hu7; 
}
CvHuMoments;


enum
{
    CV_TM_SQDIFF        =0,
    CV_TM_SQDIFF_NORMED =1,
    CV_TM_CCORR         =2,
    CV_TM_CCORR_NORMED  =3,
    CV_TM_CCOEFF        =4,
    CV_TM_CCOEFF_NORMED =5
};

typedef float (__cdecl * CvDistanceFunction)( const float* a, const float* b, void* user_param );


enum
{
    CV_RETR_EXTERNAL=0,
    CV_RETR_LIST=1,
    CV_RETR_CCOMP=2,
    CV_RETR_TREE=3,
    CV_RETR_FLOODFILL=4
};


enum
{
    CV_CHAIN_CODE=0,
    CV_CHAIN_APPROX_NONE=1,
    CV_CHAIN_APPROX_SIMPLE=2,
    CV_CHAIN_APPROX_TC89_L1=3,
    CV_CHAIN_APPROX_TC89_KCOS=4,
    CV_LINK_RUNS=5
};





typedef struct _CvContourScanner* CvContourScanner;


typedef struct CvChainPtReader
{
    int header_size; CvSeq* seq; CvSeqBlock* block; schar* ptr; schar* block_min; schar* block_max; int delta_index; schar* prev_elem;
    char      code;
    CvPoint   pt;
    schar     deltas[8][2];
}
CvChainPtReader;










enum
{
    CV_POLY_APPROX_DP = 0
};


enum
{
    CV_CONTOURS_MATCH_I1  =1, 
    CV_CONTOURS_MATCH_I2  =2, 
    CV_CONTOURS_MATCH_I3  =3  
};


enum
{
    CV_CLOCKWISE         =1,
    CV_COUNTER_CLOCKWISE =2
};



typedef struct CvConvexityDefect
{
    CvPoint* start; 
    CvPoint* end; 
    CvPoint* depth_point; 
    float depth; 
} CvConvexityDefect;



enum
{
    CV_COMP_CORREL        =0,
    CV_COMP_CHISQR        =1,
    CV_COMP_INTERSECT     =2,
    CV_COMP_BHATTACHARYYA =3,
    CV_COMP_HELLINGER     =CV_COMP_BHATTACHARYYA,
    CV_COMP_CHISQR_ALT    =4,
    CV_COMP_KL_DIV        =5
};


enum
{
    CV_DIST_MASK_3   =3,
    CV_DIST_MASK_5   =5,
    CV_DIST_MASK_PRECISE =0
};


enum
{
  CV_DIST_LABEL_CCOMP = 0,
  CV_DIST_LABEL_PIXEL = 1
};


enum
{
    CV_DIST_USER    =-1,  
    CV_DIST_L1      =1,   
    CV_DIST_L2      =2,   
    CV_DIST_C       =3,   
    CV_DIST_L12     =4,   
    CV_DIST_FAIR    =5,   
    CV_DIST_WELSCH  =6,   
    CV_DIST_HUBER   =7    
};



enum
{
    CV_THRESH_BINARY      =0,  
    CV_THRESH_BINARY_INV  =1,  
    CV_THRESH_TRUNC       =2,  
    CV_THRESH_TOZERO      =3,  
    CV_THRESH_TOZERO_INV  =4,  
    CV_THRESH_MASK        =7,
    CV_THRESH_OTSU        =8, 

    CV_THRESH_TRIANGLE    =16  


};


enum
{
    CV_ADAPTIVE_THRESH_MEAN_C  =0,
    CV_ADAPTIVE_THRESH_GAUSSIAN_C  =1
};


enum
{
    CV_FLOODFILL_FIXED_RANGE =(1 << 16),
    CV_FLOODFILL_MASK_ONLY   =(1 << 17)
};



enum
{
    CV_CANNY_L2_GRADIENT  =(1 << 31)
};


enum
{
    CV_HOUGH_STANDARD =0,
    CV_HOUGH_PROBABILISTIC =1,
    CV_HOUGH_MULTI_SCALE =2,
    CV_HOUGH_GRADIENT =3
};



struct CvFeatureTree;
struct CvLSH;
struct CvLSHOperations;




}
#line 628 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgproc/types_c.h"

#line 630 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgproc/types_c.h"
#line 47 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgproc/imgproc_c.h"


extern "C" {
#line 51 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgproc/imgproc_c.h"










extern "C"  void __cdecl  cvAcc( const CvArr* image, CvArr* sum,
                   const CvArr* mask = 0 );




extern "C"  void __cdecl  cvSquareAcc( const CvArr* image, CvArr* sqsum,
                         const CvArr* mask = 0 );




extern "C"  void __cdecl  cvMultiplyAcc( const CvArr* image1, const CvArr* image2, CvArr* acc,
                           const CvArr* mask = 0 );




extern "C"  void __cdecl  cvRunningAvg( const CvArr* image, CvArr* acc, double alpha,
                          const CvArr* mask = 0 );







extern "C"  void __cdecl cvCopyMakeBorder( const CvArr* src, CvArr* dst, CvPoint offset,
                              int bordertype, CvScalar value = cvScalarAll(0));





















extern "C"  void __cdecl cvSmooth( const CvArr* src, CvArr* dst,
                      int smoothtype = CV_GAUSSIAN,
                      int size1 = 3,
                      int size2 = 0,
                      double sigma1 = 0,
                      double sigma2 = 0);














extern "C"  void __cdecl cvFilter2D( const CvArr* src, CvArr* dst, const CvMat* kernel,
                        CvPoint anchor = cvPoint(-1,-1));




extern "C"  void __cdecl cvIntegral( const CvArr* image, CvArr* sum,
                       CvArr* sqsum = 0,
                       CvArr* tilted_sum = 0);







extern "C"  void __cdecl  cvPyrDown( const CvArr* src, CvArr* dst,
                        int filter = CV_GAUSSIAN_5x5 );







extern "C"  void __cdecl  cvPyrUp( const CvArr* src, CvArr* dst,
                      int filter = CV_GAUSSIAN_5x5 );




extern "C"  CvMat** __cdecl cvCreatePyramid( const CvArr* img, int extra_layers, double rate,
                                const CvSize* layer_sizes = 0,
                                CvArr* bufarr = 0,
                                int calc = 1,
                                int filter = CV_GAUSSIAN_5x5 );


extern "C"  void __cdecl  cvReleasePyramid( CvMat*** pyramid, int extra_layers );





extern "C"  void __cdecl cvPyrMeanShiftFiltering( const CvArr* src, CvArr* dst,
    double sp, double sr, int max_level = 1,
    CvTermCriteria termcrit = cvTermCriteria(1+2,5,1));




extern "C"  void __cdecl cvWatershed( const CvArr* image, CvArr* markers );







extern "C"  void __cdecl cvSobel( const CvArr* src, CvArr* dst,
                    int xorder, int yorder,
                    int aperture_size = 3);




extern "C"  void __cdecl cvLaplace( const CvArr* src, CvArr* dst,
                      int aperture_size = 3 );




extern "C"  void __cdecl  cvCvtColor( const CvArr* src, CvArr* dst, int code );





extern "C"  void __cdecl  cvResize( const CvArr* src, CvArr* dst,
                       int interpolation = CV_INTER_LINEAR);






extern "C"  void __cdecl  cvWarpAffine( const CvArr* src, CvArr* dst, const CvMat* map_matrix,
                           int flags = CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS,
                           CvScalar fillval = cvScalarAll(0) );




extern "C"  CvMat* __cdecl cvGetAffineTransform( const CvPoint2D32f * src,
                                    const CvPoint2D32f * dst,
                                    CvMat * map_matrix );




extern "C"  CvMat* __cdecl  cv2DRotationMatrix( CvPoint2D32f center, double angle,
                                   double scale, CvMat* map_matrix );




extern "C"  void __cdecl  cvWarpPerspective( const CvArr* src, CvArr* dst, const CvMat* map_matrix,
                                int flags = CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS,
                                CvScalar fillval = cvScalarAll(0) );




extern "C"  CvMat* __cdecl cvGetPerspectiveTransform( const CvPoint2D32f* src,
                                         const CvPoint2D32f* dst,
                                         CvMat* map_matrix );




extern "C"  void __cdecl  cvRemap( const CvArr* src, CvArr* dst,
                      const CvArr* mapx, const CvArr* mapy,
                      int flags = CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS,
                      CvScalar fillval = cvScalarAll(0) );




extern "C"  void __cdecl  cvConvertMaps( const CvArr* mapx, const CvArr* mapy,
                            CvArr* mapxy, CvArr* mapalpha );




extern "C"  void __cdecl  cvLogPolar( const CvArr* src, CvArr* dst,
                         CvPoint2D32f center, double M,
                         int flags = CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS);




extern "C"  void __cdecl  cvLinearPolar( const CvArr* src, CvArr* dst,
                         CvPoint2D32f center, double maxRadius,
                         int flags = CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS);




extern "C"  void __cdecl cvUndistort2( const CvArr* src, CvArr* dst,
                          const CvMat* camera_matrix,
                          const CvMat* distortion_coeffs,
                          const CvMat* new_camera_matrix = 0 );




extern "C"  void __cdecl cvInitUndistortMap( const CvMat* camera_matrix,
                                const CvMat* distortion_coeffs,
                                CvArr* mapx, CvArr* mapy );




extern "C"  void __cdecl cvInitUndistortRectifyMap( const CvMat* camera_matrix,
                                       const CvMat* dist_coeffs,
                                       const CvMat *R, const CvMat* new_camera_matrix,
                                       CvArr* mapx, CvArr* mapy );





extern "C"  void __cdecl cvUndistortPoints( const CvMat* src, CvMat* dst,
                               const CvMat* camera_matrix,
                               const CvMat* dist_coeffs,
                               const CvMat* R = 0,
                               const CvMat* P = 0);
















 extern "C"  IplConvKernel* __cdecl  cvCreateStructuringElementEx(
            int cols, int  rows, int  anchor_x, int  anchor_y,
            int shape, int* values = 0 );




extern "C"  void __cdecl  cvReleaseStructuringElement( IplConvKernel** element );





extern "C"  void __cdecl  cvErode( const CvArr* src, CvArr* dst,
                      IplConvKernel* element = 0,
                      int iterations = 1 );






extern "C"  void __cdecl  cvDilate( const CvArr* src, CvArr* dst,
                       IplConvKernel* element = 0,
                       int iterations = 1 );




extern "C"  void __cdecl  cvMorphologyEx( const CvArr* src, CvArr* dst,
                             CvArr* temp, IplConvKernel* element,
                             int operation, int iterations = 1 );




extern "C"  void __cdecl cvMoments( const CvArr* arr, CvMoments* moments, int binary = 0);


extern "C"  double __cdecl  cvGetSpatialMoment( CvMoments* moments, int x_order, int y_order );

extern "C"  double __cdecl  cvGetCentralMoment( CvMoments* moments, int x_order, int y_order );

extern "C"  double __cdecl  cvGetNormalizedCentralMoment( CvMoments* moments,
                                             int x_order, int y_order );




extern "C"  void __cdecl cvGetHuMoments( CvMoments*  moments, CvHuMoments*  hu_moments );








extern "C"  int __cdecl  cvSampleLine( const CvArr* image, CvPoint pt1, CvPoint pt2, void* buffer,
                          int connectivity = 8);







extern "C"  void __cdecl  cvGetRectSubPix( const CvArr* src, CvArr* dst, CvPoint2D32f center );









extern "C"  void __cdecl  cvGetQuadrangleSubPix( const CvArr* src, CvArr* dst,
                                    const CvMat* map_matrix );





extern "C"  void __cdecl  cvMatchTemplate( const CvArr* image, const CvArr* templ,
                              CvArr* result, int method );





extern "C"  float __cdecl  cvCalcEMD2( const CvArr* signature1,
                          const CvArr* signature2,
                          int distance_type,
                          CvDistanceFunction distance_func = 0,
                          const CvArr* cost_matrix = 0,
                          CvArr* flow = 0,
                          float* lower_bound = 0,
                          void* userdata = 0);









extern "C"  int __cdecl  cvFindContours( CvArr* image, CvMemStorage* storage, CvSeq** first_contour,
                            int header_size = sizeof(CvContour),
                            int mode = CV_RETR_LIST,
                            int method = CV_CHAIN_APPROX_SIMPLE,
                            CvPoint offset = cvPoint(0,0));









extern "C"  CvContourScanner __cdecl  cvStartFindContours( CvArr* image, CvMemStorage* storage,
                            int header_size = sizeof(CvContour),
                            int mode = CV_RETR_LIST,
                            int method = CV_CHAIN_APPROX_SIMPLE,
                            CvPoint offset = cvPoint(0,0));




extern "C"  CvSeq* __cdecl  cvFindNextContour( CvContourScanner scanner );







extern "C"  void __cdecl   cvSubstituteContour( CvContourScanner scanner, CvSeq* new_contour );





extern "C"  CvSeq* __cdecl  cvEndFindContours( CvContourScanner* scanner );


















extern "C"  CvSeq* __cdecl cvApproxChains( CvSeq* src_seq, CvMemStorage* storage,
                            int method = CV_CHAIN_APPROX_SIMPLE,
                            double parameter = 0,
                            int  minimal_perimeter = 0,
                            int  recursive = 0);







extern "C"  void __cdecl cvStartReadChainPoints( CvChain* chain, CvChainPtReader* reader );




extern "C"  CvPoint __cdecl cvReadChainPoint( CvChainPtReader* reader );










extern "C"  CvSeq* __cdecl  cvApproxPoly( const void* src_seq,
                             int header_size, CvMemStorage* storage,
                             int method, double eps,
                             int recursive = 0);




extern "C"  double __cdecl  cvArcLength( const void* curve,
                            CvSlice slice = cvSlice(0, 0x3fffffff),
                            int is_closed = -1);



static inline double cvContourPerimeter( const void* contour )
{
    return cvArcLength( contour, cvSlice(0, 0x3fffffff), 1 );
}






extern "C"  CvRect __cdecl  cvBoundingRect( CvArr* points, int update = 0 );




extern "C"  double __cdecl  cvContourArea( const CvArr* contour,
                              CvSlice slice = cvSlice(0, 0x3fffffff),
                              int oriented = 0);




extern "C"  CvBox2D __cdecl  cvMinAreaRect2( const CvArr* points,
                                CvMemStorage* storage = 0);




extern "C"  int __cdecl  cvMinEnclosingCircle( const CvArr* points,
                                  CvPoint2D32f* center, float* radius );




extern "C"  double __cdecl  cvMatchShapes( const void* object1, const void* object2,
                              int method, double parameter = 0);




extern "C"  CvSeq* __cdecl cvConvexHull2( const CvArr* input,
                             void* hull_storage = 0,
                             int orientation = CV_CLOCKWISE,
                             int return_points = 0);




extern "C"  int __cdecl  cvCheckContourConvexity( const CvArr* contour );





extern "C"  CvSeq* __cdecl  cvConvexityDefects( const CvArr* contour, const CvArr* convexhull,
                                   CvMemStorage* storage = 0);




extern "C"  CvBox2D __cdecl cvFitEllipse2( const CvArr* points );


extern "C"  CvRect __cdecl  cvMaxRect( const CvRect* rect1, const CvRect* rect2 );


extern "C"  void __cdecl cvBoxPoints( CvBox2D box, CvPoint2D32f pt[4] );




extern "C"  CvSeq* __cdecl cvPointSeqFromMat( int seq_kind, const CvArr* mat,
                                 CvContour* contour_header,
                                 CvSeqBlock* block );








extern "C"  double __cdecl cvPointPolygonTest( const CvArr* contour,
                                  CvPoint2D32f pt, int measure_dist );
































extern "C"  CvHistogram* __cdecl  cvCreateHist( int dims, int* sizes, int type,
                                   float** ranges = 0,
                                   int uniform = 1);












extern "C"  void __cdecl  cvSetHistBinRanges( CvHistogram* hist, float** ranges,
                                int uniform = 1);














extern "C"  CvHistogram* __cdecl  cvMakeHistHeaderForArray(
                            int  dims, int* sizes, CvHistogram* hist,
                            float* data, float** ranges = 0,
                            int uniform = 1);








extern "C"  void __cdecl  cvReleaseHist( CvHistogram** hist );








extern "C"  void __cdecl  cvClearHist( CvHistogram* hist );














extern "C"  void __cdecl  cvGetMinMaxHistValue( const CvHistogram* hist,
                                   float* min_value, float* max_value,
                                   int* min_idx = 0,
                                   int* max_idx = 0);










extern "C"  void __cdecl  cvNormalizeHist( CvHistogram* hist, double factor );









extern "C"  void __cdecl  cvThreshHist( CvHistogram* hist, double threshold );



extern "C"  double __cdecl  cvCompareHist( const CvHistogram* hist1,
                              const CvHistogram* hist2,
                              int method);











extern "C"  void __cdecl  cvCopyHist( const CvHistogram* src, CvHistogram** dst );




extern "C"  void __cdecl  cvCalcBayesianProb( CvHistogram** src, int number,
                                CvHistogram** dst);




extern "C"  void __cdecl  cvCalcArrHist( CvArr** arr, CvHistogram* hist,
                            int accumulate = 0,
                            const CvArr* mask = 0 );


static inline  void  cvCalcHist( IplImage** image, CvHistogram* hist,
                             int accumulate = 0,
                             const CvArr* mask = 0 )
{
    cvCalcArrHist( (CvArr**)image, hist, accumulate, mask );
}




extern "C"  void __cdecl  cvCalcArrBackProject( CvArr** image, CvArr* dst,
                                   const CvHistogram* hist );























extern "C"  void __cdecl  cvCalcArrBackProjectPatch( CvArr** image, CvArr* dst, CvSize range,
                                        CvHistogram* hist, int method,
                                        double factor );
















extern "C"  void __cdecl  cvCalcProbDensity( const CvHistogram* hist1, const CvHistogram* hist2,
                                CvHistogram* dst_hist, double scale = 255 );




extern "C"  void __cdecl  cvEqualizeHist( const CvArr* src, CvArr* dst );





extern "C"  void __cdecl  cvDistTransform( const CvArr* src, CvArr* dst,
                              int distance_type = CV_DIST_L2,
                              int mask_size = 3,
                              const float* mask = 0,
                              CvArr* labels = 0,
                              int labelType = CV_DIST_LABEL_CCOMP);







extern "C"  double __cdecl  cvThreshold( const CvArr*  src, CvArr*  dst,
                            double  threshold, double  max_value,
                            int threshold_type );









extern "C"  void __cdecl  cvAdaptiveThreshold( const CvArr* src, CvArr* dst, double max_value,
                                  int adaptive_method = CV_ADAPTIVE_THRESH_MEAN_C,
                                  int threshold_type = CV_THRESH_BINARY,
                                  int block_size = 3,
                                  double param1 = 5);




extern "C"  void __cdecl  cvFloodFill( CvArr* image, CvPoint seed_point,
                          CvScalar new_val, CvScalar lo_diff = cvScalarAll(0),
                          CvScalar up_diff = cvScalarAll(0),
                          CvConnectedComp* comp = 0,
                          int flags = 4,
                          CvArr* mask = 0);








extern "C"  void __cdecl  cvCanny( const CvArr* image, CvArr* edges, double threshold1,
                      double threshold2, int  aperture_size = 3 );







extern "C"  void __cdecl cvPreCornerDetect( const CvArr* image, CvArr* corners,
                               int aperture_size = 3 );





extern "C"  void __cdecl  cvCornerEigenValsAndVecs( const CvArr* image, CvArr* eigenvv,
                                       int block_size, int aperture_size = 3 );





extern "C"  void __cdecl  cvCornerMinEigenVal( const CvArr* image, CvArr* eigenval,
                                  int block_size, int aperture_size = 3 );






extern "C"  void __cdecl  cvCornerHarris( const CvArr* image, CvArr* harris_response,
                             int block_size, int aperture_size = 3,
                             double k = 0.04 );




extern "C"  void __cdecl  cvFindCornerSubPix( const CvArr* image, CvPoint2D32f* corners,
                                 int count, CvSize win, CvSize zero_zone,
                                 CvTermCriteria  criteria );





extern "C"  void __cdecl  cvGoodFeaturesToTrack( const CvArr* image, CvArr* eig_image,
                                    CvArr* temp_image, CvPoint2D32f* corners,
                                    int* corner_count, double  quality_level,
                                    double  min_distance,
                                    const CvArr* mask = 0,
                                    int block_size = 3,
                                    int use_harris = 0,
                                    double k = 0.04 );











extern "C"  CvSeq* __cdecl  cvHoughLines2( CvArr* image, void* line_storage, int method,
                              double rho, double theta, int threshold,
                              double param1 = 0, double param2 = 0,
                              double min_theta = 0, double max_theta = 3.1415926535897932384626433832795);




extern "C"  CvSeq* __cdecl cvHoughCircles( CvArr* image, void* circle_storage,
                              int method, double dp, double min_dist,
                              double param1 = 100,
                              double param2 = 100,
                              int min_radius = 0,
                              int max_radius = 0);




extern "C"  void __cdecl  cvFitLine( const CvArr* points, int dist_type, double param,
                        double reps, double aeps, float* line );























extern "C"  void __cdecl  cvLine( CvArr* img, CvPoint pt1, CvPoint pt2,
                     CvScalar color, int thickness = 1,
                     int line_type = 8, int shift = 0 );






extern "C"  void __cdecl  cvRectangle( CvArr* img, CvPoint pt1, CvPoint pt2,
                          CvScalar color, int thickness = 1,
                          int line_type = 8,
                          int shift = 0);




extern "C"  void __cdecl  cvRectangleR( CvArr* img, CvRect r,
                           CvScalar color, int thickness = 1,
                           int line_type = 8,
                           int shift = 0);







extern "C"  void __cdecl  cvCircle( CvArr* img, CvPoint center, int radius,
                       CvScalar color, int thickness = 1,
                       int line_type = 8, int shift = 0);







extern "C"  void __cdecl  cvEllipse( CvArr* img, CvPoint center, CvSize axes,
                        double angle, double start_angle, double end_angle,
                        CvScalar color, int thickness = 1,
                        int line_type = 8, int shift = 0);

static inline  void  cvEllipseBox( CvArr* img, CvBox2D box, CvScalar color,
                               int thickness = 1,
                               int line_type = 8, int shift = 0 )
{
    CvSize axes;
    axes.width = cvRound(box.size.width*0.5);
    axes.height = cvRound(box.size.height*0.5);

    cvEllipse( img, cvPointFrom32f( box.center ), axes, box.angle,
               0, 360, color, thickness, line_type, shift );
}




extern "C"  void __cdecl  cvFillConvexPoly( CvArr* img, const CvPoint* pts, int npts, CvScalar color,
                               int line_type = 8, int shift = 0);




extern "C"  void __cdecl  cvFillPoly( CvArr* img, CvPoint** pts, const int* npts,
                         int contours, CvScalar color,
                         int line_type = 8, int shift = 0 );




extern "C"  void __cdecl  cvPolyLine( CvArr* img, CvPoint** pts, const int* npts, int contours,
                         int is_closed, CvScalar color, int thickness = 1,
                         int line_type = 8, int shift = 0 );













extern "C"  int __cdecl cvClipLine( CvSize img_size, CvPoint* pt1, CvPoint* pt2 );







extern "C"  int __cdecl  cvInitLineIterator( const CvArr* image, CvPoint pt1, CvPoint pt2,
                                CvLineIterator* line_iterator,
                                int connectivity = 8,
                                int left_to_right = 0);


























typedef struct CvFont
{
  const char* nameFont;   
  CvScalar color;       
    int         font_face;    
    const int*  ascii;      
    const int*  greek;
    const int*  cyrillic;
    float       hscale, vscale;
    float       shear;      
    int         thickness;    
    float       dx;       
    int         line_type;    
}
CvFont;


















extern "C"  void __cdecl  cvInitFont( CvFont* font, int font_face,
                         double hscale, double vscale,
                         double shear = 0,
                         int thickness = 1,
                         int line_type = 8);

static inline CvFont cvFont( double scale, int thickness = 1 )
{
    CvFont font;
    cvInitFont( &font, 1, scale, scale, 0, thickness, 16 );
    return font;
}





extern "C"  void __cdecl  cvPutText( CvArr* img, const char* text, CvPoint org,
                        const CvFont* font, CvScalar color );




extern "C"  void __cdecl  cvGetTextSize( const char* text_string, const CvFont* font,
                            CvSize* text_size, int* baseline );






extern "C"  CvScalar __cdecl  cvColorToScalar( double packed_color, int arrtype );









extern "C"  int __cdecl cvEllipse2Poly( CvPoint center, CvSize axes,
                 int angle, int arc_start, int arc_end, CvPoint * pts, int delta );




extern "C"  void __cdecl  cvDrawContours( CvArr *img, CvSeq* contour,
                             CvScalar external_color, CvScalar hole_color,
                             int max_level, int thickness = 1,
                             int line_type = 8,
                             CvPoint offset = cvPoint(0,0));




}
#line 1209 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgproc/imgproc_c.h"

#line 1211 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgproc/imgproc_c.h"

#line 4714 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgproc.hpp"
#line 4715 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgproc.hpp"

#line 4717 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgproc.hpp"

#line 2 "c:\\users\\олег\\desktop\\проект\\trialcptrfromvideo\\cptrfromvideo\\Header.h"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgcodecs.hpp"













































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 47 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgcodecs.hpp"










namespace cv
{





enum ImreadModes {
       IMREAD_UNCHANGED            = -1, 
       IMREAD_GRAYSCALE            = 0,  
       IMREAD_COLOR                = 1,  
       IMREAD_ANYDEPTH             = 2,  
       IMREAD_ANYCOLOR             = 4,  
       IMREAD_LOAD_GDAL            = 8,  
       IMREAD_REDUCED_GRAYSCALE_2  = 16, 
       IMREAD_REDUCED_COLOR_2      = 17, 
       IMREAD_REDUCED_GRAYSCALE_4  = 32, 
       IMREAD_REDUCED_COLOR_4      = 33, 
       IMREAD_REDUCED_GRAYSCALE_8  = 64, 
       IMREAD_REDUCED_COLOR_8      = 65, 
       IMREAD_IGNORE_ORIENTATION   = 128 
     };


enum ImwriteFlags {
       IMWRITE_JPEG_QUALITY        = 1,  
       IMWRITE_JPEG_PROGRESSIVE    = 2,  
       IMWRITE_JPEG_OPTIMIZE       = 3,  
       IMWRITE_JPEG_RST_INTERVAL   = 4,  
       IMWRITE_JPEG_LUMA_QUALITY   = 5,  
       IMWRITE_JPEG_CHROMA_QUALITY = 6,  
       IMWRITE_PNG_COMPRESSION     = 16, 
       IMWRITE_PNG_STRATEGY        = 17, 
       IMWRITE_PNG_BILEVEL         = 18, 
       IMWRITE_PXM_BINARY          = 32, 
       IMWRITE_WEBP_QUALITY        = 64, 
       IMWRITE_PAM_TUPLETYPE       = 128,
     };









enum ImwritePNGFlags {
       IMWRITE_PNG_STRATEGY_DEFAULT      = 0, 
       IMWRITE_PNG_STRATEGY_FILTERED     = 1, 
       IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY = 2, 
       IMWRITE_PNG_STRATEGY_RLE          = 3, 
       IMWRITE_PNG_STRATEGY_FIXED        = 4  
     };


enum ImwritePAMFlags {
       IMWRITE_PAM_FORMAT_NULL = 0,
       IMWRITE_PAM_FORMAT_BLACKANDWHITE = 1,
       IMWRITE_PAM_FORMAT_GRAYSCALE = 2,
       IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA = 3,
       IMWRITE_PAM_FORMAT_RGB = 4,
       IMWRITE_PAM_FORMAT_RGB_ALPHA = 5,
     };













































 Mat imread( const String& filename, int flags = IMREAD_COLOR );









 bool imreadmulti(const String& filename, std::vector<Mat>& mats, int flags = IMREAD_ANYCOLOR);






























































 bool imwrite( const String& filename, InputArray img,
              const std::vector<int>& params = std::vector<int>());












 Mat imdecode( InputArray buf, int flags );







 Mat imdecode( InputArray buf, int flags, Mat* dst);











 bool imencode( const String& ext, InputArray img,
                             std::vector<uchar>& buf,
                            const std::vector<int>& params = std::vector<int>());



} 

#line 282 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgcodecs.hpp"
#line 3 "c:\\users\\олег\\desktop\\проект\\trialcptrfromvideo\\cptrfromvideo\\Header.h"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui.hpp"













































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 47 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui.hpp"

#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgcodecs.hpp"

























































































































































































































































































#line 49 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui.hpp"
#line 50 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui.hpp"

#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/videoio.hpp"













































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core.hpp"





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 47 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/videoio.hpp"




















typedef struct CvCapture CvCapture;
typedef struct CvVideoWriter CvVideoWriter;

namespace cv
{
















enum VideoCaptureAPIs {
       CAP_ANY          = 0,            
       CAP_VFW          = 200,          
       CAP_V4L          = 200,          
       CAP_V4L2         = CAP_V4L,      
       CAP_FIREWIRE     = 300,          
       CAP_FIREWARE     = CAP_FIREWIRE, 
       CAP_IEEE1394     = CAP_FIREWIRE, 
       CAP_DC1394       = CAP_FIREWIRE, 
       CAP_CMU1394      = CAP_FIREWIRE, 
       CAP_QT           = 500,          
       CAP_UNICAP       = 600,          
       CAP_DSHOW        = 700,          
       CAP_PVAPI        = 800,          
       CAP_OPENNI       = 900,          
       CAP_OPENNI_ASUS  = 910,          
       CAP_ANDROID      = 1000,         
       CAP_XIAPI        = 1100,         
       CAP_AVFOUNDATION = 1200,         
       CAP_GIGANETIX    = 1300,         
       CAP_MSMF         = 1400,         
       CAP_WINRT        = 1410,         
       CAP_INTELPERC    = 1500,         
       CAP_OPENNI2      = 1600,         
       CAP_OPENNI2_ASUS = 1610,         
       CAP_GPHOTO2      = 1700,         
       CAP_GSTREAMER    = 1800,         
       CAP_FFMPEG       = 1900,         
       CAP_IMAGES       = 2000,         
       CAP_ARAVIS       = 2100,         
       CAP_OPENCV_MJPEG = 2200,         
       CAP_INTEL_MFX    = 2300          
     };







enum VideoCaptureProperties {
       CAP_PROP_POS_MSEC       =0, 
       CAP_PROP_POS_FRAMES     =1, 
       CAP_PROP_POS_AVI_RATIO  =2, 
       CAP_PROP_FRAME_WIDTH    =3, 
       CAP_PROP_FRAME_HEIGHT   =4, 
       CAP_PROP_FPS            =5, 
       CAP_PROP_FOURCC         =6, 
       CAP_PROP_FRAME_COUNT    =7, 
       CAP_PROP_FORMAT         =8, 
       CAP_PROP_MODE           =9, 
       CAP_PROP_BRIGHTNESS    =10, 
       CAP_PROP_CONTRAST      =11, 
       CAP_PROP_SATURATION    =12, 
       CAP_PROP_HUE           =13, 
       CAP_PROP_GAIN          =14, 
       CAP_PROP_EXPOSURE      =15, 
       CAP_PROP_CONVERT_RGB   =16, 
       CAP_PROP_WHITE_BALANCE_BLUE_U =17, 
       CAP_PROP_RECTIFICATION =18, 
       CAP_PROP_MONOCHROME    =19,
       CAP_PROP_SHARPNESS     =20,
       CAP_PROP_AUTO_EXPOSURE =21, 
       CAP_PROP_GAMMA         =22,
       CAP_PROP_TEMPERATURE   =23,
       CAP_PROP_TRIGGER       =24,
       CAP_PROP_TRIGGER_DELAY =25,
       CAP_PROP_WHITE_BALANCE_RED_V =26,
       CAP_PROP_ZOOM          =27,
       CAP_PROP_FOCUS         =28,
       CAP_PROP_GUID          =29,
       CAP_PROP_ISO_SPEED     =30,
       CAP_PROP_BACKLIGHT     =32,
       CAP_PROP_PAN           =33,
       CAP_PROP_TILT          =34,
       CAP_PROP_ROLL          =35,
       CAP_PROP_IRIS          =36,
       CAP_PROP_SETTINGS      =37, 
       CAP_PROP_BUFFERSIZE    =38,
       CAP_PROP_AUTOFOCUS     =39
     };





enum VideoCaptureModes {
       CAP_MODE_BGR  = 0, 
       CAP_MODE_RGB  = 1, 
       CAP_MODE_GRAY = 2, 
       CAP_MODE_YUYV = 3  
     };




enum VideoWriterProperties {
  VIDEOWRITER_PROP_QUALITY = 1,    
  VIDEOWRITER_PROP_FRAMEBYTES = 2, 
  VIDEOWRITER_PROP_NSTRIPES = 3    
};














enum { CAP_PROP_DC1394_OFF                = -4, 
       CAP_PROP_DC1394_MODE_MANUAL        = -3, 
       CAP_PROP_DC1394_MODE_AUTO          = -2,
       CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO = -1,
       CAP_PROP_DC1394_MAX                = 31
     };








enum { CAP_OPENNI_DEPTH_GENERATOR = 1 << 31,
       CAP_OPENNI_IMAGE_GENERATOR = 1 << 30,
       CAP_OPENNI_IR_GENERATOR    = 1 << 29,
       CAP_OPENNI_GENERATORS_MASK = CAP_OPENNI_DEPTH_GENERATOR + CAP_OPENNI_IMAGE_GENERATOR + CAP_OPENNI_IR_GENERATOR
     };


enum { CAP_PROP_OPENNI_OUTPUT_MODE       = 100,
       CAP_PROP_OPENNI_FRAME_MAX_DEPTH   = 101, 
       CAP_PROP_OPENNI_BASELINE          = 102, 
       CAP_PROP_OPENNI_FOCAL_LENGTH      = 103, 
       CAP_PROP_OPENNI_REGISTRATION      = 104, 
                                                
                                                
       CAP_PROP_OPENNI_REGISTRATION_ON   = CAP_PROP_OPENNI_REGISTRATION,
       CAP_PROP_OPENNI_APPROX_FRAME_SYNC = 105,
       CAP_PROP_OPENNI_MAX_BUFFER_SIZE   = 106,
       CAP_PROP_OPENNI_CIRCLE_BUFFER     = 107,
       CAP_PROP_OPENNI_MAX_TIME_DURATION = 108,
       CAP_PROP_OPENNI_GENERATOR_PRESENT = 109,
       CAP_PROP_OPENNI2_SYNC             = 110,
       CAP_PROP_OPENNI2_MIRROR           = 111
     };


enum { CAP_OPENNI_IMAGE_GENERATOR_PRESENT         = CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT,
       CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE     = CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_OUTPUT_MODE,
       CAP_OPENNI_DEPTH_GENERATOR_PRESENT         = CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT,
       CAP_OPENNI_DEPTH_GENERATOR_BASELINE        = CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_BASELINE,
       CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH    = CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_FOCAL_LENGTH,
       CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION    = CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_REGISTRATION,
       CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON = CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION,
       CAP_OPENNI_IR_GENERATOR_PRESENT            = CAP_OPENNI_IR_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT,
     };


enum { CAP_OPENNI_DEPTH_MAP         = 0, 
       CAP_OPENNI_POINT_CLOUD_MAP   = 1, 
       CAP_OPENNI_DISPARITY_MAP     = 2, 
       CAP_OPENNI_DISPARITY_MAP_32F = 3, 
       CAP_OPENNI_VALID_DEPTH_MASK  = 4, 

       CAP_OPENNI_BGR_IMAGE         = 5, 
       CAP_OPENNI_GRAY_IMAGE        = 6, 

       CAP_OPENNI_IR_IMAGE          = 7  
     };


enum { CAP_OPENNI_VGA_30HZ  = 0,
       CAP_OPENNI_SXGA_15HZ = 1,
       CAP_OPENNI_SXGA_30HZ = 2,
       CAP_OPENNI_QVGA_30HZ = 3,
       CAP_OPENNI_QVGA_60HZ = 4
     };







enum { CAP_PROP_GSTREAMER_QUEUE_LENGTH = 200 
     };








enum { CAP_PROP_PVAPI_MULTICASTIP           = 300, 
       CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE = 301, 
       CAP_PROP_PVAPI_DECIMATIONHORIZONTAL  = 302, 
       CAP_PROP_PVAPI_DECIMATIONVERTICAL    = 303, 
       CAP_PROP_PVAPI_BINNINGX              = 304, 
       CAP_PROP_PVAPI_BINNINGY              = 305, 
       CAP_PROP_PVAPI_PIXELFORMAT           = 306  
     };


enum { CAP_PVAPI_FSTRIGMODE_FREERUN     = 0,    
       CAP_PVAPI_FSTRIGMODE_SYNCIN1     = 1,    
       CAP_PVAPI_FSTRIGMODE_SYNCIN2     = 2,    
       CAP_PVAPI_FSTRIGMODE_FIXEDRATE   = 3,    
       CAP_PVAPI_FSTRIGMODE_SOFTWARE    = 4     
     };


enum { CAP_PVAPI_DECIMATION_OFF       = 1,    
       CAP_PVAPI_DECIMATION_2OUTOF4   = 2,    
       CAP_PVAPI_DECIMATION_2OUTOF8   = 4,    
       CAP_PVAPI_DECIMATION_2OUTOF16  = 8     
     };


enum { CAP_PVAPI_PIXELFORMAT_MONO8    = 1,    
       CAP_PVAPI_PIXELFORMAT_MONO16   = 2,    
       CAP_PVAPI_PIXELFORMAT_BAYER8   = 3,    
       CAP_PVAPI_PIXELFORMAT_BAYER16  = 4,    
       CAP_PVAPI_PIXELFORMAT_RGB24    = 5,    
       CAP_PVAPI_PIXELFORMAT_BGR24    = 6,    
       CAP_PVAPI_PIXELFORMAT_RGBA32   = 7,    
       CAP_PVAPI_PIXELFORMAT_BGRA32   = 8,    
     };








enum { CAP_PROP_XI_DOWNSAMPLING                                 = 400, 
       CAP_PROP_XI_DATA_FORMAT                                  = 401, 
       CAP_PROP_XI_OFFSET_X                                     = 402, 
       CAP_PROP_XI_OFFSET_Y                                     = 403, 
       CAP_PROP_XI_TRG_SOURCE                                   = 404, 
       CAP_PROP_XI_TRG_SOFTWARE                                 = 405, 
       CAP_PROP_XI_GPI_SELECTOR                                 = 406, 
       CAP_PROP_XI_GPI_MODE                                     = 407, 
       CAP_PROP_XI_GPI_LEVEL                                    = 408, 
       CAP_PROP_XI_GPO_SELECTOR                                 = 409, 
       CAP_PROP_XI_GPO_MODE                                     = 410, 
       CAP_PROP_XI_LED_SELECTOR                                 = 411, 
       CAP_PROP_XI_LED_MODE                                     = 412, 
       CAP_PROP_XI_MANUAL_WB                                    = 413, 
       CAP_PROP_XI_AUTO_WB                                      = 414, 
       CAP_PROP_XI_AEAG                                         = 415, 
       CAP_PROP_XI_EXP_PRIORITY                                 = 416, 
       CAP_PROP_XI_AE_MAX_LIMIT                                 = 417, 
       CAP_PROP_XI_AG_MAX_LIMIT                                 = 418, 
       CAP_PROP_XI_AEAG_LEVEL                                   = 419, 
       CAP_PROP_XI_TIMEOUT                                      = 420, 
       CAP_PROP_XI_EXPOSURE                                     = 421, 
       CAP_PROP_XI_EXPOSURE_BURST_COUNT                         = 422, 
       CAP_PROP_XI_GAIN_SELECTOR                                = 423, 
       CAP_PROP_XI_GAIN                                         = 424, 
       CAP_PROP_XI_DOWNSAMPLING_TYPE                            = 426, 
       CAP_PROP_XI_BINNING_SELECTOR                             = 427, 
       CAP_PROP_XI_BINNING_VERTICAL                             = 428, 
       CAP_PROP_XI_BINNING_HORIZONTAL                           = 429, 
       CAP_PROP_XI_BINNING_PATTERN                              = 430, 
       CAP_PROP_XI_DECIMATION_SELECTOR                          = 431, 
       CAP_PROP_XI_DECIMATION_VERTICAL                          = 432, 
       CAP_PROP_XI_DECIMATION_HORIZONTAL                        = 433, 
       CAP_PROP_XI_DECIMATION_PATTERN                           = 434, 
       CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR              = 587, 
       CAP_PROP_XI_TEST_PATTERN                                 = 588, 
       CAP_PROP_XI_IMAGE_DATA_FORMAT                            = 435, 
       CAP_PROP_XI_SHUTTER_TYPE                                 = 436, 
       CAP_PROP_XI_SENSOR_TAPS                                  = 437, 
       CAP_PROP_XI_AEAG_ROI_OFFSET_X                            = 439, 
       CAP_PROP_XI_AEAG_ROI_OFFSET_Y                            = 440, 
       CAP_PROP_XI_AEAG_ROI_WIDTH                               = 441, 
       CAP_PROP_XI_AEAG_ROI_HEIGHT                              = 442, 
       CAP_PROP_XI_BPC                                          = 445, 
       CAP_PROP_XI_WB_KR                                        = 448, 
       CAP_PROP_XI_WB_KG                                        = 449, 
       CAP_PROP_XI_WB_KB                                        = 450, 
       CAP_PROP_XI_WIDTH                                        = 451, 
       CAP_PROP_XI_HEIGHT                                       = 452, 
       CAP_PROP_XI_REGION_SELECTOR                              = 589, 
       CAP_PROP_XI_REGION_MODE                                  = 595, 
       CAP_PROP_XI_LIMIT_BANDWIDTH                              = 459, 
       CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH                        = 460, 
       CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH                        = 461, 
       CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH                         = 462, 
       CAP_PROP_XI_OUTPUT_DATA_PACKING                          = 463, 
       CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE                     = 464, 
       CAP_PROP_XI_IS_COOLED                                    = 465, 
       CAP_PROP_XI_COOLING                                      = 466, 
       CAP_PROP_XI_TARGET_TEMP                                  = 467, 
       CAP_PROP_XI_CHIP_TEMP                                    = 468, 
       CAP_PROP_XI_HOUS_TEMP                                    = 469, 
       CAP_PROP_XI_HOUS_BACK_SIDE_TEMP                          = 590, 
       CAP_PROP_XI_SENSOR_BOARD_TEMP                            = 596, 
       CAP_PROP_XI_CMS                                          = 470, 
       CAP_PROP_XI_APPLY_CMS                                    = 471, 
       CAP_PROP_XI_IMAGE_IS_COLOR                               = 474, 
       CAP_PROP_XI_COLOR_FILTER_ARRAY                           = 475, 
       CAP_PROP_XI_GAMMAY                                       = 476, 
       CAP_PROP_XI_GAMMAC                                       = 477, 
       CAP_PROP_XI_SHARPNESS                                    = 478, 
       CAP_PROP_XI_CC_MATRIX_00                                 = 479, 
       CAP_PROP_XI_CC_MATRIX_01                                 = 480, 
       CAP_PROP_XI_CC_MATRIX_02                                 = 481, 
       CAP_PROP_XI_CC_MATRIX_03                                 = 482, 
       CAP_PROP_XI_CC_MATRIX_10                                 = 483, 
       CAP_PROP_XI_CC_MATRIX_11                                 = 484, 
       CAP_PROP_XI_CC_MATRIX_12                                 = 485, 
       CAP_PROP_XI_CC_MATRIX_13                                 = 486, 
       CAP_PROP_XI_CC_MATRIX_20                                 = 487, 
       CAP_PROP_XI_CC_MATRIX_21                                 = 488, 
       CAP_PROP_XI_CC_MATRIX_22                                 = 489, 
       CAP_PROP_XI_CC_MATRIX_23                                 = 490, 
       CAP_PROP_XI_CC_MATRIX_30                                 = 491, 
       CAP_PROP_XI_CC_MATRIX_31                                 = 492, 
       CAP_PROP_XI_CC_MATRIX_32                                 = 493, 
       CAP_PROP_XI_CC_MATRIX_33                                 = 494, 
       CAP_PROP_XI_DEFAULT_CC_MATRIX                            = 495, 
       CAP_PROP_XI_TRG_SELECTOR                                 = 498, 
       CAP_PROP_XI_ACQ_FRAME_BURST_COUNT                        = 499, 
       CAP_PROP_XI_DEBOUNCE_EN                                  = 507, 
       CAP_PROP_XI_DEBOUNCE_T0                                  = 508, 
       CAP_PROP_XI_DEBOUNCE_T1                                  = 509, 
       CAP_PROP_XI_DEBOUNCE_POL                                 = 510, 
       CAP_PROP_XI_LENS_MODE                                    = 511, 
       CAP_PROP_XI_LENS_APERTURE_VALUE                          = 512, 
       CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE                    = 513, 
       CAP_PROP_XI_LENS_FOCUS_MOVE                              = 514, 
       CAP_PROP_XI_LENS_FOCUS_DISTANCE                          = 515, 
       CAP_PROP_XI_LENS_FOCAL_LENGTH                            = 516, 
       CAP_PROP_XI_LENS_FEATURE_SELECTOR                        = 517, 
       CAP_PROP_XI_LENS_FEATURE                                 = 518, 
       CAP_PROP_XI_DEVICE_MODEL_ID                              = 521, 
       CAP_PROP_XI_DEVICE_SN                                    = 522, 
       CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA                = 529, 
       CAP_PROP_XI_IMAGE_PAYLOAD_SIZE                           = 530, 
       CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT                       = 531, 
       CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ                         = 532, 
       CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX                      = 533, 
       CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT                  = 534, 
       CAP_PROP_XI_FRAMERATE                                    = 535, 
       CAP_PROP_XI_COUNTER_SELECTOR                             = 536, 
       CAP_PROP_XI_COUNTER_VALUE                                = 537, 
       CAP_PROP_XI_ACQ_TIMING_MODE                              = 538, 
       CAP_PROP_XI_AVAILABLE_BANDWIDTH                          = 539, 
       CAP_PROP_XI_BUFFER_POLICY                                = 540, 
       CAP_PROP_XI_LUT_EN                                       = 541, 
       CAP_PROP_XI_LUT_INDEX                                    = 542, 
       CAP_PROP_XI_LUT_VALUE                                    = 543, 
       CAP_PROP_XI_TRG_DELAY                                    = 544, 
       CAP_PROP_XI_TS_RST_MODE                                  = 545, 
       CAP_PROP_XI_TS_RST_SOURCE                                = 546, 
       CAP_PROP_XI_IS_DEVICE_EXIST                              = 547, 
       CAP_PROP_XI_ACQ_BUFFER_SIZE                              = 548, 
       CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT                         = 549, 
       CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE                    = 550, 
       CAP_PROP_XI_BUFFERS_QUEUE_SIZE                           = 551, 
       CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT                  = 552, 
       CAP_PROP_XI_RECENT_FRAME                                 = 553, 
       CAP_PROP_XI_DEVICE_RESET                                 = 554, 
       CAP_PROP_XI_COLUMN_FPN_CORRECTION                        = 555, 
       CAP_PROP_XI_ROW_FPN_CORRECTION                           = 591, 
       CAP_PROP_XI_SENSOR_MODE                                  = 558, 
       CAP_PROP_XI_HDR                                          = 559, 
       CAP_PROP_XI_HDR_KNEEPOINT_COUNT                          = 560, 
       CAP_PROP_XI_HDR_T1                                       = 561, 
       CAP_PROP_XI_HDR_T2                                       = 562, 
       CAP_PROP_XI_KNEEPOINT1                                   = 563, 
       CAP_PROP_XI_KNEEPOINT2                                   = 564, 
       CAP_PROP_XI_IMAGE_BLACK_LEVEL                            = 565, 
       CAP_PROP_XI_HW_REVISION                                  = 571, 
       CAP_PROP_XI_DEBUG_LEVEL                                  = 572, 
       CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION                   = 573, 
       CAP_PROP_XI_FFS_FILE_ID                                  = 594, 
       CAP_PROP_XI_FFS_FILE_SIZE                                = 580, 
       CAP_PROP_XI_FREE_FFS_SIZE                                = 581, 
       CAP_PROP_XI_USED_FFS_SIZE                                = 582, 
       CAP_PROP_XI_FFS_ACCESS_KEY                               = 583, 
       CAP_PROP_XI_SENSOR_FEATURE_SELECTOR                      = 585, 
       CAP_PROP_XI_SENSOR_FEATURE_VALUE                         = 586, 
     };









enum { CAP_PROP_IOS_DEVICE_FOCUS        = 9001,
       CAP_PROP_IOS_DEVICE_EXPOSURE     = 9002,
       CAP_PROP_IOS_DEVICE_FLASH        = 9003,
       CAP_PROP_IOS_DEVICE_WHITEBALANCE = 9004,
       CAP_PROP_IOS_DEVICE_TORCH        = 9005
     };







enum { CAP_PROP_GIGA_FRAME_OFFSET_X   = 10001,
       CAP_PROP_GIGA_FRAME_OFFSET_Y   = 10002,
       CAP_PROP_GIGA_FRAME_WIDTH_MAX  = 10003,
       CAP_PROP_GIGA_FRAME_HEIGH_MAX  = 10004,
       CAP_PROP_GIGA_FRAME_SENS_WIDTH = 10005,
       CAP_PROP_GIGA_FRAME_SENS_HEIGH = 10006
     };






enum { CAP_PROP_INTELPERC_PROFILE_COUNT               = 11001,
       CAP_PROP_INTELPERC_PROFILE_IDX                 = 11002,
       CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE  = 11003,
       CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE      = 11004,
       CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD  = 11005,
       CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ     = 11006,
       CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT     = 11007
     };


enum { CAP_INTELPERC_DEPTH_GENERATOR = 1 << 29,
       CAP_INTELPERC_IMAGE_GENERATOR = 1 << 28,
       CAP_INTELPERC_GENERATORS_MASK = CAP_INTELPERC_DEPTH_GENERATOR + CAP_INTELPERC_IMAGE_GENERATOR
     };

enum { CAP_INTELPERC_DEPTH_MAP              = 0, 
       CAP_INTELPERC_UVDEPTH_MAP            = 1, 
       CAP_INTELPERC_IR_MAP                 = 2, 
       CAP_INTELPERC_IMAGE                  = 3
     };













enum { CAP_PROP_GPHOTO2_PREVIEW           = 17001, 
       CAP_PROP_GPHOTO2_WIDGET_ENUMERATE  = 17002, 
       CAP_PROP_GPHOTO2_RELOAD_CONFIG     = 17003, 
       CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE  = 17004, 
       CAP_PROP_GPHOTO2_COLLECT_MSGS      = 17005, 
       CAP_PROP_GPHOTO2_FLUSH_MSGS        = 17006, 
       CAP_PROP_SPEED                     = 17007, 
       CAP_PROP_APERTURE                  = 17008, 
       CAP_PROP_EXPOSUREPROGRAM           = 17009, 
       CAP_PROP_VIEWFINDER                = 17010  
     };











enum { CAP_PROP_IMAGES_BASE = 18000,
       CAP_PROP_IMAGES_LAST = 19000 
     };






class IVideoCapture;



















class  VideoCapture
{
public:
    




     VideoCapture();

    




     VideoCapture(const String& filename);

    












     VideoCapture(const String& filename, int apiPreference);

    








     VideoCapture(int index);

    



    virtual ~VideoCapture();

    








     virtual bool open(const String& filename);

    








     virtual bool open(int index);

   







     bool open(int cameraNum, int apiPreference);

    




     virtual bool isOpened() const;

    






     virtual void release();

    


















     virtual bool grab();

    















     virtual bool retrieve(OutputArray image, int flag = 0);

    


    virtual VideoCapture& operator >> ( Mat& image);

    


    virtual VideoCapture& operator >> ( UMat& image);

    













     virtual bool read(OutputArray image);

    








     virtual bool set(int propId, double value);

    
















     virtual double get(int propId) const;

    








     virtual bool open(const String& filename, int apiPreference);

protected:
    Ptr<CvCapture> cap;
    Ptr<IVideoCapture> icap;
};

class IVideoWriter;








class  VideoWriter
{
public:
    






     VideoWriter();

    




















     VideoWriter(const String& filename, int fourcc, double fps,
                Size frameSize, bool isColor = true);

    



     VideoWriter(const String& filename, int apiPreference, int fourcc, double fps,
                Size frameSize, bool isColor = true);

    



    virtual ~VideoWriter();

    







     virtual bool open(const String& filename, int fourcc, double fps,
                      Size frameSize, bool isColor = true);

    

     bool open(const String& filename, int apiPreference, int fourcc, double fps,
                      Size frameSize, bool isColor = true);

    

     virtual bool isOpened() const;

    




     virtual void release();

    


    virtual VideoWriter& operator << (const Mat& image);

    






     virtual void write(const Mat& image);

    







     virtual bool set(int propId, double value);

    







     virtual double get(int propId) const;

    






     static int fourcc(char c1, char c2, char c3, char c4);

protected:
    Ptr<CvVideoWriter> writer;
    Ptr<IVideoWriter> iwriter;

    static Ptr<IVideoWriter> create(const String& filename, int fourcc, double fps,
                                    Size frameSize, bool isColor = true);
};

template<>  void DefaultDeleter<CvCapture>::operator ()(CvCapture* obj) const;
template<>  void DefaultDeleter<CvVideoWriter>::operator ()(CvVideoWriter* obj) const;



} 

#line 953 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/videoio.hpp"

#line 52 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui.hpp"
#line 53 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui.hpp"


























































































































namespace cv
{





enum WindowFlags {
       WINDOW_NORMAL     = 0x00000000, 
       WINDOW_AUTOSIZE   = 0x00000001, 
       WINDOW_OPENGL     = 0x00001000, 

       WINDOW_FULLSCREEN = 1,          
       WINDOW_FREERATIO  = 0x00000100, 
       WINDOW_KEEPRATIO  = 0x00000000, 
       WINDOW_GUI_EXPANDED=0x00000000, 
       WINDOW_GUI_NORMAL = 0x00000010, 
    };


enum WindowPropertyFlags {
       WND_PROP_FULLSCREEN   = 0, 
       WND_PROP_AUTOSIZE     = 1, 
       WND_PROP_ASPECT_RATIO = 2, 
       WND_PROP_OPENGL       = 3, 
       WND_PROP_VISIBLE      = 4  
     };


enum MouseEventTypes {
       EVENT_MOUSEMOVE      = 0, 
       EVENT_LBUTTONDOWN    = 1, 
       EVENT_RBUTTONDOWN    = 2, 
       EVENT_MBUTTONDOWN    = 3, 
       EVENT_LBUTTONUP      = 4, 
       EVENT_RBUTTONUP      = 5, 
       EVENT_MBUTTONUP      = 6, 
       EVENT_LBUTTONDBLCLK  = 7, 
       EVENT_RBUTTONDBLCLK  = 8, 
       EVENT_MBUTTONDBLCLK  = 9, 
       EVENT_MOUSEWHEEL     = 10,
       EVENT_MOUSEHWHEEL    = 11 
     };


enum MouseEventFlags {
       EVENT_FLAG_LBUTTON   = 1, 
       EVENT_FLAG_RBUTTON   = 2, 
       EVENT_FLAG_MBUTTON   = 4, 
       EVENT_FLAG_CTRLKEY   = 8, 
       EVENT_FLAG_SHIFTKEY  = 16,
       EVENT_FLAG_ALTKEY    = 32 
     };


enum QtFontWeights {
        QT_FONT_LIGHT           = 25, 
        QT_FONT_NORMAL          = 50, 
        QT_FONT_DEMIBOLD        = 63, 
        QT_FONT_BOLD            = 75, 
        QT_FONT_BLACK           = 87  
     };


enum QtFontStyles {
        QT_STYLE_NORMAL         = 0, 
        QT_STYLE_ITALIC         = 1, 
        QT_STYLE_OBLIQUE        = 2  
     };


enum QtButtonTypes {
       QT_PUSH_BUTTON   = 0,    
       QT_CHECKBOX      = 1,    
       QT_RADIOBOX      = 2,    
       QT_NEW_BUTTONBAR = 1024  
     };








typedef void (*MouseCallback)(int event, int x, int y, int flags, void* userdata);





typedef void (*TrackbarCallback)(int pos, void* userdata);




typedef void (*OpenGlDrawCallback)(void* userdata);





typedef void (*ButtonCallback)(int state, void* userdata);



























 void namedWindow(const String& winname, int flags = WINDOW_AUTOSIZE);







 void destroyWindow(const String& winname);





 void destroyAllWindows();

 int startWindowThread();








 int waitKeyEx(int delay = 0);






















 int waitKey(int delay = 0);



































 void imshow(const String& winname, InputArray mat);












 void resizeWindow(const String& winname, int width, int height);







 void moveWindow(const String& winname, int x, int y);









 void setWindowProperty(const String& winname, int prop_id, double prop_value);





 void setWindowTitle(const String& winname, const String& title);










 double getWindowProperty(const String& winname, int prop_id);









 void setMouseCallback(const String& winname, MouseCallback onMouse, void* userdata = 0);





















 int getMouseWheelDelta(int flags);















 Rect selectROI(const String& windowName, InputArray img, bool showCrosshair = true, bool fromCenter = false);



 Rect selectROI(InputArray img, bool showCrosshair = true, bool fromCenter = false);
















 void selectROIs(const String& windowName, InputArray img,
                              std::vector<Rect>& boundingBoxes, bool showCrosshair = true, bool fromCenter = false);



























 int createTrackbar(const String& trackbarname, const String& winname,
                              int* value, int count,
                              TrackbarCallback onChange = 0,
                              void* userdata = 0);













 int getTrackbarPos(const String& trackbarname, const String& winname);














 void setTrackbarPos(const String& trackbarname, const String& winname, int pos);














 void setTrackbarMax(const String& trackbarname, const String& winname, int maxval);














 void setTrackbarMin(const String& trackbarname, const String& winname, int minval);









 void imshow(const String& winname, const ogl::Texture2D& tex);









































 void setOpenGlDrawCallback(const String& winname, OpenGlDrawCallback onOpenGlDraw, void* userdata = 0);





 void setOpenGlContext(const String& winname);





 void updateWindow(const String& winname);








struct QtFont
{
    const char* nameFont;  
    Scalar      color;     
    int         font_face; 
    const int*  ascii;     
    const int*  greek;
    const int*  cyrillic;
    float       hscale, vscale;
    float       shear;     
    int         thickness; 
    float       dx;        
    int         line_type; 
};





















 QtFont fontQt(const String& nameFont, int pointSize = -1,
                         Scalar color = Scalar::all(0), int weight = QT_FONT_NORMAL,
                         int style = QT_STYLE_NORMAL, int spacing = 0);











 void addText( const Mat& img, const String& text, Point org, const QtFont& font);















 void addText(const Mat& img, const String& text, Point org, const String& nameFont, int pointSize = -1, Scalar color = Scalar::all(0),
        int weight = QT_FONT_NORMAL, int style = QT_STYLE_NORMAL, int spacing = 0);













 void displayOverlay(const String& winname, const String& text, int delayms = 0);













 void displayStatusBar(const String& winname, const String& text, int delayms = 0);








 void saveWindowParameters(const String& windowName);








 void loadWindowParameters(const String& windowName);

  int startLoop(int (*pt2Func)(int argc, char *argv[]), int argc, char* argv[]);

  void stopLoop();



























 int createButton( const String& bar_name, ButtonCallback on_change,
                             void* userdata = 0, int type = QT_PUSH_BUTTON,
                             bool initial_button_state = false);





} 


#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui/highgui_c.h"












































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/core_c.h"

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 46 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui/highgui_c.h"
#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgproc/imgproc_c.h"



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 47 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui/highgui_c.h"

#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgcodecs/imgcodecs_c.h"












































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/core_c.h"

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 46 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgcodecs/imgcodecs_c.h"


extern "C" {
#line 50 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgcodecs/imgcodecs_c.h"





enum
{

    CV_LOAD_IMAGE_UNCHANGED  =-1,

    CV_LOAD_IMAGE_GRAYSCALE  =0,

    CV_LOAD_IMAGE_COLOR      =1,

    CV_LOAD_IMAGE_ANYDEPTH   =2,

    CV_LOAD_IMAGE_ANYCOLOR   =4,

    CV_LOAD_IMAGE_IGNORE_ORIENTATION  =128
};







extern "C"  IplImage* __cdecl cvLoadImage( const char* filename, int iscolor = CV_LOAD_IMAGE_COLOR);
extern "C"  CvMat* __cdecl cvLoadImageM( const char* filename, int iscolor = CV_LOAD_IMAGE_COLOR);

enum
{
    CV_IMWRITE_JPEG_QUALITY =1,
    CV_IMWRITE_JPEG_PROGRESSIVE =2,
    CV_IMWRITE_JPEG_OPTIMIZE =3,
    CV_IMWRITE_JPEG_RST_INTERVAL =4,
    CV_IMWRITE_JPEG_LUMA_QUALITY =5,
    CV_IMWRITE_JPEG_CHROMA_QUALITY =6,
    CV_IMWRITE_PNG_COMPRESSION =16,
    CV_IMWRITE_PNG_STRATEGY =17,
    CV_IMWRITE_PNG_BILEVEL =18,
    CV_IMWRITE_PNG_STRATEGY_DEFAULT =0,
    CV_IMWRITE_PNG_STRATEGY_FILTERED =1,
    CV_IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY =2,
    CV_IMWRITE_PNG_STRATEGY_RLE =3,
    CV_IMWRITE_PNG_STRATEGY_FIXED =4,
    CV_IMWRITE_PXM_BINARY =32,
    CV_IMWRITE_WEBP_QUALITY =64,
    CV_IMWRITE_PAM_TUPLETYPE = 128,
    CV_IMWRITE_PAM_FORMAT_NULL = 0,
    CV_IMWRITE_PAM_FORMAT_BLACKANDWHITE = 1,
    CV_IMWRITE_PAM_FORMAT_GRAYSCALE = 2,
    CV_IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA = 3,
    CV_IMWRITE_PAM_FORMAT_RGB = 4,
    CV_IMWRITE_PAM_FORMAT_RGB_ALPHA = 5,
};




extern "C"  int __cdecl cvSaveImage( const char* filename, const CvArr* image,
                        const int* params = 0 );


extern "C"  IplImage* __cdecl cvDecodeImage( const CvMat* buf, int iscolor = CV_LOAD_IMAGE_COLOR);
extern "C"  CvMat* __cdecl cvDecodeImageM( const CvMat* buf, int iscolor = CV_LOAD_IMAGE_COLOR);


extern "C"  CvMat* __cdecl cvEncodeImage( const char* ext, const CvArr* image,
                             const int* params = 0 );

enum
{
    CV_CVTIMG_FLIP      =1,
    CV_CVTIMG_SWAP_RB   =2
};


extern "C"  void __cdecl cvConvertImage( const CvArr* src, CvArr* dst, int flags = 0);

extern "C"  int __cdecl cvHaveImageReader(const char* filename);
extern "C"  int __cdecl cvHaveImageWriter(const char* filename);













}
#line 147 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgcodecs/imgcodecs_c.h"

#line 149 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/imgcodecs/imgcodecs_c.h"
#line 49 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui/highgui_c.h"
#line 50 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui/highgui_c.h"

#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/videoio/videoio_c.h"












































#line 1 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/core/core_c.h"

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 46 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/videoio/videoio_c.h"


extern "C" {
#line 50 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/videoio/videoio_c.h"














typedef struct CvCapture CvCapture;



extern "C"  CvCapture* __cdecl cvCreateFileCapture( const char* filename );



extern "C"  CvCapture* __cdecl cvCreateFileCaptureWithPreference( const char* filename , int apiPreference);

enum
{
    CV_CAP_ANY      =0,     

    CV_CAP_MIL      =100,   

    CV_CAP_VFW      =200,   
    CV_CAP_V4L      =200,
    CV_CAP_V4L2     =200,

    CV_CAP_FIREWARE =300,   
    CV_CAP_FIREWIRE =300,
    CV_CAP_IEEE1394 =300,
    CV_CAP_DC1394   =300,
    CV_CAP_CMU1394  =300,

    CV_CAP_STEREO   =400,   
    CV_CAP_TYZX     =400,
    CV_TYZX_LEFT    =400,
    CV_TYZX_RIGHT   =401,
    CV_TYZX_COLOR   =402,
    CV_TYZX_Z       =403,

    CV_CAP_QT       =500,   

    CV_CAP_UNICAP   =600,   

    CV_CAP_DSHOW    =700,   
    CV_CAP_MSMF     =1400,  

    CV_CAP_PVAPI    =800,   

    CV_CAP_OPENNI   =900,   
    CV_CAP_OPENNI_ASUS =910,   

    CV_CAP_ANDROID  =1000,  
    CV_CAP_ANDROID_BACK =CV_CAP_ANDROID+99, 
    CV_CAP_ANDROID_FRONT =CV_CAP_ANDROID+98, 

    CV_CAP_XIAPI    =1100,   

    CV_CAP_AVFOUNDATION = 1200,  

    CV_CAP_GIGANETIX = 1300,  

    CV_CAP_INTELPERC = 1500, 

    CV_CAP_OPENNI2 = 1600,   
    CV_CAP_GPHOTO2 = 1700,
    CV_CAP_GSTREAMER = 1800, 
    CV_CAP_FFMPEG = 1900,    
    CV_CAP_IMAGES = 2000,    

    CV_CAP_ARAVIS = 2100     
};



extern "C"  CvCapture* __cdecl cvCreateCameraCapture( int index );





extern "C"  int __cdecl cvGrabFrame( CvCapture* capture );







extern "C"  IplImage* __cdecl cvRetrieveFrame( CvCapture* capture, int streamIdx = 0 );





extern "C"  IplImage* __cdecl cvQueryFrame( CvCapture* capture );



extern "C"  void __cdecl cvReleaseCapture( CvCapture** capture );

enum
{
    
    
    CV_CAP_PROP_DC1394_OFF         = -4,  
    CV_CAP_PROP_DC1394_MODE_MANUAL = -3, 
    CV_CAP_PROP_DC1394_MODE_AUTO = -2,
    CV_CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO = -1,
    CV_CAP_PROP_POS_MSEC       =0,
    CV_CAP_PROP_POS_FRAMES     =1,
    CV_CAP_PROP_POS_AVI_RATIO  =2,
    CV_CAP_PROP_FRAME_WIDTH    =3,
    CV_CAP_PROP_FRAME_HEIGHT   =4,
    CV_CAP_PROP_FPS            =5,
    CV_CAP_PROP_FOURCC         =6,
    CV_CAP_PROP_FRAME_COUNT    =7,
    CV_CAP_PROP_FORMAT         =8,
    CV_CAP_PROP_MODE           =9,
    CV_CAP_PROP_BRIGHTNESS    =10,
    CV_CAP_PROP_CONTRAST      =11,
    CV_CAP_PROP_SATURATION    =12,
    CV_CAP_PROP_HUE           =13,
    CV_CAP_PROP_GAIN          =14,
    CV_CAP_PROP_EXPOSURE      =15,
    CV_CAP_PROP_CONVERT_RGB   =16,
    CV_CAP_PROP_WHITE_BALANCE_BLUE_U =17,
    CV_CAP_PROP_RECTIFICATION =18,
    CV_CAP_PROP_MONOCHROME    =19,
    CV_CAP_PROP_SHARPNESS     =20,
    CV_CAP_PROP_AUTO_EXPOSURE =21, 
                                   
                                   
    CV_CAP_PROP_GAMMA         =22,
    CV_CAP_PROP_TEMPERATURE   =23,
    CV_CAP_PROP_TRIGGER       =24,
    CV_CAP_PROP_TRIGGER_DELAY =25,
    CV_CAP_PROP_WHITE_BALANCE_RED_V =26,
    CV_CAP_PROP_ZOOM          =27,
    CV_CAP_PROP_FOCUS         =28,
    CV_CAP_PROP_GUID          =29,
    CV_CAP_PROP_ISO_SPEED     =30,
    CV_CAP_PROP_MAX_DC1394    =31,
    CV_CAP_PROP_BACKLIGHT     =32,
    CV_CAP_PROP_PAN           =33,
    CV_CAP_PROP_TILT          =34,
    CV_CAP_PROP_ROLL          =35,
    CV_CAP_PROP_IRIS          =36,
    CV_CAP_PROP_SETTINGS      =37,
    CV_CAP_PROP_BUFFERSIZE    =38,
    CV_CAP_PROP_AUTOFOCUS     =39,
    CV_CAP_PROP_SAR_NUM       =40,
    CV_CAP_PROP_SAR_DEN       =41,

    CV_CAP_PROP_AUTOGRAB      =1024, 
    CV_CAP_PROP_SUPPORTED_PREVIEW_SIZES_STRING=1025, 
    CV_CAP_PROP_PREVIEW_FORMAT=1026, 

    
    CV_CAP_OPENNI_DEPTH_GENERATOR = 1 << 31,
    CV_CAP_OPENNI_IMAGE_GENERATOR = 1 << 30,
    CV_CAP_OPENNI_IR_GENERATOR    = 1 << 29,
    CV_CAP_OPENNI_GENERATORS_MASK = CV_CAP_OPENNI_DEPTH_GENERATOR + CV_CAP_OPENNI_IMAGE_GENERATOR + CV_CAP_OPENNI_IR_GENERATOR,

    
    CV_CAP_PROP_OPENNI_OUTPUT_MODE     = 100,
    CV_CAP_PROP_OPENNI_FRAME_MAX_DEPTH = 101, 
    CV_CAP_PROP_OPENNI_BASELINE        = 102, 
    CV_CAP_PROP_OPENNI_FOCAL_LENGTH    = 103, 
    CV_CAP_PROP_OPENNI_REGISTRATION    = 104, 
    CV_CAP_PROP_OPENNI_REGISTRATION_ON = CV_CAP_PROP_OPENNI_REGISTRATION, 
                                                                          
                                                                          
    CV_CAP_PROP_OPENNI_APPROX_FRAME_SYNC = 105,
    CV_CAP_PROP_OPENNI_MAX_BUFFER_SIZE   = 106,
    CV_CAP_PROP_OPENNI_CIRCLE_BUFFER     = 107,
    CV_CAP_PROP_OPENNI_MAX_TIME_DURATION = 108,

    CV_CAP_PROP_OPENNI_GENERATOR_PRESENT = 109,
    CV_CAP_PROP_OPENNI2_SYNC = 110,
    CV_CAP_PROP_OPENNI2_MIRROR = 111,

    CV_CAP_OPENNI_IMAGE_GENERATOR_PRESENT         = CV_CAP_OPENNI_IMAGE_GENERATOR + CV_CAP_PROP_OPENNI_GENERATOR_PRESENT,
    CV_CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE     = CV_CAP_OPENNI_IMAGE_GENERATOR + CV_CAP_PROP_OPENNI_OUTPUT_MODE,
    CV_CAP_OPENNI_DEPTH_GENERATOR_PRESENT         = CV_CAP_OPENNI_DEPTH_GENERATOR + CV_CAP_PROP_OPENNI_GENERATOR_PRESENT,
    CV_CAP_OPENNI_DEPTH_GENERATOR_BASELINE        = CV_CAP_OPENNI_DEPTH_GENERATOR + CV_CAP_PROP_OPENNI_BASELINE,
    CV_CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH    = CV_CAP_OPENNI_DEPTH_GENERATOR + CV_CAP_PROP_OPENNI_FOCAL_LENGTH,
    CV_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION    = CV_CAP_OPENNI_DEPTH_GENERATOR + CV_CAP_PROP_OPENNI_REGISTRATION,
    CV_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON = CV_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION,
    CV_CAP_OPENNI_IR_GENERATOR_PRESENT            = CV_CAP_OPENNI_IR_GENERATOR + CV_CAP_PROP_OPENNI_GENERATOR_PRESENT,

    
    CV_CAP_GSTREAMER_QUEUE_LENGTH           = 200, 

    
    CV_CAP_PROP_PVAPI_MULTICASTIP           = 300, 
    CV_CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE = 301, 
    CV_CAP_PROP_PVAPI_DECIMATIONHORIZONTAL  = 302, 
    CV_CAP_PROP_PVAPI_DECIMATIONVERTICAL    = 303, 
    CV_CAP_PROP_PVAPI_BINNINGX              = 304, 
    CV_CAP_PROP_PVAPI_BINNINGY              = 305, 
    CV_CAP_PROP_PVAPI_PIXELFORMAT           = 306, 

    
    CV_CAP_PROP_XI_DOWNSAMPLING                                 = 400, 
    CV_CAP_PROP_XI_DATA_FORMAT                                  = 401, 
    CV_CAP_PROP_XI_OFFSET_X                                     = 402, 
    CV_CAP_PROP_XI_OFFSET_Y                                     = 403, 
    CV_CAP_PROP_XI_TRG_SOURCE                                   = 404, 
    CV_CAP_PROP_XI_TRG_SOFTWARE                                 = 405, 
    CV_CAP_PROP_XI_GPI_SELECTOR                                 = 406, 
    CV_CAP_PROP_XI_GPI_MODE                                     = 407, 
    CV_CAP_PROP_XI_GPI_LEVEL                                    = 408, 
    CV_CAP_PROP_XI_GPO_SELECTOR                                 = 409, 
    CV_CAP_PROP_XI_GPO_MODE                                     = 410, 
    CV_CAP_PROP_XI_LED_SELECTOR                                 = 411, 
    CV_CAP_PROP_XI_LED_MODE                                     = 412, 
    CV_CAP_PROP_XI_MANUAL_WB                                    = 413, 
    CV_CAP_PROP_XI_AUTO_WB                                      = 414, 
    CV_CAP_PROP_XI_AEAG                                         = 415, 
    CV_CAP_PROP_XI_EXP_PRIORITY                                 = 416, 
    CV_CAP_PROP_XI_AE_MAX_LIMIT                                 = 417, 
    CV_CAP_PROP_XI_AG_MAX_LIMIT                                 = 418,  
    CV_CAP_PROP_XI_AEAG_LEVEL                                   = 419, 
    CV_CAP_PROP_XI_TIMEOUT                                      = 420, 
    CV_CAP_PROP_XI_EXPOSURE                                     = 421, 
    CV_CAP_PROP_XI_EXPOSURE_BURST_COUNT                         = 422, 
    CV_CAP_PROP_XI_GAIN_SELECTOR                                = 423, 
    CV_CAP_PROP_XI_GAIN                                         = 424, 
    CV_CAP_PROP_XI_DOWNSAMPLING_TYPE                            = 426, 
    CV_CAP_PROP_XI_BINNING_SELECTOR                             = 427, 
    CV_CAP_PROP_XI_BINNING_VERTICAL                             = 428, 
    CV_CAP_PROP_XI_BINNING_HORIZONTAL                           = 429, 
    CV_CAP_PROP_XI_BINNING_PATTERN                              = 430, 
    CV_CAP_PROP_XI_DECIMATION_SELECTOR                          = 431, 
    CV_CAP_PROP_XI_DECIMATION_VERTICAL                          = 432, 
    CV_CAP_PROP_XI_DECIMATION_HORIZONTAL                        = 433, 
    CV_CAP_PROP_XI_DECIMATION_PATTERN                           = 434, 
    CV_CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR              = 587, 
    CV_CAP_PROP_XI_TEST_PATTERN                                 = 588, 
    CV_CAP_PROP_XI_IMAGE_DATA_FORMAT                            = 435, 
    CV_CAP_PROP_XI_SHUTTER_TYPE                                 = 436, 
    CV_CAP_PROP_XI_SENSOR_TAPS                                  = 437, 
    CV_CAP_PROP_XI_AEAG_ROI_OFFSET_X                            = 439, 
    CV_CAP_PROP_XI_AEAG_ROI_OFFSET_Y                            = 440, 
    CV_CAP_PROP_XI_AEAG_ROI_WIDTH                               = 441, 
    CV_CAP_PROP_XI_AEAG_ROI_HEIGHT                              = 442, 
    CV_CAP_PROP_XI_BPC                                          = 445, 
    CV_CAP_PROP_XI_WB_KR                                        = 448, 
    CV_CAP_PROP_XI_WB_KG                                        = 449, 
    CV_CAP_PROP_XI_WB_KB                                        = 450, 
    CV_CAP_PROP_XI_WIDTH                                        = 451, 
    CV_CAP_PROP_XI_HEIGHT                                       = 452, 
    CV_CAP_PROP_XI_REGION_SELECTOR                              = 589, 
    CV_CAP_PROP_XI_REGION_MODE                                  = 595, 
    CV_CAP_PROP_XI_LIMIT_BANDWIDTH                              = 459, 
    CV_CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH                        = 460, 
    CV_CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH                        = 461, 
    CV_CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH                         = 462, 
    CV_CAP_PROP_XI_OUTPUT_DATA_PACKING                          = 463, 
    CV_CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE                     = 464, 
    CV_CAP_PROP_XI_IS_COOLED                                    = 465, 
    CV_CAP_PROP_XI_COOLING                                      = 466, 
    CV_CAP_PROP_XI_TARGET_TEMP                                  = 467, 
    CV_CAP_PROP_XI_CHIP_TEMP                                    = 468, 
    CV_CAP_PROP_XI_HOUS_TEMP                                    = 469, 
    CV_CAP_PROP_XI_HOUS_BACK_SIDE_TEMP                          = 590, 
    CV_CAP_PROP_XI_SENSOR_BOARD_TEMP                            = 596, 
    CV_CAP_PROP_XI_CMS                                          = 470, 
    CV_CAP_PROP_XI_APPLY_CMS                                    = 471, 
    CV_CAP_PROP_XI_IMAGE_IS_COLOR                               = 474, 
    CV_CAP_PROP_XI_COLOR_FILTER_ARRAY                           = 475, 
    CV_CAP_PROP_XI_GAMMAY                                       = 476, 
    CV_CAP_PROP_XI_GAMMAC                                       = 477, 
    CV_CAP_PROP_XI_SHARPNESS                                    = 478, 
    CV_CAP_PROP_XI_CC_MATRIX_00                                 = 479, 
    CV_CAP_PROP_XI_CC_MATRIX_01                                 = 480, 
    CV_CAP_PROP_XI_CC_MATRIX_02                                 = 481, 
    CV_CAP_PROP_XI_CC_MATRIX_03                                 = 482, 
    CV_CAP_PROP_XI_CC_MATRIX_10                                 = 483, 
    CV_CAP_PROP_XI_CC_MATRIX_11                                 = 484, 
    CV_CAP_PROP_XI_CC_MATRIX_12                                 = 485, 
    CV_CAP_PROP_XI_CC_MATRIX_13                                 = 486, 
    CV_CAP_PROP_XI_CC_MATRIX_20                                 = 487, 
    CV_CAP_PROP_XI_CC_MATRIX_21                                 = 488, 
    CV_CAP_PROP_XI_CC_MATRIX_22                                 = 489, 
    CV_CAP_PROP_XI_CC_MATRIX_23                                 = 490, 
    CV_CAP_PROP_XI_CC_MATRIX_30                                 = 491, 
    CV_CAP_PROP_XI_CC_MATRIX_31                                 = 492, 
    CV_CAP_PROP_XI_CC_MATRIX_32                                 = 493, 
    CV_CAP_PROP_XI_CC_MATRIX_33                                 = 494, 
    CV_CAP_PROP_XI_DEFAULT_CC_MATRIX                            = 495, 
    CV_CAP_PROP_XI_TRG_SELECTOR                                 = 498, 
    CV_CAP_PROP_XI_ACQ_FRAME_BURST_COUNT                        = 499, 
    CV_CAP_PROP_XI_DEBOUNCE_EN                                  = 507, 
    CV_CAP_PROP_XI_DEBOUNCE_T0                                  = 508, 
    CV_CAP_PROP_XI_DEBOUNCE_T1                                  = 509, 
    CV_CAP_PROP_XI_DEBOUNCE_POL                                 = 510, 
    CV_CAP_PROP_XI_LENS_MODE                                    = 511, 
    CV_CAP_PROP_XI_LENS_APERTURE_VALUE                          = 512, 
    CV_CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE                    = 513, 
    CV_CAP_PROP_XI_LENS_FOCUS_MOVE                              = 514, 
    CV_CAP_PROP_XI_LENS_FOCUS_DISTANCE                          = 515, 
    CV_CAP_PROP_XI_LENS_FOCAL_LENGTH                            = 516, 
    CV_CAP_PROP_XI_LENS_FEATURE_SELECTOR                        = 517, 
    CV_CAP_PROP_XI_LENS_FEATURE                                 = 518, 
    CV_CAP_PROP_XI_DEVICE_MODEL_ID                              = 521, 
    CV_CAP_PROP_XI_DEVICE_SN                                    = 522, 
    CV_CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA                = 529, 
    CV_CAP_PROP_XI_IMAGE_PAYLOAD_SIZE                           = 530, 
    CV_CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT                       = 531, 
    CV_CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ                         = 532, 
    CV_CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX                      = 533, 
    CV_CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT                  = 534, 
    CV_CAP_PROP_XI_FRAMERATE                                    = 535, 
    CV_CAP_PROP_XI_COUNTER_SELECTOR                             = 536, 
    CV_CAP_PROP_XI_COUNTER_VALUE                                = 537, 
    CV_CAP_PROP_XI_ACQ_TIMING_MODE                              = 538, 
    CV_CAP_PROP_XI_AVAILABLE_BANDWIDTH                          = 539, 
    CV_CAP_PROP_XI_BUFFER_POLICY                                = 540, 
    CV_CAP_PROP_XI_LUT_EN                                       = 541, 
    CV_CAP_PROP_XI_LUT_INDEX                                    = 542, 
    CV_CAP_PROP_XI_LUT_VALUE                                    = 543, 
    CV_CAP_PROP_XI_TRG_DELAY                                    = 544, 
    CV_CAP_PROP_XI_TS_RST_MODE                                  = 545, 
    CV_CAP_PROP_XI_TS_RST_SOURCE                                = 546, 
    CV_CAP_PROP_XI_IS_DEVICE_EXIST                              = 547, 
    CV_CAP_PROP_XI_ACQ_BUFFER_SIZE                              = 548, 
    CV_CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT                         = 549, 
    CV_CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE                    = 550, 
    CV_CAP_PROP_XI_BUFFERS_QUEUE_SIZE                           = 551, 
    CV_CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT                  = 552, 
    CV_CAP_PROP_XI_RECENT_FRAME                                 = 553, 
    CV_CAP_PROP_XI_DEVICE_RESET                                 = 554, 
    CV_CAP_PROP_XI_COLUMN_FPN_CORRECTION                        = 555, 
    CV_CAP_PROP_XI_ROW_FPN_CORRECTION                           = 591, 
    CV_CAP_PROP_XI_SENSOR_MODE                                  = 558, 
    CV_CAP_PROP_XI_HDR                                          = 559, 
    CV_CAP_PROP_XI_HDR_KNEEPOINT_COUNT                          = 560, 
    CV_CAP_PROP_XI_HDR_T1                                       = 561, 
    CV_CAP_PROP_XI_HDR_T2                                       = 562, 
    CV_CAP_PROP_XI_KNEEPOINT1                                   = 563, 
    CV_CAP_PROP_XI_KNEEPOINT2                                   = 564, 
    CV_CAP_PROP_XI_IMAGE_BLACK_LEVEL                            = 565, 
    CV_CAP_PROP_XI_HW_REVISION                                  = 571, 
    CV_CAP_PROP_XI_DEBUG_LEVEL                                  = 572, 
    CV_CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION                   = 573, 
    CV_CAP_PROP_XI_FFS_FILE_ID                                  = 594, 
    CV_CAP_PROP_XI_FFS_FILE_SIZE                                = 580, 
    CV_CAP_PROP_XI_FREE_FFS_SIZE                                = 581, 
    CV_CAP_PROP_XI_USED_FFS_SIZE                                = 582, 
    CV_CAP_PROP_XI_FFS_ACCESS_KEY                               = 583, 
    CV_CAP_PROP_XI_SENSOR_FEATURE_SELECTOR                      = 585, 
    CV_CAP_PROP_XI_SENSOR_FEATURE_VALUE                         = 586, 


    
    CV_CAP_PROP_ANDROID_FLASH_MODE = 8001,
    CV_CAP_PROP_ANDROID_FOCUS_MODE = 8002,
    CV_CAP_PROP_ANDROID_WHITE_BALANCE = 8003,
    CV_CAP_PROP_ANDROID_ANTIBANDING = 8004,
    CV_CAP_PROP_ANDROID_FOCAL_LENGTH = 8005,
    CV_CAP_PROP_ANDROID_FOCUS_DISTANCE_NEAR = 8006,
    CV_CAP_PROP_ANDROID_FOCUS_DISTANCE_OPTIMAL = 8007,
    CV_CAP_PROP_ANDROID_FOCUS_DISTANCE_FAR = 8008,
    CV_CAP_PROP_ANDROID_EXPOSE_LOCK = 8009,
    CV_CAP_PROP_ANDROID_WHITEBALANCE_LOCK = 8010,

    
    CV_CAP_PROP_IOS_DEVICE_FOCUS = 9001,
    CV_CAP_PROP_IOS_DEVICE_EXPOSURE = 9002,
    CV_CAP_PROP_IOS_DEVICE_FLASH = 9003,
    CV_CAP_PROP_IOS_DEVICE_WHITEBALANCE = 9004,
    CV_CAP_PROP_IOS_DEVICE_TORCH = 9005,

    
    
    CV_CAP_PROP_GIGA_FRAME_OFFSET_X = 10001,
    CV_CAP_PROP_GIGA_FRAME_OFFSET_Y = 10002,
    CV_CAP_PROP_GIGA_FRAME_WIDTH_MAX = 10003,
    CV_CAP_PROP_GIGA_FRAME_HEIGH_MAX = 10004,
    CV_CAP_PROP_GIGA_FRAME_SENS_WIDTH = 10005,
    CV_CAP_PROP_GIGA_FRAME_SENS_HEIGH = 10006,

    CV_CAP_PROP_INTELPERC_PROFILE_COUNT               = 11001,
    CV_CAP_PROP_INTELPERC_PROFILE_IDX                 = 11002,
    CV_CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE  = 11003,
    CV_CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE      = 11004,
    CV_CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD  = 11005,
    CV_CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ     = 11006,
    CV_CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT     = 11007,

    
    CV_CAP_INTELPERC_DEPTH_GENERATOR = 1 << 29,
    CV_CAP_INTELPERC_IMAGE_GENERATOR = 1 << 28,
    CV_CAP_INTELPERC_GENERATORS_MASK = CV_CAP_INTELPERC_DEPTH_GENERATOR + CV_CAP_INTELPERC_IMAGE_GENERATOR
};



enum
{
    CV_CAP_MODE_BGR  = 0, 
    CV_CAP_MODE_RGB  = 1, 
    CV_CAP_MODE_GRAY = 2, 
    CV_CAP_MODE_YUYV = 3  
};

enum
{
    
    CV_CAP_OPENNI_DEPTH_MAP                 = 0, 
    CV_CAP_OPENNI_POINT_CLOUD_MAP           = 1, 
    CV_CAP_OPENNI_DISPARITY_MAP             = 2, 
    CV_CAP_OPENNI_DISPARITY_MAP_32F         = 3, 
    CV_CAP_OPENNI_VALID_DEPTH_MASK          = 4, 

    
    CV_CAP_OPENNI_BGR_IMAGE                 = 5,
    CV_CAP_OPENNI_GRAY_IMAGE                = 6,

    
    CV_CAP_OPENNI_IR_IMAGE                  = 7
};


enum
{
    CV_CAP_OPENNI_VGA_30HZ     = 0,
    CV_CAP_OPENNI_SXGA_15HZ    = 1,
    CV_CAP_OPENNI_SXGA_30HZ    = 2,
    CV_CAP_OPENNI_QVGA_30HZ    = 3,
    CV_CAP_OPENNI_QVGA_60HZ    = 4
};

enum
{
    CV_CAP_INTELPERC_DEPTH_MAP              = 0, 
    CV_CAP_INTELPERC_UVDEPTH_MAP            = 1, 
    CV_CAP_INTELPERC_IR_MAP                 = 2, 
    CV_CAP_INTELPERC_IMAGE                  = 3
};




enum
{
    CV_CAP_PROP_GPHOTO2_PREVIEW           = 17001, 
    CV_CAP_PROP_GPHOTO2_WIDGET_ENUMERATE  = 17002, 
    CV_CAP_PROP_GPHOTO2_RELOAD_CONFIG     = 17003, 
    CV_CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE  = 17004, 
    CV_CAP_PROP_GPHOTO2_COLLECT_MSGS      = 17005, 
    CV_CAP_PROP_GPHOTO2_FLUSH_MSGS        = 17006, 
    CV_CAP_PROP_SPEED                     = 17007, 
    CV_CAP_PROP_APERTURE                  = 17008, 
    CV_CAP_PROP_EXPOSUREPROGRAM           = 17009, 
    CV_CAP_PROP_VIEWFINDER                = 17010  
};



extern "C"  double __cdecl cvGetCaptureProperty( CvCapture* capture, int property_id );


extern "C"  int __cdecl    cvSetCaptureProperty( CvCapture* capture, int property_id, double value );





extern "C"  int __cdecl    cvGetCaptureDomain( CvCapture* capture);





typedef struct CvVideoWriter CvVideoWriter;












static inline int CV_FOURCC(char c1, char c2, char c3, char c4)
{
    return (((c1) & 255) + (((c2) & 255) << 8) + (((c3) & 255) << 16) + (((c4) & 255) << 24));
}








extern "C"  CvVideoWriter* __cdecl cvCreateVideoWriter( const char* filename, int fourcc,
                                           double fps, CvSize frame_size,
                                           int is_color = 1);



extern "C"  int __cdecl cvWriteFrame( CvVideoWriter* writer, const IplImage* image );



extern "C"  void __cdecl cvReleaseVideoWriter( CvVideoWriter** writer );














}
#line 586 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/videoio/videoio_c.h"

#line 588 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/videoio/videoio_c.h"

#line 52 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui/highgui_c.h"
#line 53 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui/highgui_c.h"


extern "C" {
#line 57 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui/highgui_c.h"











enum {  CV_FONT_LIGHT           = 25,
        CV_FONT_NORMAL          = 50,
        CV_FONT_DEMIBOLD        = 63,
        CV_FONT_BOLD            = 75,
        CV_FONT_BLACK           = 87 
};

enum {  CV_STYLE_NORMAL         = 0,
        CV_STYLE_ITALIC         = 1,
        CV_STYLE_OBLIQUE        = 2 
};




extern "C"  CvFont __cdecl cvFontQt(const char* nameFont, int pointSize = -1, CvScalar color = cvScalarAll(0), int weight = CV_FONT_NORMAL,  int style = CV_STYLE_NORMAL, int spacing = 0);

extern "C"  void __cdecl cvAddText(const CvArr* img, const char* text, CvPoint org, CvFont *arg2);

extern "C"  void __cdecl cvDisplayOverlay(const char* name, const char* text, int delayms = 0);
extern "C"  void __cdecl cvDisplayStatusBar(const char* name, const char* text, int delayms = 0);

extern "C"  void __cdecl cvSaveWindowParameters(const char* name);
extern "C"  void __cdecl cvLoadWindowParameters(const char* name);
extern "C"  int __cdecl cvStartLoop(int (*pt2Func)(int argc, char *argv[]), int argc, char* argv[]);
extern "C"  void __cdecl cvStopLoop( void );

typedef void (__cdecl *CvButtonCallback)(int state, void* userdata);
enum {CV_PUSH_BUTTON = 0, CV_CHECKBOX = 1, CV_RADIOBOX = 2};
extern "C"  int __cdecl cvCreateButton( const char* button_name = 0,CvButtonCallback on_change = 0, void* userdata = 0 , int button_type = CV_PUSH_BUTTON, int initial_button_state = 0);




extern "C"  int __cdecl cvInitSystem( int argc, char** argv );

extern "C"  int __cdecl cvStartWindowThread( void );


enum
{
    
    CV_WND_PROP_FULLSCREEN = 0, 
    CV_WND_PROP_AUTOSIZE   = 1, 
    CV_WND_PROP_ASPECTRATIO= 2, 
    CV_WND_PROP_OPENGL     = 3, 
    CV_WND_PROP_VISIBLE    = 4,

    
    CV_WINDOW_NORMAL       = 0x00000000, 
    CV_WINDOW_AUTOSIZE     = 0x00000001, 
    CV_WINDOW_OPENGL       = 0x00001000, 

    
    CV_GUI_EXPANDED         = 0x00000000, 
    CV_GUI_NORMAL           = 0x00000010, 

    
    CV_WINDOW_FULLSCREEN   = 1,
    CV_WINDOW_FREERATIO    = 0x00000100,
    CV_WINDOW_KEEPRATIO    = 0x00000000
};


extern "C"  int __cdecl cvNamedWindow( const char* name, int flags = CV_WINDOW_AUTOSIZE );


extern "C"  void __cdecl cvSetWindowProperty(const char* name, int prop_id, double prop_value);
extern "C"  double __cdecl cvGetWindowProperty(const char* name, int prop_id);


extern "C"  void __cdecl cvShowImage( const char* name, const CvArr* image );


extern "C"  void __cdecl cvResizeWindow( const char* name, int width, int height );
extern "C"  void __cdecl cvMoveWindow( const char* name, int x, int y );



extern "C"  void __cdecl cvDestroyWindow( const char* name );

extern "C"  void __cdecl cvDestroyAllWindows(void);


extern "C"  void* __cdecl cvGetWindowHandle( const char* name );


extern "C"  const char* __cdecl cvGetWindowName( void* window_handle );


typedef void (__cdecl *CvTrackbarCallback)(int pos);


extern "C"  int __cdecl cvCreateTrackbar( const char* trackbar_name, const char* window_name,
                             int* value, int count, CvTrackbarCallback on_change = 0);

typedef void (__cdecl *CvTrackbarCallback2)(int pos, void* userdata);

extern "C"  int __cdecl cvCreateTrackbar2( const char* trackbar_name, const char* window_name,
                              int* value, int count, CvTrackbarCallback2 on_change,
                              void* userdata = 0);


extern "C"  int __cdecl cvGetTrackbarPos( const char* trackbar_name, const char* window_name );
extern "C"  void __cdecl cvSetTrackbarPos( const char* trackbar_name, const char* window_name, int pos );
extern "C"  void __cdecl cvSetTrackbarMax(const char* trackbar_name, const char* window_name, int maxval);
extern "C"  void __cdecl cvSetTrackbarMin(const char* trackbar_name, const char* window_name, int minval);

enum
{
    CV_EVENT_MOUSEMOVE      =0,
    CV_EVENT_LBUTTONDOWN    =1,
    CV_EVENT_RBUTTONDOWN    =2,
    CV_EVENT_MBUTTONDOWN    =3,
    CV_EVENT_LBUTTONUP      =4,
    CV_EVENT_RBUTTONUP      =5,
    CV_EVENT_MBUTTONUP      =6,
    CV_EVENT_LBUTTONDBLCLK  =7,
    CV_EVENT_RBUTTONDBLCLK  =8,
    CV_EVENT_MBUTTONDBLCLK  =9,
    CV_EVENT_MOUSEWHEEL     =10,
    CV_EVENT_MOUSEHWHEEL    =11
};

enum
{
    CV_EVENT_FLAG_LBUTTON   =1,
    CV_EVENT_FLAG_RBUTTON   =2,
    CV_EVENT_FLAG_MBUTTON   =4,
    CV_EVENT_FLAG_CTRLKEY   =8,
    CV_EVENT_FLAG_SHIFTKEY  =16,
    CV_EVENT_FLAG_ALTKEY    =32
};




typedef void (__cdecl *CvMouseCallback )(int event, int x, int y, int flags, void* param);


extern "C"  void __cdecl cvSetMouseCallback( const char* window_name, CvMouseCallback on_mouse,
                                void* param = 0);


extern "C"  int __cdecl cvWaitKey(int delay = 0);



typedef void (__cdecl *CvOpenGlDrawCallback)(void* userdata);
extern "C"  void __cdecl cvSetOpenGlDrawCallback(const char* window_name, CvOpenGlDrawCallback callback, void* userdata = 0);

extern "C"  void __cdecl cvSetOpenGlContext(const char* window_name);
extern "C"  void __cdecl cvUpdateWindow(const char* window_name);























extern "C"  void __cdecl cvSetPreprocessFuncWin32_(const void* callback);
extern "C"  void __cdecl cvSetPostprocessFuncWin32_(const void* callback);



#line 250 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui/highgui_c.h"




}
#line 256 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui/highgui_c.h"

#line 258 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui/highgui_c.h"
#line 826 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui.hpp"
#line 827 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui.hpp"

#line 829 "C:\\C++_Lib\\opencv\\build\\include\\opencv2/highgui.hpp"

#line 4 "c:\\users\\олег\\desktop\\проект\\trialcptrfromvideo\\cptrfromvideo\\Header.h"



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"































































































































































































































































































































































































































































































































































































































































#line 641 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\math.h"

#line 8 "c:\\users\\олег\\desktop\\проект\\trialcptrfromvideo\\cptrfromvideo\\Header.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iostream"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {
  











		
 extern __declspec(dllimport) istream cin, *_Ptr_cin;
 extern __declspec(dllimport) ostream cout, *_Ptr_cout;
 extern __declspec(dllimport) ostream cerr, *_Ptr_cerr;
 extern __declspec(dllimport) ostream clog, *_Ptr_clog;

 extern __declspec(dllimport) wistream wcin, *_Ptr_wcin;
 extern __declspec(dllimport) wostream wcout, *_Ptr_wcout;
 extern __declspec(dllimport) wostream wcerr, *_Ptr_wcerr;
 extern __declspec(dllimport) wostream wclog, *_Ptr_wclog;

		
class __declspec(dllimport) _Winit {
public:
	__thiscall _Winit();
	__thiscall ~_Winit() throw ();
private:
	 static int _Init_cnt;
	};
  #line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iostream"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 50 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iostream"
#line 51 "C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\include\\iostream"





#line 9 "c:\\users\\олег\\desktop\\проект\\trialcptrfromvideo\\cptrfromvideo\\Header.h"

using namespace std;
using namespace cv;

void ImagesFiltering(Mat &image, Mat &imageGray, Mat &imageSmooth, Mat&imageBorders);

void ImagesLinesDrawing(Mat &imageSrc, Mat &imageDst);

void ImagesDotsSearching(Mat &imageSrc, Mat &imageDst);

void ImagesAreaDetecting(Mat &image, Mat &imageField, Mat &imageDst);

void ImagesShowing(Mat &image, Mat &imageGray, Mat &imageSmooth, Mat &imageBorders, Mat &imageLines, Mat &imageField, Mat &imageDst, Mat &imageObjects, Mat &imageColoredObjects);


void objectsDetecting(Mat &imageDst, Mat &imageObjects);

int objectsPositioning(Mat &imageObjects, Mat &imageColoredObjects, Point* &objectPosition);


#line 2 "c:\\users\\олег\\desktop\\проект\\trialcptrfromvideo\\cptrfromvideo\\Matrix.h"


class matrix
{
	public:
		double **elements;
	    int N, M;

		
		matrix (); 
		matrix (double a11, double a12, double a13, double a21, double a22, double a23, double a31, double a32, double a33); 
		matrix (double a11, double a12, double a13); 

		
		matrix(const matrix &);

		
	    ~matrix();

		
		matrix& operator=(const matrix&);

		
		double det();

		
		matrix& del(double);

		
		matrix& transp();

		
};


ostream& operator<<(ostream&, matrix&);


matrix inv(matrix&);


matrix operator* (matrix, matrix);


matrix convertMatrixCreating(Point, Point, Point, int);


int objectMatrixChoosing(Point, int, int, int, int, Point, Point);


Point objectsNewPositioning(Point, matrix&);


int sign(double);

#line 2 "c:\\users\\олег\\desktop\\проект\\trialcptrfromvideo\\cptrfromvideo\\positioning.cpp"


int objectsPositioning(Mat &imageObjects, Mat &imageColoredObjects, Point* &objectPosition)
{
	
	imageColoredObjects = Mat(imageObjects.rows, imageObjects.cols, (((0) & ((1 << 3) - 1)) + (((3)-1) << 3)));

	Mat out[] = { imageColoredObjects };
	int from_to[] = { 0,0 };
	mixChannels( &imageObjects, 1, out, 1, from_to, 1 );

	




	Point seed;
	int lo = 0;
	int up = 100;
	int color = 0;
	Scalar newVal;

	for( int y=0; y<imageColoredObjects.rows; y++ ) {

		for( int x=0; x<imageColoredObjects.cols; x++ ) {

			if ( imageColoredObjects.at<Vec3b>(y,x) == Vec3b( 255,0,0 ) )
                {
					color++;
					seed = Point(x,y);
					if (color / 256 == 0)
						newVal = Scalar( 0,0,color );
					if (color / 256 == 1)
						newVal = Scalar( 0,color - 255,255 );
					if (color / 256 == 2)
						newVal = Scalar( color - 510,255,255 );
					floodFill( imageColoredObjects, seed, newVal, 0, Scalar(lo,lo,lo), Scalar(up,up,up), FLOODFILL_FIXED_RANGE);
                }

		}
	}

	int* objects = new int[color];
	for (int i = 0; i < color; i++)
		objects[i] = 0;

	objectPosition = new Point[color];

	for( int y=0; y<imageColoredObjects.rows; y++ ) {

		for( int x=0; x<imageColoredObjects.cols; x++ ) {

			if ( imageColoredObjects.at<Vec3b>(y,x) != Vec3b( 255,255,255 ) )
                {
					int a = imageColoredObjects.at<Vec3b>(y,x)[2];
					objects[a-1]++;
					objectPosition[a-1].x += x;
					objectPosition[a-1].y += y;
                }

		}
	}

	for( int i=0; i<color; i++) 
	{
		if (objects[i] > 10)
		{
			objectPosition[i].x /= objects[i];
			objectPosition[i].y /= objects[i];
		}
		else
		{
			objects[i] = 0;
			objectPosition[i].x = -1;
			objectPosition[i].y = -1;
		}
	}

	return color;

}


int objectMatrixChoosing(Point pt, int k1, int b1, int k2, int b2, Point ptLT, Point ptRT)
{
	if (sign(k1*pt.x + b1 - pt.y) == sign(k1*ptLT.x + b1 - ptLT.y))
	{
		if (sign(k2*pt.x + b2 - pt.y) == sign(k2*ptRT.x + b2 - ptRT.y))
			return 1;
		else
			return 4;
	}
	else
		if (sign(k2*pt.x + b2 - pt.y) == sign(k2*ptRT.x + b2 - ptRT.y))
			return 2;
		else
			return 3;
}


Point objectsNewPositioning(Point p, matrix& T)
	{
		matrix m1 = matrix(p.x, p.y, 1);

		

		double xNew = p.x*T.elements[0][0] + p.y*T.elements[1][0] + T.elements[2][0];
		double yNew = p.x*T.elements[0][1] + p.y*T.elements[1][1] + T.elements[2][1];

		
		return Point(xNew, yNew);
	}



int sign(double val) {
  if (val == 0)  return 0;
  if (val > 0)  return 1;
  else return -1;
}
